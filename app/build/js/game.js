(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var configs = require('./configs.js');
var b2 = require('./utils/b2Helpers.js');
var PIXI = require('./libs/pixi.js/pixi.dev.js');

var carMaker = function (carIndex) {
  var that = {},
    carConfig = configs.cars[carIndex],
  // B2
    frontTires = [],
    rearTires = [],
    tires = [],
    tiresCount = 0,

    probeSystem = null,

  // Car Behaviours

    localNormalVector = new b2.cMath.b2Vec2(1, 0),
    vCurrentRightNormals = [],
    linearVelocities = [],
    currentRightForwards = [],

  //var  from lock to lock in 0.5 sec
    adherenceFactor = 1;


  //states
  that.adherence = true;
  that.drifting = false;
  that.puddleEffect = false;

  //for now checkPoints are relative to cars, they shouldn't...
  that.checkPointManager = null;

  that.accelerationFactor = carConfig.accelerationFactor;
  that.localAccelerationVector = new b2.cMath.b2Vec2(0, -that.accelerationFactor);

  that.turnSpeedPerSec = configs.cars[carIndex].steeringWheelSpeed * configs.consts.DEGTORAD;
  that.turnPerTimeStep = that.turnSpeedPerSec / 60;

  // Steering mgmt
  that.lockAngleDeg = carConfig.wheelMaxAngle;
  that.driftTrigger = carConfig.driftTrigger;
  that.directionJoints = [];

  //PIXI
  that.pixiSprite = new PIXI.Sprite(PIXI.Texture.fromFrame(configs.cars[carIndex].spritePath));
  that.pixiSprite.anchor.x = 0.5;
  that.pixiSprite.anchor.y = 0.5;
  that.pixiSprite.scale.x = 1;
  that.pixiSprite.scale.y = 1;

  that.setBox2dData = function (box2dData) {
    rearTires = box2dData.rearTires;
    frontTires = box2dData.frontTires;
    tires = rearTires.concat(frontTires);
    tiresCount = tires.length;
    that.directionJoints = box2dData.directionJoints;
    if (box2dData.hasOwnProperty("probeSystem")) {
      var probeSystem = box2dData.probeSystem;
    }
    if (that.directionJoints[0]) {
      that.directionJoints[0].SetLimits(0, 0);
    }
    else {
      that.directionJoints[1].SetLimits(0, 0);
    }
    that.b2Body = box2dData.carBody;
    return that.b2Body;
  };

  that.setPosition = function (chosenPosition) {
    var temp = chosenPosition.Copy();
    temp.Add(that.b2Body.GetPosition());
    that.b2Body.SetPosition(temp);
    for (var i = 0; i < tires.length; i++) {
      temp = chosenPosition.Copy();
      temp.Add(tires[i].GetPosition());
      tires[i].SetPosition(temp);
    }
    if (typeof probeSystem !== "undefined" && probeSystem !== null) {
      temp = chosenPosition.Copy();
      temp.Add(probeSystem.GetPosition());
      probeSystem.SetPosition(temp);
    }
  };

  that.updateData = function (keyboardData) {
    that.localAccelerationVector = new b2.cMath.b2Vec2(0, -that.accelerationFactor);
    //tires = @tires
    for (var i = 0; i < tires.length; i++) {
      linearVelocities[i] = that.getLinearVelocity(i)
      currentRightForwards[i] = tires[i].GetWorldVector(new b2.cMath.b2Vec2(0, 1));
      vCurrentRightNormals[i] = that.getLateralVelocity(i)
    }
  };

  that.negateTorque = function (tireIndex) {
    return b2.math.Dot(currentRightForwards[tireIndex], linearVelocities[tireIndex]) < -0.01 ? -1 : 1;
  };

  that.getLateralVelocity = function (tireIndex) {
    var currentRightNormal = tires[tireIndex].GetWorldVector(localNormalVector);
    var vCurrentRightNormal = b2.math.MulFV(
      b2.math.Dot(currentRightNormal, linearVelocities[tireIndex]),
      currentRightNormal
    );
    return vCurrentRightNormal;
  };

  that.getLinearVelocity = function (tireIndex) {
    return tires[tireIndex].GetLinearVelocity();
  };

  that.getForwardVelocity = function (tireIndex) {
    var vCurrentRightForward = b2.math.MulFV(
      b2.math.Dot(currentRightForwards[tireIndex], linearVelocities[tireIndex]),
      currentRightForwards[tireIndex]
    );
    return vCurrentRightForward;
  };

  that.applyImpulse = function (vec2) {
    //tires = @tires
    for (var i = 0; i < tires.length; i++) {
      b2.applyForceToCenter(tires[i], vec2);
    }
  };

  that.updateFriction = function (vec2) {
    //tires = @tires
    for (var i = 0; i < tires.length; i++) {

      if (that.adherence) {
        var tireType = b2.findCustomPropertyValue(tires[i], 'category', 'string')
        if (tireType == 'wheel_rear' && that.drifting) {
          adherenceFactor = 0.2
        }
        else {
          adherenceFactor = 1
        }
        var impulse = b2.math.MulFV(-adherenceFactor * tires[i].GetMass(), vCurrentRightNormals[i]);
        if (impulse.Length() > that.driftTrigger) {
          impulse = b2.math.MulFV(that.driftTrigger / impulse.Length(), impulse);
        }
        tires[i].ApplyImpulse(impulse, tires[i].GetWorldCenter());
      }
      // this has some effect on how the car turns
      var inertia = tires[i].GetInertia()
      var vel = tires[i].GetAngularVelocity();
      tires[i].ApplyAngularImpulse(10 * inertia * -vel);

      // natural friction against movement. This is a F = -kv type force.
      var currentForwardNormal = that.getForwardVelocity(i);
      var currentForwardSpeed = currentForwardNormal.Normalize();
      var dragForceMagnitude = -carConfig.natural_deceleration * currentForwardSpeed;
      tires[i].ApplyForce(b2.math.MulFV(dragForceMagnitude, currentForwardNormal), tires[i].GetWorldCenter());

      // here we update how the car behave when its puddleEffect is on (sliding on a paddle).
      if (that.puddleEffect) {
        tires[i].ApplyTorque((that.puddleEffect ? 1 : 0) * carConfig.puddleFactor);
      }
    }
  };

  return that;
}

module.exports = carMaker;
},{"./configs.js":3,"./libs/pixi.js/pixi.dev.js":9,"./utils/b2Helpers.js":13}],2:[function(require,module,exports){
"use strict";

var checkpointManagerMaker = function (nbCheckPoints) {
  var that = {},
    nbCheckPoints = nbCheckPoints,
    currentCheckPointIndex = -1,
    startLap = null,
    lastLapTime = null,
    bestLapTime = 0,
    nbLaps = 0;

  that.step = function (checkpointIndex) {
    var lapTime, now;
    if (currentCheckPointIndex % nbCheckPoints === checkpointIndex) {
      return;
    }
    if (checkpointIndex === 0) {
      if (currentCheckPointIndex === -1) {
        startLap = Date.now();
        currentCheckPointIndex = 0;
        that.updateLapTime(0);
      } else {
        now = Date.now();
        lapTime = now - startLap;
        lastLapTime = lapTime;
        startLap = now;
        if (bestLapTime === 0) {
          bestLapTime = lastLapTime;
        } else if (lastLapTime < bestLapTime) {
          bestLapTime = lastLapTime;
        }
        that.updateLapTime(lastLapTime);
        that.updateBestLapTime(bestLapTime);
      }
    }
    if (checkpointIndex === (currentCheckPointIndex + 1) % nbCheckPoints) {
      return currentCheckPointIndex++;
    }
  };

  that.updateLapTime = function (valueInMs) {
    var strValue = typeof valueInMs !== 'undefined' ? valueInMs / 1000 + "s" : "---";
    document.getElementById("lapTime").innerHTML = "Lap : " + strValue;
  };
  that.updateBestLapTime = function (valueInMs) {
    var strValue = typeof valueInMs !== 'undefined' ? valueInMs / 1000 + "s" : "---";
    document.getElementById("bestLapTime").innerHTML = "Best : " + strValue;
  };

  that.updateLapTime();
  that.updateBestLapTime();

  return that;
};

module.exports = checkpointManagerMaker;
},{}],3:[function(require,module,exports){
var b2 = require('./utils/b2Helpers.js');

var configs = function () {
  var that = {};

  that.consts = {
    METER: 100,
    STAGE_WIDTH_PIXEL: 1000,
    STAGE_HEIGHT_PIXEL: 750,
    DEGTORAD: 2 * Math.PI / 360
  };
  that.consts.STAGE_WIDTH_B2 = that.consts.STAGE_WIDTH_PIXEL / that.consts.METER;
  that.consts.STAGE_HEIGHT_B2 = that.consts.STAGE_HEIGHT_PIXEL / that.consts.METER;
  that.consts.ScreenCenterVector = new b2.cMath.b2Vec2(that.consts.STAGE_WIDTH_B2 / 2, that.consts.STAGE_HEIGHT_B2 / 2);

  that.tracks = [];
  that.tracks[0] = {
    id: 0,
    nbCheckpoints: 3,
    jsonPath: 'assets/tracks/track0.json',
    imagePath: 'assets/tracks/images/track1.png'
  };
  that.tracks[1] = {
    id: 1,
    nbCheckpoints: 3,
    jsonPath: 'assets/tracks/track1.json',
    imagePath: 'assets/tracks/images/track1.png'
  };

  that.cars = [];
  that.cars[0] = {
    width: 40, // px unit
    height: 25, // px unit
    spritePath: 'assets/cars/images/Voiture_03.png',
    jsonPath: 'assets/cars/car0.json',
    probesSystemPath: 'assets/cars/probeSystem0.json',
    // physics properties
    accelerationFactor: 0.1,
    driftTrigger: 0.003,
    driftTriggerWithHandbrake: 0.001,
    natural_deceleration: 0.01,
    steeringWheelSpeed: 200,
    wheelMaxAngle: 30,
    // car body
    restitution: 0.1,
    puddleFactor: 0.005
  };

  return that;
};

module.exports = configs();
},{"./utils/b2Helpers.js":13}],4:[function(require,module,exports){
"use strict";

var b2 = require('./utils/b2Helpers.js');

var contactManagerMaker = function (world, cars) {
  var that = {};

  var contactListener = new b2.dyn.b2ContactListener();

  contactListener.BeginContact = function (contact) {
    that.HandleContact(contact, true);
  };

  contactListener.EndContact = function (contact) {
    that.HandleContact(contact, false);
  };

  world.SetContactListener(contactListener);


  that.HandleContact = function (contact, began) {
    var cInfo = that.ExtractContactType(contact);
    if (cInfo.type === "wall")
      return;
    if (began) {
      switch (cInfo.type) {
        case "cp":
          cars[0].checkPointManager.Step(parseInt(cInfo.id));
          break;
        case "puddle":
          cars[0].adherence = false;
          cars[0].paddleEffect = puddleRandomDirectionArray[Math.floor(Math.random() * 2)];
          break;
        case "boost":
          var boostVector = new b2.cMath.b2Vec2(cInfo.boostVector.x, cInfo.boostVector.y);
          cars[0].ApplyImpulse(boostVector);
          break;
      }
    }
    else {
      cars[0].adherence = true;
      cars[0].paddleEffect = 0;
    }
  };

  that.ExtractContactType = function (contact) {
    var aData = contact.GetFixtureA();
    var bData = contact.GetFixtureB();

    if (aData.name === 'wallFixture' || bData.name === 'wallFixture')
      return { 'type': 'wall' };

    if (aData.name.indexOf('cp') === 0)
      return {
        'type': 'cp',
        'id': aData.name.substr(2, 3)
      };
    if (bData.name.indexOf('cp') === 0)
      return {
        'type': 'cp',
        'id': bData.name.substr(2, 3)
      };
    if (aData.name.indexOf('boost') === 0)
      return {
        'type': 'boost',
        'boostVector': aData.customProperties[0].vec2
      };
    if (bData.name.indexOf('boost') === 0)
      return {
        'type': 'boost',
        'boostVector': bData.customProperties[0].vec2
      };
    return { 'type': '' };
  };

  return that;
};

module.exports = contactManagerMaker;
},{"./utils/b2Helpers.js":13}],5:[function(require,module,exports){
"use strict";

var universe_maker = require('./universeMaker.js');
var b2 = require('./utils/b2Helpers.js');
var urlHelper = require('./utils/urlHelper.js');
var PIXI = require('./libs/pixi.js/pixi.dev.js');
var Stats = require('./libs/Stats.js');
var configs =  require('./configs.js');

var superSprintGame = function () {
  var that = {};

  that.stats = new Stats();
  that.pixiStage = new PIXI.Stage(0xDDDDDD, true);
  that.queryParams = urlHelper.loadQueryConfig();
  that.universe = universe_maker(that.pixiStage, that.queryParams.track, that.queryParams.cars, function () {
    return that.stats.update();
  });

  var canvas = document.getElementById('canvas');
  canvas.width = configs.STAGE_WIDTH_PIXEL;
  canvas.height = configs.STAGE_HEIGHT_PIXEL;

  that.initWindowAnimationFrame = function () {
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function () {
        return window.requestAnimationFrame
          || window.webkitRequestAnimationFrame
          || window.mozRequestAnimationFrame
          || window.oRequestAnimationFrame
          || window.msRequestAnimationFrame
          || function (callback, element) {
            return window.setTimeout(callback, 1000 / 60);
          };
      };
    }
    window.onload = that.initPixi;
  };

  that.initPixi = function () {
    var background, container, pixiLoader;
    container = document.createElement("div");
    document.body.appendChild(container);
    container.appendChild(that.stats.domElement);
    that.stats.domElement.style.position = "absolute";
    that.pixiRenderer = PIXI.autoDetectRenderer(configs.STAGE_WIDTH_PIXEL, configs.STAGE_HEIGHT_PIXEL, void 0, false);
    that.universe.setPixiRenderer(that.pixiRenderer);
    document.getElementById('gameContainer').appendChild(that.pixiRenderer.view);
    background = PIXI.Sprite.fromImage('assets/tracks/images/track0.png');
    that.pixiStage.addChild(background);
    pixiLoader = new PIXI.AssetLoader([configs.cars[that.queryParams.cars[0]].spritePath]);
    pixiLoader.onComplete = that.loadUniverse;
    return pixiLoader.load();
  };

  that.loadUniverse = function () {
    return that.universe.loadBox2d();
  };

  that.debugDraw = function () {
    var debugDrawer;
    debugDrawer = new b2.dyn.b2DebugDraw();
    debugDrawer.SetSprite(document.getElementById("canvas").getContext("2d"));
    debugDrawer.SetDrawScale(100.0);
    debugDrawer.SetFillAlpha(0.5);
    debugDrawer.SetLineThickness(10.0);
    debugDrawer.SetFlags(b2.dyn.b2DebugDraw.e_shapeBit | b2.dyn.b2DebugDraw.e_jointBit | b2.dyn.b2DebugDraw.e_controllerBit | b2.dyn.b2DebugDraw.e_pairBit);
    return that.universe.world.SetDebugDraw(debugDrawer);
  };

  that.startGame = function () {
    that.debugDraw();
    that.initWindowAnimationFrame();
  };

  return that;
};

var game = superSprintGame();
game.startGame();
},{"./configs.js":3,"./libs/Stats.js":7,"./libs/pixi.js/pixi.dev.js":9,"./universeMaker.js":12,"./utils/b2Helpers.js":13,"./utils/urlHelper.js":15}],6:[function(require,module,exports){
'use strict';

var keyboardHandler = function () {
  var that = {};

  that.keyarray = [];
  that.keys = {
    accelerate: false,
    brake: false,
    left: false,
    right: false,
    handbrake: false
  };
  that.handledkeys = [37, 38, 39, 40, 32];

  that.handlekeydown = function (event) {
    var key, knowkey;
    key = event.which;
    if (handledkeys.indexof(key) > -1) {
      event.preventdefault();
    }
    if (keyarray.indexof(key) > -1) {
      return;
    }
    knowkey = true;
    switch (key) {
      case 37:
        keys.left = true;
        break;
      case 38:
        keys.accelerate = true;
        break;
      case 39:
        keys.right = true;
        break;
      case 40:
        keys.brake = true;
        break;
      case 32:
        keys.handbrake = true;
        break;
      default:
        knowkey = false;
    }
    if (knowkey) {
      keyarray.push(key);
    }
  };

  that.handlekeyup = function (event) {
    var i, key;
    key = event.which;
    i = keyarray.indexof(key);
    if (i > -1) {
      keyarray.splice(i, 1);
    }
    switch (key) {
      case 37:
        keys.left = false;
        break;
      case 38:
        keys.accelerate = false;
        break;
      case 39:
        keys.right = false;
        break;
      case 40:
        keys.brake = false;
        break;
      case 32:
        keys.handbrake = false;
        break;
    }
  };

  return that;
};

module.exports = keyboardHandler();
},{}],7:[function(require,module,exports){
var Stats=function(){var h,a,n=0,o=0,i=Date.now(),u=i,p=i,l=0,q=1E3,r=0,e,j,f,b=[[16,16,48],[0,255,255]],m=0,s=1E3,t=0,d,k,g,c=[[16,48,16],[0,255,0]];h=document.createElement("div");h.style.cursor="pointer";h.style.width="80px";h.style.opacity="0.9";h.style.zIndex="10001";h.addEventListener("mousedown",function(a){a.preventDefault();n=(n+1)%2;0==n?(e.style.display="block",d.style.display="none"):(e.style.display="none",d.style.display="block")},!1);e=document.createElement("div");e.style.textAlign=
"left";e.style.lineHeight="1.2em";e.style.backgroundColor="rgb("+Math.floor(b[0][0]/2)+","+Math.floor(b[0][1]/2)+","+Math.floor(b[0][2]/2)+")";e.style.padding="0 0 3px 3px";h.appendChild(e);j=document.createElement("div");j.style.fontFamily="Helvetica, Arial, sans-serif";j.style.fontSize="9px";j.style.color="rgb("+b[1][0]+","+b[1][1]+","+b[1][2]+")";j.style.fontWeight="bold";j.innerHTML="FPS";e.appendChild(j);f=document.createElement("div");f.style.position="relative";f.style.width="74px";f.style.height=
"30px";f.style.backgroundColor="rgb("+b[1][0]+","+b[1][1]+","+b[1][2]+")";for(e.appendChild(f);74>f.children.length;)a=document.createElement("span"),a.style.width="1px",a.style.height="30px",a.style.cssFloat="left",a.style.backgroundColor="rgb("+b[0][0]+","+b[0][1]+","+b[0][2]+")",f.appendChild(a);d=document.createElement("div");d.style.textAlign="left";d.style.lineHeight="1.2em";d.style.backgroundColor="rgb("+Math.floor(c[0][0]/2)+","+Math.floor(c[0][1]/2)+","+Math.floor(c[0][2]/2)+")";d.style.padding=
"0 0 3px 3px";d.style.display="none";h.appendChild(d);k=document.createElement("div");k.style.fontFamily="Helvetica, Arial, sans-serif";k.style.fontSize="9px";k.style.color="rgb("+c[1][0]+","+c[1][1]+","+c[1][2]+")";k.style.fontWeight="bold";k.innerHTML="MS";d.appendChild(k);g=document.createElement("div");g.style.position="relative";g.style.width="74px";g.style.height="30px";g.style.backgroundColor="rgb("+c[1][0]+","+c[1][1]+","+c[1][2]+")";for(d.appendChild(g);74>g.children.length;)a=document.createElement("span"),
a.style.width="1px",a.style.height=30*Math.random()+"px",a.style.cssFloat="left",a.style.backgroundColor="rgb("+c[0][0]+","+c[0][1]+","+c[0][2]+")",g.appendChild(a);return{domElement:h,update:function(){i=Date.now();m=i-u;s=Math.min(s,m);t=Math.max(t,m);k.textContent=m+" MS ("+s+"-"+t+")";var a=Math.min(30,30-30*(m/200));g.appendChild(g.firstChild).style.height=a+"px";u=i;o++;if(i>p+1E3)l=Math.round(1E3*o/(i-p)),q=Math.min(q,l),r=Math.max(r,l),j.textContent=l+" FPS ("+q+"-"+r+")",a=Math.min(30,30-
30*(l/100)),f.appendChild(f.firstChild).style.height=a+"px",p=i,o=0}}};

module.exports = Stats;

},{}],8:[function(require,module,exports){
/*
* Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/
var Box2D = {};

(function (a2j, undefined) {

   if(!(Object.prototype.defineProperty instanceof Function)
      && Object.prototype.__defineGetter__ instanceof Function
      && Object.prototype.__defineSetter__ instanceof Function)
   {
      Object.defineProperty = function(obj, p, cfg) {
         if(cfg.get instanceof Function)
            obj.__defineGetter__(p, cfg.get);
         if(cfg.set instanceof Function)
            obj.__defineSetter__(p, cfg.set);
      }
   }
   
   function emptyFn() {};
   a2j.inherit = function(cls, base) {
      var tmpCtr = cls;
      emptyFn.prototype = base.prototype;
      cls.prototype = new emptyFn;
      cls.prototype.constructor = tmpCtr;
   };
   
   a2j.generateCallback = function generateCallback(context, cb) {
      return function () {
         cb.apply(context, arguments);
      };
   };
   
   a2j.NVector = function NVector(length) {
      if (length === undefined) length = 0;
      var tmp = new Array(length || 0);
      for (var i = 0; i < length; ++i)
      tmp[i] = 0;
      return tmp;
   };
   
   a2j.is = function is(o1, o2) {
      if (o1 === null) return false;
      if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
      if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
      return false;
   };
   
   a2j.parseUInt = function(v) {
      return Math.abs(parseInt(v));
   }
   
})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
   Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

   function b2AABB() {
      b2AABB.b2AABB.apply(this, arguments);
   };
   Box2D.Collision.b2AABB = b2AABB;

   function b2Bound() {
      b2Bound.b2Bound.apply(this, arguments);
   };
   Box2D.Collision.b2Bound = b2Bound;

   function b2BoundValues() {
      b2BoundValues.b2BoundValues.apply(this, arguments);
      if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
   };
   Box2D.Collision.b2BoundValues = b2BoundValues;

   function b2Collision() {
      b2Collision.b2Collision.apply(this, arguments);
   };
   Box2D.Collision.b2Collision = b2Collision;

   function b2ContactID() {
      b2ContactID.b2ContactID.apply(this, arguments);
      if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
   };
   Box2D.Collision.b2ContactID = b2ContactID;

   function b2ContactPoint() {
      b2ContactPoint.b2ContactPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ContactPoint = b2ContactPoint;

   function b2Distance() {
      b2Distance.b2Distance.apply(this, arguments);
   };
   Box2D.Collision.b2Distance = b2Distance;

   function b2DistanceInput() {
      b2DistanceInput.b2DistanceInput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceInput = b2DistanceInput;

   function b2DistanceOutput() {
      b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

   function b2DistanceProxy() {
      b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

   function b2DynamicTree() {
      b2DynamicTree.b2DynamicTree.apply(this, arguments);
      if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTree = b2DynamicTree;

   function b2DynamicTreeBroadPhase() {
      b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

   function b2DynamicTreeNode() {
      b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

   function b2DynamicTreePair() {
      b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

   function b2Manifold() {
      b2Manifold.b2Manifold.apply(this, arguments);
      if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
   };
   Box2D.Collision.b2Manifold = b2Manifold;

   function b2ManifoldPoint() {
      b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
      if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

   function b2Point() {
      b2Point.b2Point.apply(this, arguments);
   };
   Box2D.Collision.b2Point = b2Point;

   function b2RayCastInput() {
      b2RayCastInput.b2RayCastInput.apply(this, arguments);
      if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastInput = b2RayCastInput;

   function b2RayCastOutput() {
      b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

   function b2Segment() {
      b2Segment.b2Segment.apply(this, arguments);
   };
   Box2D.Collision.b2Segment = b2Segment;

   function b2SeparationFunction() {
      b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
   };
   Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

   function b2Simplex() {
      b2Simplex.b2Simplex.apply(this, arguments);
      if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
   };
   Box2D.Collision.b2Simplex = b2Simplex;

   function b2SimplexCache() {
      b2SimplexCache.b2SimplexCache.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexCache = b2SimplexCache;

   function b2SimplexVertex() {
      b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

   function b2TimeOfImpact() {
      b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
   };
   Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

   function b2TOIInput() {
      b2TOIInput.b2TOIInput.apply(this, arguments);
   };
   Box2D.Collision.b2TOIInput = b2TOIInput;

   function b2WorldManifold() {
      b2WorldManifold.b2WorldManifold.apply(this, arguments);
      if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
   };
   Box2D.Collision.b2WorldManifold = b2WorldManifold;

   function ClipVertex() {
      ClipVertex.ClipVertex.apply(this, arguments);
   };
   Box2D.Collision.ClipVertex = ClipVertex;

   function Features() {
      Features.Features.apply(this, arguments);
   };
   Box2D.Collision.Features = Features;

   function b2CircleShape() {
      b2CircleShape.b2CircleShape.apply(this, arguments);
      if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

   function b2EdgeChainDef() {
      b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
      if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

   function b2EdgeShape() {
      b2EdgeShape.b2EdgeShape.apply(this, arguments);
      if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

   function b2MassData() {
      b2MassData.b2MassData.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2MassData = b2MassData;

   function b2PolygonShape() {
      b2PolygonShape.b2PolygonShape.apply(this, arguments);
      if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

   function b2Shape() {
      b2Shape.b2Shape.apply(this, arguments);
      if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2Shape = b2Shape;
   Box2D.Common.b2internal = 'Box2D.Common.b2internal';

   function b2Color() {
      b2Color.b2Color.apply(this, arguments);
      if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
   };
   Box2D.Common.b2Color = b2Color;

   function b2Settings() {
      b2Settings.b2Settings.apply(this, arguments);
   };
   Box2D.Common.b2Settings = b2Settings;

   function b2Mat22() {
      b2Mat22.b2Mat22.apply(this, arguments);
      if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat22 = b2Mat22;

   function b2Mat33() {
      b2Mat33.b2Mat33.apply(this, arguments);
      if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat33 = b2Mat33;

   function b2Math() {
      b2Math.b2Math.apply(this, arguments);
   };
   Box2D.Common.Math.b2Math = b2Math;

   function b2Sweep() {
      b2Sweep.b2Sweep.apply(this, arguments);
   };
   Box2D.Common.Math.b2Sweep = b2Sweep;

   function b2Transform() {
      b2Transform.b2Transform.apply(this, arguments);
      if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
   };
   Box2D.Common.Math.b2Transform = b2Transform;

   function b2Vec2() {
      b2Vec2.b2Vec2.apply(this, arguments);
      if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec2 = b2Vec2;

   function b2Vec3() {
      b2Vec3.b2Vec3.apply(this, arguments);
      if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec3 = b2Vec3;

   function b2Body() {
      b2Body.b2Body.apply(this, arguments);
      if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
   };
   Box2D.Dynamics.b2Body = b2Body;

   function b2BodyDef() {
      b2BodyDef.b2BodyDef.apply(this, arguments);
      if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2BodyDef = b2BodyDef;

   function b2ContactFilter() {
      b2ContactFilter.b2ContactFilter.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

   function b2ContactImpulse() {
      b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

   function b2ContactListener() {
      b2ContactListener.b2ContactListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactListener = b2ContactListener;

   function b2ContactManager() {
      b2ContactManager.b2ContactManager.apply(this, arguments);
      if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactManager = b2ContactManager;

   function b2DebugDraw() {
      b2DebugDraw.b2DebugDraw.apply(this, arguments);
      if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
   };
   Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

   function b2DestructionListener() {
      b2DestructionListener.b2DestructionListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

   function b2FilterData() {
      b2FilterData.b2FilterData.apply(this, arguments);
   };
   Box2D.Dynamics.b2FilterData = b2FilterData;

   function b2Fixture() {
      b2Fixture.b2Fixture.apply(this, arguments);
      if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
   };
   Box2D.Dynamics.b2Fixture = b2Fixture;

   function b2FixtureDef() {
      b2FixtureDef.b2FixtureDef.apply(this, arguments);
      if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

   function b2Island() {
      b2Island.b2Island.apply(this, arguments);
      if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
   };
   Box2D.Dynamics.b2Island = b2Island;

   function b2TimeStep() {
      b2TimeStep.b2TimeStep.apply(this, arguments);
   };
   Box2D.Dynamics.b2TimeStep = b2TimeStep;

   function b2World() {
      b2World.b2World.apply(this, arguments);
      if (this.constructor === b2World) this.b2World.apply(this, arguments);
   };
   Box2D.Dynamics.b2World = b2World;

   function b2CircleContact() {
      b2CircleContact.b2CircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

   function b2Contact() {
      b2Contact.b2Contact.apply(this, arguments);
      if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2Contact = b2Contact;

   function b2ContactConstraint() {
      b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
      if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

   function b2ContactConstraintPoint() {
      b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

   function b2ContactEdge() {
      b2ContactEdge.b2ContactEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

   function b2ContactFactory() {
      b2ContactFactory.b2ContactFactory.apply(this, arguments);
      if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

   function b2ContactRegister() {
      b2ContactRegister.b2ContactRegister.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

   function b2ContactResult() {
      b2ContactResult.b2ContactResult.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

   function b2ContactSolver() {
      b2ContactSolver.b2ContactSolver.apply(this, arguments);
      if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

   function b2EdgeAndCircleContact() {
      b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

   function b2NullContact() {
      b2NullContact.b2NullContact.apply(this, arguments);
      if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

   function b2PolyAndCircleContact() {
      b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

   function b2PolyAndEdgeContact() {
      b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

   function b2PolygonContact() {
      b2PolygonContact.b2PolygonContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

   function b2PositionSolverManifold() {
      b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
      if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

   function b2BuoyancyController() {
      b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

   function b2ConstantAccelController() {
      b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

   function b2ConstantForceController() {
      b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

   function b2Controller() {
      b2Controller.b2Controller.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2Controller = b2Controller;

   function b2ControllerEdge() {
      b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

   function b2GravityController() {
      b2GravityController.b2GravityController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

   function b2TensorDampingController() {
      b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

   function b2DistanceJoint() {
      b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
      if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

   function b2DistanceJointDef() {
      b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
      if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

   function b2FrictionJoint() {
      b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
      if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

   function b2FrictionJointDef() {
      b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
      if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

   function b2GearJoint() {
      b2GearJoint.b2GearJoint.apply(this, arguments);
      if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

   function b2GearJointDef() {
      b2GearJointDef.b2GearJointDef.apply(this, arguments);
      if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

   function b2Jacobian() {
      b2Jacobian.b2Jacobian.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

   function b2Joint() {
      b2Joint.b2Joint.apply(this, arguments);
      if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Joint = b2Joint;

   function b2JointDef() {
      b2JointDef.b2JointDef.apply(this, arguments);
      if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

   function b2JointEdge() {
      b2JointEdge.b2JointEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

   function b2LineJoint() {
      b2LineJoint.b2LineJoint.apply(this, arguments);
      if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

   function b2LineJointDef() {
      b2LineJointDef.b2LineJointDef.apply(this, arguments);
      if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

   function b2MouseJoint() {
      b2MouseJoint.b2MouseJoint.apply(this, arguments);
      if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

   function b2MouseJointDef() {
      b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
      if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

   function b2PrismaticJoint() {
      b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
      if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

   function b2PrismaticJointDef() {
      b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
      if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

   function b2PulleyJoint() {
      b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
      if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

   function b2PulleyJointDef() {
      b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
      if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

   function b2RevoluteJoint() {
      b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
      if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

   function b2RevoluteJointDef() {
      b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
      if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

   function b2WeldJoint() {
      b2WeldJoint.b2WeldJoint.apply(this, arguments);
      if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

   function b2WeldJointDef() {
      b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
      if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   b2AABB.b2AABB = function () {
      this.lowerBound = new b2Vec2();
      this.upperBound = new b2Vec2();
   };
   b2AABB.prototype.IsValid = function () {
      var dX = this.upperBound.x - this.lowerBound.x;
      var dY = this.upperBound.y - this.lowerBound.y;
      var valid = dX >= 0.0 && dY >= 0.0;
      valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
      return valid;
   }
   b2AABB.prototype.GetCenter = function () {
      return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
   }
   b2AABB.prototype.GetExtents = function () {
      return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
   }
   b2AABB.prototype.Contains = function (aabb) {
      var result = true;
      result = result && this.lowerBound.x <= aabb.lowerBound.x;
      result = result && this.lowerBound.y <= aabb.lowerBound.y;
      result = result && aabb.upperBound.x <= this.upperBound.x;
      result = result && aabb.upperBound.y <= this.upperBound.y;
      return result;
   }
   b2AABB.prototype.RayCast = function (output, input) {
      var tmin = (-Number.MAX_VALUE);
      var tmax = Number.MAX_VALUE;
      var pX = input.p1.x;
      var pY = input.p1.y;
      var dX = input.p2.x - input.p1.x;
      var dY = input.p2.y - input.p1.y;
      var absDX = Math.abs(dX);
      var absDY = Math.abs(dY);
      var normal = output.normal;
      var inv_d = 0;
      var t1 = 0;
      var t2 = 0;
      var t3 = 0;
      var s = 0; {
         if (absDX < Number.MIN_VALUE) {
            if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
         }
         else {
            inv_d = 1.0 / dX;
            t1 = (this.lowerBound.x - pX) * inv_d;
            t2 = (this.upperBound.x - pX) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.x = s;
               normal.y = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      } {
         if (absDY < Number.MIN_VALUE) {
            if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
         }
         else {
            inv_d = 1.0 / dY;
            t1 = (this.lowerBound.y - pY) * inv_d;
            t2 = (this.upperBound.y - pY) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.y = s;
               normal.x = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      }
      output.fraction = tmin;
      return true;
   }
   b2AABB.prototype.TestOverlap = function (other) {
      var d1X = other.lowerBound.x - this.upperBound.x;
      var d1Y = other.lowerBound.y - this.upperBound.y;
      var d2X = this.lowerBound.x - other.upperBound.x;
      var d2Y = this.lowerBound.y - other.upperBound.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   b2AABB.Combine = function (aabb1, aabb2) {
      var aabb = new b2AABB();
      aabb.Combine(aabb1, aabb2);
      return aabb;
   }
   b2AABB.prototype.Combine = function (aabb1, aabb2) {
      this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
      this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
      this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
      this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
   }
   b2Bound.b2Bound = function () {};
   b2Bound.prototype.IsLower = function () {
      return (this.value & 1) == 0;
   }
   b2Bound.prototype.IsUpper = function () {
      return (this.value & 1) == 1;
   }
   b2Bound.prototype.Swap = function (b) {
      var tempValue = this.value;
      var tempProxy = this.proxy;
      var tempStabbingCount = this.stabbingCount;
      this.value = b.value;
      this.proxy = b.proxy;
      this.stabbingCount = b.stabbingCount;
      b.value = tempValue;
      b.proxy = tempProxy;
      b.stabbingCount = tempStabbingCount;
   }
   b2BoundValues.b2BoundValues = function () {};
   b2BoundValues.prototype.b2BoundValues = function () {
      this.lowerValues = new Vector_a2j_Number();
      this.lowerValues[0] = 0.0;
      this.lowerValues[1] = 0.0;
      this.upperValues = new Vector_a2j_Number();
      this.upperValues[0] = 0.0;
      this.upperValues[1] = 0.0;
   }
   b2Collision.b2Collision = function () {};
   b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
      if (offset === undefined) offset = 0;
      var cv;
      var numOut = 0;
      cv = vIn[0];
      var vIn0 = cv.v;
      cv = vIn[1];
      var vIn1 = cv.v;
      var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
      var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
      if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
      if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
      if (distance0 * distance1 < 0.0) {
         var interp = distance0 / (distance0 - distance1);
         cv = vOut[numOut];
         var tVec = cv.v;
         tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
         tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
         cv = vOut[numOut];
         var cv2;
         if (distance0 > 0.0) {
            cv2 = vIn[0];
            cv.id = cv2.id;
         }
         else {
            cv2 = vIn[1];
            cv.id = cv2.id;
         }++numOut;
      }
      return numOut;
   }
   b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
      var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = vertices2[i];
         var dot = tVec.x * normal1X + tVec.y * normal1Y;
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      tVec = vertices1[edge1];
      tMat = xf1.R;
      var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = vertices2[index];
      tMat = xf2.R;
      var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      v2X -= v1X;
      v2Y -= v1Y;
      var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
      return separation;
   }
   b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = poly2.m_centroid;
      var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf1.R;
      tVec = poly1.m_centroid;
      dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
      var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
      var edge = 0;
      var maxDot = (-Number.MAX_VALUE);
      for (var i = 0; i < count1; ++i) {
         tVec = normals1[i];
         var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
         if (dot > maxDot) {
            maxDot = dot;
            edge = i;
         }
      }
      var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
      var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
      var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
      var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
      var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
      var bestEdge = 0;
      var bestSeparation = 0;
      var increment = 0;
      if (sPrev > s && sPrev > sNext) {
         increment = (-1);
         bestEdge = prevEdge;
         bestSeparation = sPrev;
      }
      else if (sNext > s) {
         increment = 1;
         bestEdge = nextEdge;
         bestSeparation = sNext;
      }
      else {
         edgeIndex[0] = edge;
         return s;
      }
      while (true) {
         if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
         else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
         if (s > bestSeparation) {
            bestEdge = edge;
            bestSeparation = s;
         }
         else {
            break;
         }
      }
      edgeIndex[0] = bestEdge;
      return bestSeparation;
   }
   b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var normals2 = poly2.m_normals;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
      normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
      normal1X = tX;
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = normals2[i];
         var dot = (normal1X * tVec.x + normal1Y * tVec.y);
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      var tClip;
      var i1 = parseInt(index);
      var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
      tClip = c[0];
      tVec = vertices2[i1];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i1;
      tClip.id.features.incidentVertex = 0;
      tClip = c[1];
      tVec = vertices2[i2];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i2;
      tClip.id.features.incidentVertex = 1;
   }
   b2Collision.MakeClipPointVector = function () {
      var r = new Vector(2);
      r[0] = new ClipVertex();
      r[1] = new ClipVertex();
      return r;
   }
   b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
      var cv;
      manifold.m_pointCount = 0;
      var totalRadius = polyA.m_radius + polyB.m_radius;
      var edgeA = 0;
      b2Collision.s_edgeAO[0] = edgeA;
      var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
      edgeA = b2Collision.s_edgeAO[0];
      if (separationA > totalRadius) return;
      var edgeB = 0;
      b2Collision.s_edgeBO[0] = edgeB;
      var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
      edgeB = b2Collision.s_edgeBO[0];
      if (separationB > totalRadius) return;
      var poly1;
      var poly2;
      var xf1;
      var xf2;
      var edge1 = 0;
      var flip = 0;
      var k_relativeTol = 0.98;
      var k_absoluteTol = 0.001;
      var tMat;
      if (separationB > k_relativeTol * separationA + k_absoluteTol) {
         poly1 = polyB;
         poly2 = polyA;
         xf1 = xfB;
         xf2 = xfA;
         edge1 = edgeB;
         manifold.m_type = b2Manifold.e_faceB;
         flip = 1;
      }
      else {
         poly1 = polyA;
         poly2 = polyB;
         xf1 = xfA;
         xf2 = xfB;
         edge1 = edgeA;
         manifold.m_type = b2Manifold.e_faceA;
         flip = 0;
      }
      var incidentEdge = b2Collision.s_incidentEdge;
      b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var local_v11 = vertices1[edge1];
      var local_v12;
      if (edge1 + 1 < count1) {
         local_v12 = vertices1[parseInt(edge1 + 1)];
      }
      else {
         local_v12 = vertices1[0];
      }
      var localTangent = b2Collision.s_localTangent;
      localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
      localTangent.Normalize();
      var localNormal = b2Collision.s_localNormal;
      localNormal.x = localTangent.y;
      localNormal.y = (-localTangent.x);
      var planePoint = b2Collision.s_planePoint;
      planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
      var tangent = b2Collision.s_tangent;
      tMat = xf1.R;
      tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
      tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
      var tangent2 = b2Collision.s_tangent2;
      tangent2.x = (-tangent.x);
      tangent2.y = (-tangent.y);
      var normal = b2Collision.s_normal;
      normal.x = tangent.y;
      normal.y = (-tangent.x);
      var v11 = b2Collision.s_v11;
      var v12 = b2Collision.s_v12;
      v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
      v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
      v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
      v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
      var frontOffset = normal.x * v11.x + normal.y * v11.y;
      var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
      var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
      var clipPoints1 = b2Collision.s_clipPoints1;
      var clipPoints2 = b2Collision.s_clipPoints2;
      var np = 0;
      np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
      if (np < 2) return;
      np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
      if (np < 2) return;
      manifold.m_localPlaneNormal.SetV(localNormal);
      manifold.m_localPoint.SetV(planePoint);
      var pointCount = 0;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
         cv = clipPoints2[i];
         var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
         if (separation <= totalRadius) {
            var cp = manifold.m_points[pointCount];
            tMat = xf2.R;
            var tX = cv.v.x - xf2.position.x;
            var tY = cv.v.y - xf2.position.y;
            cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
            cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
            cp.m_id.Set(cv.id);
            cp.m_id.features.flip = flip;
            ++pointCount;
         }
      }
      manifold.m_pointCount = pointCount;
   }
   b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
      manifold.m_pointCount = 0;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = circle1.m_p;
      var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      tVec = circle2.m_p;
      var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var distSqr = dX * dX + dY * dY;
      var radius = circle1.m_radius + circle2.m_radius;
      if (distSqr > radius * radius) {
         return;
      }
      manifold.m_type = b2Manifold.e_circles;
      manifold.m_localPoint.SetV(circle1.m_p);
      manifold.m_localPlaneNormal.SetZero();
      manifold.m_pointCount = 1;
      manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
      manifold.m_points[0].m_id.key = 0;
   }
   b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
      manifold.m_pointCount = 0;
      var tPoint;
      var dX = 0;
      var dY = 0;
      var positionX = 0;
      var positionY = 0;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = circle.m_p;
      var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      dX = cX - xf1.position.x;
      dY = cY - xf1.position.y;
      tMat = xf1.R;
      var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
      var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
      var dist = 0;
      var normalIndex = 0;
      var separation = (-Number.MAX_VALUE);
      var radius = polygon.m_radius + circle.m_radius;
      var vertexCount = parseInt(polygon.m_vertexCount);
      var vertices = polygon.m_vertices;
      var normals = polygon.m_normals;
      for (var i = 0; i < vertexCount; ++i) {
         tVec = vertices[i];
         dX = cLocalX - tVec.x;
         dY = cLocalY - tVec.y;
         tVec = normals[i];
         var s = tVec.x * dX + tVec.y * dY;
         if (s > radius) {
            return;
         }
         if (s > separation) {
            separation = s;
            normalIndex = i;
         }
      }
      var vertIndex1 = parseInt(normalIndex);
      var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
      var v1 = vertices[vertIndex1];
      var v2 = vertices[vertIndex2];
      if (separation < Number.MIN_VALUE) {
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
         manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
         manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
         return;
      }
      var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
      var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
      if (u1 <= 0.0) {
         if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v1.x;
         manifold.m_localPlaneNormal.y = cLocalY - v1.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v1);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else if (u2 <= 0) {
         if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v2.x;
         manifold.m_localPlaneNormal.y = cLocalY - v2.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v2);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else {
         var faceCenterX = 0.5 * (v1.x + v2.x);
         var faceCenterY = 0.5 * (v1.y + v2.y);
         separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
         if (separation > radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
         manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.Set(faceCenterX, faceCenterY);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
   }
   b2Collision.TestOverlap = function (a, b) {
      var t1 = b.lowerBound;
      var t2 = a.upperBound;
      var d1X = t1.x - t2.x;
      var d1Y = t1.y - t2.y;
      t1 = a.lowerBound;
      t2 = b.upperBound;
      var d2X = t1.x - t2.x;
      var d2Y = t1.y - t2.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
      Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
      Box2D.Collision.b2Collision.s_normal = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
      Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
      Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
   });
   b2ContactID.b2ContactID = function () {
      this.features = new Features();
   };
   b2ContactID.prototype.b2ContactID = function () {
      this.features._m_id = this;
   }
   b2ContactID.prototype.Set = function (id) {
      this.key = id._key;
   }
   b2ContactID.prototype.Copy = function () {
      var id = new b2ContactID();
      id.key = this.key;
      return id;
   }
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._key;
      }
   });
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._key = value;
         this.features._referenceEdge = this._key & 0x000000ff;
         this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
         this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
         this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
      }
   });
   b2ContactPoint.b2ContactPoint = function () {
      this.position = new b2Vec2();
      this.velocity = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2Distance.b2Distance = function () {};
   b2Distance.Distance = function (output, cache, input) {
      ++b2Distance.b2_gjkCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var transformA = input.transformA;
      var transformB = input.transformB;
      var simplex = b2Distance.s_simplex;
      simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
      var vertices = simplex.m_vertices;
      var k_maxIters = 20;
      var saveA = b2Distance.s_saveA;
      var saveB = b2Distance.s_saveB;
      var saveCount = 0;
      var closestPoint = simplex.GetClosestPoint();
      var distanceSqr1 = closestPoint.LengthSquared();
      var distanceSqr2 = distanceSqr1;
      var i = 0;
      var p;
      var iter = 0;
      while (iter < k_maxIters) {
         saveCount = simplex.m_count;
         for (i = 0;
         i < saveCount; i++) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
         }
         switch (simplex.m_count) {
         case 1:
            break;
         case 2:
            simplex.Solve2();
            break;
         case 3:
            simplex.Solve3();
            break;
         default:
            b2Settings.b2Assert(false);
         }
         if (simplex.m_count == 3) {
            break;
         }
         p = simplex.GetClosestPoint();
         distanceSqr2 = p.LengthSquared();
         if (distanceSqr2 > distanceSqr1) {}
         distanceSqr1 = distanceSqr2;
         var d = simplex.GetSearchDirection();
         if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
            break;
         }
         var vertex = vertices[simplex.m_count];
         vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
         vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
         vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
         vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
         vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
         ++iter;
         ++b2Distance.b2_gjkIters;
         var duplicate = false;
         for (i = 0;
         i < saveCount; i++) {
            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
               duplicate = true;
               break;
            }
         }
         if (duplicate) {
            break;
         }++simplex.m_count;
      }
      b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
      simplex.GetWitnessPoints(output.pointA, output.pointB);
      output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
      output.iterations = iter;
      simplex.WriteCache(cache);
      if (input.useRadii) {
         var rA = proxyA.m_radius;
         var rB = proxyB.m_radius;
         if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
            output.distance -= rA + rB;
            var normal = b2Math.SubtractVV(output.pointB, output.pointA);
            normal.Normalize();
            output.pointA.x += rA * normal.x;
            output.pointA.y += rA * normal.y;
            output.pointB.x -= rB * normal.x;
            output.pointB.y -= rB * normal.y;
         }
         else {
            p = new b2Vec2();
            p.x = .5 * (output.pointA.x + output.pointB.x);
            p.y = .5 * (output.pointA.y + output.pointB.y);
            output.pointA.x = output.pointB.x = p.x;
            output.pointA.y = output.pointB.y = p.y;
            output.distance = 0.0;
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
      Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
      Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
   });
   b2DistanceInput.b2DistanceInput = function () {};
   b2DistanceOutput.b2DistanceOutput = function () {
      this.pointA = new b2Vec2();
      this.pointB = new b2Vec2();
   };
   b2DistanceProxy.b2DistanceProxy = function () {};
   b2DistanceProxy.prototype.Set = function (shape) {
      switch (shape.GetType()) {
      case b2Shape.e_circleShape:
         {
            var circle = (shape instanceof b2CircleShape ? shape : null);
            this.m_vertices = new Vector(1, true);
            this.m_vertices[0] = circle.m_p;
            this.m_count = 1;
            this.m_radius = circle.m_radius;
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var polygon = (shape instanceof b2PolygonShape ? shape : null);
            this.m_vertices = polygon.m_vertices;
            this.m_count = polygon.m_vertexCount;
            this.m_radius = polygon.m_radius;
         }
         break;
      default:
         b2Settings.b2Assert(false);
      }
   }
   b2DistanceProxy.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2DistanceProxy.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2DistanceProxy.prototype.GetVertexCount = function () {
      return this.m_count;
   }
   b2DistanceProxy.prototype.GetVertex = function (index) {
      if (index === undefined) index = 0;
      b2Settings.b2Assert(0 <= index && index < this.m_count);
      return this.m_vertices[index];
   }
   b2DynamicTree.b2DynamicTree = function () {};
   b2DynamicTree.prototype.b2DynamicTree = function () {
      this.m_root = null;
      this.m_freeList = null;
      this.m_path = 0;
      this.m_insertionCount = 0;
   }
   b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
      var node = this.AllocateNode();
      var extendX = b2Settings.b2_aabbExtension;
      var extendY = b2Settings.b2_aabbExtension;
      node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      node.aabb.upperBound.x = aabb.upperBound.x + extendX;
      node.aabb.upperBound.y = aabb.upperBound.y + extendY;
      node.userData = userData;
      this.InsertLeaf(node);
      return node;
   }
   b2DynamicTree.prototype.DestroyProxy = function (proxy) {
      this.RemoveLeaf(proxy);
      this.FreeNode(proxy);
   }
   b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
      b2Settings.b2Assert(proxy.IsLeaf());
      if (proxy.aabb.Contains(aabb)) {
         return false;
      }
      this.RemoveLeaf(proxy);
      var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
      var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
      proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
      proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
      this.InsertLeaf(proxy);
      return true;
   }
   b2DynamicTree.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      if (this.m_root == null) return;
      for (var i = 0; i < iterations; i++) {
         var node = this.m_root;
         var bit = 0;
         while (node.IsLeaf() == false) {
            node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
            bit = (bit + 1) & 31;
         }++this.m_path;
         this.RemoveLeaf(node);
         this.InsertLeaf(node);
      }
   }
   b2DynamicTree.prototype.GetFatAABB = function (proxy) {
      return proxy.aabb;
   }
   b2DynamicTree.prototype.GetUserData = function (proxy) {
      return proxy.userData;
   }
   b2DynamicTree.prototype.Query = function (callback, aabb) {
      if (this.m_root == null) return;
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(aabb)) {
            if (node.IsLeaf()) {
               var proceed = callback(node);
               if (!proceed) return;
            }
            else {
               stack[count++] = node.child1;
               stack[count++] = node.child2;
            }
         }
      }
   }
   b2DynamicTree.prototype.RayCast = function (callback, input) {
      if (this.m_root == null) return;
      var p1 = input.p1;
      var p2 = input.p2;
      var r = b2Math.SubtractVV(p1, p2);
      r.Normalize();
      var v = b2Math.CrossFV(1.0, r);
      var abs_v = b2Math.AbsV(v);
      var maxFraction = input.maxFraction;
      var segmentAABB = new b2AABB();
      var tX = 0;
      var tY = 0; {
         tX = p1.x + maxFraction * (p2.x - p1.x);
         tY = p1.y + maxFraction * (p2.y - p1.y);
         segmentAABB.lowerBound.x = Math.min(p1.x, tX);
         segmentAABB.lowerBound.y = Math.min(p1.y, tY);
         segmentAABB.upperBound.x = Math.max(p1.x, tX);
         segmentAABB.upperBound.y = Math.max(p1.y, tY);
      }
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(segmentAABB) == false) {
            continue;
         }
         var c = node.aabb.GetCenter();
         var h = node.aabb.GetExtents();
         var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
         if (separation > 0.0) continue;
         if (node.IsLeaf()) {
            var subInput = new b2RayCastInput();
            subInput.p1 = input.p1;
            subInput.p2 = input.p2;
            subInput.maxFraction = input.maxFraction;
            maxFraction = callback(subInput, node);
            if (maxFraction == 0.0) return;
            if (maxFraction > 0.0) {
               tX = p1.x + maxFraction * (p2.x - p1.x);
               tY = p1.y + maxFraction * (p2.y - p1.y);
               segmentAABB.lowerBound.x = Math.min(p1.x, tX);
               segmentAABB.lowerBound.y = Math.min(p1.y, tY);
               segmentAABB.upperBound.x = Math.max(p1.x, tX);
               segmentAABB.upperBound.y = Math.max(p1.y, tY);
            }
         }
         else {
            stack[count++] = node.child1;
            stack[count++] = node.child2;
         }
      }
   }
   b2DynamicTree.prototype.AllocateNode = function () {
      if (this.m_freeList) {
         var node = this.m_freeList;
         this.m_freeList = node.parent;
         node.parent = null;
         node.child1 = null;
         node.child2 = null;
         return node;
      }
      return new b2DynamicTreeNode();
   }
   b2DynamicTree.prototype.FreeNode = function (node) {
      node.parent = this.m_freeList;
      this.m_freeList = node;
   }
   b2DynamicTree.prototype.InsertLeaf = function (leaf) {
      ++this.m_insertionCount;
      if (this.m_root == null) {
         this.m_root = leaf;
         this.m_root.parent = null;
         return;
      }
      var center = leaf.aabb.GetCenter();
      var sibling = this.m_root;
      if (sibling.IsLeaf() == false) {
         do {
            var child1 = sibling.child1;
            var child2 = sibling.child2;
            var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
            var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
            if (norm1 < norm2) {
               sibling = child1;
            }
            else {
               sibling = child2;
            }
         }
         while (sibling.IsLeaf() == false)
      }
      var node1 = sibling.parent;
      var node2 = this.AllocateNode();
      node2.parent = node1;
      node2.userData = null;
      node2.aabb.Combine(leaf.aabb, sibling.aabb);
      if (node1) {
         if (sibling.parent.child1 == sibling) {
            node1.child1 = node2;
         }
         else {
            node1.child2 = node2;
         }
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         do {
            if (node1.aabb.Contains(node2.aabb)) break;
            node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
            node2 = node1;
            node1 = node1.parent;
         }
         while (node1)
      }
      else {
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         this.m_root = node2;
      }
   }
   b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
      if (leaf == this.m_root) {
         this.m_root = null;
         return;
      }
      var node2 = leaf.parent;
      var node1 = node2.parent;
      var sibling;
      if (node2.child1 == leaf) {
         sibling = node2.child2;
      }
      else {
         sibling = node2.child1;
      }
      if (node1) {
         if (node1.child1 == node2) {
            node1.child1 = sibling;
         }
         else {
            node1.child2 = sibling;
         }
         sibling.parent = node1;
         this.FreeNode(node2);
         while (node1) {
            var oldAABB = node1.aabb;
            node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
            if (oldAABB.Contains(node1.aabb)) break;
            node1 = node1.parent;
         }
      }
      else {
         this.m_root = sibling;
         sibling.parent = null;
         this.FreeNode(node2);
      }
   }
   b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new b2DynamicTree();
      this.m_moveBuffer = new Vector();
      this.m_pairBuffer = new Vector();
      this.m_pairCount = 0;
   };
   b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
      var proxy = this.m_tree.CreateProxy(aabb, userData);
      ++this.m_proxyCount;
      this.BufferMove(proxy);
      return proxy;
   }
   b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
      this.UnBufferMove(proxy);
      --this.m_proxyCount;
      this.m_tree.DestroyProxy(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
      var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
      if (buffer) {
         this.BufferMove(proxy);
      }
   }
   b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
      var aabbA = this.m_tree.GetFatAABB(proxyA);
      var aabbB = this.m_tree.GetFatAABB(proxyB);
      return aabbA.TestOverlap(aabbB);
   }
   b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
      return this.m_tree.GetUserData(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
      return this.m_tree.GetFatAABB(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
   }
   b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
      var __this = this;
      __this.m_pairCount = 0;
      var i = 0,
         queryProxy;
      for (i = 0;
      i < __this.m_moveBuffer.length; ++i) {
         queryProxy = __this.m_moveBuffer[i];

         function QueryCallback(proxy) {
            if (proxy == queryProxy) return true;
            if (__this.m_pairCount == __this.m_pairBuffer.length) {
               __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
            }
            var pair = __this.m_pairBuffer[__this.m_pairCount];
            pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
            pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
            return true;
         };
         var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
         __this.m_tree.Query(QueryCallback, fatAABB);
      }
      __this.m_moveBuffer.length = 0;
      for (var i = 0; i < __this.m_pairCount;) {
         var primaryPair = __this.m_pairBuffer[i];
         var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
         var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
         callback(userDataA, userDataB);
         ++i;
         while (i < __this.m_pairCount) {
            var pair = __this.m_pairBuffer[i];
            if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
               break;
            }++i;
         }
      }
   }
   b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
      this.m_tree.Query(callback, aabb);
   }
   b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
      this.m_tree.RayCast(callback, input);
   }
   b2DynamicTreeBroadPhase.prototype.Validate = function () {}
   b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      this.m_tree.Rebalance(iterations);
   }
   b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
      this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
   }
   b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
      var i = parseInt(this.m_moveBuffer.indexOf(proxy));
      this.m_moveBuffer.splice(i, 1);
   }
   b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
      return 0;
   }
   b2DynamicTreeBroadPhase.__implements = {};
   b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
   b2DynamicTreeNode.b2DynamicTreeNode = function () {
      this.aabb = new b2AABB();
   };
   b2DynamicTreeNode.prototype.IsLeaf = function () {
      return this.child1 == null;
   }
   b2DynamicTreePair.b2DynamicTreePair = function () {};
   b2Manifold.b2Manifold = function () {
      this.m_pointCount = 0;
   };
   b2Manifold.prototype.b2Manifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2ManifoldPoint();
      }
      this.m_localPlaneNormal = new b2Vec2();
      this.m_localPoint = new b2Vec2();
   }
   b2Manifold.prototype.Reset = function () {
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
      }
      this.m_localPlaneNormal.SetZero();
      this.m_localPoint.SetZero();
      this.m_type = 0;
      this.m_pointCount = 0;
   }
   b2Manifold.prototype.Set = function (m) {
      this.m_pointCount = m.m_pointCount;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
      }
      this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_type = m.m_type;
   }
   b2Manifold.prototype.Copy = function () {
      var copy = new b2Manifold();
      copy.Set(this);
      return copy;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Manifold.e_circles = 0x0001;
      Box2D.Collision.b2Manifold.e_faceA = 0x0002;
      Box2D.Collision.b2Manifold.e_faceB = 0x0004;
   });
   b2ManifoldPoint.b2ManifoldPoint = function () {
      this.m_localPoint = new b2Vec2();
      this.m_id = new b2ContactID();
   };
   b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
      this.Reset();
   }
   b2ManifoldPoint.prototype.Reset = function () {
      this.m_localPoint.SetZero();
      this.m_normalImpulse = 0.0;
      this.m_tangentImpulse = 0.0;
      this.m_id.key = 0;
   }
   b2ManifoldPoint.prototype.Set = function (m) {
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_normalImpulse = m.m_normalImpulse;
      this.m_tangentImpulse = m.m_tangentImpulse;
      this.m_id.Set(m.m_id);
   }
   b2Point.b2Point = function () {
      this.p = new b2Vec2();
   };
   b2Point.prototype.Support = function (xf, vX, vY) {
      if (vX === undefined) vX = 0;
      if (vY === undefined) vY = 0;
      return this.p;
   }
   b2Point.prototype.GetFirstVertex = function (xf) {
      return this.p;
   }
   b2RayCastInput.b2RayCastInput = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
      if (p1 === undefined) p1 = null;
      if (p2 === undefined) p2 = null;
      if (maxFraction === undefined) maxFraction = 1;
      if (p1) this.p1.SetV(p1);
      if (p2) this.p2.SetV(p2);
      this.maxFraction = maxFraction;
   }
   b2RayCastOutput.b2RayCastOutput = function () {
      this.normal = new b2Vec2();
   };
   b2Segment.b2Segment = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
      if (maxLambda === undefined) maxLambda = 0;
      var s = segment.p1;
      var rX = segment.p2.x - s.x;
      var rY = segment.p2.y - s.y;
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var nX = dY;
      var nY = (-dX);
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = s.x - this.p1.x;
         var bY = s.y - this.p1.y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= maxLambda * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               nX /= nLen;
               nY /= nLen;
               lambda[0] = a;
               normal.Set(nX, nY);
               return true;
            }
         }
      }
      return false;
   }
   b2Segment.prototype.Extend = function (aabb) {
      this.ExtendForward(aabb);
      this.ExtendBackward(aabb);
   }
   b2Segment.prototype.ExtendForward = function (aabb) {
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + dX * lambda;
      this.p2.y = this.p1.y + dY * lambda;
   }
   b2Segment.prototype.ExtendBackward = function (aabb) {
      var dX = (-this.p2.x) + this.p1.x;
      var dY = (-this.p2.y) + this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + dX * lambda;
      this.p1.y = this.p2.y + dY * lambda;
   }
   b2SeparationFunction.b2SeparationFunction = function () {
      this.m_localPoint = new b2Vec2();
      this.m_axis = new b2Vec2();
   };
   b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
      this.m_proxyA = proxyA;
      this.m_proxyB = proxyB;
      var count = parseInt(cache.count);
      b2Settings.b2Assert(0 < count && count < 3);
      var localPointA;
      var localPointA1;
      var localPointA2;
      var localPointB;
      var localPointB1;
      var localPointB2;
      var pointAX = 0;
      var pointAY = 0;
      var pointBX = 0;
      var pointBY = 0;
      var normalX = 0;
      var normalY = 0;
      var tMat;
      var tVec;
      var s = 0;
      var sgn = 0;
      if (count == 1) {
         this.m_type = b2SeparationFunction.e_points;
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         this.m_axis.x = pointBX - pointAX;
         this.m_axis.y = pointBY - pointAY;
         this.m_axis.Normalize();
      }
      else if (cache.indexB[0] == cache.indexB[1]) {
         this.m_type = b2SeparationFunction.e_faceA;
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
         this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformA.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else if (cache.indexA[0] == cache.indexA[0]) {
         this.m_type = b2SeparationFunction.e_faceB;
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
         this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformB.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else {
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         var pA = b2Math.MulX(transformA, localPointA);
         var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
         var pB = b2Math.MulX(transformB, localPointB);
         var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
         var a = dA.x * dA.x + dA.y * dA.y;
         var e = dB.x * dB.x + dB.y * dB.y;
         var r = b2Math.SubtractVV(dB, dA);
         var c = dA.x * r.x + dA.y * r.y;
         var f = dB.x * r.x + dB.y * r.y;
         var b = dA.x * dB.x + dA.y * dB.y;
         var denom = a * e - b * b;
         s = 0.0;
         if (denom != 0.0) {
            s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
         }
         var t = (b * s + f) / e;
         if (t < 0.0) {
            t = 0.0;
            s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
         }
         localPointA = new b2Vec2();
         localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
         localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
         localPointB = new b2Vec2();
         localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
         localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
         if (s == 0.0 || s == 1.0) {
            this.m_type = b2SeparationFunction.e_faceB;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            this.m_localPoint = localPointB;
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
         else {
            this.m_type = b2SeparationFunction.e_faceA;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_localPoint = localPointA;
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
      }
   }
   b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
      var axisA;
      var axisB;
      var localPointA;
      var localPointB;
      var pointA;
      var pointB;
      var seperation = 0;
      var normal;
      switch (this.m_type) {
      case b2SeparationFunction.e_points:
         {
            axisA = b2Math.MulTMV(transformA.R, this.m_axis);
            axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointA = b2Math.MulX(transformA, localPointA);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceA:
         {
            normal = b2Math.MulMV(transformA.R, this.m_axis);
            pointA = b2Math.MulX(transformA, this.m_localPoint);
            axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceB:
         {
            normal = b2Math.MulMV(transformB.R, this.m_axis);
            pointB = b2Math.MulX(transformB, this.m_localPoint);
            axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            pointA = b2Math.MulX(transformA, localPointA);
            seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
            return seperation;
         }
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2SeparationFunction.e_points = 0x01;
      Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
      Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
   });
   b2Simplex.b2Simplex = function () {
      this.m_v1 = new b2SimplexVertex();
      this.m_v2 = new b2SimplexVertex();
      this.m_v3 = new b2SimplexVertex();
      this.m_vertices = new Vector(3);
   };
   b2Simplex.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1;
      this.m_vertices[1] = this.m_v2;
      this.m_vertices[2] = this.m_v3;
   }
   b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
      b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
      var wALocal;
      var wBLocal;
      this.m_count = cache.count;
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         var v = vertices[i];
         v.indexA = cache.indexA[i];
         v.indexB = cache.indexB[i];
         wALocal = proxyA.GetVertex(v.indexA);
         wBLocal = proxyB.GetVertex(v.indexB);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         v.a = 0;
      }
      if (this.m_count > 1) {
         var metric1 = cache.metric;
         var metric2 = this.GetMetric();
         if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
            this.m_count = 0;
         }
      }
      if (this.m_count == 0) {
         v = vertices[0];
         v.indexA = 0;
         v.indexB = 0;
         wALocal = proxyA.GetVertex(0);
         wBLocal = proxyB.GetVertex(0);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         this.m_count = 1;
      }
   }
   b2Simplex.prototype.WriteCache = function (cache) {
      cache.metric = this.GetMetric();
      cache.count = Box2D.parseUInt(this.m_count);
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
         cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
      }
   }
   b2Simplex.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
      case 1:
         return this.m_v1.w.GetNegative();
      case 2:
         {
            var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
            var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
            if (sgn > 0.0) {
               return b2Math.CrossFV(1.0, e12);
            }
            else {
               return b2Math.CrossVF(e12, 1.0);
            }
         }
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      case 1:
         return this.m_v1.w;
      case 2:
         return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         break;
      case 1:
         pA.SetV(this.m_v1.wA);
         pB.SetV(this.m_v1.wB);
         break;
      case 2:
         pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
         pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
         pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
         pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
         break;
      case 3:
         pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
         pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
         break;
      default:
         b2Settings.b2Assert(false);
         break;
      }
   }
   b2Simplex.prototype.GetMetric = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return 0.0;
      case 1:
         return 0.0;
      case 2:
         return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
      case 3:
         return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   b2Simplex.prototype.Solve2 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
      if (d12_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      var d12_1 = (w2.x * e12.x + w2.y * e12.y);
      if (d12_1 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      var inv_d12 = 1.0 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
   }
   b2Simplex.prototype.Solve3 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var w3 = this.m_v3.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var w1e12 = b2Math.Dot(w1, e12);
      var w2e12 = b2Math.Dot(w2, e12);
      var d12_1 = w2e12;
      var d12_2 = (-w1e12);
      var e13 = b2Math.SubtractVV(w3, w1);
      var w1e13 = b2Math.Dot(w1, e13);
      var w3e13 = b2Math.Dot(w3, e13);
      var d13_1 = w3e13;
      var d13_2 = (-w1e13);
      var e23 = b2Math.SubtractVV(w3, w2);
      var w2e23 = b2Math.Dot(w2, e23);
      var w3e23 = b2Math.Dot(w3, e23);
      var d23_1 = w3e23;
      var d23_2 = (-w2e23);
      var n123 = b2Math.CrossVV(e12, e13);
      var d123_1 = n123 * b2Math.CrossVV(w2, w3);
      var d123_2 = n123 * b2Math.CrossVV(w3, w1);
      var d123_3 = n123 * b2Math.CrossVV(w1, w2);
      if (d12_2 <= 0.0 && d13_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
         var inv_d12 = 1.0 / (d12_1 + d12_2);
         this.m_v1.a = d12_1 * inv_d12;
         this.m_v2.a = d12_2 * inv_d12;
         this.m_count = 2;
         return;
      }
      if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
         var inv_d13 = 1.0 / (d13_1 + d13_2);
         this.m_v1.a = d13_1 * inv_d13;
         this.m_v3.a = d13_2 * inv_d13;
         this.m_count = 2;
         this.m_v2.Set(this.m_v3);
         return;
      }
      if (d12_1 <= 0.0 && d23_2 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      if (d13_1 <= 0.0 && d23_1 <= 0.0) {
         this.m_v3.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v3);
         return;
      }
      if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
         var inv_d23 = 1.0 / (d23_1 + d23_2);
         this.m_v2.a = d23_1 * inv_d23;
         this.m_v3.a = d23_2 * inv_d23;
         this.m_count = 2;
         this.m_v1.Set(this.m_v3);
         return;
      }
      var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
      this.m_v1.a = d123_1 * inv_d123;
      this.m_v2.a = d123_2 * inv_d123;
      this.m_v3.a = d123_3 * inv_d123;
      this.m_count = 3;
   }
   b2SimplexCache.b2SimplexCache = function () {
      this.indexA = new Vector_a2j_Number(3);
      this.indexB = new Vector_a2j_Number(3);
   };
   b2SimplexVertex.b2SimplexVertex = function () {};
   b2SimplexVertex.prototype.Set = function (other) {
      this.wA.SetV(other.wA);
      this.wB.SetV(other.wB);
      this.w.SetV(other.w);
      this.a = other.a;
      this.indexA = other.indexA;
      this.indexB = other.indexB;
   }
   b2TimeOfImpact.b2TimeOfImpact = function () {};
   b2TimeOfImpact.TimeOfImpact = function (input) {
      ++b2TimeOfImpact.b2_toiCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var sweepA = input.sweepA;
      var sweepB = input.sweepB;
      b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
      b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
      var radius = proxyA.m_radius + proxyB.m_radius;
      var tolerance = input.tolerance;
      var alpha = 0.0;
      var k_maxIterations = 1000;
      var iter = 0;
      var target = 0.0;
      b2TimeOfImpact.s_cache.count = 0;
      b2TimeOfImpact.s_distanceInput.useRadii = false;
      for (;;) {
         sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
         sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
         b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
         b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
         b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
         b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
         b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
         if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
            alpha = 1.0;
            break;
         }
         b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
         var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
         if (separation <= 0.0) {
            alpha = 1.0;
            break;
         }
         if (iter == 0) {
            if (separation > radius) {
               target = b2Math.Max(radius - tolerance, 0.75 * radius);
            }
            else {
               target = b2Math.Max(separation - tolerance, 0.02 * radius);
            }
         }
         if (separation - target < 0.5 * tolerance) {
            if (iter == 0) {
               alpha = 1.0;
               break;
            }
            break;
         }
         var newAlpha = alpha; {
            var x1 = alpha;
            var x2 = 1.0;
            var f1 = separation;
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
            var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (f2 >= target) {
               alpha = 1.0;
               break;
            }
            var rootIterCount = 0;
            for (;;) {
               var x = 0;
               if (rootIterCount & 1) {
                  x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
               }
               else {
                  x = 0.5 * (x1 + x2);
               }
               sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
               sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
               var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
               if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                  newAlpha = x;
                  break;
               }
               if (f > target) {
                  x1 = x;
                  f1 = f;
               }
               else {
                  x2 = x;
                  f2 = f;
               }++rootIterCount;
               ++b2TimeOfImpact.b2_toiRootIters;
               if (rootIterCount == 50) {
                  break;
               }
            }
            b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
         }
         if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
            break;
         }
         alpha = newAlpha;
         iter++;
         ++b2TimeOfImpact.b2_toiIters;
         if (iter == k_maxIterations) {
            break;
         }
      }
      b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
      return alpha;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
      Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
      Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
      Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
   });
   b2TOIInput.b2TOIInput = function () {
      this.proxyA = new b2DistanceProxy();
      this.proxyB = new b2DistanceProxy();
      this.sweepA = new b2Sweep();
      this.sweepB = new b2Sweep();
   };
   b2WorldManifold.b2WorldManifold = function () {
      this.m_normal = new b2Vec2();
   };
   b2WorldManifold.prototype.b2WorldManifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
      if (radiusA === undefined) radiusA = 0;
      if (radiusB === undefined) radiusB = 0;
      if (manifold.m_pointCount == 0) {
         return;
      }
      var i = 0;
      var tVec;
      var tMat;
      var normalX = 0;
      var normalY = 0;
      var planePointX = 0;
      var planePointY = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      switch (manifold.m_type) {
      case b2Manifold.e_circles:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_points[0].m_localPoint;
            var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1;
               this.m_normal.y = 0;
            }
            var cAX = pointAX + radiusA * this.m_normal.x;
            var cAY = pointAY + radiusA * this.m_normal.y;
            var cBX = pointBX - radiusB * this.m_normal.x;
            var cBY = pointBY - radiusB * this.m_normal.y;
            this.m_points[0].x = 0.5 * (cAX + cBX);
            this.m_points[0].y = 0.5 * (cAY + cBY);
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = normalX;
            this.m_normal.y = normalY;
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfB.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = xfB.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_localPoint;
            planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = (-normalX);
            this.m_normal.y = (-normalY);
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfA.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
            }
         }
         break;
      }
   }
   ClipVertex.ClipVertex = function () {
      this.v = new b2Vec2();
      this.id = new b2ContactID();
   };
   ClipVertex.prototype.Set = function (other) {
      this.v.SetV(other.v);
      this.id.Set(other.id);
   }
   Features.Features = function () {};
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._referenceEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._referenceEdge = value;
         this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentEdge = value;
         this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentVertex;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentVertex = value;
         this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._flip;
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._flip = value;
         this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
      }
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
   b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2CircleShape.b2CircleShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.m_p = new b2Vec2();
   };
   b2CircleShape.prototype.Copy = function () {
      var s = new b2CircleShape();
      s.Set(this);
      return s;
   }
   b2CircleShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2CircleShape)) {
         var other2 = (other instanceof b2CircleShape ? other : null);
         this.m_p.SetV(other2.m_p);
      }
   }
   b2CircleShape.prototype.TestPoint = function (transform, p) {
      var tMat = transform.R;
      var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      dX = p.x - dX;
      dY = p.y - dY;
      return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
   }
   b2CircleShape.prototype.RayCast = function (output, input, transform) {
      var tMat = transform.R;
      var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      var sX = input.p1.x - positionX;
      var sY = input.p1.y - positionY;
      var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      var c = (sX * rX + sY * rY);
      var rr = (rX * rX + rY * rY);
      var sigma = c * c - rr * b;
      if (sigma < 0.0 || rr < Number.MIN_VALUE) {
         return false;
      }
      var a = (-(c + Math.sqrt(sigma)));
      if (0.0 <= a && a <= input.maxFraction * rr) {
         a /= rr;
         output.fraction = a;
         output.normal.x = sX + a * rX;
         output.normal.y = sY + a * rY;
         output.normal.Normalize();
         return true;
      }
      return false;
   }
   b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
      aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
   }
   b2CircleShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
      massData.center.SetV(this.m_p);
      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
   }
   b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var p = b2Math.MulX(xf, this.m_p);
      var l = (-(b2Math.Dot(normal, p) - offset));
      if (l < (-this.m_radius) + Number.MIN_VALUE) {
         return 0;
      }
      if (l > this.m_radius) {
         c.SetV(p);
         return Math.PI * this.m_radius * this.m_radius;
      }
      var r2 = this.m_radius * this.m_radius;
      var l2 = l * l;
      var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
      var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
      c.x = p.x + normal.x * com;
      c.y = p.y + normal.y * com;
      return area;
   }
   b2CircleShape.prototype.GetLocalPosition = function () {
      return this.m_p;
   }
   b2CircleShape.prototype.SetLocalPosition = function (position) {
      this.m_p.SetV(position);
   }
   b2CircleShape.prototype.GetRadius = function () {
      return this.m_radius;
   }
   b2CircleShape.prototype.SetRadius = function (radius) {
      if (radius === undefined) radius = 0;
      this.m_radius = radius;
   }
   b2CircleShape.prototype.b2CircleShape = function (radius) {
      if (radius === undefined) radius = 0;
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_circleShape;
      this.m_radius = radius;
   }
   b2EdgeChainDef.b2EdgeChainDef = function () {};
   b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
      this.vertexCount = 0;
      this.isALoop = true;
      this.vertices = [];
   }
   Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
   b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2EdgeShape.b2EdgeShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.s_supportVec = new b2Vec2();
      this.m_v1 = new b2Vec2();
      this.m_v2 = new b2Vec2();
      this.m_coreV1 = new b2Vec2();
      this.m_coreV2 = new b2Vec2();
      this.m_normal = new b2Vec2();
      this.m_direction = new b2Vec2();
      this.m_cornerDir1 = new b2Vec2();
      this.m_cornerDir2 = new b2Vec2();
   };
   b2EdgeShape.prototype.TestPoint = function (transform, p) {
      return false;
   }
   b2EdgeShape.prototype.RayCast = function (output, input, transform) {
      var tMat;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
      var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = input.p1.x - v1X;
         var bY = input.p1.y - v1Y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= input.maxFraction * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               output.fraction = a;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               output.normal.x = nX / nLen;
               output.normal.y = nY / nLen;
               return true;
            }
         }
      }
      return false;
   }
   b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
      var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
      if (v1X < v2X) {
         aabb.lowerBound.x = v1X;
         aabb.upperBound.x = v2X;
      }
      else {
         aabb.lowerBound.x = v2X;
         aabb.upperBound.x = v1X;
      }
      if (v1Y < v2Y) {
         aabb.lowerBound.y = v1Y;
         aabb.upperBound.y = v2Y;
      }
      else {
         aabb.lowerBound.y = v2Y;
         aabb.upperBound.y = v1Y;
      }
   }
   b2EdgeShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = 0;
      massData.center.SetV(this.m_v1);
      massData.I = 0;
   }
   b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
      var v1 = b2Math.MulX(xf, this.m_v1);
      var v2 = b2Math.MulX(xf, this.m_v2);
      var d1 = b2Math.Dot(normal, v1) - offset;
      var d2 = b2Math.Dot(normal, v2) - offset;
      if (d1 > 0) {
         if (d2 > 0) {
            return 0;
         }
         else {
            v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
      }
      else {
         if (d2 > 0) {
            v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
         else {}
      }
      c.x = (v0.x + v1.x + v2.x) / 3;
      c.y = (v0.y + v1.y + v2.y) / 3;
      return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
   }
   b2EdgeShape.prototype.GetLength = function () {
      return this.m_length;
   }
   b2EdgeShape.prototype.GetVertex1 = function () {
      return this.m_v1;
   }
   b2EdgeShape.prototype.GetVertex2 = function () {
      return this.m_v2;
   }
   b2EdgeShape.prototype.GetCoreVertex1 = function () {
      return this.m_coreV1;
   }
   b2EdgeShape.prototype.GetCoreVertex2 = function () {
      return this.m_coreV2;
   }
   b2EdgeShape.prototype.GetNormalVector = function () {
      return this.m_normal;
   }
   b2EdgeShape.prototype.GetDirectionVector = function () {
      return this.m_direction;
   }
   b2EdgeShape.prototype.GetCorner1Vector = function () {
      return this.m_cornerDir1;
   }
   b2EdgeShape.prototype.GetCorner2Vector = function () {
      return this.m_cornerDir2;
   }
   b2EdgeShape.prototype.Corner1IsConvex = function () {
      return this.m_cornerConvex1;
   }
   b2EdgeShape.prototype.Corner2IsConvex = function () {
      return this.m_cornerConvex2;
   }
   b2EdgeShape.prototype.GetFirstVertex = function (xf) {
      var tMat = xf.R;
      return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
   }
   b2EdgeShape.prototype.GetNextEdge = function () {
      return this.m_nextEdge;
   }
   b2EdgeShape.prototype.GetPrevEdge = function () {
      return this.m_prevEdge;
   }
   b2EdgeShape.prototype.Support = function (xf, dX, dY) {
      if (dX === undefined) dX = 0;
      if (dY === undefined) dY = 0;
      var tMat = xf.R;
      var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
      var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
      var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
      var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
      if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
         this.s_supportVec.x = v1X;
         this.s_supportVec.y = v1Y;
      }
      else {
         this.s_supportVec.x = v2X;
         this.s_supportVec.y = v2Y;
      }
      return this.s_supportVec;
   }
   b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_edgeShape;
      this.m_prevEdge = null;
      this.m_nextEdge = null;
      this.m_v1 = v1;
      this.m_v2 = v2;
      this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
      this.m_length = this.m_direction.Normalize();
      this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
      this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
      this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
      this.m_cornerDir1 = this.m_normal;
      this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
   }
   b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
      this.m_prevEdge = edge;
      this.m_coreV1 = core;
      this.m_cornerDir1 = cornerDir;
      this.m_cornerConvex1 = convex;
   }
   b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
      this.m_nextEdge = edge;
      this.m_coreV2 = core;
      this.m_cornerDir2 = cornerDir;
      this.m_cornerConvex2 = convex;
   }
   b2MassData.b2MassData = function () {
      this.mass = 0.0;
      this.center = new b2Vec2(0, 0);
      this.I = 0.0;
   };
   Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
   b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2PolygonShape.b2PolygonShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
   };
   b2PolygonShape.prototype.Copy = function () {
      var s = new b2PolygonShape();
      s.Set(this);
      return s;
   }
   b2PolygonShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2PolygonShape)) {
         var other2 = (other instanceof b2PolygonShape ? other : null);
         this.m_centroid.SetV(other2.m_centroid);
         this.m_vertexCount = other2.m_vertexCount;
         this.Reserve(this.m_vertexCount);
         for (var i = 0; i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(other2.m_vertices[i]);
            this.m_normals[i].SetV(other2.m_normals[i]);
         }
      }
   }
   b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var v = new Vector();
      var i = 0,
         tVec;
      for (i = 0;
      i < vertices.length; ++i) {
         tVec = vertices[i];
         v.push(tVec);
      }
      this.SetAsVector(v, vertexCount);
   }
   b2PolygonShape.AsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsArray(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      if (vertexCount == 0) vertexCount = vertices.length;
      b2Settings.b2Assert(2 <= vertexCount);
      this.m_vertexCount = vertexCount;
      this.Reserve(vertexCount);
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; i++) {
         this.m_vertices[i].SetV(vertices[i]);
      }
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         var i1 = parseInt(i);
         var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
         var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
         b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
         this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
         this.m_normals[i].Normalize();
      }
      this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
   }
   b2PolygonShape.AsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsVector(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid.SetZero();
   }
   b2PolygonShape.AsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsBox(hx, hy);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid = center;
      var xf = new b2Transform();
      xf.position = center;
      xf.R.Set(angle);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
         this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
      }
   }
   b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsOrientedBox(hx, hy, center, angle);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
      this.m_vertexCount = 2;
      this.Reserve(2);
      this.m_vertices[0].SetV(v1);
      this.m_vertices[1].SetV(v2);
      this.m_centroid.x = 0.5 * (v1.x + v2.x);
      this.m_centroid.y = 0.5 * (v1.y + v2.y);
      this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
      this.m_normals[0].Normalize();
      this.m_normals[1].x = (-this.m_normals[0].x);
      this.m_normals[1].y = (-this.m_normals[0].y);
   }
   b2PolygonShape.AsEdge = function (v1, v2) {
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsEdge(v1, v2);
      return polygonShape;
   }
   b2PolygonShape.prototype.TestPoint = function (xf, p) {
      var tVec;
      var tMat = xf.R;
      var tX = p.x - xf.position.x;
      var tY = p.y - xf.position.y;
      var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
      var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = pLocalX - tVec.x;
         tY = pLocalY - tVec.y;
         tVec = this.m_normals[i];
         var dot = (tVec.x * tX + tVec.y * tY);
         if (dot > 0.0) {
            return false;
         }
      }
      return true;
   }
   b2PolygonShape.prototype.RayCast = function (output, input, transform) {
      var lower = 0.0;
      var upper = input.maxFraction;
      var tX = 0;
      var tY = 0;
      var tMat;
      var tVec;
      tX = input.p1.x - transform.position.x;
      tY = input.p1.y - transform.position.y;
      tMat = transform.R;
      var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      tX = input.p2.x - transform.position.x;
      tY = input.p2.y - transform.position.y;
      tMat = transform.R;
      var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var index = parseInt((-1));
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = tVec.x - p1X;
         tY = tVec.y - p1Y;
         tVec = this.m_normals[i];
         var numerator = (tVec.x * tX + tVec.y * tY);
         var denominator = (tVec.x * dX + tVec.y * dY);
         if (denominator == 0.0) {
            if (numerator < 0.0) {
               return false;
            }
         }
         else {
            if (denominator < 0.0 && numerator < lower * denominator) {
               lower = numerator / denominator;
               index = i;
            }
            else if (denominator > 0.0 && numerator < upper * denominator) {
               upper = numerator / denominator;
            }
         }
         if (upper < lower - Number.MIN_VALUE) {
            return false;
         }
      }
      if (index >= 0) {
         output.fraction = lower;
         tMat = transform.R;
         tVec = this.m_normals[index];
         output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         return true;
      }
      return false;
   }
   b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
      var tMat = xf.R;
      var tVec = this.m_vertices[0];
      var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var upperX = lowerX;
      var upperY = lowerY;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         lowerX = lowerX < vX ? lowerX : vX;
         lowerY = lowerY < vY ? lowerY : vY;
         upperX = upperX > vX ? upperX : vX;
         upperY = upperY > vY ? upperY : vY;
      }
      aabb.lowerBound.x = lowerX - this.m_radius;
      aabb.lowerBound.y = lowerY - this.m_radius;
      aabb.upperBound.x = upperX + this.m_radius;
      aabb.upperBound.y = upperY + this.m_radius;
   }
   b2PolygonShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      if (this.m_vertexCount == 2) {
         massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
         massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
         massData.mass = 0.0;
         massData.I = 0.0;
         return;
      }
      var centerX = 0.0;
      var centerY = 0.0;
      var area = 0.0;
      var I = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var k_inv3 = 1.0 / 3.0;
      for (var i = 0; i < this.m_vertexCount; ++i) {
         var p2 = this.m_vertices[i];
         var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = e1X * e2Y - e1Y * e2X;
         var triangleArea = 0.5 * D;area += triangleArea;
         centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
         centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
         var px = p1X;
         var py = p1Y;
         var ex1 = e1X;
         var ey1 = e1Y;
         var ex2 = e2X;
         var ey2 = e2Y;
         var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
         var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
      }
      massData.mass = density * area;
      centerX *= 1.0 / area;
      centerY *= 1.0 / area;
      massData.center.Set(centerX, centerY);
      massData.I = density * I;
   }
   b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var normalL = b2Math.MulTMV(xf.R, normal);
      var offsetL = offset - b2Math.Dot(normal, xf.position);
      var depths = new Vector_a2j_Number();
      var diveCount = 0;
      var intoIndex = parseInt((-1));
      var outoIndex = parseInt((-1));
      var lastSubmerged = false;
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
         var isSubmerged = depths[i] < (-Number.MIN_VALUE);
         if (i > 0) {
            if (isSubmerged) {
               if (!lastSubmerged) {
                  intoIndex = i - 1;
                  diveCount++;
               }
            }
            else {
               if (lastSubmerged) {
                  outoIndex = i - 1;
                  diveCount++;
               }
            }
         }
         lastSubmerged = isSubmerged;
      }
      switch (diveCount) {
      case 0:
         if (lastSubmerged) {
            var md = new b2MassData();
            this.ComputeMass(md, 1);
            c.SetV(b2Math.MulX(xf, md.center));
            return md.mass;
         }
         else {
            return 0;
         }
         break;
      case 1:
         if (intoIndex == (-1)) {
            intoIndex = this.m_vertexCount - 1;
         }
         else {
            outoIndex = this.m_vertexCount - 1;
         }
         break;
      }
      var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
      var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
      var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
      var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
      var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
      var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
      var area = 0;
      var center = new b2Vec2();
      var p2 = this.m_vertices[intoIndex2];
      var p3;
      i = intoIndex2;
      while (i != outoIndex2) {
         i = (i + 1) % this.m_vertexCount;
         if (i == outoIndex2) p3 = outoVec;
         else p3 = this.m_vertices[i];
         var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
         area += triangleArea;
         center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
         center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
         p2 = p3;
      }
      center.Multiply(1 / area);
      c.SetV(b2Math.MulX(xf, center));
      return area;
   }
   b2PolygonShape.prototype.GetVertexCount = function () {
      return this.m_vertexCount;
   }
   b2PolygonShape.prototype.GetVertices = function () {
      return this.m_vertices;
   }
   b2PolygonShape.prototype.GetNormals = function () {
      return this.m_normals;
   }
   b2PolygonShape.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2PolygonShape.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2PolygonShape.prototype.Validate = function () {
      return false;
   }
   b2PolygonShape.prototype.b2PolygonShape = function () {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_polygonShape;
      this.m_centroid = new b2Vec2();
      this.m_vertices = new Vector();
      this.m_normals = new Vector();
   }
   b2PolygonShape.prototype.Reserve = function (count) {
      if (count === undefined) count = 0;
      for (var i = parseInt(this.m_vertices.length); i < count; i++) {
         this.m_vertices[i] = new b2Vec2();
         this.m_normals[i] = new b2Vec2();
      }
   }
   b2PolygonShape.ComputeCentroid = function (vs, count) {
      if (count === undefined) count = 0;
      var c = new b2Vec2();
      var area = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var inv3 = 1.0 / 3.0;
      for (var i = 0; i < count; ++i) {
         var p2 = vs[i];
         var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = (e1X * e2Y - e1Y * e2X);
         var triangleArea = 0.5 * D;area += triangleArea;
         c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
         c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
      }
      c.x *= 1.0 / area;
      c.y *= 1.0 / area;
      return c;
   }
   b2PolygonShape.ComputeOBB = function (obb, vs, count) {
      if (count === undefined) count = 0;
      var i = 0;
      var p = new Vector(count + 1);
      for (i = 0;
      i < count; ++i) {
         p[i] = vs[i];
      }
      p[count] = p[0];
      var minArea = Number.MAX_VALUE;
      for (i = 1;
      i <= count; ++i) {
         var root = p[parseInt(i - 1)];
         var uxX = p[i].x - root.x;
         var uxY = p[i].y - root.y;
         var length = Math.sqrt(uxX * uxX + uxY * uxY);
         uxX /= length;
         uxY /= length;
         var uyX = (-uxY);
         var uyY = uxX;
         var lowerX = Number.MAX_VALUE;
         var lowerY = Number.MAX_VALUE;
         var upperX = (-Number.MAX_VALUE);
         var upperY = (-Number.MAX_VALUE);
         for (var j = 0; j < count; ++j) {
            var dX = p[j].x - root.x;
            var dY = p[j].y - root.y;
            var rX = (uxX * dX + uxY * dY);
            var rY = (uyX * dX + uyY * dY);
            if (rX < lowerX) lowerX = rX;
            if (rY < lowerY) lowerY = rY;
            if (rX > upperX) upperX = rX;
            if (rY > upperY) upperY = rY;
         }
         var area = (upperX - lowerX) * (upperY - lowerY);
         if (area < 0.95 * minArea) {
            minArea = area;
            obb.R.col1.x = uxX;
            obb.R.col1.y = uxY;
            obb.R.col2.x = uyX;
            obb.R.col2.y = uyY;
            var centerX = 0.5 * (lowerX + upperX);
            var centerY = 0.5 * (lowerY + upperY);
            var tMat = obb.R;
            obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
            obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
            obb.extents.x = 0.5 * (upperX - lowerX);
            obb.extents.y = 0.5 * (upperY - lowerY);
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
   });
   b2Shape.b2Shape = function () {};
   b2Shape.prototype.Copy = function () {
      return null;
   }
   b2Shape.prototype.Set = function (other) {
      this.m_radius = other.m_radius;
   }
   b2Shape.prototype.GetType = function () {
      return this.m_type;
   }
   b2Shape.prototype.TestPoint = function (xf, p) {
      return false;
   }
   b2Shape.prototype.RayCast = function (output, input, transform) {
      return false;
   }
   b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
   b2Shape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
   }
   b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      return 0;
   }
   b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
      var input = new b2DistanceInput();
      input.proxyA = new b2DistanceProxy();
      input.proxyA.Set(shape1);
      input.proxyB = new b2DistanceProxy();
      input.proxyB.Set(shape2);
      input.transformA = transform1;
      input.transformB = transform2;
      input.useRadii = true;
      var simplexCache = new b2SimplexCache();
      simplexCache.count = 0;
      var output = new b2DistanceOutput();
      b2Distance.Distance(output, simplexCache, input);
      return output.distance < 10.0 * Number.MIN_VALUE;
   }
   b2Shape.prototype.b2Shape = function () {
      this.m_type = b2Shape.e_unknownShape;
      this.m_radius = b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
      Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
      Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
      Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
      Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
      Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
      Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
      Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Color.b2Color = function () {
      this._r = 0;
      this._g = 0;
      this._b = 0;
   };
   b2Color.prototype.b2Color = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   b2Color.prototype.Set = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   Object.defineProperty(b2Color.prototype, 'r', {
      enumerable: false,
      configurable: true,
      set: function (rr) {
         if (rr === undefined) rr = 0;
         this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'g', {
      enumerable: false,
      configurable: true,
      set: function (gg) {
         if (gg === undefined) gg = 0;
         this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'b', {
      enumerable: false,
      configurable: true,
      set: function (bb) {
         if (bb === undefined) bb = 0;
         this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'color', {
      enumerable: false,
      configurable: true,
      get: function () {
         return (this._r << 16) | (this._g << 8) | (this._b);
      }
   });
   b2Settings.b2Settings = function () {};
   b2Settings.b2MixFriction = function (friction1, friction2) {
      if (friction1 === undefined) friction1 = 0;
      if (friction2 === undefined) friction2 = 0;
      return Math.sqrt(friction1 * friction2);
   }
   b2Settings.b2MixRestitution = function (restitution1, restitution2) {
      if (restitution1 === undefined) restitution1 = 0;
      if (restitution2 === undefined) restitution2 = 0;
      return restitution1 > restitution2 ? restitution1 : restitution2;
   }
   b2Settings.b2Assert = function (a) {
      if (!a) {
         throw "Assertion Failed";
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.b2Settings.VERSION = "2.1alpha";
      Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
      Box2D.Common.b2Settings.b2_pi = Math.PI;
      Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
      Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
      Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
      Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_linearSlop = 0.005;
      Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
      Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
      Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
      Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
      Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
      Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
      Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
      Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
      Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
      Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
      Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
   });
})();
(function () {
   var b2AABB = Box2D.Collision.b2AABB,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Mat22.b2Mat22 = function () {
      this.col1 = new b2Vec2();
      this.col2 = new b2Vec2();
   };
   b2Mat22.prototype.b2Mat22 = function () {
      this.SetIdentity();
   }
   b2Mat22.FromAngle = function (angle) {
      if (angle === undefined) angle = 0;
      var mat = new b2Mat22();
      mat.Set(angle);
      return mat;
   }
   b2Mat22.FromVV = function (c1, c2) {
      var mat = new b2Mat22();
      mat.SetVV(c1, c2);
      return mat;
   }
   b2Mat22.prototype.Set = function (angle) {
      if (angle === undefined) angle = 0;
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      this.col1.x = c;
      this.col2.x = (-s);
      this.col1.y = s;
      this.col2.y = c;
   }
   b2Mat22.prototype.SetVV = function (c1, c2) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
   }
   b2Mat22.prototype.Copy = function () {
      var mat = new b2Mat22();
      mat.SetM(this);
      return mat;
   }
   b2Mat22.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
   }
   b2Mat22.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
   }
   b2Mat22.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
   }
   b2Mat22.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
   }
   b2Mat22.prototype.GetAngle = function () {
      return Math.atan2(this.col1.y, this.col1.x);
   }
   b2Mat22.prototype.GetInverse = function (out) {
      var a = this.col1.x;
      var b = this.col2.x;
      var c = this.col1.y;
      var d = this.col2.y;
      var det = a * d - b * c;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.col1.x = det * d;
      out.col2.x = (-det * b);
      out.col1.y = (-det * c);
      out.col2.y = det * a;
      return out;
   }
   b2Mat22.prototype.Solve = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat22.prototype.Abs = function () {
      this.col1.Abs();
      this.col2.Abs();
   }
   b2Mat33.b2Mat33 = function () {
      this.col1 = new b2Vec3();
      this.col2 = new b2Vec3();
      this.col3 = new b2Vec3();
   };
   b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
      if (c1 === undefined) c1 = null;
      if (c2 === undefined) c2 = null;
      if (c3 === undefined) c3 = null;
      if (!c1 && !c2 && !c3) {
         this.col1.SetZero();
         this.col2.SetZero();
         this.col3.SetZero();
      }
      else {
         this.col1.SetV(c1);
         this.col2.SetV(c2);
         this.col3.SetV(c3);
      }
   }
   b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
      this.col3.SetV(c3);
   }
   b2Mat33.prototype.Copy = function () {
      return new b2Mat33(this.col1, this.col2, this.col3);
   }
   b2Mat33.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
      this.col3.SetV(m.col3);
   }
   b2Mat33.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col1.z += m.col1.z;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
      this.col2.z += m.col2.z;
      this.col3.x += m.col3.x;
      this.col3.y += m.col3.y;
      this.col3.z += m.col3.z;
   }
   b2Mat33.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 1.0;
   }
   b2Mat33.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 0.0;
   }
   b2Mat33.prototype.Solve22 = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      if (bZ === undefined) bZ = 0;
      var a11 = this.col1.x;
      var a21 = this.col1.y;
      var a31 = this.col1.z;
      var a12 = this.col2.x;
      var a22 = this.col2.y;
      var a32 = this.col2.z;
      var a13 = this.col3.x;
      var a23 = this.col3.y;
      var a33 = this.col3.z;
      var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
      out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
      out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
      return out;
   }
   b2Math.b2Math = function () {};
   b2Math.IsValid = function (x) {
      if (x === undefined) x = 0;
      return isFinite(x);
   }
   b2Math.Dot = function (a, b) {
      return a.x * b.x + a.y * b.y;
   }
   b2Math.CrossVV = function (a, b) {
      return a.x * b.y - a.y * b.x;
   }
   b2Math.CrossVF = function (a, s) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.y, (-s * a.x));
      return v;
   }
   b2Math.CrossFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2((-s * a.y), s * a.x);
      return v;
   }
   b2Math.MulMV = function (A, v) {
      var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
      return u;
   }
   b2Math.MulTMV = function (A, v) {
      var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
      return u;
   }
   b2Math.MulX = function (T, v) {
      var a = b2Math.MulMV(T.R, v);
      a.x += T.position.x;
      a.y += T.position.y;
      return a;
   }
   b2Math.MulXT = function (T, v) {
      var a = b2Math.SubtractVV(v, T.position);
      var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
      a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
      a.x = tX;
      return a;
   }
   b2Math.AddVV = function (a, b) {
      var v = new b2Vec2(a.x + b.x, a.y + b.y);
      return v;
   }
   b2Math.SubtractVV = function (a, b) {
      var v = new b2Vec2(a.x - b.x, a.y - b.y);
      return v;
   }
   b2Math.Distance = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return Math.sqrt(cX * cX + cY * cY);
   }
   b2Math.DistanceSquared = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return (cX * cX + cY * cY);
   }
   b2Math.MulFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.x, s * a.y);
      return v;
   }
   b2Math.AddMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
      return C;
   }
   b2Math.MulMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
      return C;
   }
   b2Math.MulTMM = function (A, B) {
      var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
      var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
      var C = b2Mat22.FromVV(c1, c2);
      return C;
   }
   b2Math.Abs = function (a) {
      if (a === undefined) a = 0;
      return a > 0.0 ? a : (-a);
   }
   b2Math.AbsV = function (a) {
      var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
      return b;
   }
   b2Math.AbsM = function (A) {
      var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
      return B;
   }
   b2Math.Min = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a < b ? a : b;
   }
   b2Math.MinV = function (a, b) {
      var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
      return c;
   }
   b2Math.Max = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a > b ? a : b;
   }
   b2Math.MaxV = function (a, b) {
      var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
      return c;
   }
   b2Math.Clamp = function (a, low, high) {
      if (a === undefined) a = 0;
      if (low === undefined) low = 0;
      if (high === undefined) high = 0;
      return a < low ? low : a > high ? high : a;
   }
   b2Math.ClampV = function (a, low, high) {
      return b2Math.MaxV(low, b2Math.MinV(a, high));
   }
   b2Math.Swap = function (a, b) {
      var tmp = a[0];
      a[0] = b[0];
      b[0] = tmp;
   }
   b2Math.Random = function () {
      return Math.random() * 2 - 1;
   }
   b2Math.RandomRange = function (lo, hi) {
      if (lo === undefined) lo = 0;
      if (hi === undefined) hi = 0;
      var r = Math.random();
      r = (hi - lo) * r + lo;
      return r;
   }
   b2Math.NextPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      x |= (x >> 1) & 0x7FFFFFFF;
      x |= (x >> 2) & 0x3FFFFFFF;
      x |= (x >> 4) & 0x0FFFFFFF;
      x |= (x >> 8) & 0x00FFFFFF;
      x |= (x >> 16) & 0x0000FFFF;
      return x + 1;
   }
   b2Math.IsPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      var result = x > 0 && (x & (x - 1)) == 0;
      return result;
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
      Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
      Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
   });
   b2Sweep.b2Sweep = function () {
      this.localCenter = new b2Vec2();
      this.c0 = new b2Vec2;
      this.c = new b2Vec2();
   };
   b2Sweep.prototype.Set = function (other) {
      this.localCenter.SetV(other.localCenter);
      this.c0.SetV(other.c0);
      this.c.SetV(other.c);
      this.a0 = other.a0;
      this.a = other.a;
      this.t0 = other.t0;
   }
   b2Sweep.prototype.Copy = function () {
      var copy = new b2Sweep();
      copy.localCenter.SetV(this.localCenter);
      copy.c0.SetV(this.c0);
      copy.c.SetV(this.c);
      copy.a0 = this.a0;
      copy.a = this.a;
      copy.t0 = this.t0;
      return copy;
   }
   b2Sweep.prototype.GetTransform = function (xf, alpha) {
      if (alpha === undefined) alpha = 0;
      xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
      xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
      var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
      xf.R.Set(angle);
      var tMat = xf.R;
      xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
      xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
   }
   b2Sweep.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
         var alpha = (t - this.t0) / (1.0 - this.t0);
         this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
         this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
         this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
         this.t0 = t;
      }
   }
   b2Transform.b2Transform = function () {
      this.position = new b2Vec2;
      this.R = new b2Mat22();
   };
   b2Transform.prototype.b2Transform = function (pos, r) {
      if (pos === undefined) pos = null;
      if (r === undefined) r = null;
      if (pos) {
         this.position.SetV(pos);
         this.R.SetM(r);
      }
   }
   b2Transform.prototype.Initialize = function (pos, r) {
      this.position.SetV(pos);
      this.R.SetM(r);
   }
   b2Transform.prototype.SetIdentity = function () {
      this.position.SetZero();
      this.R.SetIdentity();
   }
   b2Transform.prototype.Set = function (x) {
      this.position.SetV(x.position);
      this.R.SetM(x.R);
   }
   b2Transform.prototype.GetAngle = function () {
      return Math.atan2(this.R.col1.y, this.R.col1.x);
   }
   b2Vec2.b2Vec2 = function () {};
   b2Vec2.prototype.b2Vec2 = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetZero = function () {
      this.x = 0.0;
      this.y = 0.0;
   }
   b2Vec2.prototype.Set = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
   }
   b2Vec2.prototype.GetNegative = function () {
      return new b2Vec2((-this.x), (-this.y));
   }
   b2Vec2.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
   }
   b2Vec2.Make = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      return new b2Vec2(x_, y_);
   }
   b2Vec2.prototype.Copy = function () {
      return new b2Vec2(this.x, this.y);
   }
   b2Vec2.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
   }
   b2Vec2.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
   }
   b2Vec2.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
   }
   b2Vec2.prototype.MulM = function (A) {
      var tX = this.x;
      this.x = A.col1.x * tX + A.col2.x * this.y;
      this.y = A.col1.y * tX + A.col2.y * this.y;
   }
   b2Vec2.prototype.MulTM = function (A) {
      var tX = b2Math.Dot(this, A.col1);
      this.y = b2Math.Dot(this, A.col2);
      this.x = tX;
   }
   b2Vec2.prototype.CrossVF = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = s * this.y;
      this.y = (-s * tX);
   }
   b2Vec2.prototype.CrossFV = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = (-s * this.y);
      this.y = s * tX;
   }
   b2Vec2.prototype.MinV = function (b) {
      this.x = this.x < b.x ? this.x : b.x;
      this.y = this.y < b.y ? this.y : b.y;
   }
   b2Vec2.prototype.MaxV = function (b) {
      this.x = this.x > b.x ? this.x : b.x;
      this.y = this.y > b.y ? this.y : b.y;
   }
   b2Vec2.prototype.Abs = function () {
      if (this.x < 0) this.x = (-this.x);
      if (this.y < 0) this.y = (-this.y);
   }
   b2Vec2.prototype.Length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.LengthSquared = function () {
      return (this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.Normalize = function () {
      var length = Math.sqrt(this.x * this.x + this.y * this.y);
      if (length < Number.MIN_VALUE) {
         return 0.0;
      }
      var invLength = 1.0 / length;
      this.x *= invLength;
      this.y *= invLength;
      return length;
   }
   b2Vec2.prototype.IsValid = function () {
      return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
   }
   b2Vec3.b2Vec3 = function () {};
   b2Vec3.prototype.b2Vec3 = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetZero = function () {
      this.x = this.y = this.z = 0.0;
   }
   b2Vec3.prototype.Set = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
   }
   b2Vec3.prototype.GetNegative = function () {
      return new b2Vec3((-this.x), (-this.y), (-this.z));
   }
   b2Vec3.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
      this.z = (-this.z);
   }
   b2Vec3.prototype.Copy = function () {
      return new b2Vec3(this.x, this.y, this.z);
   }
   b2Vec3.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
   }
   b2Vec3.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
   }
   b2Vec3.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
      this.z *= a;
   }
})();
(function () {
   var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

   b2Body.b2Body = function () {
      this.m_xf = new b2Transform();
      this.m_sweep = new b2Sweep();
      this.m_linearVelocity = new b2Vec2();
      this.m_force = new b2Vec2();
   };
   b2Body.prototype.connectEdges = function (s1, s2, angle1) {
      if (angle1 === undefined) angle1 = 0;
      var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
      var coreOffset = Math.tan((angle2 - angle1) * 0.5);
      var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
      core = b2Math.SubtractVV(core, s2.GetNormalVector());
      core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
      core = b2Math.AddVV(core, s2.GetVertex1());
      var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
      cornerDir.Normalize();
      var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
      s1.SetNextEdge(s2, core, cornerDir, convex);
      s2.SetPrevEdge(s1, core, cornerDir, convex);
      return angle2;
   }
   b2Body.prototype.CreateFixture = function (def) {
      if (this.m_world.IsLocked() == true) {
         return null;
      }
      var fixture = new b2Fixture();
      fixture.Create(this, this.m_xf, def);
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.CreateProxy(broadPhase, this.m_xf);
      }
      fixture.m_next = this.m_fixtureList;
      this.m_fixtureList = fixture;
      ++this.m_fixtureCount;
      fixture.m_body = this;
      if (fixture.m_density > 0.0) {
         this.ResetMassData();
      }
      this.m_world.m_flags |= b2World.e_newFixture;
      return fixture;
   }
   b2Body.prototype.CreateFixture2 = function (shape, density) {
      if (density === undefined) density = 0.0;
      var def = new b2FixtureDef();
      def.shape = shape;
      def.density = density;
      return this.CreateFixture(def);
   }
   b2Body.prototype.DestroyFixture = function (fixture) {
      if (this.m_world.IsLocked() == true) {
         return;
      }
      var node = this.m_fixtureList;
      var ppF = null;
      var found = false;
      while (node != null) {
         if (node == fixture) {
            if (ppF) ppF.m_next = fixture.m_next;
            else this.m_fixtureList = fixture.m_next;
            found = true;
            break;
         }
         ppF = node;
         node = node.m_next;
      }
      var edge = this.m_contactList;
      while (edge) {
         var c = edge.contact;
         edge = edge.next;
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         if (fixture == fixtureA || fixture == fixtureB) {
            this.m_world.m_contactManager.Destroy(c);
         }
      }
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.DestroyProxy(broadPhase);
      }
      else {}
      fixture.Destroy();
      fixture.m_body = null;
      fixture.m_next = null;
      --this.m_fixtureCount;
      this.ResetMassData();
   }
   b2Body.prototype.SetPositionAndAngle = function (position, angle) {
      if (angle === undefined) angle = 0;
      var f;
      if (this.m_world.IsLocked() == true) {
         return;
      }
      this.m_xf.R.Set(angle);
      this.m_xf.position.SetV(position);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_sweep.a0 = this.m_sweep.a = angle;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, this.m_xf, this.m_xf);
      }
      this.m_world.m_contactManager.FindNewContacts();
   }
   b2Body.prototype.SetTransform = function (xf) {
      this.SetPositionAndAngle(xf.position, xf.GetAngle());
   }
   b2Body.prototype.GetTransform = function () {
      return this.m_xf;
   }
   b2Body.prototype.GetPosition = function () {
      return this.m_xf.position;
   }
   b2Body.prototype.SetPosition = function (position) {
      this.SetPositionAndAngle(position, this.GetAngle());
   }
   b2Body.prototype.GetAngle = function () {
      return this.m_sweep.a;
   }
   b2Body.prototype.SetAngle = function (angle) {
      if (angle === undefined) angle = 0;
      this.SetPositionAndAngle(this.GetPosition(), angle);
   }
   b2Body.prototype.GetWorldCenter = function () {
      return this.m_sweep.c;
   }
   b2Body.prototype.GetLocalCenter = function () {
      return this.m_sweep.localCenter;
   }
   b2Body.prototype.SetLinearVelocity = function (v) {
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_linearVelocity.SetV(v);
   }
   b2Body.prototype.GetLinearVelocity = function () {
      return this.m_linearVelocity;
   }
   b2Body.prototype.SetAngularVelocity = function (omega) {
      if (omega === undefined) omega = 0;
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_angularVelocity = omega;
   }
   b2Body.prototype.GetAngularVelocity = function () {
      return this.m_angularVelocity;
   }
   b2Body.prototype.GetDefinition = function () {
      var bd = new b2BodyDef();
      bd.type = this.GetType();
      bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
      bd.angle = this.GetAngle();
      bd.angularDamping = this.m_angularDamping;
      bd.angularVelocity = this.m_angularVelocity;
      bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
      bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
      bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
      bd.linearDamping = this.m_linearDamping;
      bd.linearVelocity.SetV(this.GetLinearVelocity());
      bd.position = this.GetPosition();
      bd.userData = this.GetUserData();
      return bd;
   }
   b2Body.prototype.ApplyForce = function (force, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_force.x += force.x;
      this.m_force.y += force.y;
      this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
   }
   b2Body.prototype.ApplyTorque = function (torque) {
      if (torque === undefined) torque = 0;
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_torque += torque;
   }
   b2Body.prototype.ApplyImpulse = function (impulse, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_linearVelocity.x += this.m_invMass * impulse.x;
      this.m_linearVelocity.y += this.m_invMass * impulse.y;
      this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
   }
   b2Body.prototype.ApplyAngularImpulse = function (impulse)
   {
   	if (this.IsAwake() == false)
   	{
   		this.SetAwake(true);
   	}
   	this.m_angularVelocity += this.m_invI * impulse;
   };
   b2Body.prototype.Split = function (callback) {
      var linearVelocity = this.GetLinearVelocity().Copy();
      var angularVelocity = this.GetAngularVelocity();
      var center = this.GetWorldCenter();
      var body1 = this;
      var body2 = this.m_world.CreateBody(this.GetDefinition());
      var prev;
      for (var f = body1.m_fixtureList; f;) {
         if (callback(f)) {
            var next = f.m_next;
            if (prev) {
               prev.m_next = next;
            }
            else {
               body1.m_fixtureList = next;
            }
            body1.m_fixtureCount--;
            f.m_next = body2.m_fixtureList;
            body2.m_fixtureList = f;
            body2.m_fixtureCount++;
            f.m_body = body2;
            f = next;
         }
         else {
            prev = f;
            f = f.m_next;
         }
      }
      body1.ResetMassData();
      body2.ResetMassData();
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
      var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
      body1.SetLinearVelocity(velocity1);
      body2.SetLinearVelocity(velocity2);
      body1.SetAngularVelocity(angularVelocity);
      body2.SetAngularVelocity(angularVelocity);
      body1.SynchronizeFixtures();
      body2.SynchronizeFixtures();
      return body2;
   }
   b2Body.prototype.Merge = function (other) {
      var f;
      for (f = other.m_fixtureList;
      f;) {
         var next = f.m_next;
         other.m_fixtureCount--;
         f.m_next = this.m_fixtureList;
         this.m_fixtureList = f;
         this.m_fixtureCount++;
         f.m_body = body2;
         f = next;
      }
      body1.m_fixtureCount = 0;
      var body1 = this;
      var body2 = other;
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = body1.GetLinearVelocity().Copy();
      var velocity2 = body2.GetLinearVelocity().Copy();
      var angular1 = body1.GetAngularVelocity();
      var angular = body2.GetAngularVelocity();
      body1.ResetMassData();
      this.SynchronizeFixtures();
   }
   b2Body.prototype.GetMass = function () {
      return this.m_mass;
   }
   b2Body.prototype.GetInertia = function () {
      return this.m_I;
   }
   b2Body.prototype.GetMassData = function (data) {
      data.mass = this.m_mass;
      data.I = this.m_I;
      data.center.SetV(this.m_sweep.localCenter);
   }
   b2Body.prototype.SetMassData = function (massData) {
      b2Settings.b2Assert(this.m_world.IsLocked() == false);
      if (this.m_world.IsLocked() == true) {
         return;
      }
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_mass = massData.mass;
      if (this.m_mass <= 0.0) {
         this.m_mass = 1.0;
      }
      this.m_invMass = 1.0 / this.m_mass;
      if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
         this.m_invI = 1.0 / this.m_I;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(massData.center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.ResetMassData = function () {
      this.m_mass = 0.0;
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_sweep.localCenter.SetZero();
      if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
         return;
      }
      var center = b2Vec2.Make(0, 0);
      for (var f = this.m_fixtureList; f; f = f.m_next) {
         if (f.m_density == 0.0) {
            continue;
         }
         var massData = f.GetMassData();
         this.m_mass += massData.mass;
         center.x += massData.center.x * massData.mass;
         center.y += massData.center.y * massData.mass;
         this.m_I += massData.I;
      }
      if (this.m_mass > 0.0) {
         this.m_invMass = 1.0 / this.m_mass;
         center.x *= this.m_invMass;
         center.y *= this.m_invMass;
      }
      else {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
         this.m_I *= this.m_inertiaScale;
         b2Settings.b2Assert(this.m_I > 0);
         this.m_invI = 1.0 / this.m_I;
      }
      else {
         this.m_I = 0.0;
         this.m_invI = 0.0;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.GetWorldPoint = function (localPoint) {
      var A = this.m_xf.R;
      var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      u.x += this.m_xf.position.x;
      u.y += this.m_xf.position.y;
      return u;
   }
   b2Body.prototype.GetWorldVector = function (localVector) {
      return b2Math.MulMV(this.m_xf.R, localVector);
   }
   b2Body.prototype.GetLocalPoint = function (worldPoint) {
      return b2Math.MulXT(this.m_xf, worldPoint);
   }
   b2Body.prototype.GetLocalVector = function (worldVector) {
      return b2Math.MulTMV(this.m_xf.R, worldVector);
   }
   b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
      var A = this.m_xf.R;
      var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      worldPoint.x += this.m_xf.position.x;
      worldPoint.y += this.m_xf.position.y;
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearDamping = function () {
      return this.m_linearDamping;
   }
   b2Body.prototype.SetLinearDamping = function (linearDamping) {
      if (linearDamping === undefined) linearDamping = 0;
      this.m_linearDamping = linearDamping;
   }
   b2Body.prototype.GetAngularDamping = function () {
      return this.m_angularDamping;
   }
   b2Body.prototype.SetAngularDamping = function (angularDamping) {
      if (angularDamping === undefined) angularDamping = 0;
      this.m_angularDamping = angularDamping;
   }
   b2Body.prototype.SetType = function (type) {
      if (type === undefined) type = 0;
      if (this.m_type == type) {
         return;
      }
      this.m_type = type;
      this.ResetMassData();
      if (this.m_type == b2Body.b2_staticBody) {
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
      }
      this.SetAwake(true);
      this.m_force.SetZero();
      this.m_torque = 0.0;
      for (var ce = this.m_contactList; ce; ce = ce.next) {
         ce.contact.FlagForFiltering();
      }
   }
   b2Body.prototype.GetType = function () {
      return this.m_type;
   }
   b2Body.prototype.SetBullet = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_bulletFlag;
      }
   }
   b2Body.prototype.IsBullet = function () {
      return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
   }
   b2Body.prototype.SetSleepingAllowed = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_allowSleepFlag;
         this.SetAwake(true);
      }
   }
   b2Body.prototype.SetAwake = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
      }
      else {
         this.m_flags &= ~b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
         this.m_force.SetZero();
         this.m_torque = 0.0;
      }
   }
   b2Body.prototype.IsAwake = function () {
      return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
   }
   b2Body.prototype.SetFixedRotation = function (fixed) {
      if (fixed) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_fixedRotationFlag;
      }
      this.ResetMassData();
   }
   b2Body.prototype.IsFixedRotation = function () {
      return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
   }
   b2Body.prototype.SetActive = function (flag) {
      if (flag == this.IsActive()) {
         return;
      }
      var broadPhase;
      var f;
      if (flag) {
         this.m_flags |= b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.CreateProxy(broadPhase, this.m_xf);
         }
      }
      else {
         this.m_flags &= ~b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.DestroyProxy(broadPhase);
         }
         var ce = this.m_contactList;
         while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
         }
         this.m_contactList = null;
      }
   }
   b2Body.prototype.IsActive = function () {
      return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
   }
   b2Body.prototype.IsSleepingAllowed = function () {
      return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
   }
   b2Body.prototype.GetFixtureList = function () {
      return this.m_fixtureList;
   }
   b2Body.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2Body.prototype.GetControllerList = function () {
      return this.m_controllerList;
   }
   b2Body.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2Body.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Body.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Body.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Body.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Body.prototype.b2Body = function (bd, world) {
      this.m_flags = 0;
      if (bd.bullet) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      if (bd.fixedRotation) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      if (bd.allowSleep) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      if (bd.awake) {
         this.m_flags |= b2Body.e_awakeFlag;
      }
      if (bd.active) {
         this.m_flags |= b2Body.e_activeFlag;
      }
      this.m_world = world;
      this.m_xf.position.SetV(bd.position);
      this.m_xf.R.Set(bd.angle);
      this.m_sweep.localCenter.SetZero();
      this.m_sweep.t0 = 1.0;
      this.m_sweep.a0 = this.m_sweep.a = bd.angle;
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_contactList = null;
      this.m_controllerCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_linearVelocity.SetV(bd.linearVelocity);
      this.m_angularVelocity = bd.angularVelocity;
      this.m_linearDamping = bd.linearDamping;
      this.m_angularDamping = bd.angularDamping;
      this.m_force.Set(0.0, 0.0);
      this.m_torque = 0.0;
      this.m_sleepTime = 0.0;
      this.m_type = bd.type;
      if (this.m_type == b2Body.b2_dynamicBody) {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      else {
         this.m_mass = 0.0;
         this.m_invMass = 0.0;
      }
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_inertiaScale = bd.inertiaScale;
      this.m_userData = bd.userData;
      this.m_fixtureList = null;
      this.m_fixtureCount = 0;
   }
   b2Body.prototype.SynchronizeFixtures = function () {
      var xf1 = b2Body.s_xf1;
      xf1.R.Set(this.m_sweep.a0);
      var tMat = xf1.R;
      var tVec = this.m_sweep.localCenter;
      xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var f;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, xf1, this.m_xf);
      }
   }
   b2Body.prototype.SynchronizeTransform = function () {
      this.m_xf.R.Set(this.m_sweep.a);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
   }
   b2Body.prototype.ShouldCollide = function (other) {
      if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
         return false;
      }
      for (var jn = this.m_jointList; jn; jn = jn.next) {
         if (jn.other == other) if (jn.joint.m_collideConnected == false) {
            return false;
         }
      }
      return true;
   }
   b2Body.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      this.m_sweep.Advance(t);
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_sweep.a = this.m_sweep.a0;
      this.SynchronizeTransform();
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
      Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
      Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
      Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
      Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
      Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
      Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
      Box2D.Dynamics.b2Body.b2_staticBody = 0;
      Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
      Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
   });
   b2BodyDef.b2BodyDef = function () {
      this.position = new b2Vec2();
      this.linearVelocity = new b2Vec2();
   };
   b2BodyDef.prototype.b2BodyDef = function () {
      this.userData = null;
      this.position.Set(0.0, 0.0);
      this.angle = 0.0;
      this.linearVelocity.Set(0, 0);
      this.angularVelocity = 0.0;
      this.linearDamping = 0.0;
      this.angularDamping = 0.0;
      this.allowSleep = true;
      this.awake = true;
      this.fixedRotation = false;
      this.bullet = false;
      this.type = b2Body.b2_staticBody;
      this.active = true;
      this.inertiaScale = 1.0;
   }
   b2ContactFilter.b2ContactFilter = function () {};
   b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
      var filter1 = fixtureA.GetFilterData();
      var filter2 = fixtureB.GetFilterData();
      if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
         return filter1.groupIndex > 0;
      }
      var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
      return collide;
   }
   b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
      if (!userData) return true;
      return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
   });
   b2ContactImpulse.b2ContactImpulse = function () {
      this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
   };
   b2ContactListener.b2ContactListener = function () {};
   b2ContactListener.prototype.BeginContact = function (contact) {}
   b2ContactListener.prototype.EndContact = function (contact) {}
   b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
   b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
   });
   b2ContactManager.b2ContactManager = function () {};
   b2ContactManager.prototype.b2ContactManager = function () {
      this.m_world = null;
      this.m_contactCount = 0;
      this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
      this.m_contactListener = b2ContactListener.b2_defaultListener;
      this.m_contactFactory = new b2ContactFactory(this.m_allocator);
      this.m_broadPhase = new b2DynamicTreeBroadPhase();
   }
   b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
      var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
      var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA == bodyB) return;
      var edge = bodyB.GetContactList();
      while (edge) {
         if (edge.other == bodyA) {
            var fA = edge.contact.GetFixtureA();
            var fB = edge.contact.GetFixtureB();
            if (fA == fixtureA && fB == fixtureB) return;
            if (fA == fixtureB && fB == fixtureA) return;
         }
         edge = edge.next;
      }
      if (bodyB.ShouldCollide(bodyA) == false) {
         return;
      }
      if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
         return;
      }
      var c = this.m_contactFactory.Create(fixtureA, fixtureB);
      fixtureA = c.GetFixtureA();
      fixtureB = c.GetFixtureB();
      bodyA = fixtureA.m_body;
      bodyB = fixtureB.m_body;
      c.m_prev = null;
      c.m_next = this.m_world.m_contactList;
      if (this.m_world.m_contactList != null) {
         this.m_world.m_contactList.m_prev = c;
      }
      this.m_world.m_contactList = c;
      c.m_nodeA.contact = c;
      c.m_nodeA.other = bodyB;
      c.m_nodeA.prev = null;
      c.m_nodeA.next = bodyA.m_contactList;
      if (bodyA.m_contactList != null) {
         bodyA.m_contactList.prev = c.m_nodeA;
      }
      bodyA.m_contactList = c.m_nodeA;
      c.m_nodeB.contact = c;
      c.m_nodeB.other = bodyA;
      c.m_nodeB.prev = null;
      c.m_nodeB.next = bodyB.m_contactList;
      if (bodyB.m_contactList != null) {
         bodyB.m_contactList.prev = c.m_nodeB;
      }
      bodyB.m_contactList = c.m_nodeB;
      ++this.m_world.m_contactCount;
      return;
   }
   b2ContactManager.prototype.FindNewContacts = function () {
      this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
   }
   b2ContactManager.prototype.Destroy = function (c) {
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (c.IsTouching()) {
         this.m_contactListener.EndContact(c);
      }
      if (c.m_prev) {
         c.m_prev.m_next = c.m_next;
      }
      if (c.m_next) {
         c.m_next.m_prev = c.m_prev;
      }
      if (c == this.m_world.m_contactList) {
         this.m_world.m_contactList = c.m_next;
      }
      if (c.m_nodeA.prev) {
         c.m_nodeA.prev.next = c.m_nodeA.next;
      }
      if (c.m_nodeA.next) {
         c.m_nodeA.next.prev = c.m_nodeA.prev;
      }
      if (c.m_nodeA == bodyA.m_contactList) {
         bodyA.m_contactList = c.m_nodeA.next;
      }
      if (c.m_nodeB.prev) {
         c.m_nodeB.prev.next = c.m_nodeB.next;
      }
      if (c.m_nodeB.next) {
         c.m_nodeB.next.prev = c.m_nodeB.prev;
      }
      if (c.m_nodeB == bodyB.m_contactList) {
         bodyB.m_contactList = c.m_nodeB.next;
      }
      this.m_contactFactory.Destroy(c);
      --this.m_contactCount;
   }
   b2ContactManager.prototype.Collide = function () {
      var c = this.m_world.m_contactList;
      while (c) {
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         var bodyA = fixtureA.GetBody();
         var bodyB = fixtureB.GetBody();
         if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
            c = c.GetNext();
            continue;
         }
         if (c.m_flags & b2Contact.e_filterFlag) {
            if (bodyB.ShouldCollide(bodyA) == false) {
               var cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
               cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            c.m_flags &= ~b2Contact.e_filterFlag;
         }
         var proxyA = fixtureA.m_proxy;
         var proxyB = fixtureB.m_proxy;
         var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
         if (overlap == false) {
            cNuke = c;
            c = cNuke.GetNext();
            this.Destroy(cNuke);
            continue;
         }
         c.Update(this.m_contactListener);
         c = c.GetNext();
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
   });
   b2DebugDraw.b2DebugDraw = function () {};
   b2DebugDraw.prototype.b2DebugDraw = function () {}
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.GetFlags = function () {}
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.SetSprite = function (sprite) {}
   b2DebugDraw.prototype.GetSprite = function () {}
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
   }
   b2DebugDraw.prototype.GetDrawScale = function () {}
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
   }
   b2DebugDraw.prototype.GetLineThickness = function () {}
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetAlpha = function () {}
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetFillAlpha = function () {}
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
   }
   b2DebugDraw.prototype.GetXFormScale = function () {}
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
   b2DebugDraw.prototype.DrawTransform = function (xf) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
      Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
      Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
      Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
      Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
      Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
   });
   b2DestructionListener.b2DestructionListener = function () {};
   b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
   b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
   b2FilterData.b2FilterData = function () {
      this.categoryBits = 0x0001;
      this.maskBits = 0xFFFF;
      this.groupIndex = 0;
   };
   b2FilterData.prototype.Copy = function () {
      var copy = new b2FilterData();
      copy.categoryBits = this.categoryBits;
      copy.maskBits = this.maskBits;
      copy.groupIndex = this.groupIndex;
      return copy;
   }
   b2Fixture.b2Fixture = function () {
      this.m_filter = new b2FilterData();
   };
   b2Fixture.prototype.GetType = function () {
      return this.m_shape.GetType();
   }
   b2Fixture.prototype.GetShape = function () {
      return this.m_shape;
   }
   b2Fixture.prototype.SetSensor = function (sensor) {
      if (this.m_isSensor == sensor) return;
      this.m_isSensor = sensor;
      if (this.m_body == null) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
         edge = edge.next;
      }
   }
   b2Fixture.prototype.IsSensor = function () {
      return this.m_isSensor;
   }
   b2Fixture.prototype.SetFilterData = function (filter) {
      this.m_filter = filter.Copy();
      if (this.m_body) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
         edge = edge.next;
      }
   }
   b2Fixture.prototype.GetFilterData = function () {
      return this.m_filter.Copy();
   }
   b2Fixture.prototype.GetBody = function () {
      return this.m_body;
   }
   b2Fixture.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Fixture.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Fixture.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Fixture.prototype.TestPoint = function (p) {
      return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
   }
   b2Fixture.prototype.RayCast = function (output, input) {
      return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
   }
   b2Fixture.prototype.GetMassData = function (massData) {
      if (massData === undefined) massData = null;
      if (massData == null) {
         massData = new b2MassData();
      }
      this.m_shape.ComputeMass(massData, this.m_density);
      return massData;
   }
   b2Fixture.prototype.SetDensity = function (density) {
      if (density === undefined) density = 0;
      this.m_density = density;
   }
   b2Fixture.prototype.GetDensity = function () {
      return this.m_density;
   }
   b2Fixture.prototype.GetFriction = function () {
      return this.m_friction;
   }
   b2Fixture.prototype.SetFriction = function (friction) {
      if (friction === undefined) friction = 0;
      this.m_friction = friction;
   }
   b2Fixture.prototype.GetRestitution = function () {
      return this.m_restitution;
   }
   b2Fixture.prototype.SetRestitution = function (restitution) {
      if (restitution === undefined) restitution = 0;
      this.m_restitution = restitution;
   }
   b2Fixture.prototype.GetAABB = function () {
      return this.m_aabb;
   }
   b2Fixture.prototype.b2Fixture = function () {
      this.m_aabb = new b2AABB();
      this.m_userData = null;
      this.m_body = null;
      this.m_next = null;
      this.m_shape = null;
      this.m_density = 0.0;
      this.m_friction = 0.0;
      this.m_restitution = 0.0;
   }
   b2Fixture.prototype.Create = function (body, xf, def) {
      this.m_userData = def.userData;
      this.m_friction = def.friction;
      this.m_restitution = def.restitution;
      this.m_body = body;
      this.m_next = null;
      this.m_filter = def.filter.Copy();
      this.m_isSensor = def.isSensor;
      this.m_shape = def.shape.Copy();
      this.m_density = def.density;
   }
   b2Fixture.prototype.Destroy = function () {
      this.m_shape = null;
   }
   b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
      this.m_shape.ComputeAABB(this.m_aabb, xf);
      this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
   }
   b2Fixture.prototype.DestroyProxy = function (broadPhase) {
      if (this.m_proxy == null) {
         return;
      }
      broadPhase.DestroyProxy(this.m_proxy);
      this.m_proxy = null;
   }
   b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
      if (!this.m_proxy) return;
      var aabb1 = new b2AABB();
      var aabb2 = new b2AABB();
      this.m_shape.ComputeAABB(aabb1, transform1);
      this.m_shape.ComputeAABB(aabb2, transform2);
      this.m_aabb.Combine(aabb1, aabb2);
      var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
      broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
   }
   b2FixtureDef.b2FixtureDef = function () {
      this.filter = new b2FilterData();
   };
   b2FixtureDef.prototype.b2FixtureDef = function () {
      this.shape = null;
      this.userData = null;
      this.friction = 0.2;
      this.restitution = 0.0;
      this.density = 0.0;
      this.filter.categoryBits = 0x0001;
      this.filter.maskBits = 0xFFFF;
      this.filter.groupIndex = 0;
      this.isSensor = false;
   }
   b2Island.b2Island = function () {};
   b2Island.prototype.b2Island = function () {
      this.m_bodies = new Vector();
      this.m_contacts = new Vector();
      this.m_joints = new Vector();
   }
   b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
      if (bodyCapacity === undefined) bodyCapacity = 0;
      if (contactCapacity === undefined) contactCapacity = 0;
      if (jointCapacity === undefined) jointCapacity = 0;
      var i = 0;
      this.m_bodyCapacity = bodyCapacity;
      this.m_contactCapacity = contactCapacity;
      this.m_jointCapacity = jointCapacity;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_allocator = allocator;
      this.m_listener = listener;
      this.m_contactSolver = contactSolver;
      for (i = this.m_bodies.length;
      i < bodyCapacity; i++)
      this.m_bodies[i] = null;
      for (i = this.m_contacts.length;
      i < contactCapacity; i++)
      this.m_contacts[i] = null;
      for (i = this.m_joints.length;
      i < jointCapacity; i++)
      this.m_joints[i] = null;
   }
   b2Island.prototype.Clear = function () {
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
   }
   b2Island.prototype.Solve = function (step, gravity, allowSleep) {
      var i = 0;
      var j = 0;
      var b;
      var joint;
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() != b2Body.b2_dynamicBody) continue;
         b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
         b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
         b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
         b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
         b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
      }
      this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      contactSolver.InitVelocityConstraints(step);
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.InitVelocityConstraints(step);
      }
      for (i = 0;
      i < step.velocityIterations; ++i) {
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            joint.SolveVelocityConstraints(step);
         }
         contactSolver.SolveVelocityConstraints();
      }
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.FinalizeVelocityConstraints();
      }
      contactSolver.FinalizeVelocityConstraints();
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = step.dt * b.m_linearVelocity.x;
         var translationY = step.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
         }
         var rotation = step.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
         b.m_sweep.a += step.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      for (i = 0;
      i < step.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
      if (allowSleep) {
         var minSleepTime = Number.MAX_VALUE;
         var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
         var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
         for (i = 0;
         i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            else {
               b.m_sleepTime += step.dt;
               minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
            }
         }
         if (minSleepTime >= b2Settings.b2_timeToSleep) {
            for (i = 0;
            i < this.m_bodyCount; ++i) {
               b = this.m_bodies[i];
               b.SetAwake(false);
            }
         }
      }
   }
   b2Island.prototype.SolveTOI = function (subStep) {
      var i = 0;
      var j = 0;
      this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      for (i = 0;
      i < this.m_jointCount; ++i) {
         this.m_joints[i].InitVelocityConstraints(subStep);
      }
      for (i = 0;
      i < subStep.velocityIterations; ++i) {
         contactSolver.SolveVelocityConstraints();
         for (j = 0;
         j < this.m_jointCount; ++j) {
            this.m_joints[j].SolveVelocityConstraints(subStep);
         }
      }
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         var b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = subStep.dt * b.m_linearVelocity.x;
         var translationY = subStep.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
         }
         var rotation = subStep.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
         b.m_sweep.a += subStep.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      var k_toiBaumgarte = 0.75;
      for (i = 0;
      i < subStep.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
   }
   b2Island.prototype.Report = function (constraints) {
      if (this.m_listener == null) {
         return;
      }
      for (var i = 0; i < this.m_contactCount; ++i) {
         var c = this.m_contacts[i];
         var cc = constraints[i];
         for (var j = 0; j < cc.pointCount; ++j) {
            b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
            b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
         }
         this.m_listener.PostSolve(c, b2Island.s_impulse);
      }
   }
   b2Island.prototype.AddBody = function (body) {
      body.m_islandIndex = this.m_bodyCount;
      this.m_bodies[this.m_bodyCount++] = body;
   }
   b2Island.prototype.AddContact = function (contact) {
      this.m_contacts[this.m_contactCount++] = contact;
   }
   b2Island.prototype.AddJoint = function (joint) {
      this.m_joints[this.m_jointCount++] = joint;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
   });
   b2TimeStep.b2TimeStep = function () {};
   b2TimeStep.prototype.Set = function (step) {
      this.dt = step.dt;
      this.inv_dt = step.inv_dt;
      this.positionIterations = step.positionIterations;
      this.velocityIterations = step.velocityIterations;
      this.warmStarting = step.warmStarting;
   }
   b2World.b2World = function () {
      this.s_stack = new Vector();
      this.m_contactManager = new b2ContactManager();
      this.m_contactSolver = new b2ContactSolver();
      this.m_island = new b2Island();
   };
   b2World.prototype.b2World = function (gravity, doSleep) {
      this.m_destructionListener = null;
      this.m_debugDraw = null;
      this.m_bodyList = null;
      this.m_contactList = null;
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_controllerCount = 0;
      b2World.m_warmStarting = true;
      b2World.m_continuousPhysics = true;
      this.m_allowSleep = doSleep;
      this.m_gravity = gravity;
      this.m_inv_dt0 = 0.0;
      this.m_contactManager.m_world = this;
      var bd = new b2BodyDef();
      this.m_groundBody = this.CreateBody(bd);
   }
   b2World.prototype.SetDestructionListener = function (listener) {
      this.m_destructionListener = listener;
   }
   b2World.prototype.SetContactFilter = function (filter) {
      this.m_contactManager.m_contactFilter = filter;
   }
   b2World.prototype.SetContactListener = function (listener) {
      this.m_contactManager.m_contactListener = listener;
   }
   b2World.prototype.SetDebugDraw = function (debugDraw) {
      this.m_debugDraw = debugDraw;
   }
   b2World.prototype.SetBroadPhase = function (broadPhase) {
      var oldBroadPhase = this.m_contactManager.m_broadPhase;
      this.m_contactManager.m_broadPhase = broadPhase;
      for (var b = this.m_bodyList; b; b = b.m_next) {
         for (var f = b.m_fixtureList; f; f = f.m_next) {
            f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
         }
      }
   }
   b2World.prototype.Validate = function () {
      this.m_contactManager.m_broadPhase.Validate();
   }
   b2World.prototype.GetProxyCount = function () {
      return this.m_contactManager.m_broadPhase.GetProxyCount();
   }
   b2World.prototype.CreateBody = function (def) {
      if (this.IsLocked() == true) {
         return null;
      }
      var b = new b2Body(def, this);
      b.m_prev = null;
      b.m_next = this.m_bodyList;
      if (this.m_bodyList) {
         this.m_bodyList.m_prev = b;
      }
      this.m_bodyList = b;
      ++this.m_bodyCount;
      return b;
   }
   b2World.prototype.DestroyBody = function (b) {
      if (this.IsLocked() == true) {
         return;
      }
      var jn = b.m_jointList;
      while (jn) {
         var jn0 = jn;
         jn = jn.next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
         }
         this.DestroyJoint(jn0.joint);
      }
      var coe = b.m_controllerList;
      while (coe) {
         var coe0 = coe;
         coe = coe.nextController;
         coe0.controller.RemoveBody(b);
      }
      var ce = b.m_contactList;
      while (ce) {
         var ce0 = ce;
         ce = ce.next;
         this.m_contactManager.Destroy(ce0.contact);
      }
      b.m_contactList = null;
      var f = b.m_fixtureList;
      while (f) {
         var f0 = f;
         f = f.m_next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeFixture(f0);
         }
         f0.DestroyProxy(this.m_contactManager.m_broadPhase);
         f0.Destroy();
      }
      b.m_fixtureList = null;
      b.m_fixtureCount = 0;
      if (b.m_prev) {
         b.m_prev.m_next = b.m_next;
      }
      if (b.m_next) {
         b.m_next.m_prev = b.m_prev;
      }
      if (b == this.m_bodyList) {
         this.m_bodyList = b.m_next;
      }--this.m_bodyCount;
   }
   b2World.prototype.CreateJoint = function (def) {
      var j = b2Joint.Create(def, null);
      j.m_prev = null;
      j.m_next = this.m_jointList;
      if (this.m_jointList) {
         this.m_jointList.m_prev = j;
      }
      this.m_jointList = j;
      ++this.m_jointCount;
      j.m_edgeA.joint = j;
      j.m_edgeA.other = j.m_bodyB;
      j.m_edgeA.prev = null;
      j.m_edgeA.next = j.m_bodyA.m_jointList;
      if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
      j.m_bodyA.m_jointList = j.m_edgeA;
      j.m_edgeB.joint = j;
      j.m_edgeB.other = j.m_bodyA;
      j.m_edgeB.prev = null;
      j.m_edgeB.next = j.m_bodyB.m_jointList;
      if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
      j.m_bodyB.m_jointList = j.m_edgeB;
      var bodyA = def.bodyA;
      var bodyB = def.bodyB;
      if (def.collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
      return j;
   }
   b2World.prototype.DestroyJoint = function (j) {
      var collideConnected = j.m_collideConnected;
      if (j.m_prev) {
         j.m_prev.m_next = j.m_next;
      }
      if (j.m_next) {
         j.m_next.m_prev = j.m_prev;
      }
      if (j == this.m_jointList) {
         this.m_jointList = j.m_next;
      }
      var bodyA = j.m_bodyA;
      var bodyB = j.m_bodyB;
      bodyA.SetAwake(true);
      bodyB.SetAwake(true);
      if (j.m_edgeA.prev) {
         j.m_edgeA.prev.next = j.m_edgeA.next;
      }
      if (j.m_edgeA.next) {
         j.m_edgeA.next.prev = j.m_edgeA.prev;
      }
      if (j.m_edgeA == bodyA.m_jointList) {
         bodyA.m_jointList = j.m_edgeA.next;
      }
      j.m_edgeA.prev = null;
      j.m_edgeA.next = null;
      if (j.m_edgeB.prev) {
         j.m_edgeB.prev.next = j.m_edgeB.next;
      }
      if (j.m_edgeB.next) {
         j.m_edgeB.next.prev = j.m_edgeB.prev;
      }
      if (j.m_edgeB == bodyB.m_jointList) {
         bodyB.m_jointList = j.m_edgeB.next;
      }
      j.m_edgeB.prev = null;
      j.m_edgeB.next = null;
      b2Joint.Destroy(j, null);
      --this.m_jointCount;
      if (collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
   }
   b2World.prototype.AddController = function (c) {
      c.m_next = this.m_controllerList;
      c.m_prev = null;
      this.m_controllerList = c;
      c.m_world = this;
      this.m_controllerCount++;
      return c;
   }
   b2World.prototype.RemoveController = function (c) {
      if (c.m_prev) c.m_prev.m_next = c.m_next;
      if (c.m_next) c.m_next.m_prev = c.m_prev;
      if (this.m_controllerList == c) this.m_controllerList = c.m_next;
      this.m_controllerCount--;
   }
   b2World.prototype.CreateController = function (controller) {
      if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
      controller.m_next = this.m_controllerList;
      controller.m_prev = null;
      if (this.m_controllerList) this.m_controllerList.m_prev = controller;
      this.m_controllerList = controller;
      ++this.m_controllerCount;
      controller.m_world = this;
      return controller;
   }
   b2World.prototype.DestroyController = function (controller) {
      controller.Clear();
      if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
      if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
      if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
      --this.m_controllerCount;
   }
   b2World.prototype.SetWarmStarting = function (flag) {
      b2World.m_warmStarting = flag;
   }
   b2World.prototype.SetContinuousPhysics = function (flag) {
      b2World.m_continuousPhysics = flag;
   }
   b2World.prototype.GetBodyCount = function () {
      return this.m_bodyCount;
   }
   b2World.prototype.GetJointCount = function () {
      return this.m_jointCount;
   }
   b2World.prototype.GetContactCount = function () {
      return this.m_contactCount;
   }
   b2World.prototype.SetGravity = function (gravity) {
      this.m_gravity = gravity;
   }
   b2World.prototype.GetGravity = function () {
      return this.m_gravity;
   }
   b2World.prototype.GetGroundBody = function () {
      return this.m_groundBody;
   }
   b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
      if (dt === undefined) dt = 0;
      if (velocityIterations === undefined) velocityIterations = 0;
      if (positionIterations === undefined) positionIterations = 0;
      if (this.m_flags & b2World.e_newFixture) {
         this.m_contactManager.FindNewContacts();
         this.m_flags &= ~b2World.e_newFixture;
      }
      this.m_flags |= b2World.e_locked;
      var step = b2World.s_timestep2;
      step.dt = dt;
      step.velocityIterations = velocityIterations;
      step.positionIterations = positionIterations;
      if (dt > 0.0) {
         step.inv_dt = 1.0 / dt;
      }
      else {
         step.inv_dt = 0.0;
      }
      step.dtRatio = this.m_inv_dt0 * dt;
      step.warmStarting = b2World.m_warmStarting;
      this.m_contactManager.Collide();
      if (step.dt > 0.0) {
         this.Solve(step);
      }
      if (b2World.m_continuousPhysics && step.dt > 0.0) {
         this.SolveTOI(step);
      }
      if (step.dt > 0.0) {
         this.m_inv_dt0 = step.inv_dt;
      }
      this.m_flags &= ~b2World.e_locked;
   }
   b2World.prototype.ClearForces = function () {
      for (var body = this.m_bodyList; body; body = body.m_next) {
         body.m_force.SetZero();
         body.m_torque = 0.0;
      }
   }
   b2World.prototype.DrawDebugData = function () {
      if (this.m_debugDraw == null) {
         return;
      }
      this.m_debugDraw.m_sprite.graphics.clear();
      var flags = this.m_debugDraw.GetFlags();
      var i = 0;
      var b;
      var f;
      var s;
      var j;
      var bp;
      var invQ = new b2Vec2;
      var x1 = new b2Vec2;
      var x2 = new b2Vec2;
      var xf;
      var b1 = new b2AABB();
      var b2 = new b2AABB();
      var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
      var color = new b2Color(0, 0, 0);
      if (flags & b2DebugDraw.e_shapeBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b.m_xf;
            for (f = b.GetFixtureList();
            f; f = f.m_next) {
               s = f.GetShape();
               if (b.IsActive() == false) {
                  color.Set(0.5, 0.5, 0.3);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_staticBody) {
                  color.Set(0.5, 0.9, 0.5);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_kinematicBody) {
                  color.Set(0.5, 0.5, 0.9);
                  this.DrawShape(s, xf, color);
               }
               else if (b.IsAwake() == false) {
                  color.Set(0.6, 0.6, 0.6);
                  this.DrawShape(s, xf, color);
               }
               else {
                  color.Set(0.9, 0.7, 0.7);
                  this.DrawShape(s, xf, color);
               }
            }
         }
      }
      if (flags & b2DebugDraw.e_jointBit) {
         for (j = this.m_jointList;
         j; j = j.m_next) {
            this.DrawJoint(j);
         }
      }
      if (flags & b2DebugDraw.e_controllerBit) {
         for (var c = this.m_controllerList; c; c = c.m_next) {
            c.Draw(this.m_debugDraw);
         }
      }
      if (flags & b2DebugDraw.e_pairBit) {
         color.Set(0.3, 0.9, 0.9);
         for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            var cA = fixtureA.GetAABB().GetCenter();
            var cB = fixtureB.GetAABB().GetCenter();
            this.m_debugDraw.DrawSegment(cA, cB, color);
         }
      }
      if (flags & b2DebugDraw.e_aabbBit) {
         bp = this.m_contactManager.m_broadPhase;
         vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
         for (b = this.m_bodyList;
         b; b = b.GetNext()) {
            if (b.IsActive() == false) {
               continue;
            }
            for (f = b.GetFixtureList();
            f; f = f.GetNext()) {
               var aabb = bp.GetFatAABB(f.m_proxy);
               vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
               vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
               vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
               vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
               this.m_debugDraw.DrawPolygon(vs, 4, color);
            }
         }
      }
      if (flags & b2DebugDraw.e_centerOfMassBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b2World.s_xf;
            xf.R = b.m_xf.R;
            xf.position = b.GetWorldCenter();
            this.m_debugDraw.DrawTransform(xf);
         }
      }
   }
   b2World.prototype.QueryAABB = function (callback, aabb) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         return callback(broadPhase.GetUserData(proxy));
      };
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryShape = function (callback, shape, transform) {
      var __this = this;
      if (transform === undefined) transform = null;
      if (transform == null) {
         transform = new b2Transform();
         transform.SetIdentity();
      }
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      shape.ComputeAABB(aabb, transform);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryPoint = function (callback, p) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (fixture.TestPoint(p)) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
      aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.RayCast = function (callback, point1, point2) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;
      var output = new b2RayCastOutput;

      function RayCastWrapper(input, proxy) {
         var userData = broadPhase.GetUserData(proxy);
         var fixture = (userData instanceof b2Fixture ? userData : null);
         var hit = fixture.RayCast(output, input);
         if (hit) {
            var fraction = output.fraction;
            var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
            return callback(fixture, point, output.normal, fraction);
         }
         return input.maxFraction;
      };
      var input = new b2RayCastInput(point1, point2);
      broadPhase.RayCast(RayCastWrapper, input);
   }
   b2World.prototype.RayCastOne = function (point1, point2) {
      var __this = this;
      var result;

      function RayCastOneWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result = fixture;
         return fraction;
      };
      __this.RayCast(RayCastOneWrapper, point1, point2);
      return result;
   }
   b2World.prototype.RayCastAll = function (point1, point2) {
      var __this = this;
      var result = new Vector();

      function RayCastAllWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result[result.length] = fixture;
         return 1;
      };
      __this.RayCast(RayCastAllWrapper, point1, point2);
      return result;
   }
   b2World.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2World.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2World.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2World.prototype.IsLocked = function () {
      return (this.m_flags & b2World.e_locked) > 0;
   }
   b2World.prototype.Solve = function (step) {
      var b;
      for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
         controller.Step(step);
      }
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
      }
      for (var c = this.m_contactList; c; c = c.m_next) {
         c.m_flags &= ~b2Contact.e_islandFlag;
      }
      for (var j = this.m_jointList; j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      var stackSize = parseInt(this.m_bodyCount);
      var stack = this.s_stack;
      for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
         if (seed.m_flags & b2Body.e_islandFlag) {
            continue;
         }
         if (seed.IsAwake() == false || seed.IsActive() == false) {
            continue;
         }
         if (seed.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         island.Clear();
         var stackCount = 0;
         stack[stackCount++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (stackCount > 0) {
            b = stack[--stackCount];
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            var other;
            for (var ce = b.m_contactList; ce; ce = ce.next) {
               if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(ce.contact);
               ce.contact.m_flags |= b2Contact.e_islandFlag;
               other = ce.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jn = b.m_jointList; jn; jn = jn.next) {
               if (jn.joint.m_islandFlag == true) {
                  continue;
               }
               other = jn.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jn.joint);
               jn.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         island.Solve(step, this.m_gravity, this.m_allowSleep);
         for (var i = 0; i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               b.m_flags &= ~b2Body.e_islandFlag;
            }
         }
      }
      for (i = 0;
      i < stack.length; ++i) {
         if (!stack[i]) break;
         stack[i] = null;
      }
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         if (b.IsAwake() == false || b.IsActive() == false) {
            continue;
         }
         if (b.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         b.SynchronizeFixtures();
      }
      this.m_contactManager.FindNewContacts();
   }
   b2World.prototype.SolveTOI = function (step) {
      var b;
      var fA;
      var fB;
      var bA;
      var bB;
      var cEdge;
      var j;
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      var queue = b2World.s_queue;
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
         b.m_sweep.t0 = 0.0;
      }
      var c;
      for (c = this.m_contactList;
      c; c = c.m_next) {
         c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
      }
      for (j = this.m_jointList;
      j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      for (;;) {
         var minContact = null;
         var minTOI = 1.0;
         for (c = this.m_contactList;
         c; c = c.m_next) {
            if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
               continue;
            }
            var toi = 1.0;
            if (c.m_flags & b2Contact.e_toiFlag) {
               toi = c.m_toi;
            }
            else {
               fA = c.m_fixtureA;
               fB = c.m_fixtureB;
               bA = fA.m_body;
               bB = fB.m_body;
               if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                  continue;
               }
               var t0 = bA.m_sweep.t0;
               if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                  t0 = bB.m_sweep.t0;
                  bA.m_sweep.Advance(t0);
               }
               else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                  t0 = bA.m_sweep.t0;
                  bB.m_sweep.Advance(t0);
               }
               toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
               b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
               if (toi > 0.0 && toi < 1.0) {
                  toi = (1.0 - toi) * t0 + toi;
                  if (toi > 1) toi = 1;
               }
               c.m_toi = toi;
               c.m_flags |= b2Contact.e_toiFlag;
            }
            if (Number.MIN_VALUE < toi && toi < minTOI) {
               minContact = c;
               minTOI = toi;
            }
         }
         if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
            break;
         }
         fA = minContact.m_fixtureA;
         fB = minContact.m_fixtureB;
         bA = fA.m_body;
         bB = fB.m_body;
         b2World.s_backupA.Set(bA.m_sweep);
         b2World.s_backupB.Set(bB.m_sweep);
         bA.Advance(minTOI);
         bB.Advance(minTOI);
         minContact.Update(this.m_contactManager.m_contactListener);
         minContact.m_flags &= ~b2Contact.e_toiFlag;
         if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
            bA.m_sweep.Set(b2World.s_backupA);
            bB.m_sweep.Set(b2World.s_backupB);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
            continue;
         }
         if (minContact.IsTouching() == false) {
            continue;
         }
         var seed = bA;
         if (seed.GetType() != b2Body.b2_dynamicBody) {
            seed = bB;
         }
         island.Clear();
         var queueStart = 0;
         var queueSize = 0;
         queue[queueStart + queueSize++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (queueSize > 0) {
            b = queue[queueStart++];
            --queueSize;
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               if (island.m_contactCount == island.m_contactCapacity) {
                  break;
               }
               if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(cEdge.contact);
               cEdge.contact.m_flags |= b2Contact.e_islandFlag;
               var other = cEdge.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
               if (island.m_jointCount == island.m_jointCapacity) continue;
               if (jEdge.joint.m_islandFlag == true) continue;
               other = jEdge.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jEdge.joint);
               jEdge.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) continue;
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         var subStep = b2World.s_timestep;
         subStep.warmStarting = false;
         subStep.dt = (1.0 - minTOI) * step.dt;
         subStep.inv_dt = 1.0 / subStep.dt;
         subStep.dtRatio = 0.0;
         subStep.velocityIterations = step.velocityIterations;
         subStep.positionIterations = step.positionIterations;
         island.SolveTOI(subStep);
         var i = 0;
         for (i = 0;
         i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            b.m_flags &= ~b2Body.e_islandFlag;
            if (b.IsAwake() == false) {
               continue;
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            b.SynchronizeFixtures();
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
            }
         }
         for (i = 0;
         i < island.m_contactCount; ++i) {
            c = island.m_contacts[i];
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
         }
         for (i = 0;
         i < island.m_jointCount; ++i) {
            j = island.m_joints[i];
            j.m_islandFlag = false;
         }
         this.m_contactManager.FindNewContacts();
      }
   }
   b2World.prototype.DrawJoint = function (joint) {
      var b1 = joint.GetBodyA();
      var b2 = joint.GetBodyB();
      var xf1 = b1.m_xf;
      var xf2 = b2.m_xf;
      var x1 = xf1.position;
      var x2 = xf2.position;
      var p1 = joint.GetAnchorA();
      var p2 = joint.GetAnchorB();
      var color = b2World.s_jointColor;
      switch (joint.m_type) {
      case b2Joint.e_distanceJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      case b2Joint.e_pulleyJoint:
         {
            var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(s1, p1, color);
            this.m_debugDraw.DrawSegment(s2, p2, color);
            this.m_debugDraw.DrawSegment(s1, s2, color);
         }
         break;
      case b2Joint.e_mouseJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      default:
         if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
         this.m_debugDraw.DrawSegment(p1, p2, color);
         if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
      }
   }
   b2World.prototype.DrawShape = function (shape, xf, color) {
      switch (shape.m_type) {
      case b2Shape.e_circleShape:
         {
            var circle = ((shape instanceof b2CircleShape ? shape : null));
            var center = b2Math.MulX(xf, circle.m_p);
            var radius = circle.m_radius;
            var axis = xf.R.col1;
            this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var i = 0;
            var poly = ((shape instanceof b2PolygonShape ? shape : null));
            var vertexCount = parseInt(poly.GetVertexCount());
            var localVertices = poly.GetVertices();
            var vertices = new Vector(vertexCount);
            for (i = 0;
            i < vertexCount; ++i) {
               vertices[i] = b2Math.MulX(xf, localVertices[i]);
            }
            this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
         }
         break;
      case b2Shape.e_edgeShape:
         {
            var edge = (shape instanceof b2EdgeShape ? shape : null);
            this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
      Box2D.Dynamics.b2World.s_xf = new b2Transform();
      Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
      Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
      Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
      Box2D.Dynamics.b2World.s_queue = new Vector();
      Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
      Box2D.Dynamics.b2World.e_newFixture = 0x0001;
      Box2D.Dynamics.b2World.e_locked = 0x0002;
   });
})();
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2CircleContact.b2CircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2CircleContact.Create = function (allocator) {
      return new b2CircleContact();
   }
   b2CircleContact.Destroy = function (contact, allocator) {}
   b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2CircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2Contact.b2Contact = function () {
      this.m_nodeA = new b2ContactEdge();
      this.m_nodeB = new b2ContactEdge();
      this.m_manifold = new b2Manifold();
      this.m_oldManifold = new b2Manifold();
   };
   b2Contact.prototype.GetManifold = function () {
      return this.m_manifold;
   }
   b2Contact.prototype.GetWorldManifold = function (worldManifold) {
      var bodyA = this.m_fixtureA.GetBody();
      var bodyB = this.m_fixtureB.GetBody();
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
   }
   b2Contact.prototype.IsTouching = function () {
      return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
   }
   b2Contact.prototype.IsContinuous = function () {
      return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
   }
   b2Contact.prototype.SetSensor = function (sensor) {
      if (sensor) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_sensorFlag;
      }
   }
   b2Contact.prototype.IsSensor = function () {
      return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
   }
   b2Contact.prototype.SetEnabled = function (flag) {
      if (flag) {
         this.m_flags |= b2Contact.e_enabledFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_enabledFlag;
      }
   }
   b2Contact.prototype.IsEnabled = function () {
      return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
   }
   b2Contact.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Contact.prototype.GetFixtureA = function () {
      return this.m_fixtureA;
   }
   b2Contact.prototype.GetFixtureB = function () {
      return this.m_fixtureB;
   }
   b2Contact.prototype.FlagForFiltering = function () {
      this.m_flags |= b2Contact.e_filterFlag;
   }
   b2Contact.prototype.b2Contact = function () {}
   b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
      if (fixtureA === undefined) fixtureA = null;
      if (fixtureB === undefined) fixtureB = null;
      this.m_flags = b2Contact.e_enabledFlag;
      if (!fixtureA || !fixtureB) {
         this.m_fixtureA = null;
         this.m_fixtureB = null;
         return;
      }
      if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
         this.m_flags |= b2Contact.e_continuousFlag;
      }
      this.m_fixtureA = fixtureA;
      this.m_fixtureB = fixtureB;
      this.m_manifold.m_pointCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_nodeA.contact = null;
      this.m_nodeA.prev = null;
      this.m_nodeA.next = null;
      this.m_nodeA.other = null;
      this.m_nodeB.contact = null;
      this.m_nodeB.prev = null;
      this.m_nodeB.next = null;
      this.m_nodeB.other = null;
   }
   b2Contact.prototype.Update = function (listener) {
      var tManifold = this.m_oldManifold;
      this.m_oldManifold = this.m_manifold;
      this.m_manifold = tManifold;
      this.m_flags |= b2Contact.e_enabledFlag;
      var touching = false;
      var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
      var bodyA = this.m_fixtureA.m_body;
      var bodyB = this.m_fixtureB.m_body;
      var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
      if (this.m_flags & b2Contact.e_sensorFlag) {
         if (aabbOverlap) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            var xfA = bodyA.GetTransform();
            var xfB = bodyB.GetTransform();
            touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
         }
         this.m_manifold.m_pointCount = 0;
      }
      else {
         if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
         }
         else {
            this.m_flags &= ~b2Contact.e_continuousFlag;
         }
         if (aabbOverlap) {
            this.Evaluate();
            touching = this.m_manifold.m_pointCount > 0;
            for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
               var mp2 = this.m_manifold.m_points[i];
               mp2.m_normalImpulse = 0.0;
               mp2.m_tangentImpulse = 0.0;
               var id2 = mp2.m_id;
               for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                  var mp1 = this.m_oldManifold.m_points[j];
                  if (mp1.m_id.key == id2.key) {
                     mp2.m_normalImpulse = mp1.m_normalImpulse;
                     mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                     break;
                  }
               }
            }
         }
         else {
            this.m_manifold.m_pointCount = 0;
         }
         if (touching != wasTouching) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
         }
      }
      if (touching) {
         this.m_flags |= b2Contact.e_touchingFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_touchingFlag;
      }
      if (wasTouching == false && touching == true) {
         listener.BeginContact(this);
      }
      if (wasTouching == true && touching == false) {
         listener.EndContact(this);
      }
      if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
         listener.PreSolve(this, this.m_oldManifold);
      }
   }
   b2Contact.prototype.Evaluate = function () {}
   b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
      b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
      b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
      b2Contact.s_input.sweepA = sweepA;
      b2Contact.s_input.sweepB = sweepB;
      b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
      return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
      Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
      Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
      Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
      Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
      Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
      Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
      Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
   });
   b2ContactConstraint.b2ContactConstraint = function () {
      this.localPlaneNormal = new b2Vec2();
      this.localPoint = new b2Vec2();
      this.normal = new b2Vec2();
      this.normalMass = new b2Mat22();
      this.K = new b2Mat22();
   };
   b2ContactConstraint.prototype.b2ContactConstraint = function () {
      this.points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.points[i] = new b2ContactConstraintPoint();
      }
   }
   b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
      this.localPoint = new b2Vec2();
      this.rA = new b2Vec2();
      this.rB = new b2Vec2();
   };
   b2ContactEdge.b2ContactEdge = function () {};
   b2ContactFactory.b2ContactFactory = function () {};
   b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
      this.m_allocator = allocator;
      this.InitializeRegisters();
   }
   b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
      if (type1 === undefined) type1 = 0;
      if (type2 === undefined) type2 = 0;
      this.m_registers[type1][type2].createFcn = createFcn;
      this.m_registers[type1][type2].destroyFcn = destroyFcn;
      this.m_registers[type1][type2].primary = true;
      if (type1 != type2) {
         this.m_registers[type2][type1].createFcn = createFcn;
         this.m_registers[type2][type1].destroyFcn = destroyFcn;
         this.m_registers[type2][type1].primary = false;
      }
   }
   b2ContactFactory.prototype.InitializeRegisters = function () {
      this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
      for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
         this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
         for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
            this.m_registers[i][j] = new b2ContactRegister();
         }
      }
      this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
      this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
      this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
   }
   b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
      var type1 = parseInt(fixtureA.GetType());
      var type2 = parseInt(fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      var c;
      if (reg.pool) {
         c = reg.pool;
         reg.pool = c.m_next;
         reg.poolCount--;
         c.Reset(fixtureA, fixtureB);
         return c;
      }
      var createFcn = reg.createFcn;
      if (createFcn != null) {
         if (reg.primary) {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureA, fixtureB);
            return c;
         }
         else {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureB, fixtureA);
            return c;
         }
      }
      else {
         return null;
      }
   }
   b2ContactFactory.prototype.Destroy = function (contact) {
      if (contact.m_manifold.m_pointCount > 0) {
         contact.m_fixtureA.m_body.SetAwake(true);
         contact.m_fixtureB.m_body.SetAwake(true);
      }
      var type1 = parseInt(contact.m_fixtureA.GetType());
      var type2 = parseInt(contact.m_fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      if (true) {
         reg.poolCount++;
         contact.m_next = reg.pool;
         reg.pool = contact;
      }
      var destroyFcn = reg.destroyFcn;
      destroyFcn(contact, this.m_allocator);
   }
   b2ContactRegister.b2ContactRegister = function () {};
   b2ContactResult.b2ContactResult = function () {
      this.position = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2ContactSolver.b2ContactSolver = function () {
      this.m_step = new b2TimeStep();
      this.m_constraints = new Vector();
   };
   b2ContactSolver.prototype.b2ContactSolver = function () {}
   b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
      if (contactCount === undefined) contactCount = 0;
      var contact;
      this.m_step.Set(step);
      this.m_allocator = allocator;
      var i = 0;
      var tVec;
      var tMat;
      this.m_constraintCount = contactCount;
      while (this.m_constraints.length < this.m_constraintCount) {
         this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
      }
      for (i = 0;
      i < contactCount; ++i) {
         contact = contacts[i];
         var fixtureA = contact.m_fixtureA;
         var fixtureB = contact.m_fixtureB;
         var shapeA = fixtureA.m_shape;
         var shapeB = fixtureB.m_shape;
         var radiusA = shapeA.m_radius;
         var radiusB = shapeB.m_radius;
         var bodyA = fixtureA.m_body;
         var bodyB = fixtureB.m_body;
         var manifold = contact.GetManifold();
         var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
         var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
         var vAX = bodyA.m_linearVelocity.x;
         var vAY = bodyA.m_linearVelocity.y;
         var vBX = bodyB.m_linearVelocity.x;
         var vBY = bodyB.m_linearVelocity.y;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         b2Settings.b2Assert(manifold.m_pointCount > 0);
         b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
         var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
         var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
         var cc = this.m_constraints[i];
         cc.bodyA = bodyA;
         cc.bodyB = bodyB;
         cc.manifold = manifold;
         cc.normal.x = normalX;
         cc.normal.y = normalY;
         cc.pointCount = manifold.m_pointCount;
         cc.friction = friction;
         cc.restitution = restitution;
         cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
         cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
         cc.localPoint.x = manifold.m_localPoint.x;
         cc.localPoint.y = manifold.m_localPoint.y;
         cc.radius = radiusA + radiusB;
         cc.type = manifold.m_type;
         for (var k = 0; k < cc.pointCount; ++k) {
            var cp = manifold.m_points[k];
            var ccp = cc.points[k];
            ccp.normalImpulse = cp.m_normalImpulse;
            ccp.tangentImpulse = cp.m_tangentImpulse;
            ccp.localPoint.SetV(cp.m_localPoint);
            var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
            var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
            var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
            var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
            var rnA = rAX * normalY - rAY * normalX;
            var rnB = rBX * normalY - rBY * normalX;
            rnA *= rnA;
            rnB *= rnB;
            var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
            ccp.normalMass = 1.0 / kNormal;
            var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
            kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
            ccp.equalizedMass = 1.0 / kEqualized;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var rtA = rAX * tangentY - rAY * tangentX;
            var rtB = rBX * tangentY - rBY * tangentX;
            rtA *= rtA;
            rtB *= rtB;
            var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
            ccp.tangentMass = 1.0 / kTangent;
            ccp.velocityBias = 0.0;
            var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
            var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
            var vRel = cc.normal.x * tX + cc.normal.y * tY;
            if (vRel < (-b2Settings.b2_velocityThreshold)) {
               ccp.velocityBias += (-cc.restitution * vRel);
            }
         }
         if (cc.pointCount == 2) {
            var ccp1 = cc.points[0];
            var ccp2 = cc.points[1];
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
            var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
            var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
            var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
            var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
            var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
            var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
            var k_maxConditionNumber = 100.0;
            if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
               cc.K.col1.Set(k11, k12);
               cc.K.col2.Set(k12, k22);
               cc.K.GetInverse(cc.normalMass);
            }
            else {
               cc.pointCount = 1;
            }
         }
      }
   }
   b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
      var tVec;
      var tVec2;
      var tMat;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var tX = 0;
         var j = 0;
         var tCount = 0;
         if (step.warmStarting) {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp = c.points[j];
               ccp.normalImpulse *= step.dtRatio;
               ccp.tangentImpulse *= step.dtRatio;
               var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
               var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
               bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
               bodyA.m_linearVelocity.x -= invMassA * PX;
               bodyA.m_linearVelocity.y -= invMassA * PY;
               bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
               bodyB.m_linearVelocity.x += invMassB * PX;
               bodyB.m_linearVelocity.y += invMassB * PY;
            }
         }
         else {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp2 = c.points[j];
               ccp2.normalImpulse = 0.0;
               ccp2.tangentImpulse = 0.0;
            }
         }
      }
   }
   b2ContactSolver.prototype.SolveVelocityConstraints = function () {
      var j = 0;
      var ccp;
      var rAX = 0;
      var rAY = 0;
      var rBX = 0;
      var rBY = 0;
      var dvX = 0;
      var dvY = 0;
      var vn = 0;
      var vt = 0;
      var lambda = 0;
      var maxFriction = 0;
      var newImpulse = 0;
      var PX = 0;
      var PY = 0;
      var dX = 0;
      var dY = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var tMat;
      var tVec;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         var vA = bodyA.m_linearVelocity;
         var vB = bodyB.m_linearVelocity;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var friction = c.friction;
         var tX = 0;
         for (j = 0;
         j < c.pointCount; j++) {
            ccp = c.points[j];
            dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
            dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
            vt = dvX * tangentX + dvY * tangentY;
            lambda = ccp.tangentMass * (-vt);
            maxFriction = friction * ccp.normalImpulse;
            newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
            lambda = newImpulse - ccp.tangentImpulse;
            PX = lambda * tangentX;
            PY = lambda * tangentY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.tangentImpulse = newImpulse;
         }
         var tCount = parseInt(c.pointCount);
         if (c.pointCount == 1) {
            ccp = c.points[0];
            dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
            dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
            vn = dvX * normalX + dvY * normalY;
            lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
            newImpulse = ccp.normalImpulse + lambda;
            newImpulse = newImpulse > 0 ? newImpulse : 0.0;
            lambda = newImpulse - ccp.normalImpulse;
            PX = lambda * normalX;
            PY = lambda * normalY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.normalImpulse = newImpulse;
         }
         else {
            var cp1 = c.points[0];
            var cp2 = c.points[1];
            var aX = cp1.normalImpulse;
            var aY = cp2.normalImpulse;
            var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
            var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
            var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
            var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
            var vn1 = dv1X * normalX + dv1Y * normalY;
            var vn2 = dv2X * normalX + dv2Y * normalY;
            var bX = vn1 - cp1.velocityBias;
            var bY = vn2 - cp2.velocityBias;
            tMat = c.K;
            bX -= tMat.col1.x * aX + tMat.col2.x * aY;
            bY -= tMat.col1.y * aX + tMat.col2.y * aY;
            var k_errorTol = 0.001;
            for (;;) {
               tMat = c.normalMass;
               var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
               var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
               if (xX >= 0.0 && xY >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = (-cp1.normalMass * bX);
               xY = 0.0;
               vn1 = 0.0;
               vn2 = c.K.col1.y * xX + bY;
               if (xX >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = (-cp2.normalMass * bY);
               vn1 = c.K.col2.x * xY + bX;
               vn2 = 0.0;
               if (xY >= 0.0 && vn1 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = 0.0;
               vn1 = bX;
               vn2 = bY;
               if (vn1 >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               break;
            }
         }
         bodyA.m_angularVelocity = wA;
         bodyB.m_angularVelocity = wB;
      }
   }
   b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var m = c.manifold;
         for (var j = 0; j < c.pointCount; ++j) {
            var point1 = m.m_points[j];
            var point2 = c.points[j];
            point1.m_normalImpulse = point2.normalImpulse;
            point1.m_tangentImpulse = point2.tangentImpulse;
         }
      }
   }
   b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var minSeparation = 0.0;
      for (var i = 0; i < this.m_constraintCount; i++) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_mass * bodyA.m_invMass;
         var invIA = bodyA.m_mass * bodyA.m_invI;
         var invMassB = bodyB.m_mass * bodyB.m_invMass;
         var invIB = bodyB.m_mass * bodyB.m_invI;
         b2ContactSolver.s_psm.Initialize(c);
         var normal = b2ContactSolver.s_psm.m_normal;
         for (var j = 0; j < c.pointCount; j++) {
            var ccp = c.points[j];
            var point = b2ContactSolver.s_psm.m_points[j];
            var separation = b2ContactSolver.s_psm.m_separations[j];
            var rAX = point.x - bodyA.m_sweep.c.x;
            var rAY = point.y - bodyA.m_sweep.c.y;
            var rBX = point.x - bodyB.m_sweep.c.x;
            var rBY = point.y - bodyB.m_sweep.c.y;
            minSeparation = minSeparation < separation ? minSeparation : separation;
            var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
            var impulse = (-ccp.equalizedMass * C);
            var PX = impulse * normal.x;
            var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
            bodyA.m_sweep.c.y -= invMassA * PY;
            bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
            bodyA.SynchronizeTransform();
            bodyB.m_sweep.c.x += invMassB * PX;
            bodyB.m_sweep.c.y += invMassB * PY;
            bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
            bodyB.SynchronizeTransform();
         }
      }
      return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
      Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
   });
   Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2EdgeAndCircleContact.Create = function (allocator) {
      return new b2EdgeAndCircleContact();
   }
   b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
   b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2EdgeAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {}
   Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
   b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2NullContact.b2NullContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2NullContact.prototype.b2NullContact = function () {
      this.__super.b2Contact.call(this);
   }
   b2NullContact.prototype.Evaluate = function () {}
   Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndCircleContact.Create = function (allocator) {
      return new b2PolyAndCircleContact();
   }
   b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
   b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
   }
   b2PolyAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.m_body;
      var bB = this.m_fixtureB.m_body;
      b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndEdgeContact.Create = function (allocator) {
      return new b2PolyAndEdgeContact();
   }
   b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
   b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
   }
   b2PolyAndEdgeContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
   Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolygonContact.b2PolygonContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolygonContact.Create = function (allocator) {
      return new b2PolygonContact();
   }
   b2PolygonContact.Destroy = function (contact, allocator) {}
   b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2PolygonContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PositionSolverManifold.b2PositionSolverManifold = function () {};
   b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
      this.m_normal = new b2Vec2();
      this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2PositionSolverManifold.prototype.Initialize = function (cc) {
      b2Settings.b2Assert(cc.pointCount > 0);
      var i = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      var tMat;
      var tVec;
      var planePointX = 0;
      var planePointY = 0;
      switch (cc.type) {
      case b2Manifold.e_circles:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.points[0].localPoint;
            var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1.0;
               this.m_normal.y = 0.0;
            }
            this.m_points[0].x = 0.5 * (pointAX + pointBX);
            this.m_points[0].y = 0.5 * (pointAY + pointBY);
            this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].x = clipPointX;
               this.m_points[i].y = clipPointY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyA.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].Set(clipPointX, clipPointY);
            }
            this.m_normal.x *= (-1);
            this.m_normal.y *= (-1);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
   });
})();
(function () {
   var b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
      b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
      b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
      b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

   Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
   b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2BuoyancyController.b2BuoyancyController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.normal = new b2Vec2(0, (-1));
      this.offset = 0;
      this.density = 0;
      this.velocity = new b2Vec2(0, 0);
      this.linearDrag = 2;
      this.angularDrag = 1;
      this.useDensity = false;
      this.useWorldGravity = true;
      this.gravity = null;
   };
   b2BuoyancyController.prototype.Step = function (step) {
      if (!this.m_bodyList) return;
      if (this.useWorldGravity) {
         this.gravity = this.GetWorld().GetGravity().Copy();
      }
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (body.IsAwake() == false) {
            continue;
         }
         var areac = new b2Vec2();
         var massc = new b2Vec2();
         var area = 0.0;
         var mass = 0.0;
         for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
            var sc = new b2Vec2();
            var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
            area += sarea;
            areac.x += sarea * sc.x;
            areac.y += sarea * sc.y;
            var shapeDensity = 0;
            if (this.useDensity) {
               shapeDensity = 1;
            }
            else {
               shapeDensity = 1;
            }
            mass += sarea * shapeDensity;
            massc.x += sarea * sc.x * shapeDensity;
            massc.y += sarea * sc.y * shapeDensity;
         }
         areac.x /= area;
         areac.y /= area;
         massc.x /= mass;
         massc.y /= mass;
         if (area < Number.MIN_VALUE) continue;
         var buoyancyForce = this.gravity.GetNegative();
         buoyancyForce.Multiply(this.density * area);
         body.ApplyForce(buoyancyForce, massc);
         var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
         dragForce.Subtract(this.velocity);
         dragForce.Multiply((-this.linearDrag * area));
         body.ApplyForce(dragForce, areac);
         body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
      }
   }
   b2BuoyancyController.prototype.Draw = function (debugDraw) {
      var r = 1000;
      var p1 = new b2Vec2();
      var p2 = new b2Vec2();
      p1.x = this.normal.x * this.offset + this.normal.y * r;
      p1.y = this.normal.y * this.offset - this.normal.x * r;
      p2.x = this.normal.x * this.offset - this.normal.y * r;
      p2.y = this.normal.y * this.offset + this.normal.x * r;
      var color = new b2Color(0, 0, 1);
      debugDraw.DrawSegment(p1, p2, color);
   }
   Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantAccelController.b2ConstantAccelController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.A = new b2Vec2(0, 0);
   };
   b2ConstantAccelController.prototype.Step = function (step) {
      var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
      }
   }
   Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantForceController.b2ConstantForceController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.F = new b2Vec2(0, 0);
   };
   b2ConstantForceController.prototype.Step = function (step) {
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.ApplyForce(this.F, body.GetWorldCenter());
      }
   }
   b2Controller.b2Controller = function () {};
   b2Controller.prototype.Step = function (step) {}
   b2Controller.prototype.Draw = function (debugDraw) {}
   b2Controller.prototype.AddBody = function (body) {
      var edge = new b2ControllerEdge();
      edge.controller = this;
      edge.body = body;
      edge.nextBody = this.m_bodyList;
      edge.prevBody = null;
      this.m_bodyList = edge;
      if (edge.nextBody) edge.nextBody.prevBody = edge;
      this.m_bodyCount++;
      edge.nextController = body.m_controllerList;
      edge.prevController = null;
      body.m_controllerList = edge;
      if (edge.nextController) edge.nextController.prevController = edge;
      body.m_controllerCount++;
   }
   b2Controller.prototype.RemoveBody = function (body) {
      var edge = body.m_controllerList;
      while (edge && edge.controller != this)
      edge = edge.nextController;
      if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
      if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
      if (edge.nextController) edge.nextController.prevController = edge.prevController;
      if (edge.prevController) edge.prevController.nextController = edge.nextController;
      if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
      if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
      body.m_controllerCount--;
      this.m_bodyCount--;
   }
   b2Controller.prototype.Clear = function () {
      while (this.m_bodyList)
      this.RemoveBody(this.m_bodyList.body);
   }
   b2Controller.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Controller.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Controller.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2ControllerEdge.b2ControllerEdge = function () {};
   Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
   b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2GravityController.b2GravityController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.G = 1;
      this.invSqr = true;
   };
   b2GravityController.prototype.Step = function (step) {
      var i = null;
      var body1 = null;
      var p1 = null;
      var mass1 = 0;
      var j = null;
      var body2 = null;
      var p2 = null;
      var dx = 0;
      var dy = 0;
      var r2 = 0;
      var f = null;
      if (this.invSqr) {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
      else {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
   }
   Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
   b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2TensorDampingController.b2TensorDampingController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.T = new b2Mat22();
      this.maxTimestep = 0;
   };
   b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
      if (xDamping === undefined) xDamping = 0;
      if (yDamping === undefined) yDamping = 0;
      this.T.col1.x = (-xDamping);
      this.T.col1.y = 0;
      this.T.col2.x = 0;
      this.T.col2.y = (-yDamping);
      if (xDamping > 0 || yDamping > 0) {
         this.maxTimestep = 1 / Math.max(xDamping, yDamping);
      }
      else {
         this.maxTimestep = 0;
      }
   }
   b2TensorDampingController.prototype.Step = function (step) {
      var timestep = step.dt;
      if (timestep <= Number.MIN_VALUE) return;
      if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) {
            continue;
         }
         var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
      }
   }
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World;

   Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
   b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2DistanceJoint.b2DistanceJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u = new b2Vec2();
   };
   b2DistanceJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2DistanceJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
   }
   b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2DistanceJoint.prototype.GetLength = function () {
      return this.m_length;
   }
   b2DistanceJoint.prototype.SetLength = function (length) {
      if (length === undefined) length = 0;
      this.m_length = length;
   }
   b2DistanceJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2DistanceJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2DistanceJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_length = def.length;
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_impulse = 0.0;
      this.m_gamma = 0.0;
      this.m_bias = 0.0;
   }
   b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
      if (length > b2Settings.b2_linearSlop) {
         this.m_u.Multiply(1.0 / length);
      }
      else {
         this.m_u.SetZero();
      }
      var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
      var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
      var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
      if (this.m_frequencyHz > 0.0) {
         var C = length - this.m_length;
         var omega = 2.0 * Math.PI * this.m_frequencyHz;
         var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
         var k = this.m_mass * omega * omega;
         this.m_gamma = step.dt * (d + step.dt * k);
         this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
         this.m_bias = C * step.dt * k * this.m_gamma;
         this.m_mass = invMass + this.m_gamma;
         this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         var PX = this.m_impulse * this.m_u.x;
         var PY = this.m_impulse * this.m_u.y;
         bA.m_linearVelocity.x -= bA.m_invMass * PX;
         bA.m_linearVelocity.y -= bA.m_invMass * PY;
         bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
         bB.m_linearVelocity.x += bB.m_invMass * PX;
         bB.m_linearVelocity.y += bB.m_invMass * PY;
         bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
      var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
      var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
      var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
      var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
      var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
      this.m_impulse += impulse;
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_linearVelocity.x -= bA.m_invMass * PX;
      bA.m_linearVelocity.y -= bA.m_invMass * PY;
      bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_linearVelocity.x += bB.m_invMass * PX;
      bB.m_linearVelocity.y += bB.m_invMass * PY;
      bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
   }
   b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      if (this.m_frequencyHz > 0.0) {
         return true;
      }
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(dX * dX + dY * dY);
      dX /= length;
      dY /= length;
      var C = length - this.m_length;
      C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
      var impulse = (-this.m_mass * C);
      this.m_u.Set(dX, dY);
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_sweep.c.x -= bA.m_invMass * PX;
      bA.m_sweep.c.y -= bA.m_invMass * PY;
      bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_sweep.c.x += bB.m_invMass * PX;
      bB.m_sweep.c.y += bB.m_invMass * PY;
      bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return b2Math.Abs(C) < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2DistanceJointDef.b2DistanceJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_distanceJoint;
      this.length = 1.0;
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
      var dX = anchorB.x - anchorA.x;
      var dY = anchorB.y - anchorA.y;
      this.length = Math.sqrt(dX * dX + dY * dY);
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
   b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2FrictionJoint.b2FrictionJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_linearMass = new b2Mat22();
      this.m_linearImpulse = new b2Vec2();
   };
   b2FrictionJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2FrictionJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
   }
   b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_angularImpulse;
   }
   b2FrictionJoint.prototype.SetMaxForce = function (force) {
      if (force === undefined) force = 0;
      this.m_maxForce = force;
   }
   b2FrictionJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxTorque = torque;
   }
   b2FrictionJoint.prototype.GetMaxTorque = function () {
      return this.m_maxTorque;
   }
   b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_linearMass.SetZero();
      this.m_angularMass = 0.0;
      this.m_linearImpulse.SetZero();
      this.m_angularImpulse = 0.0;
      this.m_maxForce = def.maxForce;
      this.m_maxTorque = def.maxTorque;
   }
   b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var K = new b2Mat22();
      K.col1.x = mA + mB;
      K.col2.x = 0.0;
      K.col1.y = 0.0;
      K.col2.y = mA + mB;
      K.col1.x += iA * rAY * rAY;
      K.col2.x += (-iA * rAX * rAY);
      K.col1.y += (-iA * rAX * rAY);
      K.col2.y += iA * rAX * rAX;
      K.col1.x += iB * rBY * rBY;
      K.col2.x += (-iB * rBX * rBY);
      K.col1.y += (-iB * rBX * rBY);
      K.col2.y += iB * rBX * rBX;
      K.GetInverse(this.m_linearMass);
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0.0) {
         this.m_angularMass = 1.0 / this.m_angularMass;
      }
      if (step.warmStarting) {
         this.m_linearImpulse.x *= step.dtRatio;
         this.m_linearImpulse.y *= step.dtRatio;
         this.m_angularImpulse *= step.dtRatio;
         var P = this.m_linearImpulse;
         bA.m_linearVelocity.x -= mA * P.x;
         bA.m_linearVelocity.y -= mA * P.y;
         bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
         bB.m_linearVelocity.x += mB * P.x;
         bB.m_linearVelocity.y += mB * P.y;
         bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
      }
      else {
         this.m_linearImpulse.SetZero();
         this.m_angularImpulse = 0.0;
      }
   }
   b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var maxImpulse = 0; {
         var Cdot = wB - wA;
         var impulse = (-this.m_angularMass * Cdot);
         var oldImpulse = this.m_angularImpulse;
         maxImpulse = step.dt * this.m_maxTorque;
         this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_angularImpulse - oldImpulse;
         wA -= iA * impulse;
         wB += iB * impulse;
      } {
         var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
         var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
         var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
         var oldImpulseV = this.m_linearImpulse.Copy();
         this.m_linearImpulse.Add(impulseV);
         maxImpulse = step.dt * this.m_maxForce;
         if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
         }
         impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
         vA.x -= mA * impulseV.x;
         vA.y -= mA * impulseV.y;
         wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
         vB.x += mB * impulseV.x;
         vB.y += mB * impulseV.y;
         wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
      }
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2FrictionJointDef.b2FrictionJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_frictionJoint;
      this.maxForce = 0.0;
      this.maxTorque = 0.0;
   }
   b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
   }
   Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
   b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2GearJoint.b2GearJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_J = new b2Jacobian();
   };
   b2GearJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2GearJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
   }
   b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      var tMat = this.m_bodyB.m_xf.R;
      var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
      var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
      var tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      var PX = this.m_impulse * this.m_J.linearB.x;
      var PY = this.m_impulse * this.m_J.linearB.y;
      return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
   }
   b2GearJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2GearJoint.prototype.SetRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_ratio = ratio;
   }
   b2GearJoint.prototype.b2GearJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var type1 = parseInt(def.joint1.m_type);
      var type2 = parseInt(def.joint2.m_type);
      this.m_revolute1 = null;
      this.m_prismatic1 = null;
      this.m_revolute2 = null;
      this.m_prismatic2 = null;
      var coordinate1 = 0;
      var coordinate2 = 0;
      this.m_ground1 = def.joint1.GetBodyA();
      this.m_bodyA = def.joint1.GetBodyB();
      if (type1 == b2Joint.e_revoluteJoint) {
         this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      this.m_ground2 = def.joint2.GetBodyA();
      this.m_bodyB = def.joint2.GetBodyB();
      if (type2 == b2Joint.e_revoluteJoint) {
         this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      this.m_ratio = def.ratio;
      this.m_constant = coordinate1 + this.m_ratio * coordinate2;
      this.m_impulse = 0.0;
   }
   b2GearJoint.prototype.InitVelocityConstraints = function (step) {
      var g1 = this.m_ground1;
      var g2 = this.m_ground2;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var ugX = 0;
      var ugY = 0;
      var rX = 0;
      var rY = 0;
      var tMat;
      var tVec;
      var crug = 0;
      var tX = 0;
      var K = 0.0;
      this.m_J.SetZero();
      if (this.m_revolute1) {
         this.m_J.angularA = (-1.0);
         K += bA.m_invI;
      }
      else {
         tMat = g1.m_xf.R;
         tVec = this.m_prismatic1.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bA.m_xf.R;
         rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearA.Set((-ugX), (-ugY));
         this.m_J.angularA = (-crug);
         K += bA.m_invMass + bA.m_invI * crug * crug;
      }
      if (this.m_revolute2) {
         this.m_J.angularB = (-this.m_ratio);
         K += this.m_ratio * this.m_ratio * bB.m_invI;
      }
      else {
         tMat = g2.m_xf.R;
         tVec = this.m_prismatic2.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bB.m_xf.R;
         rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
         this.m_J.angularB = (-this.m_ratio * crug);
         K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
      }
      this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
      if (step.warmStarting) {
         bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
         bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
         bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
         bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
         bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
         bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
      var impulse = (-this.m_mass * Cdot);
      this.m_impulse += impulse;
      bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
   }
   b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var linearError = 0.0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var coordinate1 = 0;
      var coordinate2 = 0;
      if (this.m_revolute1) {
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      if (this.m_revolute2) {
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
      var impulse = (-this.m_mass * C);
      bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2GearJointDef.b2GearJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
   };
   b2GearJointDef.prototype.b2GearJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_gearJoint;
      this.joint1 = null;
      this.joint2 = null;
      this.ratio = 1.0;
   }
   b2Jacobian.b2Jacobian = function () {
      this.linearA = new b2Vec2();
      this.linearB = new b2Vec2();
   };
   b2Jacobian.prototype.SetZero = function () {
      this.linearA.SetZero();
      this.angularA = 0.0;
      this.linearB.SetZero();
      this.angularB = 0.0;
   }
   b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      this.linearA.SetV(x1);
      this.angularA = a1;
      this.linearB.SetV(x2);
      this.angularB = a2;
   }
   b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
   }
   b2Joint.b2Joint = function () {
      this.m_edgeA = new b2JointEdge();
      this.m_edgeB = new b2JointEdge();
      this.m_localCenterA = new b2Vec2();
      this.m_localCenterB = new b2Vec2();
   };
   b2Joint.prototype.GetType = function () {
      return this.m_type;
   }
   b2Joint.prototype.GetAnchorA = function () {
      return null;
   }
   b2Joint.prototype.GetAnchorB = function () {
      return null;
   }
   b2Joint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return null;
   }
   b2Joint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2Joint.prototype.GetBodyA = function () {
      return this.m_bodyA;
   }
   b2Joint.prototype.GetBodyB = function () {
      return this.m_bodyB;
   }
   b2Joint.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Joint.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Joint.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Joint.prototype.IsActive = function () {
      return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
   }
   b2Joint.Create = function (def, allocator) {
      var joint = null;
      switch (def.type) {
      case b2Joint.e_distanceJoint:
         {
            joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
         }
         break;
      case b2Joint.e_mouseJoint:
         {
            joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
         }
         break;
      case b2Joint.e_prismaticJoint:
         {
            joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
         }
         break;
      case b2Joint.e_revoluteJoint:
         {
            joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
         }
         break;
      case b2Joint.e_pulleyJoint:
         {
            joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
         }
         break;
      case b2Joint.e_gearJoint:
         {
            joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
         }
         break;
      case b2Joint.e_lineJoint:
         {
            joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
         }
         break;
      case b2Joint.e_weldJoint:
         {
            joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
         }
         break;
      case b2Joint.e_frictionJoint:
         {
            joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
         }
         break;
      default:
         break;
      }
      return joint;
   }
   b2Joint.Destroy = function (joint, allocator) {}
   b2Joint.prototype.b2Joint = function (def) {
      b2Settings.b2Assert(def.bodyA != def.bodyB);
      this.m_type = def.type;
      this.m_prev = null;
      this.m_next = null;
      this.m_bodyA = def.bodyA;
      this.m_bodyB = def.bodyB;
      this.m_collideConnected = def.collideConnected;
      this.m_islandFlag = false;
      this.m_userData = def.userData;
   }
   b2Joint.prototype.InitVelocityConstraints = function (step) {}
   b2Joint.prototype.SolveVelocityConstraints = function (step) {}
   b2Joint.prototype.FinalizeVelocityConstraints = function () {}
   b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return false;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
      Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
      Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
      Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
      Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
      Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
      Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
      Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
      Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
      Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
      Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
      Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
      Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
      Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
   });
   b2JointDef.b2JointDef = function () {};
   b2JointDef.prototype.b2JointDef = function () {
      this.type = b2Joint.e_unknownJoint;
      this.userData = null;
      this.bodyA = null;
      this.bodyB = null;
      this.collideConnected = false;
   }
   b2JointEdge.b2JointEdge = function () {};
   Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
   b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2LineJoint.b2LineJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat22();
      this.m_impulse = new b2Vec2();
   };
   b2LineJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2LineJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
   }
   b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2LineJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2LineJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2LineJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2LineJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2LineJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2LineJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2LineJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2LineJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2LineJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2LineJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2LineJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2LineJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2LineJoint.prototype.GetMaxMotorForce = function () {
      return this.m_maxMotorForce;
   }
   b2LineJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2LineJoint.prototype.b2LineJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2LineJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.y = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
         }
         var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
         var f2r = 0;
         if (this.m_K.col1.x != 0.0) {
            f2r = b / this.m_K.col1.x + f1.x;
         }
         else {
            f2r = f1.x;
         }
         this.m_impulse.x = f2r;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y * this.m_a1;
         L2 = df.x * this.m_s2 + df.y * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = 0;
         if (this.m_K.col1.x != 0.0) {
            df2 = ((-Cdot1)) / this.m_K.col1.x;
         }
         else {
            df2 = 0.0;
         }
         this.m_impulse.x += df2;
         PX = df2 * this.m_perp.x;
         PY = df2 * this.m_perp.y;
         L1 = df2 * this.m_s1;
         L2 = df2 * this.m_s2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec2();
      var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1));
      angularError = 0.0;
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve(impulse, (-C1), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var impulse1 = 0;
         if (k11 != 0.0) {
            impulse1 = ((-C1)) / k11;
         }
         else {
            impulse1 = 0.0;
         }
         impulse.x = impulse1;
         impulse.y = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2LineJointDef.b2LineJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2LineJointDef.prototype.b2LineJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_lineJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
   }
   Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
   b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2MouseJoint.b2MouseJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.m_localAnchor = new b2Vec2();
      this.m_target = new b2Vec2();
      this.m_impulse = new b2Vec2();
      this.m_mass = new b2Mat22();
      this.m_C = new b2Vec2();
   };
   b2MouseJoint.prototype.GetAnchorA = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
   }
   b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2MouseJoint.prototype.GetTarget = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.SetTarget = function (target) {
      if (this.m_bodyB.IsAwake() == false) {
         this.m_bodyB.SetAwake(true);
      }
      this.m_target = target;
   }
   b2MouseJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
      if (maxForce === undefined) maxForce = 0;
      this.m_maxForce = maxForce;
   }
   b2MouseJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2MouseJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2MouseJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2MouseJoint.prototype.b2MouseJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_target.SetV(def.target);
      var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
      var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
      var tMat = this.m_bodyB.m_xf.R;
      this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
      this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
      this.m_maxForce = def.maxForce;
      this.m_impulse.SetZero();
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_beta = 0.0;
      this.m_gamma = 0.0;
   }
   b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var mass = b.GetMass();
      var omega = 2.0 * Math.PI * this.m_frequencyHz;
      var d = 2.0 * mass * this.m_dampingRatio * omega;
      var k = mass * omega * omega;
      this.m_gamma = step.dt * (d + step.dt * k);
      this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
      this.m_beta = step.dt * k * this.m_gamma;
      var tMat;tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var invMass = b.m_invMass;
      var invI = b.m_invI;this.K1.col1.x = invMass;
      this.K1.col2.x = 0.0;
      this.K1.col1.y = 0.0;
      this.K1.col2.y = invMass;
      this.K2.col1.x = invI * rY * rY;
      this.K2.col2.x = (-invI * rX * rY);
      this.K2.col1.y = (-invI * rX * rY);
      this.K2.col2.y = invI * rX * rX;
      this.K.SetM(this.K1);
      this.K.AddM(this.K2);
      this.K.col1.x += this.m_gamma;
      this.K.col2.y += this.m_gamma;
      this.K.GetInverse(this.m_mass);
      this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
      this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
      b.m_angularVelocity *= 0.98;
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      b.m_linearVelocity.x += invMass * this.m_impulse.x;
      b.m_linearVelocity.y += invMass * this.m_impulse.y;
      b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
   }
   b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var tMat;
      var tX = 0;
      var tY = 0;
      tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rX + tMat.col2.x * rY);
      rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
      var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
      tMat = this.m_mass;
      tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
      tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
      var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
      var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
      var oldImpulseX = this.m_impulse.x;
      var oldImpulseY = this.m_impulse.y;
      this.m_impulse.x += impulseX;
      this.m_impulse.y += impulseY;
      var maxImpulse = step.dt * this.m_maxForce;
      if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
         this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
      }
      impulseX = this.m_impulse.x - oldImpulseX;
      impulseY = this.m_impulse.y - oldImpulseY;
      b.m_linearVelocity.x += b.m_invMass * impulseX;
      b.m_linearVelocity.y += b.m_invMass * impulseY;
      b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
   }
   b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2MouseJointDef.b2MouseJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.target = new b2Vec2();
   };
   b2MouseJointDef.prototype.b2MouseJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_mouseJoint;
      this.maxForce = 0.0;
      this.frequencyHz = 5.0;
      this.dampingRatio = 0.7;
   }
   Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PrismaticJoint.b2PrismaticJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat33();
      this.m_impulse = new b2Vec3();
   };
   b2PrismaticJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PrismaticJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
   }
   b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2PrismaticJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2PrismaticJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2PrismaticJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2PrismaticJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2PrismaticJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2PrismaticJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2PrismaticJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2PrismaticJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2PrismaticJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2PrismaticJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_refAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      var Cdot1Y = w2 - w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
         }
         var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
         var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
         var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
         f2r.x += f1.x;
         f2r.y += f1.y;
         this.m_impulse.x = f2r.x;
         this.m_impulse.y = f2r.y;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         df.z = this.m_impulse.z - f1.z;
         PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
         L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
         this.m_impulse.x += df2.x;
         this.m_impulse.y += df2.y;
         PX = df2.x * this.m_perp.x;
         PY = df2.x * this.m_perp.y;
         L1 = df2.x * this.m_s1 + df2.y;
         L2 = df2.x * this.m_s2 + df2.y;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec3();
      var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
      var C1Y = a2 - a1 - this.m_refAngle;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
      angularError = b2Math.Abs(C1Y);
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var k12 = i1 * this.m_s1 + i2 * this.m_s2;
         var k22 = i1 + i2;
         this.m_K.col1.Set(k11, k12, 0.0);
         this.m_K.col2.Set(k12, k22, 0.0);
         var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
         impulse.x = impulse1.x;
         impulse.y = impulse1.y;
         impulse.z = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PrismaticJointDef.b2PrismaticJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_prismaticJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.referenceAngle = 0.0;
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PulleyJoint.b2PulleyJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u1 = new b2Vec2();
      this.m_u2 = new b2Vec2();
   };
   b2PulleyJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PulleyJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
   }
   b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2PulleyJoint.prototype.GetGroundAnchorA = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor1);
      return a;
   }
   b2PulleyJoint.prototype.GetGroundAnchorB = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor2);
      return a;
   }
   b2PulleyJoint.prototype.GetLength1 = function () {
      var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetLength2 = function () {
      var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_ground = this.m_bodyA.m_world.m_groundBody;
      this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
      this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_ratio = def.ratio;
      this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
      this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
      this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
      this.m_impulse = 0.0;
      this.m_limitImpulse1 = 0.0;
      this.m_limitImpulse2 = 0.0;
   }
   b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      var length1 = this.m_u1.Length();
      var length2 = this.m_u2.Length();
      if (length1 > b2Settings.b2_linearSlop) {
         this.m_u1.Multiply(1.0 / length1);
      }
      else {
         this.m_u1.SetZero();
      }
      if (length2 > b2Settings.b2_linearSlop) {
         this.m_u2.Multiply(1.0 / length2);
      }
      else {
         this.m_u2.SetZero();
      }
      var C = this.m_constant - length1 - this.m_ratio * length2;
      if (C > 0.0) {
         this.m_state = b2Joint.e_inactiveLimit;
         this.m_impulse = 0.0;
      }
      else {
         this.m_state = b2Joint.e_atUpperLimit;
      }
      if (length1 < this.m_maxLength1) {
         this.m_limitState1 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse1 = 0.0;
      }
      else {
         this.m_limitState1 = b2Joint.e_atUpperLimit;
      }
      if (length2 < this.m_maxLength2) {
         this.m_limitState2 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse2 = 0.0;
      }
      else {
         this.m_limitState2 = b2Joint.e_atUpperLimit;
      }
      var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
      var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
      this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
      this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
      this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
      this.m_limitMass1 = 1.0 / this.m_limitMass1;
      this.m_limitMass2 = 1.0 / this.m_limitMass2;
      this.m_pulleyMass = 1.0 / this.m_pulleyMass;
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         this.m_limitImpulse1 *= step.dtRatio;
         this.m_limitImpulse2 *= step.dtRatio;
         var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
         var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
         var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
         var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      else {
         this.m_impulse = 0.0;
         this.m_limitImpulse1 = 0.0;
         this.m_limitImpulse2 = 0.0;
      }
   }
   b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = 0;
      var v1Y = 0;
      var v2X = 0;
      var v2Y = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var Cdot = 0;
      var impulse = 0;
      var oldImpulse = 0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
         impulse = this.m_pulleyMass * ((-Cdot));
         oldImpulse = this.m_impulse;
         this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
         impulse = this.m_impulse - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         P2X = (-this.m_ratio * impulse * this.m_u2.x);
         P2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
         impulse = (-this.m_limitMass1 * Cdot);
         oldImpulse = this.m_limitImpulse1;
         this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
         impulse = this.m_limitImpulse1 - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
         impulse = (-this.m_limitMass2 * Cdot);
         oldImpulse = this.m_limitImpulse2;
         this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
         impulse = this.m_limitImpulse2 - oldImpulse;
         P2X = (-impulse * this.m_u2.x);
         P2Y = (-impulse * this.m_u2.y);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
   }
   b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var p1X = 0;
      var p1Y = 0;
      var p2X = 0;
      var p2Y = 0;
      var length1 = 0;
      var length2 = 0;
      var C = 0;
      var impulse = 0;
      var oldImpulse = 0;
      var oldLimitPositionImpulse = 0;
      var tX = 0;
      var linearError = 0.0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length1 = this.m_u1.Length();
         length2 = this.m_u2.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
         }
         else {
            this.m_u1.SetZero();
         }
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_constant - length1 - this.m_ratio * length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_pulleyMass * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         p2X = (-this.m_ratio * impulse * this.m_u2.x);
         p2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         length1 = this.m_u1.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.x *= 1.0 / length1;
            this.m_u1.y *= 1.0 / length1;
         }
         else {
            this.m_u1.SetZero();
         }
         C = this.m_maxLength1 - length1;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass1 * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bA.SynchronizeTransform();
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length2 = this.m_u2.Length();
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.x *= 1.0 / length2;
            this.m_u2.y *= 1.0 / length2;
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_maxLength2 - length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass2 * C);
         p2X = (-impulse * this.m_u2.x);
         p2Y = (-impulse * this.m_u2.y);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bB.SynchronizeTransform();
      }
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
   });
   Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PulleyJointDef.b2PulleyJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.groundAnchorA = new b2Vec2();
      this.groundAnchorB = new b2Vec2();
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_pulleyJoint;
      this.groundAnchorA.Set((-1.0), 1.0);
      this.groundAnchorB.Set(1.0, 1.0);
      this.localAnchorA.Set((-1.0), 0.0);
      this.localAnchorB.Set(1.0, 0.0);
      this.lengthA = 0.0;
      this.maxLengthA = 0.0;
      this.lengthB = 0.0;
      this.maxLengthB = 0.0;
      this.ratio = 1.0;
      this.collideConnected = true;
   }
   b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
      if (r === undefined) r = 0;
      this.bodyA = bA;
      this.bodyB = bB;
      this.groundAnchorA.SetV(gaA);
      this.groundAnchorB.SetV(gaB);
      this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
      var d1X = anchorA.x - gaA.x;
      var d1Y = anchorA.y - gaA.y;
      this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
      var d2X = anchorB.x - gaB.x;
      var d2Y = anchorB.y - gaB.y;
      this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
      this.ratio = r;
      var C = this.lengthA + this.ratio * this.lengthB;
      this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
      this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
   }
   Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
   b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2RevoluteJoint.b2RevoluteJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.K3 = new b2Mat22();
      this.impulse3 = new b2Vec3();
      this.impulse2 = new b2Vec2();
      this.reduced = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2RevoluteJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2RevoluteJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2RevoluteJoint.prototype.GetJointAngle = function () {
      return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
   }
   b2RevoluteJoint.prototype.GetJointSpeed = function () {
      return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
   }
   b2RevoluteJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2RevoluteJoint.prototype.EnableLimit = function (flag) {
      this.m_enableLimit = flag;
   }
   b2RevoluteJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerAngle;
   }
   b2RevoluteJoint.prototype.GetUpperLimit = function () {
      return this.m_upperAngle;
   }
   b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_lowerAngle = lower;
      this.m_upperAngle = upper;
   }
   b2RevoluteJoint.prototype.IsMotorEnabled = function () {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      return this.m_enableMotor;
   }
   b2RevoluteJoint.prototype.EnableMotor = function (flag) {
      this.m_enableMotor = flag;
   }
   b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2RevoluteJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxMotorTorque = torque;
   }
   b2RevoluteJoint.prototype.GetMotorTorque = function () {
      return this.m_maxMotorTorque;
   }
   b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
      this.m_lowerAngle = def.lowerAngle;
      this.m_upperAngle = def.upperAngle;
      this.m_maxMotorTorque = def.maxMotorTorque;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
   }
   b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      if (this.m_enableMotor || this.m_enableLimit) {}
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
      this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
      this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
      this.m_mass.col3.y = r1X * i1 + r2X * i2;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = i1 + i2;
      this.m_motorMass = 1.0 / (i1 + i2);
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (this.m_enableLimit) {
         var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointAngle <= this.m_lowerAngle) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atLowerLimit;
         }
         else if (jointAngle >= this.m_upperAngle) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atUpperLimit;
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x;
         var PY = this.m_impulse.y;
         bA.m_linearVelocity.x -= m1 * PX;
         bA.m_linearVelocity.y -= m1 * PY;
         bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
         bB.m_linearVelocity.x += m2 * PX;
         bB.m_linearVelocity.y += m2 * PY;
         bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      var newImpulse = 0;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = w2 - w1 - this.m_motorSpeed;
         var impulse = this.m_motorMass * ((-Cdot));
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorTorque;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         w1 -= i1 * impulse;
         w2 += i2 * impulse;
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         var Cdot2 = w2 - w1;
         this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
         if (this.m_limitState == b2Joint.e_equalLimits) {
            this.m_impulse.Add(this.impulse3);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse < 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse > 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         v1.x -= m1 * this.impulse3.x;
         v1.y -= m1 * this.impulse3.y;
         w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
         v2.x += m2 * this.impulse3.x;
         v2.y += m2 * this.impulse3.y;
         w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
      }
      else {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
         this.m_impulse.x += this.impulse2.x;
         this.m_impulse.y += this.impulse2.y;
         v1.x -= m1 * this.impulse2.x;
         v1.y -= m1 * this.impulse2.y;
         w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
         v2.x += m2 * this.impulse2.x;
         v2.y += m2 * this.impulse2.y;
         w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var oldLimitImpulse = 0;
      var C = 0;
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var angularError = 0.0;
      var positionError = 0.0;
      var tX = 0;
      var impulseX = 0;
      var impulseY = 0;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         var limitImpulse = 0.0;
         if (this.m_limitState == b2Joint.e_equalLimits) {
            C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
            angularError = b2Math.Abs(C);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            C = angle - this.m_lowerAngle;
            angularError = (-C);
            C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
            limitImpulse = (-this.m_motorMass * C);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            C = angle - this.m_upperAngle;
            angularError = C;
            C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
         }
         bA.m_sweep.a -= bA.m_invI * limitImpulse;
         bB.m_sweep.a += bB.m_invI * limitImpulse;
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      } {
         tMat = bA.m_xf.R;
         var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
         var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         var CLengthSquared = CX * CX + CY * CY;
         var CLength = Math.sqrt(CLengthSquared);
         positionError = CLength;
         var invMass1 = bA.m_invMass;
         var invMass2 = bB.m_invMass;
         var invI1 = bA.m_invI;
         var invI2 = bB.m_invI;
         var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
         if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
            var uX = CX / CLength;
            var uY = CY / CLength;
            var k = invMass1 + invMass2;
            var m = 1.0 / k;
            impulseX = m * ((-CX));
            impulseY = m * ((-CY));
            var k_beta = 0.5;
            bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
            bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
            bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
            bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
            CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         }
         this.K1.col1.x = invMass1 + invMass2;
         this.K1.col2.x = 0.0;
         this.K1.col1.y = 0.0;
         this.K1.col2.y = invMass1 + invMass2;
         this.K2.col1.x = invI1 * r1Y * r1Y;
         this.K2.col2.x = (-invI1 * r1X * r1Y);
         this.K2.col1.y = (-invI1 * r1X * r1Y);
         this.K2.col2.y = invI1 * r1X * r1X;
         this.K3.col1.x = invI2 * r2Y * r2Y;
         this.K3.col2.x = (-invI2 * r2X * r2Y);
         this.K3.col1.y = (-invI2 * r2X * r2Y);
         this.K3.col2.y = invI2 * r2X * r2X;
         this.K.SetM(this.K1);
         this.K.AddM(this.K2);
         this.K.AddM(this.K3);
         this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
         impulseX = b2RevoluteJoint.tImpulse.x;
         impulseY = b2RevoluteJoint.tImpulse.y;
         bA.m_sweep.c.x -= bA.m_invMass * impulseX;
         bA.m_sweep.c.y -= bA.m_invMass * impulseY;
         bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
         bB.m_sweep.c.x += bB.m_invMass * impulseX;
         bB.m_sweep.c.y += bB.m_invMass * impulseY;
         bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
   });
   Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2RevoluteJointDef.b2RevoluteJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_revoluteJoint;
      this.localAnchorA.Set(0.0, 0.0);
      this.localAnchorB.Set(0.0, 0.0);
      this.referenceAngle = 0.0;
      this.lowerAngle = 0.0;
      this.upperAngle = 0.0;
      this.maxMotorTorque = 0.0;
      this.motorSpeed = 0.0;
      this.enableLimit = false;
      this.enableMotor = false;
   }
   b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
   b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2WeldJoint.b2WeldJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2WeldJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2WeldJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2WeldJoint.prototype.b2WeldJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_mass = new b2Mat33();
   }
   b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_impulse.z *= step.dtRatio;
         bA.m_linearVelocity.x -= mA * this.m_impulse.x;
         bA.m_linearVelocity.y -= mA * this.m_impulse.y;
         bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
         bB.m_linearVelocity.x += mB * this.m_impulse.x;
         bB.m_linearVelocity.y += mB * this.m_impulse.y;
         bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
      }
   }
   b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
      var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
      var Cdot2 = wB - wA;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
      this.m_impulse.Add(impulse);
      vA.x -= mA * impulse.x;
      vA.y -= mA * impulse.y;
      wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      vB.x += mB * impulse.x;
      vB.y += mB * impulse.y;
      wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
      var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
      var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
      var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
      var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
      var angularError = b2Math.Abs(C2);
      if (positionError > k_allowedStretch) {
         iA *= 1.0;
         iB *= 1.0;
      }
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      bA.m_sweep.c.x -= mA * impulse.x;
      bA.m_sweep.c.y -= mA * impulse.y;
      bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      bB.m_sweep.c.x += mB * impulse.x;
      bB.m_sweep.c.y += mB * impulse.y;
      bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2WeldJointDef.b2WeldJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2WeldJointDef.prototype.b2WeldJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_weldJoint;
      this.referenceAngle = 0.0;
   }
   b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
})();
(function () {
   var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
   b2DebugDraw.b2DebugDraw = function () {
      this.m_drawScale = 1.0;
      this.m_lineThickness = 1.0;
      this.m_alpha = 1.0;
      this.m_fillAlpha = 1.0;
      this.m_xformScale = 1.0;
      var __this = this;
      //#WORKAROUND
      this.m_sprite = {
         graphics: {
            clear: function () {
               __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
            }
         }
      };
   };
   b2DebugDraw.prototype._color = function (color, alpha) {
      return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
   };
   b2DebugDraw.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
   };
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags = flags;
   };
   b2DebugDraw.prototype.GetFlags = function () {
      return this.m_drawFlags;
   };
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags |= flags;
   };
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags &= ~flags;
   };
   b2DebugDraw.prototype.SetSprite = function (sprite) {
      this.m_ctx = sprite;
   };
   b2DebugDraw.prototype.GetSprite = function () {
      return this.m_ctx;
   };
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
      this.m_drawScale = drawScale;
   };
   b2DebugDraw.prototype.GetDrawScale = function () {
      return this.m_drawScale;
   };
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
      this.m_lineThickness = lineThickness;
      this.m_ctx.strokeWidth = lineThickness;
   };
   b2DebugDraw.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
   };
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_alpha = alpha;
   };
   b2DebugDraw.prototype.GetAlpha = function () {
      return this.m_alpha;
   };
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_fillAlpha = alpha;
   };
   b2DebugDraw.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
   };
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
      this.m_xformScale = xformScale;
   };
   b2DebugDraw.prototype.GetXFormScale = function () {
      return this.m_xformScale;
   };
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (!radius) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (!radius) return;
      var s = this.m_ctx,
         drawScale = this.m_drawScale,
         cx = center.x * drawScale,
         cy = center.y * drawScale;
      s.moveTo(0, 0);
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
      s.moveTo(cx, cy);
      s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.beginPath();
      s.moveTo(p1.x * drawScale, p1.y * drawScale);
      s.lineTo(p2.x * drawScale, p2.y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawTransform = function (xf) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(0xff0000, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

      s.strokeStyle = this._color(0xff00, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
      s.closePath();
      s.stroke();
   };
})(); //post-definitions
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;


module.exports = Box2D;
},{}],9:[function(require,module,exports){
/**
 * @license
 * pixi.js - v1.5.2
 * Copyright (c) 2012-2014, Mat Groves
 * http://goodboydigital.com/
 *
 * Compiled: 2014-03-31
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license.php
 */
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

(function(){

    var root = this;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * @module PIXI
 */
var PIXI = PIXI || {};

/* 
* 
* This file contains a lot of pixi consts which are used across the rendering engine
* @class Consts
*/
PIXI.WEBGL_RENDERER = 0;
PIXI.CANVAS_RENDERER = 1;

// useful for testing against if your lib is using pixi.
PIXI.VERSION = "v1.5.2";

// the various blend modes supported by pixi
PIXI.blendModes = {
    NORMAL:0,
    ADD:1,
    MULTIPLY:2,
    SCREEN:3,
    OVERLAY:4,
    DARKEN:5,
    LIGHTEN:6,
    COLOR_DODGE:7,
    COLOR_BURN:8,
    HARD_LIGHT:9,
    SOFT_LIGHT:10,
    DIFFERENCE:11,
    EXCLUSION:12,
    HUE:13,
    SATURATION:14,
    COLOR:15,
    LUMINOSITY:16
};

// the scale modes
PIXI.scaleModes = {
    DEFAULT:0,
    LINEAR:0,
    NEAREST:1
};

// interaction frequency 
PIXI.INTERACTION_FREQUENCY = 30;
PIXI.AUTO_PREVENT_DEFAULT = true;

PIXI.RAD_TO_DEG = 180 / Math.PI;
PIXI.DEG_TO_RAD = Math.PI / 180;
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
 *
 * @class Point
 * @constructor
 * @param x {Number} position of the point on the x axis
 * @param y {Number} position of the point on the y axis
 */
PIXI.Point = function(x, y)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;
};

/**
 * Creates a clone of this point
 *
 * @method clone
 * @return {Point} a copy of the point
 */
PIXI.Point.prototype.clone = function()
{
    return new PIXI.Point(this.x, this.y);
};

// constructor
PIXI.Point.prototype.constructor = PIXI.Point;

PIXI.Point.prototype.set = function(x, y)
{
    this.x = x || 0;
    this.y = y || ( (y !== 0) ? this.x : 0 ) ;
};


/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
 *
 * @class Rectangle
 * @constructor
 * @param x {Number} The X coord of the upper-left corner of the rectangle
 * @param y {Number} The Y coord of the upper-left corner of the rectangle
 * @param width {Number} The overall width of this rectangle
 * @param height {Number} The overall height of this rectangle
 */
PIXI.Rectangle = function(x, y, width, height)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property width
     * @type Number
     * @default 0
     */
    this.width = width || 0;

    /**
     * @property height
     * @type Number
     * @default 0
     */
    this.height = height || 0;
};

/**
 * Creates a clone of this Rectangle
 *
 * @method clone
 * @return {Rectangle} a copy of the rectangle
 */
PIXI.Rectangle.prototype.clone = function()
{
    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this Rectangle
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coords are within this Rectangle
 */
PIXI.Rectangle.prototype.contains = function(x, y)
{
    if(this.width <= 0 || this.height <= 0)
        return false;

    var x1 = this.x;
    if(x >= x1 && x <= x1 + this.width)
    {
        var y1 = this.y;

        if(y >= y1 && y <= y1 + this.height)
        {
            return true;
        }
    }

    return false;
};

// constructor
PIXI.Rectangle.prototype.constructor = PIXI.Rectangle;

PIXI.EmptyRectangle = new PIXI.Rectangle(0,0,0,0);
/**
 * @author Adrien Brault <adrien.brault@gmail.com>
 */

/**
 * @class Polygon
 * @constructor
 * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,
 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
 *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
 *      Numbers.
 */
PIXI.Polygon = function(points)
{
    //if points isn't an array, use arguments as the array
    if(!(points instanceof Array))
        points = Array.prototype.slice.call(arguments);

    //if this is a flat array of numbers, convert it to points
    if(typeof points[0] === 'number') {
        var p = [];
        for(var i = 0, il = points.length; i < il; i+=2) {
            p.push(
                new PIXI.Point(points[i], points[i + 1])
            );
        }

        points = p;
    }

    this.points = points;
};

/**
 * Creates a clone of this polygon
 *
 * @method clone
 * @return {Polygon} a copy of the polygon
 */
PIXI.Polygon.prototype.clone = function()
{
    var points = [];
    for (var i=0; i<this.points.length; i++) {
        points.push(this.points[i].clone());
    }

    return new PIXI.Polygon(points);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this polygon
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coordinates are within this polygon
 */
PIXI.Polygon.prototype.contains = function(x, y)
{
    var inside = false;

    // use some raycasting to test hits
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    for(var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
        var xi = this.points[i].x, yi = this.points[i].y,
            xj = this.points[j].x, yj = this.points[j].y,
            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if(intersect) inside = !inside;
    }

    return inside;
};

// constructor
PIXI.Polygon.prototype.constructor = PIXI.Polygon;

/**
 * @author Chad Engler <chad@pantherdev.com>
 */

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class Circle
 * @constructor
 * @param x {Number} The X coordinate of the upper-left corner of the framing rectangle of this circle
 * @param y {Number} The Y coordinate of the upper-left corner of the framing rectangle of this circle
 * @param radius {Number} The radius of the circle
 */
PIXI.Circle = function(x, y, radius)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property radius
     * @type Number
     * @default 0
     */
    this.radius = radius || 0;
};

/**
 * Creates a clone of this Circle instance
 *
 * @method clone
 * @return {Circle} a copy of the polygon
 */
PIXI.Circle.prototype.clone = function()
{
    return new PIXI.Circle(this.x, this.y, this.radius);
};

/**
 * Checks whether the x, and y coordinates passed to this function are contained within this circle
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coordinates are within this polygon
 */
PIXI.Circle.prototype.contains = function(x, y)
{
    if(this.radius <= 0)
        return false;

    var dx = (this.x - x),
        dy = (this.y - y),
        r2 = this.radius * this.radius;

    dx *= dx;
    dy *= dy;

    return (dx + dy <= r2);
};

// constructor
PIXI.Circle.prototype.constructor = PIXI.Circle;


/**
 * @author Chad Engler <chad@pantherdev.com>
 */

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class Ellipse
 * @constructor
 * @param x {Number} The X coordinate of the upper-left corner of the framing rectangle of this ellipse
 * @param y {Number} The Y coordinate of the upper-left corner of the framing rectangle of this ellipse
 * @param width {Number} The overall width of this ellipse
 * @param height {Number} The overall height of this ellipse
 */
PIXI.Ellipse = function(x, y, width, height)
{
    /**
     * @property x
     * @type Number
     * @default 0
     */
    this.x = x || 0;

    /**
     * @property y
     * @type Number
     * @default 0
     */
    this.y = y || 0;

    /**
     * @property width
     * @type Number
     * @default 0
     */
    this.width = width || 0;

    /**
     * @property height
     * @type Number
     * @default 0
     */
    this.height = height || 0;
};

/**
 * Creates a clone of this Ellipse instance
 *
 * @method clone
 * @return {Ellipse} a copy of the ellipse
 */
PIXI.Ellipse.prototype.clone = function()
{
    return new PIXI.Ellipse(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this ellipse
 *
 * @method contains
 * @param x {Number} The X coordinate of the point to test
 * @param y {Number} The Y coordinate of the point to test
 * @return {Boolean} Whether the x/y coords are within this ellipse
 */
PIXI.Ellipse.prototype.contains = function(x, y)
{
    if(this.width <= 0 || this.height <= 0)
        return false;

    //normalize the coords to an ellipse with center 0,0
    var normx = ((x - this.x) / this.width),
        normy = ((y - this.y) / this.height);

    normx *= normx;
    normy *= normy;

    return (normx + normy <= 1);
};

/**
* Returns the framing rectangle of the ellipse as a PIXI.Rectangle object
*
* @method getBounds
* @return {Rectangle} the framing rectangle
*/
PIXI.Ellipse.prototype.getBounds = function()
{
    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);
};

// constructor
PIXI.Ellipse.prototype.constructor = PIXI.Ellipse;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.determineMatrixArrayType = function() {
    return (typeof Float32Array !== 'undefined') ? Float32Array : Array;
};

/*
* @class Matrix2
* The Matrix2 class will choose the best type of array to use between
* a regular javascript Array and a Float32Array if the latter is available
*
*/
PIXI.Matrix2 = PIXI.determineMatrixArrayType();

/*
* @class Matrix
* The Matrix class is now an object, which makes it a lot faster, 
* here is a representation of it : 
* | a | b | tx|
* | c | c | ty|
* | 0 | 0 | 1 |
*
*/
PIXI.Matrix = function()
{
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
};

/**
 * Creates a pixi matrix object based on the array given as a parameter
 *
 * @method fromArray
 * @param array {Array} The array that the matrix will be filled with
 */
PIXI.Matrix.prototype.fromArray = function(array)
{
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
};

/**
 * Creates an array from the current Matrix object
 *
 * @method toArray
 * @param transpose {Boolean} Whether we need to transpose the matrix or not
 * @return array {Array} the newly created array which contains the matrix
 */
PIXI.Matrix.prototype.toArray = function(transpose)
{
    if(!this.array) this.array = new Float32Array(9);
    var array = this.array;

    if(transpose)
    {
        this.array[0] = this.a;
        this.array[1] = this.c;
        this.array[2] = 0;
        this.array[3] = this.b;
        this.array[4] = this.d;
        this.array[5] = 0;
        this.array[6] = this.tx;
        this.array[7] = this.ty;
        this.array[8] = 1;
    }
    else
    {
        this.array[0] = this.a;
        this.array[1] = this.b;
        this.array[2] = this.tx;
        this.array[3] = this.c;
        this.array[4] = this.d;
        this.array[5] = this.ty;
        this.array[6] = 0;
        this.array[7] = 0;
        this.array[8] = 1;
    }

    return array;//[this.a, this.b, this.tx, this.c, this.d, this.ty, 0, 0, 1];
};

PIXI.identityMatrix = new PIXI.Matrix();
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The base class for all objects that are rendered on the screen.
 *
 * @class DisplayObject
 * @constructor
 */
PIXI.DisplayObject = function()
{
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     *
     * @property position
     * @type Point
     */
    this.position = new PIXI.Point();

    /**
     * The scale factor of the object.
     *
     * @property scale
     * @type Point
     */
    this.scale = new PIXI.Point(1,1);//{x:1, y:1};

    /**
     * The pivot point of the displayObject that it rotates around
     *
     * @property pivot
     * @type Point
     */
    this.pivot = new PIXI.Point(0,0);

    /**
     * The rotation of the object in radians.
     *
     * @property rotation
     * @type Number
     */
    this.rotation = 0;

    /**
     * The opacity of the object.
     *
     * @property alpha
     * @type Number
     */
    this.alpha = 1;

    /**
     * The visibility of the object.
     *
     * @property visible
     * @type Boolean
     */
    this.visible = true;

    /**
     * This is the defined area that will pick up mouse / touch events. It is null by default.
     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)
     *
     * @property hitArea
     * @type Rectangle|Circle|Ellipse|Polygon
     */
    this.hitArea = null;

    /**
     * This is used to indicate if the displayObject should display a mouse hand cursor on rollover
     *
     * @property buttonMode
     * @type Boolean
     */
    this.buttonMode = false;

    /**
     * Can this object be rendered
     *
     * @property renderable
     * @type Boolean
     */
    this.renderable = false;

    /**
     * [read-only] The display object container that contains this display object.
     *
     * @property parent
     * @type DisplayObjectContainer
     * @readOnly
     */
    this.parent = null;

    /**
     * [read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.
     *
     * @property stage
     * @type Stage
     * @readOnly
     */
    this.stage = null;

    /**
     * [read-only] The multiplied alpha of the displayObject
     *
     * @property worldAlpha
     * @type Number
     * @readOnly
     */
    this.worldAlpha = 1;

    /**
     * [read-only] Whether or not the object is interactive, do not toggle directly! use the `interactive` property
     *
     * @property _interactive
     * @type Boolean
     * @readOnly
     * @private
     */
    this._interactive = false;

    /**
     * This is the cursor that will be used when the mouse is over this object. To enable this the element must have interaction = true and buttonMode = true
     * 
     * @property defaultCursor
     * @type String
     *
    */
    this.defaultCursor = 'pointer';

    /**
     * [read-only] Current transform of the object based on world (parent) factors
     *
     * @property worldTransform
     * @type Mat3
     * @readOnly
     * @private
     */
    this.worldTransform = new PIXI.Matrix();

    /**
     * [NYI] Unknown
     *
     * @property color
     * @type Array<>
     * @private
     */
    this.color = [];

    /**
     * [NYI] Holds whether or not this object is dynamic, for rendering optimization
     *
     * @property dynamic
     * @type Boolean
     * @private
     */
    this.dynamic = true;

    // cached sin rotation and cos rotation
    this._sr = 0;
    this._cr = 1;

    /**
     * The area the filter is applied to like the hitArea this is used as more of an optimisation
     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
     *
     * @property filterArea
     * @type Rectangle
     */
    this.filterArea = null;//new PIXI.Rectangle(0,0,1,1);

    /**
     * The original, cached bounds of the object
     *
     * @property _bounds
     * @type Rectangle
     * @private
     */
    this._bounds = new PIXI.Rectangle(0, 0, 1, 1);
    /**
     * The most up-to-date bounds of the object
     *
     * @property _currentBounds
     * @type Rectangle
     * @private
     */
    this._currentBounds = null;
    /**
     * The original, cached mask of the object
     *
     * @property _currentBounds
     * @type Rectangle
     * @private
     */
    this._mask = null;

    this._cacheAsBitmap = false;
    this._cacheIsDirty = false;


    /*
     * MOUSE Callbacks
     */

    /**
     * A callback that is used when the users clicks on the displayObject with their mouse
     * @method click
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user clicks the mouse down over the sprite
     * @method mousedown
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the mouse that was over the displayObject
     * for this callback to be fired the mouse must have been pressed down over the displayObject
     * @method mouseup
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the mouse that was over the displayObject but is no longer over the displayObject
     * for this callback to be fired, The touch must have started over the displayObject
     * @method mouseupoutside
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the users mouse rolls over the displayObject
     * @method mouseover
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the users mouse leaves the displayObject
     * @method mouseout
     * @param interactionData {InteractionData}
     */


    /*
     * TOUCH Callbacks
     */

    /**
     * A callback that is used when the users taps on the sprite with their finger
     * basically a touch version of click
     * @method tap
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user touches over the displayObject
     * @method touchstart
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases a touch over the displayObject
     * @method touchend
     * @param interactionData {InteractionData}
     */

    /**
     * A callback that is used when the user releases the touch that was over the displayObject
     * for this callback to be fired, The touch must have started over the sprite
     * @method touchendoutside
     * @param interactionData {InteractionData}
     */
};

// constructor
PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;

/**
 * [Deprecated] Indicates if the sprite will have touch and mouse interactivity. It is false by default
 * Instead of using this function you can now simply set the interactive property to true or false
 *
 * @method setInteractive
 * @param interactive {Boolean}
 * @deprecated Simply set the `interactive` property directly
 */
PIXI.DisplayObject.prototype.setInteractive = function(interactive)
{
    this.interactive = interactive;
};

/**
 * Indicates if the sprite will have touch and mouse interactivity. It is false by default
 *
 * @property interactive
 * @type Boolean
 * @default false
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'interactive', {
    get: function() {
        return this._interactive;
    },
    set: function(value) {
        this._interactive = value;

        // TODO more to be done here..
        // need to sort out a re-crawl!
        if(this.stage)this.stage.dirty = true;
    }
});

/**
 * [read-only] Indicates if the sprite is globaly visible.
 *
 * @property worldVisible
 * @type Boolean
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'worldVisible', {
    get: function() {
        var item = this;

        do
        {
            if(!item.visible)return false;
            item = item.parent;
        }
        while(item);

        return true;
    }
});

/**
 * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
 * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.
 * To remove a mask, set this property to null.
 *
 * @property mask
 * @type Graphics
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'mask', {
    get: function() {
        return this._mask;
    },
    set: function(value) {

        if(this._mask)this._mask.isMask = false;
        this._mask = value;
        if(this._mask)this._mask.isMask = true;
    }
});

/**
 * Sets the filters for the displayObject.
 * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
 * To remove filters simply set this property to 'null'
 * @property filters
 * @type Array An array of filters
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'filters', {
    get: function() {
        return this._filters;
    },
    set: function(value) {

        if(value)
        {
            // now put all the passes in one place..
            var passes = [];
            for (var i = 0; i < value.length; i++)
            {
                var filterPasses = value[i].passes;
                for (var j = 0; j < filterPasses.length; j++)
                {
                    passes.push(filterPasses[j]);
                }
            }

            // TODO change this as it is legacy
            this._filterBlock = {target:this, filterPasses:passes};
        }

        this._filters = value;
    }
});

/**
 * Set weather or not a the display objects is cached as a bitmap.
 * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects
 * To remove filters simply set this property to 'null'
 * @property cacheAsBitmap
 * @type Boolean
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'cacheAsBitmap', {
    get: function() {
        return  this._cacheAsBitmap;
    },
    set: function(value) {

        if(this._cacheAsBitmap === value)return;

        if(value)
        {
            //this._cacheIsDirty = true;
            this._generateCachedSprite();
        }
        else
        {
            this._destroyCachedSprite();
        }

        this._cacheAsBitmap = value;
    }
});

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.DisplayObject.prototype.updateTransform = function()
{
    // TODO OPTIMIZE THIS!! with dirty
    if(this.rotation !== this.rotationCache)
    {

        this.rotationCache = this.rotation;
        this._sr =  Math.sin(this.rotation);
        this._cr =  Math.cos(this.rotation);
    }

   // var localTransform = this.localTransform//.toArray();
    var parentTransform = this.parent.worldTransform;//.toArray();
    var worldTransform = this.worldTransform;//.toArray();

    var px = this.pivot.x;
    var py = this.pivot.y;

    var a00 = this._cr * this.scale.x,
        a01 = -this._sr * this.scale.y,
        a10 = this._sr * this.scale.x,
        a11 = this._cr * this.scale.y,
        a02 = this.position.x - a00 * px - py * a01,
        a12 = this.position.y - a11 * py - px * a10,
        b00 = parentTransform.a, b01 = parentTransform.b,
        b10 = parentTransform.c, b11 = parentTransform.d;

    worldTransform.a = b00 * a00 + b01 * a10;
    worldTransform.b = b00 * a01 + b01 * a11;
    worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx;

    worldTransform.c = b10 * a00 + b11 * a10;
    worldTransform.d = b10 * a01 + b11 * a11;
    worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty;

    this.worldAlpha = this.alpha * this.parent.worldAlpha;
};

/**
 * Retrieves the bounds of the displayObject as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObject.prototype.getBounds = function( matrix )
{
    matrix = matrix;//just to get passed js hinting (and preserve inheritance)
    return PIXI.EmptyRectangle;
};

/**
 * Retrieves the local bounds of the displayObject as a rectangle object
 *
 * @method getLocalBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObject.prototype.getLocalBounds = function()
{
    return this.getBounds(PIXI.identityMatrix);///PIXI.EmptyRectangle();
};


/**
 * Sets the object's stage reference, the stage this object is connected to
 *
 * @method setStageReference
 * @param stage {Stage} the stage that the object will have as its current stage reference
 */
PIXI.DisplayObject.prototype.setStageReference = function(stage)
{
    this.stage = stage;
    if(this._interactive)this.stage.dirty = true;
};

PIXI.DisplayObject.prototype.generateTexture = function(renderer)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer);
    renderTexture.render(this, new PIXI.Point(-bounds.x, -bounds.y) );

    return renderTexture;
};

PIXI.DisplayObject.prototype.updateCache = function()
{
    this._generateCachedSprite();
};

PIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession)
{
    if(renderSession.gl)
    {
        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
    }
    else
    {
        PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
    }
};

PIXI.DisplayObject.prototype._generateCachedSprite = function()//renderSession)
{
    this._cacheAsBitmap = false;
    var bounds = this.getLocalBounds();
   
    if(!this._cachedSprite)
    {
        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0);//, renderSession.renderer);
        
        this._cachedSprite = new PIXI.Sprite(renderTexture);
        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.texture.resize(bounds.width | 0, bounds.height | 0);
    }

    //REMOVE filter!
    var tempFilters = this._filters;
    this._filters = null;

    this._cachedSprite.filters = tempFilters;
    this._cachedSprite.texture.render(this, new PIXI.Point(-bounds.x, -bounds.y) );

    this._filters = tempFilters;

    this._cacheAsBitmap = true;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObject.prototype._destroyCachedSprite = function()
{
    if(!this._cachedSprite)return;

    this._cachedSprite.texture.destroy(true);
  //  console.log("DESTROY")
    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};


PIXI.DisplayObject.prototype._renderWebGL = function(renderSession)
{
    // OVERWRITE;
    // this line is just here to pass jshinting :)
    renderSession = renderSession;
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObject.prototype._renderCanvas = function(renderSession)
{
    // OVERWRITE;
    // this line is just here to pass jshinting :)
    renderSession = renderSession;
};

/**
 * The position of the displayObject on the x axis relative to the local coordinates of the parent.
 *
 * @property x
 * @type Number
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'x', {
    get: function() {
        return  this.position.x;
    },
    set: function(value) {
        this.position.x = value;
    }
});

/**
 * The position of the displayObject on the y axis relative to the local coordinates of the parent.
 *
 * @property y
 * @type Number
 */
Object.defineProperty(PIXI.DisplayObject.prototype, 'y', {
    get: function() {
        return  this.position.y;
    },
    set: function(value) {
        this.position.y = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * A DisplayObjectContainer represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 * @class DisplayObjectContainer
 * @extends DisplayObject
 * @constructor
 */
PIXI.DisplayObjectContainer = function()
{
    PIXI.DisplayObject.call( this );

    /**
     * [read-only] The array of children of this container.
     *
     * @property children
     * @type Array<DisplayObject>
     * @readOnly
     */
    this.children = [];
};

// constructor
PIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );
PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;

/**
 * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */

 /*
Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {
    get: function() {
        return this.scale.x * this.getLocalBounds().width;
    },
    set: function(value) {
        this.scale.x = value / (this.getLocalBounds().width/this.scale.x);
        this._width = value;
    }
});
*/

/**
 * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */

/*
Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {
    get: function() {
        return  this.scale.y * this.getLocalBounds().height;
    },
    set: function(value) {
        this.scale.y = value / (this.getLocalBounds().height/this.scale.y);
        this._height = value;
    }
});
*/

/**
 * Adds a child to the container.
 *
 * @method addChild
 * @param child {DisplayObject} The DisplayObject to add to the container
 */
PIXI.DisplayObjectContainer.prototype.addChild = function(child)
{
    this.addChildAt(child, this.children.length);
};

/**
 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @method addChildAt
 * @param child {DisplayObject} The child to add
 * @param index {Number} The index to place the child in
 */
PIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index)
{
    if(index >= 0 && index <= this.children.length)
    {
        if(child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        if(this.stage)child.setStageReference(this.stage);
    }
    else
    {
        throw new Error(child + ' The index '+ index +' supplied is out of bounds ' + this.children.length);
    }
};

/**
 * [NYI] Swaps the depth of 2 displayObjects
 *
 * @method swapChildren
 * @param child {DisplayObject}
 * @param child2 {DisplayObject}
 * @private
 */
PIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2)
{
    if(child === child2) {
        return;
    }

    var index1 = this.children.indexOf(child);
    var index2 = this.children.indexOf(child2);

    if(index1 < 0 || index2 < 0) {
        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');
    }

    this.children[index1] = child2;
    this.children[index2] = child;
    
};

/**
 * Returns the child at the specified index
 *
 * @method getChildAt
 * @param index {Number} The index to get the child from
 */
PIXI.DisplayObjectContainer.prototype.getChildAt = function(index)
{
    if(index >= 0 && index < this.children.length)
    {
        return this.children[index];
    }
    else
    {
        throw new Error('Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller');
    }
};

/**
 * Removes a child from the container.
 *
 * @method removeChild
 * @param child {DisplayObject} The DisplayObject to remove
 */
PIXI.DisplayObjectContainer.prototype.removeChild = function(child)
{
    return this.removeChildAt( this.children.indexOf( child ) );
};

/**
 * Removes a child from the specified index position in the child list of the container.
 *
 * @method removeChildAt
 * @param index {Number} The index to get the child from
 */
PIXI.DisplayObjectContainer.prototype.removeChildAt = function(index)
{
    var child = this.getChildAt( index );
    if(this.stage)
        child.removeStageReference();

    child.parent = undefined;
    this.children.splice( index, 1 );
    return child;
};

/**
* Removes all child instances from the child list of the container.
*
* @method removeChildren
* @param beginIndex {Number} The beginning position. Predefined value is 0.
* @param endIndex {Number} The ending position. Predefined value is children's array length.
*/
PIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex)
{
    var begin = beginIndex || 0;
    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
    var range = end - begin;

    if (range > 0 && range <= end)
    {
        var removed = this.children.splice(begin, range);
        for (var i = 0; i < removed.length; i++) {
            var child = removed[i];
            if(this.stage)
                child.removeStageReference();
            child.parent = undefined;
        }
        return removed;
    }
    else
    {
        throw new Error( 'Range Error, numeric values are outside the acceptable range' );
    }
};

/*
 * Updates the container's childrens transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.DisplayObjectContainer.prototype.updateTransform = function()
{
    //this._currentBounds = null;

    if(!this.visible)return;

    PIXI.DisplayObject.prototype.updateTransform.call( this );

    if(this._cacheAsBitmap)return;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }
};

/**
 * Retrieves the bounds of the displayObjectContainer as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.DisplayObjectContainer.prototype.getBounds = function(matrix)
{
    if(this.children.length === 0)return PIXI.EmptyRectangle;

    // TODO the bounds have already been calculated this render session so return what we have
    if(matrix)
    {
        var matrixCache = this.worldTransform;
        this.worldTransform = matrix;
        this.updateTransform();
        this.worldTransform = matrixCache;
    }

    var minX = Infinity;
    var minY = Infinity;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var childBounds;
    var childMaxX;
    var childMaxY;

    var childVisible = false;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        
        if(!child.visible)continue;

        childVisible = true;

        childBounds = this.children[i].getBounds( matrix );
     
        minX = minX < childBounds.x ? minX : childBounds.x;
        minY = minY < childBounds.y ? minY : childBounds.y;

        childMaxX = childBounds.width + childBounds.x;
        childMaxY = childBounds.height + childBounds.y;

        maxX = maxX > childMaxX ? maxX : childMaxX;
        maxY = maxY > childMaxY ? maxY : childMaxY;
    }

    if(!childVisible)
        return PIXI.EmptyRectangle;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.y = minY;
    bounds.width = maxX - minX;
    bounds.height = maxY - minY;

    // TODO: store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    //this._currentBounds = bounds;
   
    return bounds;
};

PIXI.DisplayObjectContainer.prototype.getLocalBounds = function()
{
    var matrixCache = this.worldTransform;

    this.worldTransform = PIXI.identityMatrix;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }

    var bounds = this.getBounds();

    this.worldTransform = matrixCache;

    return bounds;
};

/**
 * Sets the container's stage reference, the stage this object is connected to
 *
 * @method setStageReference
 * @param stage {Stage} the stage that the container will have as its current stage reference
 */
PIXI.DisplayObjectContainer.prototype.setStageReference = function(stage)
{
    this.stage = stage;
    if(this._interactive)this.stage.dirty = true;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child.setStageReference(stage);
    }
};

/**
 * removes the current stage reference of the container
 *
 * @method removeStageReference
 */
PIXI.DisplayObjectContainer.prototype.removeStageReference = function()
{

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child.removeStageReference();
    }

    if(this._interactive)this.stage.dirty = true;
    
    this.stage = null;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession)
{
    if(!this.visible || this.alpha <= 0)return;
    
    if(this._cacheAsBitmap)
    {
        this._renderCachedSprite(renderSession);
        return;
    }
    
    var i,j;

    if(this._mask || this._filters)
    {
        if(this._mask)
        {
            renderSession.spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            renderSession.spriteBatch.start();
        }

        if(this._filters)
        {
            renderSession.spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }

        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }

        renderSession.spriteBatch.stop();

        if(this._filters)renderSession.filterManager.popFilter();
        if(this._mask)renderSession.maskManager.popMask(renderSession);
        
        renderSession.spriteBatch.start();
    }
    else
    {
        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }
    }
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession)
{
    if(this.visible === false || this.alpha === 0)return;

    if(this._cacheAsBitmap)
    {

        this._renderCachedSprite(renderSession);
        return;
    }

    if(this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession.context);
    }

    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child._renderCanvas(renderSession);
    }

    if(this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * @class Sprite
 * @extends DisplayObjectContainer
 * @constructor
 * @param texture {Texture} The texture for this sprite
 * 
 * A sprite can be created directly from an image like this : 
 * var sprite = nex PIXI.Sprite.FromImage('assets/image.png');
 * yourStage.addChild(sprite);
 * then obviously don't forget to add it to the stage you have already created
 */
PIXI.Sprite = function(texture)
{
    PIXI.DisplayObjectContainer.call( this );

    /**
     * The anchor sets the origin point of the texture.
     * The default is 0,0 this means the texture's origin is the top left
     * Setting than anchor to 0.5,0.5 means the textures origin is centred
     * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner
     *
     * @property anchor
     * @type Point
     */
    this.anchor = new PIXI.Point();

    /**
     * The texture that the sprite is using
     *
     * @property texture
     * @type Texture
     */
    this.texture = texture;

    /**
     * The width of the sprite (this is initially set by the texture)
     *
     * @property _width
     * @type Number
     * @private
     */
    this._width = 0;

    /**
     * The height of the sprite (this is initially set by the texture)
     *
     * @property _height
     * @type Number
     * @private
     */
    this._height = 0;


    /**
     * The tint applied to the sprite. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;// * Math.random();
    
    /**
     * The blend mode to be applied to the sprite
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;

    if(texture.baseTexture.hasLoaded)
    {
        this.onTextureUpdate();
    }
    else
    {
        this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
        this.texture.addEventListener( 'update', this.onTextureUpdateBind );
    }

    this.renderable = true;
};

// constructor
PIXI.Sprite.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Sprite.prototype.constructor = PIXI.Sprite;

/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.Sprite.prototype, 'width', {
    get: function() {
        return this.scale.x * this.texture.frame.width;
    },
    set: function(value) {
        this.scale.x = value / this.texture.frame.width;
        this._width = value;
    }
});

/**
 * The height of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.Sprite.prototype, 'height', {
    get: function() {
        return  this.scale.y * this.texture.frame.height;
    },
    set: function(value) {
        this.scale.y = value / this.texture.frame.height;
        this._height = value;
    }
});

/**
 * Sets the texture of the sprite
 *
 * @method setTexture
 * @param texture {Texture} The PIXI texture that is displayed by the sprite
 */
PIXI.Sprite.prototype.setTexture = function(texture)
{
    // stop current texture;
    if(this.texture.baseTexture !== texture.baseTexture)
    {
        this.textureChange = true;
        this.texture = texture;
    }
    else
    {
        this.texture = texture;
    }

    this.cachedTint = 0xFFFFFF;
    this.updateFrame = true;
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */
PIXI.Sprite.prototype.onTextureUpdate = function()
{
    // so if _width is 0 then width was not set..
    if(this._width)this.scale.x = this._width / this.texture.frame.width;
    if(this._height)this.scale.y = this._height / this.texture.frame.height;


    this.updateFrame = true;
};

/**
* Returns the framing rectangle of the sprite as a PIXI.Rectangle object
*
* @method getBounds
* @param matrix {Matrix} the transformation matrix of the sprite
* @return {Rectangle} the framing rectangle
*/
PIXI.Sprite.prototype.getBounds = function(matrix)
{

    var width = this.texture.frame.width;
    var height = this.texture.frame.height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = matrix || this.worldTransform ;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    minX = x1 < minX ? x1 : minX;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1 < minY ? y1 : minY;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1 > maxX ? x1 : maxX;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1 > maxY ? y1 : maxY;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Sprite.prototype._renderWebGL = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(!this.visible || this.alpha <= 0)return;
    
    var i,j;

    // do a quick check to see if this element has a mask or a filter.
    if(this._mask || this._filters)
    {
        var spriteBatch =  renderSession.spriteBatch;

        if(this._mask)
        {
            spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            spriteBatch.start();
        }

        if(this._filters)
        {
            spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }

        // add this sprite to the batch
        spriteBatch.render(this);

        // now loop through the children and make sure they get rendered
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }

        // time to stop the sprite batch as either a mask element or a filter draw will happen next
        spriteBatch.stop();

        if(this._filters)renderSession.filterManager.popFilter();
        if(this._mask)renderSession.maskManager.popMask(renderSession);
        
        spriteBatch.start();
    }
    else
    {
        renderSession.spriteBatch.render(this);

        // simple render children!
        for(i=0,j=this.children.length; i<j; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }
    }

   
    //TODO check culling  
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Sprite.prototype._renderCanvas = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(this.visible === false || this.alpha === 0)return;
    
    var frame = this.texture.frame;
    var context = renderSession.context;
    var texture = this.texture;

    if(this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    if(this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession.context);
    }

    

    //ignore null sources
    if(frame && frame.width && frame.height && texture.baseTexture.source)
    {
        context.globalAlpha = this.worldAlpha;

        var transform = this.worldTransform;

        // allow for trimming
        if (renderSession.roundPixels)
        {
            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx | 0, transform.ty | 0);
        }
        else
        {
            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        }

        //if smoothingEnabled is supported and we need to change the smoothing property for this texture
        if(renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode) {
            renderSession.scaleMode = this.texture.baseTexture.scaleMode;
            context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);
        }

        if(this.tint !== 0xFFFFFF)
        {
            
            if(this.cachedTint !== this.tint)
            {
                // no point tinting an image that has not loaded yet!
                if(!texture.baseTexture.hasLoaded)return;

                this.cachedTint = this.tint;
                
                //TODO clean up caching - how to clean up the caches?
                this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);
                
            }

            context.drawImage(this.tintedTexture,
                               0,
                               0,
                               frame.width,
                               frame.height,
                               (this.anchor.x) * -frame.width,
                               (this.anchor.y) * -frame.height,
                               frame.width,
                               frame.height);
        }
        else
        {

           

            if(texture.trim)
            {
                var trim =  texture.trim;

                context.drawImage(this.texture.baseTexture.source,
                               frame.x,
                               frame.y,
                               frame.width,
                               frame.height,
                               trim.x - this.anchor.x * trim.width,
                               trim.y - this.anchor.y * trim.height,
                               frame.width,
                               frame.height);
            }
            else
            {
               
                context.drawImage(this.texture.baseTexture.source,
                               frame.x,
                               frame.y,
                               frame.width,
                               frame.height,
                               (this.anchor.x) * -frame.width,
                               (this.anchor.y) * -frame.height,
                               frame.width,
                               frame.height);
            }
            
        }
    }

    // OVERWRITE
    for(var i=0,j=this.children.length; i<j; i++)
    {
        var child = this.children[i];
        child._renderCanvas(renderSession);
    }

    if(this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};


// some helper functions..

/**
 *
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @method fromFrame
 * @static
 * @param frameId {String} The frame Id of the texture in the cache
 * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId
 */
PIXI.Sprite.fromFrame = function(frameId)
{
    var texture = PIXI.TextureCache[frameId];
    if(!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache' + this);
    return new PIXI.Sprite(texture);
};

/**
 *
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @method fromImage
 * @static
 * @param imageId {String} The image url of the texture
 * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id
 */
PIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode)
{
    var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);
    return new PIXI.Sprite(texture);
};

/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * The SpriteBatch class is a really fast version of the DisplayObjectContainer 
 * built solely for speed, so use when you need a lot of sprites or particles.
 * And it's extremely easy to use : 

    var container = new PIXI.SpriteBatch();
 
    stage.addChild(container);
 
    for(var i  = 0; i < 100; i++)
    {
        var sprite = new PIXI.Sprite.fromImage("myImage.png");
        container.addChild(sprite);
    }
 * And here you have a hundred sprites that will be renderer at the speed of light
 *
 * @class SpriteBatch
 * @constructor
 * @param texture {Texture}
 */
PIXI.SpriteBatch = function(texture)
{
    PIXI.DisplayObjectContainer.call( this);

    this.textureThing = texture;

    this.ready = false;
};

PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.SpriteBatch.constructor = PIXI.SpriteBatch;

/*
 * Initialises the spriteBatch
 *
 * @method initWebGL
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.SpriteBatch.prototype.initWebGL = function(gl)
{
    // TODO only one needed for the whole engine really?
    this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);

    this.ready = true;
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.SpriteBatch.prototype.updateTransform = function()
{
   // TODO dont need to!
    PIXI.DisplayObject.prototype.updateTransform.call( this );
  //  PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.SpriteBatch.prototype._renderWebGL = function(renderSession)
{
    if(!this.visible || this.alpha <= 0 || !this.children.length)return;

    if(!this.ready)this.initWebGL( renderSession.gl );
    
    renderSession.spriteBatch.stop();
    
    renderSession.shaderManager.activateShader(renderSession.shaderManager.fastShader);
    
    this.fastSpriteBatch.begin(this, renderSession);
    this.fastSpriteBatch.render(this);

    renderSession.shaderManager.activateShader(renderSession.shaderManager.defaultShader);

    renderSession.spriteBatch.start();
 
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.SpriteBatch.prototype._renderCanvas = function(renderSession)
{
    var context = renderSession.context;
    context.globalAlpha = this.worldAlpha;

    PIXI.DisplayObject.prototype.updateTransform.call(this);

    var transform = this.worldTransform;
    // alow for trimming
       
    var isRotated = true;

    for (var i = 0; i < this.children.length; i++) {
       
        var child = this.children[i];

        if(!child.visible)continue;

        var texture = child.texture;
        var frame = texture.frame;

        context.globalAlpha = this.worldAlpha * child.alpha;

        if(child.rotation % (Math.PI * 2) === 0)
        {
            if(isRotated)
            {
                context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
                isRotated = false;
            }

            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
            context.drawImage(texture.baseTexture.source,
                                 frame.x,
                                 frame.y,
                                 frame.width,
                                 frame.height,
                                 ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5) | 0,
                                 ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5) | 0,
                                 frame.width * child.scale.x,
                                 frame.height * child.scale.y);
        }
        else
        {
            if(!isRotated)isRotated = true;
    
            PIXI.DisplayObject.prototype.updateTransform.call(child);
           
            var childTransform = child.worldTransform;

            // allow for trimming
           
            if (renderSession.roundPixels)
            {
                context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);
            }
            else
            {
                context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx, childTransform.ty);
            }

            context.drawImage(texture.baseTexture.source,
                                 frame.x,
                                 frame.y,
                                 frame.width,
                                 frame.height,
                                 ((child.anchor.x) * (-frame.width) + 0.5) | 0,
                                 ((child.anchor.y) * (-frame.height) + 0.5) | 0,
                                 frame.width,
                                 frame.height);
           

        }

       // context.restore();
    }

//    context.restore();
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A MovieClip is a simple way to display an animation depicted by a list of textures.
 *
 * @class MovieClip
 * @extends Sprite
 * @constructor
 * @param textures {Array<Texture>} an array of {Texture} objects that make up the animation
 */
PIXI.MovieClip = function(textures)
{
    PIXI.Sprite.call(this, textures[0]);

    /**
     * The array of textures that make up the animation
     *
     * @property textures
     * @type Array
     */
    this.textures = textures;

    /**
     * The speed that the MovieClip will play at. Higher is faster, lower is slower
     *
     * @property animationSpeed
     * @type Number
     * @default 1
     */
    this.animationSpeed = 1;

    /**
     * Whether or not the movie clip repeats after playing.
     *
     * @property loop
     * @type Boolean
     * @default true
     */
    this.loop = true;

    /**
     * Function to call when a MovieClip finishes playing
     *
     * @property onComplete
     * @type Function
     */
    this.onComplete = null;

    /**
     * [read-only] The MovieClips current frame index (this may not have to be a whole number)
     *
     * @property currentFrame
     * @type Number
     * @default 0
     * @readOnly
     */
    this.currentFrame = 0;

    /**
     * [read-only] Indicates if the MovieClip is currently playing
     *
     * @property playing
     * @type Boolean
     * @readOnly
     */
    this.playing = false;
};

// constructor
PIXI.MovieClip.prototype = Object.create( PIXI.Sprite.prototype );
PIXI.MovieClip.prototype.constructor = PIXI.MovieClip;

/**
* [read-only] totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
* assigned to the MovieClip.
*
* @property totalFrames
* @type Number
* @default 0
* @readOnly
*/
Object.defineProperty( PIXI.MovieClip.prototype, 'totalFrames', {
	get: function() {

		return this.textures.length;
	}
});


/**
 * Stops the MovieClip
 *
 * @method stop
 */
PIXI.MovieClip.prototype.stop = function()
{
    this.playing = false;
};

/**
 * Plays the MovieClip
 *
 * @method play
 */
PIXI.MovieClip.prototype.play = function()
{
    this.playing = true;
};

/**
 * Stops the MovieClip and goes to a specific frame
 *
 * @method gotoAndStop
 * @param frameNumber {Number} frame index to stop at
 */
PIXI.MovieClip.prototype.gotoAndStop = function(frameNumber)
{
    this.playing = false;
    this.currentFrame = frameNumber;
    var round = (this.currentFrame + 0.5) | 0;
    this.setTexture(this.textures[round % this.textures.length]);
};

/**
 * Goes to a specific frame and begins playing the MovieClip
 *
 * @method gotoAndPlay
 * @param frameNumber {Number} frame index to start at
 */
PIXI.MovieClip.prototype.gotoAndPlay = function(frameNumber)
{
    this.currentFrame = frameNumber;
    this.playing = true;
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.MovieClip.prototype.updateTransform = function()
{
    PIXI.Sprite.prototype.updateTransform.call(this);

    if(!this.playing)return;

    this.currentFrame += this.animationSpeed;

    var round = (this.currentFrame + 0.5) | 0;

    if(this.loop || round < this.textures.length)
    {
        this.setTexture(this.textures[round % this.textures.length]);
    }
    else if(round >= this.textures.length)
    {
        this.gotoAndStop(this.textures.length - 1);
        if(this.onComplete)
        {
            this.onComplete();
        }
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


PIXI.FilterBlock = function()
{
    this.visible = true;
    this.renderable = true;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * - Modified by Tom Slezakowski http://www.tomslezakowski.com @TomSlezakowski (24/03/2014) - Added dropShadowColor.
 */

/**
 * A Text Object will create a line(s) of text. To split a line you can use '\n' 
 * or add a wordWrap property set to true and and wordWrapWidth property with a value
 * in the style object
 *
 * @class Text
 * @extends Sprite
 * @constructor
 * @param text {String} The copy that you would like the text to display
 * @param [style] {Object} The style parameters
 * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font
 * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap, it needs wordWrap to be set to true
 * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow
 */
PIXI.Text = function(text, style)
{
    /**
     * The canvas element that everything is drawn to
     *
     * @property canvas
     * @type HTMLCanvasElement
     */
    this.canvas = document.createElement('canvas');

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type HTMLCanvasElement 2d Context
     */
    this.context = this.canvas.getContext('2d');

    PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));

    this.setText(text);
    this.setStyle(style);

    this.updateText();
    this.dirty = false;
};

// constructor
PIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);
PIXI.Text.prototype.constructor = PIXI.Text;

/**
 * Set the style of the text
 *
 * @method setStyle
 * @param [style] {Object} The style parameters
 * @param [style.font='bold 20pt Arial'] {String} The style and size of the font
 * @param [style.fill='black'] {Object} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke='black'] {String} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap
 * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow
 */
PIXI.Text.prototype.setStyle = function(style)
{
    style = style || {};
    style.font = style.font || 'bold 20pt Arial';
    style.fill = style.fill || 'black';
    style.align = style.align || 'left';
    style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136
    style.strokeThickness = style.strokeThickness || 0;
    style.wordWrap = style.wordWrap || false;
    style.wordWrapWidth = style.wordWrapWidth || 100;
    style.wordWrapWidth = style.wordWrapWidth || 100;
    
    style.dropShadow = style.dropShadow || false;
    style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;
    style.dropShadowDistance = style.dropShadowDistance || 4;
    style.dropShadowColor = style.dropShadowColor || 'black';

    this.style = style;
    this.dirty = true;
};

/**
 * Set the copy for the text object. To split a line you can use '\n'
 *
 * @method setText
 * @param {String} text The copy that you would like the text to display
 */
PIXI.Text.prototype.setText = function(text)
{
    this.text = text.toString() || ' ';
    this.dirty = true;

};

/**
 * Renders text and updates it when needed
 *
 * @method updateText
 * @private
 */
PIXI.Text.prototype.updateText = function()
{
    this.context.font = this.style.font;

    var outputText = this.text;

    // word wrap
    // preserve original text
    if(this.style.wordWrap)outputText = this.wordWrap(this.text);

    //split text into lines
    var lines = outputText.split(/(?:\r\n|\r|\n)/);

    //calculate text width
    var lineWidths = [];
    var maxLineWidth = 0;
    for (var i = 0; i < lines.length; i++)
    {
        var lineWidth = this.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }

    var width = maxLineWidth + this.style.strokeThickness;
    if(this.style.dropShadow)width += this.style.dropShadowDistance;

    this.canvas.width = width;
    //calculate text height
    var lineHeight = this.determineFontHeight('font: ' + this.style.font  + ';') + this.style.strokeThickness;
    
    var height = lineHeight * lines.length;
    if(this.style.dropShadow)height += this.style.dropShadowDistance;

    this.canvas.height = height;

    if(navigator.isCocoonJS) this.context.clearRect(0,0,this.canvas.width,this.canvas.height);
    
    this.context.font = this.style.font;
    this.context.strokeStyle = this.style.stroke;
    this.context.lineWidth = this.style.strokeThickness;
    this.context.textBaseline = 'top';

    var linePositionX;
    var linePositionY;

    if(this.style.dropShadow)
    {
        this.context.fillStyle = this.style.dropShadowColor;

        var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance;
        var yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;

        for (i = 0; i < lines.length; i++)
        {
            linePositionX = this.style.strokeThickness / 2;
            linePositionY = this.style.strokeThickness / 2 + i * lineHeight;

            if(this.style.align === 'right')
            {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if(this.style.align === 'center')
            {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }

            if(this.style.fill)
            {
                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset);
            }

          //  if(dropShadow)
        }
    }

    //set canvas text styles
    this.context.fillStyle = this.style.fill;
    
    //draw lines line by line
    for (i = 0; i < lines.length; i++)
    {
        linePositionX = this.style.strokeThickness / 2;
        linePositionY = this.style.strokeThickness / 2 + i * lineHeight;

        if(this.style.align === 'right')
        {
            linePositionX += maxLineWidth - lineWidths[i];
        }
        else if(this.style.align === 'center')
        {
            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
        }

        if(this.style.stroke && this.style.strokeThickness)
        {
            this.context.strokeText(lines[i], linePositionX, linePositionY);
        }

        if(this.style.fill)
        {
            this.context.fillText(lines[i], linePositionX, linePositionY);
        }

      //  if(dropShadow)
    }


    this.updateTexture();
};

/**
 * Updates texture size based on canvas size
 *
 * @method updateTexture
 * @private
 */
PIXI.Text.prototype.updateTexture = function()
{
    this.texture.baseTexture.width = this.canvas.width;
    this.texture.baseTexture.height = this.canvas.height;
    this.texture.frame.width = this.canvas.width;
    this.texture.frame.height = this.canvas.height;

    this._width = this.canvas.width;
    this._height = this.canvas.height;

    this.requiresUpdate =  true;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Text.prototype._renderWebGL = function(renderSession)
{
    if(this.requiresUpdate)
    {
        this.requiresUpdate = false;
        PIXI.updateWebGLTexture(this.texture.baseTexture, renderSession.gl);
    }

    PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);
};

/**
 * Updates the transform of this object
 *
 * @method updateTransform
 * @private
 */
PIXI.Text.prototype.updateTransform = function()
{
    if(this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }

    PIXI.Sprite.prototype.updateTransform.call(this);
};

/*
 * http://stackoverflow.com/users/34441/ellisbben
 * great solution to the problem!
 * returns the height of the given font
 *
 * @method determineFontHeight
 * @param fontStyle {Object}
 * @private
 */
PIXI.Text.prototype.determineFontHeight = function(fontStyle)
{
    // build a little reference dictionary so if the font style has been used return a
    // cached version...
    var result = PIXI.Text.heightCache[fontStyle];

    if(!result)
    {
        var body = document.getElementsByTagName('body')[0];
        var dummy = document.createElement('div');
        var dummyText = document.createTextNode('M');
        dummy.appendChild(dummyText);
        dummy.setAttribute('style', fontStyle + ';position:absolute;top:0;left:0');
        body.appendChild(dummy);

        result = dummy.offsetHeight;
        PIXI.Text.heightCache[fontStyle] = result;

        body.removeChild(dummy);
    }

    return result;
};

/**
 * Applies newlines to a string to have it optimally fit into the horizontal
 * bounds set by the Text object's wordWrapWidth property.
 *
 * @method wordWrap
 * @param text {String}
 * @private
 */
PIXI.Text.prototype.wordWrap = function(text)
{
    // Greedy wrapping algorithm that will wrap words as the line grows longer
    // than its horizontal bounds.
    var result = '';
    var lines = text.split('\n');
    for (var i = 0; i < lines.length; i++)
    {
        var spaceLeft = this.style.wordWrapWidth;
        var words = lines[i].split(' ');
        for (var j = 0; j < words.length; j++)
        {
            var wordWidth = this.context.measureText(words[j]).width;
            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
            if(wordWidthWithSpace > spaceLeft)
            {
                // Skip printing the newline if it's the first word of the line that is
                // greater than the word wrap width.
                if(j > 0)
                {
                    result += '\n';
                }
                result += words[j] + ' ';
                spaceLeft = this.style.wordWrapWidth - wordWidth;
            }
            else
            {
                spaceLeft -= wordWidthWithSpace;
                result += words[j] + ' ';
            }
        }

        if (i < lines.length-1)
        {
            result += '\n';
        }
    }
    return result;
};

/**
 * Destroys this text object
 *
 * @method destroy
 * @param destroyTexture {Boolean}
 */
PIXI.Text.prototype.destroy = function(destroyTexture)
{
    if(destroyTexture)
    {
        this.texture.destroy();
    }

};

PIXI.Text.heightCache = {};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Text Object will create a line(s) of text using bitmap font. To split a line you can use '\n', '\r' or '\r\n'
 * You can generate the fnt files using
 * http://www.angelcode.com/products/bmfont/ for windows or
 * http://www.bmglyph.com/ for mac.
 *
 * @class BitmapText
 * @extends DisplayObjectContainer
 * @constructor
 * @param text {String} The copy that you would like the text to display
 * @param style {Object} The style parameters
 * @param style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)
 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 */
PIXI.BitmapText = function(text, style)
{
    PIXI.DisplayObjectContainer.call(this);

    this._pool = [];

    this.setText(text);
    this.setStyle(style);
    this.updateText();
    this.dirty = false;
};

// constructor
PIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.BitmapText.prototype.constructor = PIXI.BitmapText;

/**
 * Set the copy for the text object
 *
 * @method setText
 * @param text {String} The copy that you would like the text to display
 */
PIXI.BitmapText.prototype.setText = function(text)
{
    this.text = text || ' ';
    this.dirty = true;
};

/**
 * Set the style of the text
 * style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)
 * [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 *
 * @method setStyle
 * @param style {Object} The style parameters, contained as properties of an object
 */
PIXI.BitmapText.prototype.setStyle = function(style)
{
    style = style || {};
    style.align = style.align || 'left';
    this.style = style;

    var font = style.font.split(' ');
    this.fontName = font[font.length - 1];
    this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;

    this.dirty = true;
    this.tint = style.tint;
};

/**
 * Renders text and updates it when needed
 *
 * @method updateText
 * @private
 */
PIXI.BitmapText.prototype.updateText = function()
{
    var data = PIXI.BitmapText.fonts[this.fontName];
    var pos = new PIXI.Point();
    var prevCharCode = null;
    var chars = [];
    var maxLineWidth = 0;
    var lineWidths = [];
    var line = 0;
    var scale = this.fontSize / data.size;
    

    for(var i = 0; i < this.text.length; i++)
    {
        var charCode = this.text.charCodeAt(i);
        if(/(?:\r\n|\r|\n)/.test(this.text.charAt(i)))
        {
            lineWidths.push(pos.x);
            maxLineWidth = Math.max(maxLineWidth, pos.x);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        var charData = data.chars[charCode];
        if(!charData) continue;

        if(prevCharCode && charData[prevCharCode])
        {
            pos.x += charData.kerning[prevCharCode];
        }
        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});
        pos.x += charData.xAdvance;

        prevCharCode = charCode;
    }

    lineWidths.push(pos.x);
    maxLineWidth = Math.max(maxLineWidth, pos.x);

    var lineAlignOffsets = [];
    for(i = 0; i <= line; i++)
    {
        var alignOffset = 0;
        if(this.style.align === 'right')
        {
            alignOffset = maxLineWidth - lineWidths[i];
        }
        else if(this.style.align === 'center')
        {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
        }
        lineAlignOffsets.push(alignOffset);
    }

    var lenChildren = this.children.length;
    var lenChars = chars.length;
    var tint = this.tint || 0xFFFFFF;
    for(i = 0; i < lenChars; i++)
    {
        var c = i < lenChildren ? this.children[i] : this._pool.pop(); // get old child if have. if not - take from pool.

        if (c) c.setTexture(chars[i].texture); // check if got one before.
        else c = new PIXI.Sprite(chars[i].texture); // if no create new one.

        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
        c.position.y = chars[i].position.y * scale;
        c.scale.x = c.scale.y = scale;
        c.tint = tint;
        if (!c.parent) this.addChild(c);
    }

    // remove unnecessary children.
    // and put their into the pool.
    while(this.children.length > lenChars)
    {
        var child = this.getChildAt(this.children.length - 1);
        this._pool.push(child);
        this.removeChild(child);
    }


    /**
     * [read-only] The width of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @property textWidth
     * @type Number
     */
    this.textWidth = maxLineWidth * scale;

    /**
     * [read-only] The height of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @property textHeight
     * @type Number
     */
    this.textHeight = (pos.y + data.lineHeight) * scale;
};

/**
 * Updates the transform of this object
 *
 * @method updateTransform
 * @private
 */
PIXI.BitmapText.prototype.updateTransform = function()
{
    if(this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
};

PIXI.BitmapText.fonts = {};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
/**
 * Holds all information related to an Interaction event
 *
 * @class InteractionData
 * @constructor
 */
PIXI.InteractionData = function()
{
    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @property global
     * @type Point
     */
    this.global = new PIXI.Point();

    // this is here for legacy... but will remove
    this.local = new PIXI.Point();

    /**
     * The target Sprite that was interacted with
     *
     * @property target
     * @type Sprite
     */
    this.target = null;

    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @property originalEvent
     * @type Event
     */
    this.originalEvent = null;
};

/**
 * This will return the local coordinates of the specified displayObject for this InteractionData
 *
 * @method getLocalPosition
 * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off
 * @return {Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject
 */
PIXI.InteractionData.prototype.getLocalPosition = function(displayObject)
{
    var worldTransform = displayObject.worldTransform;
    var global = this.global;

    // do a cheeky transform to get the mouse coords;
    var a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx,
        a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty,
        id = 1 / (a00 * a11 + a01 * -a10);
    // set the mouse coords...
    return new PIXI.Point(a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,
                               a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id);
};

// constructor
PIXI.InteractionData.prototype.constructor = PIXI.InteractionData;
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

 /**
 * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * @class InteractionManager
 * @constructor
 * @param stage {Stage} The stage to handle interactions
 */
PIXI.InteractionManager = function(stage)
{
    /**
     * a reference to the stage
     *
     * @property stage
     * @type Stage
     */
    this.stage = stage;

    /**
     * the mouse data
     *
     * @property mouse
     * @type InteractionData
     */
    this.mouse = new PIXI.InteractionData();

    /**
     * an object that stores current touches (InteractionData) by id reference
     *
     * @property touchs
     * @type Object
     */
    this.touchs = {};

    // helpers
    this.tempPoint = new PIXI.Point();

    /**
     * 
     * @property mouseoverEnabled
     * @type Boolean
     * @default
     */
    this.mouseoverEnabled = true;

    /**
     * tiny little interactiveData pool !
     * 
     * @property pool
     * @type Array
     */
    this.pool = [];

    /**
     * An array containing all the iterative items from the our interactive tree
     * @property interactiveItems
     * @type Array
     * @private
     *
     */
    this.interactiveItems = [];

    /**
     * Our canvas
     * @property interactionDOMElement
     * @type HTMLCanvasElement
     * @private
     */
    this.interactionDOMElement = null;

    //this will make it so that you dont have to call bind all the time
    this.onMouseMove = this.onMouseMove.bind( this );
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseOut = this.onMouseOut.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);

    this.onTouchStart = this.onTouchStart.bind(this);
    this.onTouchEnd = this.onTouchEnd.bind(this);
    this.onTouchMove = this.onTouchMove.bind(this);

    this.last = 0;

    /**
     * The css style of the cursor that is being used
     * @property currentCursorStyle
     * @type String
     *
     */
    this.currentCursorStyle = 'inherit';

    /**
     * Is set to true when the mouse is moved out of the canvas
     * @property mouseOut
     * @type Boolean
     *
     */
    this.mouseOut = false;
};

// constructor
PIXI.InteractionManager.prototype.constructor = PIXI.InteractionManager;

/**
 * Collects an interactive sprite recursively to have their interactions managed
 *
 * @method collectInteractiveSprite
 * @param displayObject {DisplayObject} the displayObject to collect
 * @param iParent {DisplayObject} the display object's parent
 * @private
 */
PIXI.InteractionManager.prototype.collectInteractiveSprite = function(displayObject, iParent)
{
    var children = displayObject.children;
    var length = children.length;

    // make an interaction tree... {item.__interactiveParent}
    for (var i = length-1; i >= 0; i--)
    {
        var child = children[i];

        // push all interactive bits
        if(child._interactive)
        {
            iParent.interactiveChildren = true;
            //child.__iParent = iParent;
            this.interactiveItems.push(child);

            if(child.children.length > 0)
            {
                this.collectInteractiveSprite(child, child);
            }
        }
        else
        {
            child.__iParent = null;

            if(child.children.length > 0)
            {
                this.collectInteractiveSprite(child, iParent);
            }
        }

    }
};

/**
 * Sets the target for event delegation
 *
 * @method setTarget
 * @param target {WebGLRenderer|CanvasRenderer} the renderer to bind events to
 * @private
 */
PIXI.InteractionManager.prototype.setTarget = function(target)
{
    this.target = target;

    //check if the dom element has been set. If it has don't do anything
    if( this.interactionDOMElement === null ) {

        this.setTargetDomElement( target.view );
    }

    
};


/**
 * Sets the DOM element which will receive mouse/touch events. This is useful for when you have other DOM
 * elements on top of the renderers Canvas element. With this you'll be able to delegate another DOM element
 * to receive those events
 *
 * @method setTargetDomElement
 * @param domElement {DOMElement} the DOM element which will receive mouse and touch events
 * @private
 */
PIXI.InteractionManager.prototype.setTargetDomElement = function(domElement)
{

    this.removeEvents();


    if (window.navigator.msPointerEnabled)
    {
        // time to remove some of that zoom in ja..
        domElement.style['-ms-content-zooming'] = 'none';
        domElement.style['-ms-touch-action'] = 'none';

        // DO some window specific touch!
    }

    this.interactionDOMElement = domElement;

    domElement.addEventListener('mousemove',  this.onMouseMove, true);
    domElement.addEventListener('mousedown',  this.onMouseDown, true);
    domElement.addEventListener('mouseout',   this.onMouseOut, true);

    // aint no multi touch just yet!
    domElement.addEventListener('touchstart', this.onTouchStart, true);
    domElement.addEventListener('touchend', this.onTouchEnd, true);
    domElement.addEventListener('touchmove', this.onTouchMove, true);

    window.addEventListener('mouseup',  this.onMouseUp, true);
};


PIXI.InteractionManager.prototype.removeEvents = function()
{
    if(!this.interactionDOMElement)return;

    this.interactionDOMElement.style['-ms-content-zooming'] = '';
    this.interactionDOMElement.style['-ms-touch-action'] = '';

    this.interactionDOMElement.removeEventListener('mousemove',  this.onMouseMove, true);
    this.interactionDOMElement.removeEventListener('mousedown',  this.onMouseDown, true);
    this.interactionDOMElement.removeEventListener('mouseout',   this.onMouseOut, true);

    // aint no multi touch just yet!
    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
    this.interactionDOMElement.removeEventListener('touchend', this.onTouchEnd, true);
    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);

    this.interactionDOMElement = null;

    window.removeEventListener('mouseup',  this.onMouseUp, true);
};

/**
 * updates the state of interactive objects
 *
 * @method update
 * @private
 */
PIXI.InteractionManager.prototype.update = function()
{
    if(!this.target)return;

    // frequency of 30fps??
    var now = Date.now();
    var diff = now - this.last;
    diff = (diff * PIXI.INTERACTION_FREQUENCY ) / 1000;
    if(diff < 1)return;
    this.last = now;

    var i = 0;

    // ok.. so mouse events??
    // yes for now :)
    // OPTIMISE - how often to check??
    if(this.dirty)
    {
        this.dirty = false;

        var len = this.interactiveItems.length;

        for (i = 0; i < len; i++) {
            this.interactiveItems[i].interactiveChildren = false;
        }

        this.interactiveItems = [];

        if(this.stage.interactive)this.interactiveItems.push(this.stage);
        // go through and collect all the objects that are interactive..
        this.collectInteractiveSprite(this.stage, this.stage);
    }

    // loop through interactive objects!
    var length = this.interactiveItems.length;
    var cursor = 'inherit';
    var over = false;

    for (i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        // OPTIMISATION - only calculate every time if the mousemove function exists..
        // OK so.. does the object have any other interactive functions?
        // hit-test the clip!
       // if(item.mouseover || item.mouseout || item.buttonMode)
       // {
        // ok so there are some functions so lets hit test it..
        item.__hit = this.hitTest(item, this.mouse);
        this.mouse.target = item;
        // ok so deal with interactions..
        // looks like there was a hit!
        if(item.__hit && !over)
        {
            if(item.buttonMode) cursor = item.defaultCursor;

            if(!item.interactiveChildren)over = true;

            if(!item.__isOver)
            {
                if(item.mouseover)item.mouseover(this.mouse);
                item.__isOver = true;
            }
        }
        else
        {
            if(item.__isOver)
            {
                // roll out!
                if(item.mouseout)item.mouseout(this.mouse);
                item.__isOver = false;
            }
        }
    }

    if( this.currentCursorStyle !== cursor )
    {
        this.currentCursorStyle = cursor;
        this.interactionDOMElement.style.cursor = cursor;
    }
};

/**
 * Is called when the mouse moves across the renderer element
 *
 * @method onMouseMove
 * @param event {Event} The DOM event of the mouse moving
 * @private
 */
PIXI.InteractionManager.prototype.onMouseMove = function(event)
{
    this.mouse.originalEvent = event || window.event; //IE uses window.event
    // TODO optimize by not check EVERY TIME! maybe half as often? //
    var rect = this.interactionDOMElement.getBoundingClientRect();

    this.mouse.global.x = (event.clientX - rect.left) * (this.target.width / rect.width);
    this.mouse.global.y = (event.clientY - rect.top) * ( this.target.height / rect.height);

    var length = this.interactiveItems.length;

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        if(item.mousemove)
        {
            //call the function!
            item.mousemove(this.mouse);
        }
    }
};

/**
 * Is called when the mouse button is pressed down on the renderer element
 *
 * @method onMouseDown
 * @param event {Event} The DOM event of a mouse button being pressed down
 * @private
 */
PIXI.InteractionManager.prototype.onMouseDown = function(event)
{
    this.mouse.originalEvent = event || window.event; //IE uses window.event

    if(PIXI.AUTO_PREVENT_DEFAULT)this.mouse.originalEvent.preventDefault();

    // loop through interaction tree...
    // hit test each item! ->
    // get interactive items under point??
    //stage.__i
    var length = this.interactiveItems.length;

    // while
    // hit test
    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        if(item.mousedown || item.click)
        {
            item.__mouseIsDown = true;
            item.__hit = this.hitTest(item, this.mouse);

            if(item.__hit)
            {
                //call the function!
                if(item.mousedown)item.mousedown(this.mouse);
                item.__isDown = true;

                // just the one!
                if(!item.interactiveChildren)break;
            }
        }
    }
};

/**
 * Is called when the mouse button is moved out of the renderer element
 *
 * @method onMouseOut
 * @param event {Event} The DOM event of a mouse button being moved out
 * @private 
 */
PIXI.InteractionManager.prototype.onMouseOut = function()
{
    var length = this.interactiveItems.length;

    this.interactionDOMElement.style.cursor = 'inherit';

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];
        if(item.__isOver)
        {
            this.mouse.target = item;
            if(item.mouseout)item.mouseout(this.mouse);
            item.__isOver = false;
        }
    }

    this.mouseOut = true;

    // move the mouse to an impossible position
    this.mouse.global.x = -10000;
    this.mouse.global.y = -10000;
};

/**
 * Is called when the mouse button is released on the renderer element
 *
 * @method onMouseUp
 * @param event {Event} The DOM event of a mouse button being released
 * @private
 */
PIXI.InteractionManager.prototype.onMouseUp = function(event)
{

    this.mouse.originalEvent = event || window.event; //IE uses window.event

    var length = this.interactiveItems.length;
    var up = false;

    for (var i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];

        item.__hit = this.hitTest(item, this.mouse);

        if(item.__hit && !up)
        {
            //call the function!
            if(item.mouseup)
            {
                item.mouseup(this.mouse);
            }
            if(item.__isDown)
            {
                if(item.click)item.click(this.mouse);
            }

            if(!item.interactiveChildren)up = true;
        }
        else
        {
            if(item.__isDown)
            {
                if(item.mouseupoutside)item.mouseupoutside(this.mouse);
            }
        }

        item.__isDown = false;
        //}
    }
};

/**
 * Tests if the current mouse coordinates hit a sprite
 *
 * @method hitTest
 * @param item {DisplayObject} The displayObject to test for a hit
 * @param interactionData {InteractionData} The interactionData object to update in the case there is a hit
 * @private
 */
PIXI.InteractionManager.prototype.hitTest = function(item, interactionData)
{
    var global = interactionData.global;

    if( !item.worldVisible )return false;

    // temp fix for if the element is in a non visible
   
    var isSprite = (item instanceof PIXI.Sprite),
        worldTransform = item.worldTransform,
        a00 = worldTransform.a, a01 = worldTransform.b, a02 = worldTransform.tx,
        a10 = worldTransform.c, a11 = worldTransform.d, a12 = worldTransform.ty,
        id = 1 / (a00 * a11 + a01 * -a10),
        x = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id,
        y = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id;

    interactionData.target = item;

    //a sprite or display object with a hit area defined
    if(item.hitArea && item.hitArea.contains) {
        if(item.hitArea.contains(x, y)) {
            //if(isSprite)
            interactionData.target = item;

            return true;
        }

        return false;
    }
    // a sprite with no hitarea defined
    else if(isSprite)
    {
        var width = item.texture.frame.width,
            height = item.texture.frame.height,
            x1 = -width * item.anchor.x,
            y1;

        if(x > x1 && x < x1 + width)
        {
            y1 = -height * item.anchor.y;

            if(y > y1 && y < y1 + height)
            {
                // set the target property if a hit is true!
                interactionData.target = item;
                return true;
            }
        }
    }

    var length = item.children.length;

    for (var i = 0; i < length; i++)
    {
        var tempItem = item.children[i];
        var hit = this.hitTest(tempItem, interactionData);
        if(hit)
        {
            // hmm.. TODO SET CORRECT TARGET?
            interactionData.target = item;
            return true;
        }
    }

    return false;
};

/**
 * Is called when a touch is moved across the renderer element
 *
 * @method onTouchMove
 * @param event {Event} The DOM event of a touch moving across the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchMove = function(event)
{
    var rect = this.interactionDOMElement.getBoundingClientRect();
    var changedTouches = event.changedTouches;
    var touchData;
    var i = 0;

    for (i = 0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];
        touchData = this.touchs[touchEvent.identifier];
        touchData.originalEvent =  event || window.event;

        // update the touch position
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }
    }

    var length = this.interactiveItems.length;
    for (i = 0; i < length; i++)
    {
        var item = this.interactiveItems[i];
        if(item.touchmove)
            item.touchmove(touchData);
    }
};

/**
 * Is called when a touch is started on the renderer element
 *
 * @method onTouchStart
 * @param event {Event} The DOM event of a touch starting on the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchStart = function(event)
{
    var rect = this.interactionDOMElement.getBoundingClientRect();

    if(PIXI.AUTO_PREVENT_DEFAULT)event.preventDefault();
    
    var changedTouches = event.changedTouches;
    for (var i=0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.pool.pop();
        if(!touchData)touchData = new PIXI.InteractionData();

        touchData.originalEvent =  event || window.event;

        this.touchs[touchEvent.identifier] = touchData;
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }

        var length = this.interactiveItems.length;

        for (var j = 0; j < length; j++)
        {
            var item = this.interactiveItems[j];

            if(item.touchstart || item.tap)
            {
                item.__hit = this.hitTest(item, touchData);

                if(item.__hit)
                {
                    //call the function!
                    if(item.touchstart)item.touchstart(touchData);
                    item.__isDown = true;
                    item.__touchData = touchData;

                    if(!item.interactiveChildren)break;
                }
            }
        }
    }
};

/**
 * Is called when a touch is ended on the renderer element
 *
 * @method onTouchEnd
 * @param event {Event} The DOM event of a touch ending on the renderer view
 * @private
 */
PIXI.InteractionManager.prototype.onTouchEnd = function(event)
{
    //this.mouse.originalEvent = event || window.event; //IE uses window.event
    var rect = this.interactionDOMElement.getBoundingClientRect();
    var changedTouches = event.changedTouches;

    for (var i=0; i < changedTouches.length; i++)
    {
        var touchEvent = changedTouches[i];
        var touchData = this.touchs[touchEvent.identifier];
        var up = false;
        touchData.global.x = (touchEvent.clientX - rect.left) * (this.target.width / rect.width);
        touchData.global.y = (touchEvent.clientY - rect.top)  * (this.target.height / rect.height);
        if(navigator.isCocoonJS) {
            touchData.global.x = touchEvent.clientX;
            touchData.global.y = touchEvent.clientY;
        }

        var length = this.interactiveItems.length;
        for (var j = 0; j < length; j++)
        {
            var item = this.interactiveItems[j];
            var itemTouchData = item.__touchData; // <-- Here!
            item.__hit = this.hitTest(item, touchData);

            if(itemTouchData === touchData)
            {
                // so this one WAS down...
                touchData.originalEvent = event || window.event;
                // hitTest??

                if(item.touchend || item.tap)
                {
                    if(item.__hit && !up)
                    {
                        if(item.touchend)item.touchend(touchData);
                        if(item.__isDown)
                        {
                            if(item.tap)item.tap(touchData);
                        }

                        if(!item.interactiveChildren)up = true;
                    }
                    else
                    {
                        if(item.__isDown)
                        {
                            if(item.touchendoutside)item.touchendoutside(touchData);
                        }
                    }

                    item.__isDown = false;
                }

                item.__touchData = null;

            }
            /*
            else
            {

            }
            */
        }
        // remove the touch..
        this.pool.push(touchData);
        this.touchs[touchEvent.identifier] = null;
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Stage represents the root of the display tree. Everything connected to the stage is rendered
 *
 * @class Stage
 * @extends DisplayObjectContainer
 * @constructor
 * @param backgroundColor {Number} the background color of the stage, you have to pass this in is in hex format
 *      like: 0xFFFFFF for white
 * 
 * Creating a stage is a mandatory process when you use Pixi, which is as simple as this : 
 * var stage = new PIXI.Stage(0xFFFFFF);
 * where the parameter given is the background colour of the stage, in hex
 * you will use this stage instance to add your sprites to it and therefore to the renderer
 * Here is how to add a sprite to the stage : 
 * stage.addChild(sprite);
 */
PIXI.Stage = function(backgroundColor)
{
    PIXI.DisplayObjectContainer.call( this );

    /**
     * [read-only] Current transform of the object based on world (parent) factors
     *
     * @property worldTransform
     * @type Mat3
     * @readOnly
     * @private
     */
    this.worldTransform = new PIXI.Matrix();

    /**
     * Whether or not the stage is interactive
     *
     * @property interactive
     * @type Boolean
     */
    this.interactive = true;

    /**
     * The interaction manage for this stage, manages all interactive activity on the stage
     *
     * @property interactive
     * @type InteractionManager
     */
    this.interactionManager = new PIXI.InteractionManager(this);

    /**
     * Whether the stage is dirty and needs to have interactions updated
     *
     * @property dirty
     * @type Boolean
     * @private
     */
    this.dirty = true;

    //the stage is its own stage
    this.stage = this;

    //optimize hit detection a bit
    this.stage.hitArea = new PIXI.Rectangle(0,0,100000, 100000);

    this.setBackgroundColor(backgroundColor);
};

// constructor
PIXI.Stage.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Stage.prototype.constructor = PIXI.Stage;

/**
 * Sets another DOM element which can receive mouse/touch interactions instead of the default Canvas element.
 * This is useful for when you have other DOM elements on top of the Canvas element.
 *
 * @method setInteractionDelegate
 * @param domElement {DOMElement} This new domElement which will receive mouse/touch events
 */
PIXI.Stage.prototype.setInteractionDelegate = function(domElement)
{
    this.interactionManager.setTargetDomElement( domElement );
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Stage.prototype.updateTransform = function()
{
    this.worldAlpha = 1;

    for(var i=0,j=this.children.length; i<j; i++)
    {
        this.children[i].updateTransform();
    }

    if(this.dirty)
    {
        this.dirty = false;
        // update interactive!
        this.interactionManager.dirty = true;
    }

    if(this.interactive)this.interactionManager.update();
};

/**
 * Sets the background color for the stage
 *
 * @method setBackgroundColor
 * @param backgroundColor {Number} the color of the background, easiest way to pass this in is in hex format
 *      like: 0xFFFFFF for white
 */
PIXI.Stage.prototype.setBackgroundColor = function(backgroundColor)
{
    this.backgroundColor = backgroundColor || 0x000000;
    this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);
    var hex = this.backgroundColor.toString(16);
    hex = '000000'.substr(0, 6 - hex.length) + hex;
    this.backgroundColorString = '#' + hex;
};

/**
 * This will return the point containing global coords of the mouse.
 *
 * @method getMousePosition
 * @return {Point} The point containing the coords of the global InteractionData position.
 */
PIXI.Stage.prototype.getMousePosition = function()
{
    return this.interactionManager.mouse.global;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel

// MIT license

/**
 * A polyfill for requestAnimationFrame
 * You can actually use both requestAnimationFrame and requestAnimFrame, 
 * you will still benefit from the polyfill
 *
 * @method requestAnimationFrame
 */
/**
 * A polyfill for cancelAnimationFrame
 *
 * @method cancelAnimationFrame
 */
var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
        window[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() { callback(currTime + timeToCall); },
          timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}

if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

window.requestAnimFrame = window.requestAnimationFrame;

/**
 * Converts a hex color number to an [R, G, B] array
 *
 * @method hex2rgb
 * @param hex {Number}
 */
PIXI.hex2rgb = function(hex) {
    return [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];
};

/**
 * Converts a color as an [R, G, B] array to a hex number
 *
 * @method rgb2hex
 * @param rgb {Array}
 */
PIXI.rgb2hex = function(rgb) {
    return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);
};

/**
 * A polyfill for Function.prototype.bind
 *
 * @method bind
 */
if (typeof Function.prototype.bind !== 'function') {
    Function.prototype.bind = (function () {
        var slice = Array.prototype.slice;
        return function (thisArg) {
            var target = this, boundArgs = slice.call(arguments, 1);

            if (typeof target !== 'function') throw new TypeError();

            function bound() {
                var args = boundArgs.concat(slice.call(arguments));
                target.apply(this instanceof bound ? this : thisArg, args);
            }

            bound.prototype = (function F(proto) {
                if (proto) F.prototype = proto;
                if (!(this instanceof F)) return new F();
            })(target.prototype);

            return bound;
        };
    })();
}

/**
 * A wrapper for ajax requests to be handled cross browser
 *
 * @class AjaxRequest
 * @constructor
 */
PIXI.AjaxRequest = function()
{
    var activexmodes = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP']; //activeX versions to check for in IE

    if (window.ActiveXObject)
    { //Test for support for ActiveXObject in IE first (as XMLHttpRequest in IE7 is broken)
        for (var i=0; i<activexmodes.length; i++)
        {
            try{
                return new window.ActiveXObject(activexmodes[i]);
            }
            catch(e) {
                //suppress error
            }
        }
    }
    else if (window.XMLHttpRequest) // if Mozilla, Safari etc
    {
        return new window.XMLHttpRequest();
    }
    else
    {
        return false;
    }
};
/*
PIXI.packColorRGBA = function(r, g, b, a)//r, g, b, a)
{
  //  console.log(r, b, c, d)
  return (Math.floor((r)*63) << 18) | (Math.floor((g)*63) << 12) | (Math.floor((b)*63) << 6);// | (Math.floor((a)*63))
  //  i = i | (Math.floor((a)*63));
   // return i;
   // var r = (i / 262144.0 ) / 64;
   // var g = (i / 4096.0)%64 / 64;
  //  var b = (i / 64.0)%64 / 64;
  //  var a = (i)%64 / 64;
     
  //  console.log(r, g, b, a);
  //  return i;

};
*/
/*
PIXI.packColorRGB = function(r, g, b)//r, g, b, a)
{
    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));
};

PIXI.unpackColorRGB = function(r, g, b)//r, g, b, a)
{
    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));
};
*/

/**
 * Checks whether the Canvas BlendModes are supported by the current browser
 *
 * @method canUseNewCanvasBlendModes
 * @return {Boolean} whether they are supported
 */
PIXI.canUseNewCanvasBlendModes = function()
{
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    var context = canvas.getContext('2d');
    context.fillStyle = '#000';
    context.fillRect(0,0,1,1);
    context.globalCompositeOperation = 'multiply';
    context.fillStyle = '#fff';
    context.fillRect(0,0,1,1);
    return context.getImageData(0,0,1,1).data[0] === 0;
};

/**
 * Given a number, this function returns the closest number that is a power of two
 * this function is taken from Starling Framework as its pretty neat ;)
 *
 * @method getNextPowerOfTwo
 * @param number {Number}
 * @return {Number} the closest number that is a power of two
 */
PIXI.getNextPowerOfTwo = function(number)
{
    if (number > 0 && (number & (number - 1)) === 0) // see: http://goo.gl/D9kPj
        return number;
    else
    {
        var result = 1;
        while (result < number) result <<= 1;
        return result;
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 
/**
 * https://github.com/mrdoob/eventtarget.js/
 * THankS mr DOob!
 */

/**
 * Adds event emitter functionality to a class
 *
 * @class EventTarget
 * @example
 *      function MyEmitter() {
 *          PIXI.EventTarget.call(this); //mixes in event target stuff
 *      }
 *
 *      var em = new MyEmitter();
 *      em.emit({ type: 'eventName', data: 'some data' });
 */
PIXI.EventTarget = function () {

    /**
     * Holds all the listeners
     *
     * @property listeners
     * @type Object
     */
    var listeners = {};

    /**
     * Adds a listener for a specific event
     *
     * @method addEventListener
     * @param type {string} A string representing the event type to listen for.
     * @param listener {function} The callback function that will be fired when the event occurs
     */
    this.addEventListener = this.on = function ( type, listener ) {


        if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

        }

        if ( listeners[ type ].indexOf( listener ) === - 1 ) {

            listeners[ type ].push( listener );
        }

    };

    /**
     * Fires the event, ie pretends that the event has happened
     *
     * @method dispatchEvent
     * @param event {Event} the event object
     */
    this.dispatchEvent = this.emit = function ( event ) {

        if ( !listeners[ event.type ] || !listeners[ event.type ].length ) {

            return;

        }

        for(var i = 0, l = listeners[ event.type ].length; i < l; i++) {

            listeners[ event.type ][ i ]( event );

        }

    };

    /**
     * Removes the specified listener that was assigned to the specified event type
     *
     * @method removeEventListener
     * @param type {string} A string representing the event type which will have its listener removed
     * @param listener {function} The callback function that was be fired when the event occured
     */
    this.removeEventListener = this.off = function ( type, listener ) {

        var index = listeners[ type ].indexOf( listener );

        if ( index !== - 1 ) {

            listeners[ type ].splice( index, 1 );

        }

    };

    /**
     * Removes all the listeners that were active for the specified event type
     *
     * @method removeAllEventListeners
     * @param type {string} A string representing the event type which will have all its listeners removed
     */
	this.removeAllEventListeners = function( type ) {
		var a = listeners[type];
		if (a)
			a.length = 0;
	};
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * This helper function will automatically detect which renderer you should be using.
 * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
 * the browser then this function will return a canvas renderer
 * @class autoDetectRenderer
 * @static
 * @param width=800 {Number} the width of the renderers view
 * @param height=600 {Number} the height of the renderers view
 * @param [view] {Canvas} the canvas to use as a view, optional 
 * @param [transparent=false] {Boolean} the transparency of the render view, default false
 * @param [antialias=false] {Boolean} sets antialias (only applicable in webGL chrome at the moment)
 *
 */
PIXI.autoDetectRenderer = function(width, height, view, transparent, antialias)
{
    if(!width)width = 800;
    if(!height)height = 600;

    // BORROWED from Mr Doob (mrdoob.com)
    var webgl = ( function () { try {
                                    var canvas = document.createElement( 'canvas' );
                                    return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );
                                } catch( e ) {
                                    return false;
                                }
                            } )();


    if( webgl )
    {
        return new PIXI.WebGLRenderer(width, height, view, transparent, antialias);
    }

    return  new PIXI.CanvasRenderer(width, height, view, transparent);
};

/*
    PolyK library
    url: http://polyk.ivank.net
    Released under MIT licence.

    Copyright (c) 2012 Ivan Kuckir

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    This is an amazing lib!

    slightly modified by Mat Groves (matgroves.com);
*/

/**
 * Based on the Polyk library http://polyk.ivank.net released under MIT licence.
 * This is an amazing lib!
 * slightly modified by Mat Groves (matgroves.com);
 * @class PolyK
 *
 */
PIXI.PolyK = {};

/**
 * Triangulates shapes for webGL graphic fills
 *
 * @method Triangulate
 * 
 */
PIXI.PolyK.Triangulate = function(p)
{
    var sign = true;

    var n = p.length >> 1;
    if(n < 3) return [];

    var tgs = [];
    var avl = [];
    for(var i = 0; i < n; i++) avl.push(i);

    i = 0;
    var al = n;
    while(al > 3)
    {
        var i0 = avl[(i+0)%al];
        var i1 = avl[(i+1)%al];
        var i2 = avl[(i+2)%al];

        var ax = p[2*i0],  ay = p[2*i0+1];
        var bx = p[2*i1],  by = p[2*i1+1];
        var cx = p[2*i2],  cy = p[2*i2+1];

        var earFound = false;
        if(PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign))
        {
            earFound = true;
            for(var j = 0; j < al; j++)
            {
                var vi = avl[j];
                if(vi === i0 || vi === i1 || vi === i2) continue;

                if(PIXI.PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {
                    earFound = false;
                    break;
                }
            }
        }

        if(earFound)
        {
            tgs.push(i0, i1, i2);
            avl.splice((i+1)%al, 1);
            al--;
            i = 0;
        }
        else if(i++ > 3*al)
        {
            // need to flip flip reverse it!
            // reset!
            if(sign)
            {
                tgs = [];
                avl = [];
                for(i = 0; i < n; i++) avl.push(i);

                i = 0;
                al = n;

                sign = false;
            }
            else
            {
                window.console.log("PIXI Warning: shape too complex to fill");
                return [];
            }
        }
    }

    tgs.push(avl[0], avl[1], avl[2]);
    return tgs;
};

/**
 * Checks whether a point is within a triangle
 *
 * @method _PointInTriangle
 * @param px {Number} x coordinate of the point to test
 * @param py {Number} y coordinate of the point to test
 * @param ax {Number} x coordinate of the a point of the triangle
 * @param ay {Number} y coordinate of the a point of the triangle
 * @param bx {Number} x coordinate of the b point of the triangle
 * @param by {Number} y coordinate of the b point of the triangle
 * @param cx {Number} x coordinate of the c point of the triangle
 * @param cy {Number} y coordinate of the c point of the triangle
 * @private
 */
PIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
{
    var v0x = cx-ax;
    var v0y = cy-ay;
    var v1x = bx-ax;
    var v1y = by-ay;
    var v2x = px-ax;
    var v2y = py-ay;

    var dot00 = v0x*v0x+v0y*v0y;
    var dot01 = v0x*v1x+v0y*v1y;
    var dot02 = v0x*v2x+v0y*v2y;
    var dot11 = v1x*v1x+v1y*v1y;
    var dot12 = v1x*v2x+v1y*v2y;

    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is in triangle
    return (u >= 0) && (v >= 0) && (u + v < 1);
};

/**
 * Checks whether a shape is convex
 *
 * @method _convex
 * 
 * @private
 */
PIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign)
{
    return ((ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0) === sign;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

// TODO Alvin and Mat
// Should we eventually create a Utils class ? 
// Or just move this file to the pixi.js file ?
PIXI.initDefaultShaders = function()
{
   
  //  PIXI.stripShader = new PIXI.StripShader();
//    PIXI.stripShader.init();

};

PIXI.CompileVertexShader = function(gl, shaderSrc)
{
    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
};

PIXI.CompileFragmentShader = function(gl, shaderSrc)
{
    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
};

PIXI._CompileShader = function(gl, shaderSrc, shaderType)
{
    var src = shaderSrc.join("\n");
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        window.console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc)
{
    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);
    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);

    var shaderProgram = gl.createProgram();

    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        window.console.log("Could not initialise shaders");
    }

    return shaderProgram;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * @author Richard Davey http://www.photonstorm.com @photonstorm
 */

/**
* @class PixiShader
* @constructor
*/
PIXI.PixiShader = function(gl)
{
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
    * @property {array} fragmentSrc - The fragment shader.
    */
    this.fragmentSrc = [
        'precision lowp float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
        '}'
    ];

    /**
    * @property {number} textureCount - A local texture counter for multi-texture shaders.
    */
    this.textureCount = 0;

    this.attributes = [];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PixiShader.prototype.init = function()
{
    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);
    
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');


    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its something to do with the current state of the gl context.
    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if(this.colorAttribute === -1)
    {
        this.colorAttribute = 2;
    }

    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];

    // End worst hack eva //

    // add those custom shaders!
    for (var key in this.uniforms)
    {
        // get the uniform locations..
        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
    }

    this.initUniforms();

    this.program = program;
};

/**
* Initialises the shader uniform values.
* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/
* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf
*
* @method initUniforms
*/
PIXI.PixiShader.prototype.initUniforms = function()
{
    this.textureCount = 1;
    var gl = this.gl;
    var uniform;

    for (var key in this.uniforms)
    {
        uniform = this.uniforms[key];

        var type = uniform.type;

        if (type === 'sampler2D')
        {
            uniform._init = false;

            if (uniform.value !== null)
            {
                this.initSampler2D(uniform);
            }
        }
        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')
        {
            //  These require special handling
            uniform.glMatrix = true;
            uniform.glValueLength = 1;

            if (type === 'mat2')
            {
                uniform.glFunc = gl.uniformMatrix2fv;
            }
            else if (type === 'mat3')
            {
                uniform.glFunc = gl.uniformMatrix3fv;
            }
            else if (type === 'mat4')
            {
                uniform.glFunc = gl.uniformMatrix4fv;
            }
        }
        else
        {
            //  GL function reference
            uniform.glFunc = gl['uniform' + type];

            if (type === '2f' || type === '2i')
            {
                uniform.glValueLength = 2;
            }
            else if (type === '3f' || type === '3i')
            {
                uniform.glValueLength = 3;
            }
            else if (type === '4f' || type === '4i')
            {
                uniform.glValueLength = 4;
            }
            else
            {
                uniform.glValueLength = 1;
            }
        }
    }

};

/**
* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)
*
* @method initSampler2D
*/
PIXI.PixiShader.prototype.initSampler2D = function(uniform)
{
    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)
    {
        return;
    }

    var gl = this.gl;

    gl.activeTexture(gl['TEXTURE' + this.textureCount]);
    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);

    //  Extended texture data
    if (uniform.textureData)
    {
        var data = uniform.textureData;

        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);
        // GLTextureLinear = mag/min linear, wrap clamp
        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat
        // GLTextureNearest = mag/min nearest, wrap clamp
        // AudioTexture = whatever + luminance + width 512, height 2, border 0
        // KeyTexture = whatever + luminance + width 256, height 2, border 0

        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT

        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;
        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;
        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;
        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;
        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;

        if (data.repeat)
        {
            wrapS = gl.REPEAT;
            wrapT = gl.REPEAT;
        }

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);

        if (data.width)
        {
            var width = (data.width) ? data.width : 512;
            var height = (data.height) ? data.height : 2;
            var border = (data.border) ? data.border : 0;

            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
        }
        else
        {
            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);
            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);
        }

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
    }

    gl.uniform1i(uniform.uniformLocation, this.textureCount);

    uniform._init = true;

    this.textureCount++;

};

/**
* Updates the shader uniform values.
*
* @method syncUniforms
*/
PIXI.PixiShader.prototype.syncUniforms = function()
{
    this.textureCount = 1;
    var uniform;
    var gl = this.gl;

    //  This would probably be faster in an array and it would guarantee key order
    for (var key in this.uniforms)
    {
        uniform = this.uniforms[key];

        if (uniform.glValueLength === 1)
        {
            if (uniform.glMatrix === true)
            {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);
            }
            else
            {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);
            }
        }
        else if (uniform.glValueLength === 2)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);
        }
        else if (uniform.glValueLength === 3)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);
        }
        else if (uniform.glValueLength === 4)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);
        }
        else if (uniform.type === 'sampler2D')
        {
            if (uniform._init)
            {
                gl.activeTexture(gl['TEXTURE' + this.textureCount]);
                gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));
                gl.uniform1i(uniform.uniformLocation, this.textureCount);
                this.textureCount++;
            }
            else
            {
                this.initSampler2D(uniform);
            }
        }
    }

};

/**
* Destroys the shader
* @method destroy
*/
PIXI.PixiShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};

/**
* The Default Vertex shader source
* @property defaultVertexSrc
* @type String
*/
PIXI.PixiShader.defaultVertexSrc = [
    'attribute vec2 aVertexPosition;',
    'attribute vec2 aTextureCoord;',
    'attribute vec2 aColor;',

    'uniform vec2 projectionVector;',
    'uniform vec2 offsetVector;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'const vec2 center = vec2(-1.0, 1.0);',

    'void main(void) {',
    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',
    '   vTextureCoord = aTextureCoord;',
    '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',
    '   vColor = vec4(color * aColor.x, aColor.x);',
    '}'
];

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * @author Richard Davey http://www.photonstorm.com @photonstorm
 */

/**
* @class PixiFastShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.PixiFastShader = function(gl)
{

    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
     * @property {any} program - The WebGL program.
     */
    this.program = null;

    /**
     * @property {array} fragmentSrc - The fragment shader.
     */
    this.fragmentSrc = [
        'precision lowp float;',
        'varying vec2 vTextureCoord;',
        'varying float vColor;',
        'uniform sampler2D uSampler;',
        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
        '}'
    ];

    /**
    * @property {array} vertexSrc - The vertex shader
    */
    this.vertexSrc = [
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aPositionCoord;',
        'attribute vec2 aScale;',
        'attribute float aRotation;',
        'attribute vec2 aTextureCoord;',
        'attribute float aColor;',

        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        'uniform mat3 uMatrix;',

        'varying vec2 vTextureCoord;',
        'varying float vColor;',

        'const vec2 center = vec2(-1.0, 1.0);',

        'void main(void) {',
        '   vec2 v;',
        '   vec2 sv = aVertexPosition * aScale;',
        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',
        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',
        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',
        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',
        '   vTextureCoord = aTextureCoord;',
      //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',
        '   vColor = aColor;',
        '}'
    ];


    /**
    * @property {number} textureCount - A local texture counter for multi-texture shaders.
    */
    this.textureCount = 0;

    
    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PixiFastShader.prototype.init = function()
{

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');

    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');
    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');

    this.aScale = gl.getAttribLocation(program, 'aScale');
    this.aRotation = gl.getAttribLocation(program, 'aRotation');

    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
   

   
    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its somthing to do with the current state of the gl context.
    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if(this.colorAttribute === -1)
    {
        this.colorAttribute = 2;
    }

    this.attributes = [this.aVertexPosition, this.aPositionCoord,  this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];
    
    // End worst hack eva //


    this.program = program;
};

/**
* Destroys the shader
* @method destroy
*
*/
PIXI.PixiFastShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


PIXI.StripShader = function()
{
    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
     * @property {array} fragmentSrc - The fragment shader.
     */
    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying float vColor;',
        'uniform float alpha;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));',
        '   gl_FragColor = gl_FragColor * alpha;',
        '}'
    ];

    /**
    * @property {array} fragmentSrc - The fragment shader.
    */
    this.vertexSrc = [
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aTextureCoord;',
        'attribute float aColor;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'varying vec2 vTextureCoord;',
        'uniform vec2 offsetVector;',
        'varying float vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vTextureCoord = aTextureCoord;',
        '   vColor = aColor;',
        '}'
    ];
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.StripShader.prototype.init = function()
{

    var gl = PIXI.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
    //this.dimensions = gl.getUniformLocation(this.program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class PrimitiveShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.PrimitiveShader = function(gl)
{
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
    * @property {any} program - The WebGL program.
    */
    this.program = null;

    /**
     * @property fragmentSrc
     * @type Array
     */
    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   gl_FragColor = vColor;',
        '}'
    ];

    /**
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        'attribute vec4 aColor;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        'uniform float alpha;',
        'uniform vec3 tint;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vColor = aColor * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

/**
* Initialises the shader
* @method init
*
*/
PIXI.PrimitiveShader.prototype.init = function()
{

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.tintColor = gl.getUniformLocation(program, 'tint');


    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');

    this.attributes = [this.aVertexPosition, this.colorAttribute];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
* Destroys the shader
* @method destroy
*
*/
PIXI.PrimitiveShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attribute = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A set of functions used by the webGL renderer to draw the primitive graphics data
 *
 * @class WebGLGraphics
 * @private
 * @static
 */
PIXI.WebGLGraphics = function()
{

};

/**
 * Renders the graphics object
 *
 * @static
 * @private
 * @method renderGraphics
 * @param graphics {Graphics}
 * @param renderSession {Object}
 */
PIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession)//projection, offset)
{
    var gl = renderSession.gl;
    var projection = renderSession.projection,
        offset = renderSession.offset,
        shader = renderSession.shaderManager.primitiveShader;

    if(!graphics._webGL[gl.id])graphics._webGL[gl.id] = {points:[], indices:[], lastIndex:0,
                                           buffer:gl.createBuffer(),
                                           indexBuffer:gl.createBuffer()};

    var webGL = graphics._webGL[gl.id];

    if(graphics.dirty)
    {
        graphics.dirty = false;

        if(graphics.clearDirty)
        {
            graphics.clearDirty = false;

            webGL.lastIndex = 0;
            webGL.points = [];
            webGL.indices = [];

        }

        PIXI.WebGLGraphics.updateGraphics(graphics, gl);
    }

    renderSession.shaderManager.activatePrimitiveShader();

    // This  could be speeded up for sure!

    // set the matrix transform
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

    gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
    gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

    gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));

    gl.uniform1f(shader.alpha, graphics.worldAlpha);
    gl.bindBuffer(gl.ARRAY_BUFFER, webGL.buffer);

    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
    gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);

    // set the index buffer!
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGL.indexBuffer);

    gl.drawElements(gl.TRIANGLE_STRIP,  webGL.indices.length, gl.UNSIGNED_SHORT, 0 );

    renderSession.shaderManager.deactivatePrimitiveShader();

    // return to default shader...
//  PIXI.activateShader(PIXI.defaultShader);
};

/**
 * Updates the graphics object
 *
 * @static
 * @private
 * @method updateGraphics
 * @param graphicsData {Graphics} The graphics object to update
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.WebGLGraphics.updateGraphics = function(graphics, gl)
{
    var webGL = graphics._webGL[gl.id];
    
    for (var i = webGL.lastIndex; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        if(data.type === PIXI.Graphics.POLY)
        {
            if(data.fill)
            {
                if(data.points.length>3)
                    PIXI.WebGLGraphics.buildPoly(data, webGL);
            }

            if(data.lineWidth > 0)
            {
                PIXI.WebGLGraphics.buildLine(data, webGL);
            }
        }
        else if(data.type === PIXI.Graphics.RECT)
        {
            PIXI.WebGLGraphics.buildRectangle(data, webGL);
        }
        else if(data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP)
        {
            PIXI.WebGLGraphics.buildCircle(data, webGL);
        }
    }

    webGL.lastIndex = graphics.graphicsData.length;

   

    webGL.glPoints = new Float32Array(webGL.points);

    gl.bindBuffer(gl.ARRAY_BUFFER, webGL.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, webGL.glPoints, gl.STATIC_DRAW);

    webGL.glIndicies = new Uint16Array(webGL.indices);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGL.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, webGL.glIndicies, gl.STATIC_DRAW);
};

/**
 * Builds a rectangle to draw
 *
 * @static
 * @private
 * @method buildRectangle
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData)
{
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.points;
    var x = rectData[0];
    var y = rectData[1];
    var width = rectData[2];
    var height = rectData[3];


    if(graphicsData.fill)
    {
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length/6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x , y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);
    }

    if(graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y,
                  x + width, y,
                  x + width, y + height,
                  x, y + height,
                  x, y];


        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a circle to draw
 *
 * @static
 * @private
 * @method buildCircle
 * @param graphicsData {Graphics} The graphics object to draw
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData)
{
    
    // need to convert points to a nice regular data
    var rectData = graphicsData.points;
    var x = rectData[0];
    var y = rectData[1];
    var width = rectData[2];
    var height = rectData[3];

    var totalSegs = 40;
    var seg = (Math.PI * 2) / totalSegs ;

    var i = 0;

    if(graphicsData.fill)
    {
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        indices.push(vecPos);

        for (i = 0; i < totalSegs + 1 ; i++)
        {
            verts.push(x,y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width,
                       y + Math.cos(seg * i) * height,
                       r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos-1);
    }

    if(graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (i = 0; i < totalSegs + 1; i++)
        {
            graphicsData.points.push(x + Math.sin(seg * i) * width,
                                     y + Math.cos(seg * i) * height);
        }

        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a line to draw
 *
 * @static
 * @private
 * @method buildLine
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData)
{
    // TODO OPTIMISE!
    var i = 0;

    var points = graphicsData.points;
    if(points.length === 0)return;

    // if the line width is an odd number add 0.5 to align to a whole pixel
    if(graphicsData.lineWidth%2)
    {
        for (i = 0; i < points.length; i++) {
            points[i] += 0.5;
        }
    }

    // get first and last point.. figure out the middle!
    var firstPoint = new PIXI.Point( points[0], points[1] );
    var lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );

    // if the first point is the last point - gonna have issues :)
    if(firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)
    {
        points.pop();
        points.pop();

        lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length/6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = PIXI.hex2rgb(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
    var a1, b1, c1, a2, b2, c2;
    var denom, pdist, dist;

    p1x = points[0];
    p1y = points[1];

    p2x = points[2];
    p2y = points[3];

    perpx = -(p1y - p2y);
    perpy =  p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx , p1y - perpy,
                r, g, b, alpha);

    verts.push(p1x + perpx , p1y + perpy,
                r, g, b, alpha);

    for (i = 1; i < length-1; i++)
    {
        p1x = points[(i-1)*2];
        p1y = points[(i-1)*2 + 1];

        p2x = points[(i)*2];
        p2y = points[(i)*2 + 1];

        p3x = points[(i+1)*2];
        p3y = points[(i+1)*2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx*perpx + perpy*perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        a1 = (-perpy + p1y) - (-perpy + p2y);
        b1 = (-perpx + p2x) - (-perpx + p1x);
        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        a2 = (-perp2y + p3y) - (-perp2y + p2y);
        b2 = (-perp2x + p2x) - (-perp2x + p3x);
        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        denom = a1*b2 - a2*b1;

        if(Math.abs(denom) < 0.1 )
        {

            denom+=10.1;
            verts.push(p2x - perpx , p2y - perpy,
                r, g, b, alpha);

            verts.push(p2x + perpx , p2y + perpy,
                r, g, b, alpha);

            continue;
        }

        px = (b1*c2 - b2*c1)/denom;
        py = (a2*c1 - a1*c2)/denom;


        pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);


        if(pdist > 140 * 140)
        {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y +perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        }
        else
        {

            verts.push(px , py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px-p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length-2)*2];
    p1y = points[(length-2)*2 + 1];

    p2x = points[(length-1)*2];
    p2y = points[(length-1)*2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx , p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx , p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (i = 0; i < indexCount; i++)
    {
        indices.push(indexStart++);
    }

    indices.push(indexStart-1);
};

/**
 * Builds a polygon to draw
 *
 * @static
 * @private
 * @method buildPoly
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {Object}
 */
PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData)
{
    var points = graphicsData.points;
    if(points.length < 6)return;

    // get first and last point.. figure out the middle!
    var verts = webGLData.points;
    var indices = webGLData.indices;

    var length = points.length / 2;

    // sort color
    var color = PIXI.hex2rgb(graphicsData.fillColor);
    var alpha = graphicsData.fillAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var triangles = PIXI.PolyK.Triangulate(points);

    var vertPos = verts.length / 6;

    var i = 0;

    for (i = 0; i < triangles.length; i+=3)
    {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i+1] + vertPos);
        indices.push(triangles[i+2] +vertPos);
        indices.push(triangles[i+2] + vertPos);
    }

    for (i = 0; i < length; i++)
    {
        verts.push(points[i * 2], points[i * 2 + 1],
                   r, g, b, alpha);
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.glContexts = []; // this is where we store the webGL contexts for easy access.

/**
 * the WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatch's.
 * So no need for Sprite Batch's or Sprite Cloud's
 * Dont forget to add the view to your DOM or you will not see anything :)
 *
 * @class WebGLRenderer
 * @constructor
 * @param width=0 {Number} the width of the canvas view
 * @param height=0 {Number} the height of the canvas view
 * @param view {HTMLCanvasElement} the canvas to use as a view, optional
 * @param transparent=false {Boolean} If the render view is transparent, default false
 * @param antialias=false {Boolean} sets antialias (only applicable in chrome at the moment)
 *
 */
PIXI.WebGLRenderer = function(width, height, view, transparent, antialias)
{
    if(!PIXI.defaultRenderer)PIXI.defaultRenderer = this;

    this.type = PIXI.WEBGL_RENDERER;

    // do a catch.. only 1 webGL renderer..
    /**
     * Whether the render view is transparent
     *
     * @property transparent
     * @type Boolean
     */
    this.transparent = !!transparent;

    /**
     * The width of the canvas view
     *
     * @property width
     * @type Number
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @property height
     * @type Number
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @property view
     * @type HTMLCanvasElement
     */
    this.view = view || document.createElement( 'canvas' );
    this.view.width = this.width;
    this.view.height = this.height;

    // deal with losing context..
    this.contextLost = this.handleContextLost.bind(this);
    this.contextRestoredLost = this.handleContextRestored.bind(this);
    
    this.view.addEventListener('webglcontextlost', this.contextLost, false);
    this.view.addEventListener('webglcontextrestored', this.contextRestoredLost, false);

    this.options = {
        alpha: this.transparent,
        antialias:!!antialias, // SPEED UP??
        premultipliedAlpha:!!transparent,
        stencil:true
    };

    //try 'experimental-webgl'
    try {
        this.gl = this.view.getContext('experimental-webgl',  this.options);
    } catch (e) {
        //try 'webgl'
        try {
            this.gl = this.view.getContext('webgl',  this.options);
        } catch (e2) {
            // fail, not able to get a context
            throw new Error(' This browser does not support webGL. Try using the canvas renderer' + this);
        }
    }

    var gl = this.gl;
    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId ++;

    PIXI.glContexts[this.glContextId] = gl;

    if(!PIXI.blendModesWebGL)
    {
        PIXI.blendModesWebGL = [];

        PIXI.blendModesWebGL[PIXI.blendModes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];
        PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
    }




    this.projection = new PIXI.Point();
    this.projection.x =  this.width/2;
    this.projection.y =  -this.height/2;

    this.offset = new PIXI.Point(0, 0);

    this.resize(this.width, this.height);
    this.contextLost = false;

    // time to create the render managers! each one focuses on managine a state in webGL
    this.shaderManager = new PIXI.WebGLShaderManager(gl);                   // deals with managing the shader programs and their attribs
    this.spriteBatch = new PIXI.WebGLSpriteBatch(gl);                       // manages the rendering of sprites
    this.maskManager = new PIXI.WebGLMaskManager(gl);                       // manages the masks using the stencil buffer
    this.filterManager = new PIXI.WebGLFilterManager(gl, this.transparent); // manages the filters

    this.renderSession = {};
    this.renderSession.gl = this.gl;
    this.renderSession.drawCount = 0;
    this.renderSession.shaderManager = this.shaderManager;
    this.renderSession.maskManager = this.maskManager;
    this.renderSession.filterManager = this.filterManager;
    this.renderSession.spriteBatch = this.spriteBatch;
    this.renderSession.renderer = this;

    gl.useProgram(this.shaderManager.defaultShader.program);

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.enable(gl.BLEND);
    gl.colorMask(true, true, true, this.transparent);
};

// constructor
PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;

/**
 * Renders the stage to its webGL view
 *
 * @method render
 * @param stage {Stage} the Stage element to be rendered
 */
PIXI.WebGLRenderer.prototype.render = function(stage)
{
    if(this.contextLost)return;


    // if rendering a new stage clear the batches..
    if(this.__stage !== stage)
    {
        if(stage.interactive)stage.interactionManager.removeEvents();

        // TODO make this work
        // dont think this is needed any more?
        this.__stage = stage;
    }

    // update any textures this includes uvs and uploading them to the gpu
    PIXI.WebGLRenderer.updateTextures();

    // update the scene graph
    stage.updateTransform();


    // interaction
    if(stage._interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }
    
    var gl = this.gl;

    // -- Does this need to be set every frame? -- //
    //gl.colorMask(true, true, true, this.transparent);
    gl.viewport(0, 0, this.width, this.height);

    // make sure we are bound to the main frame buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if(this.transparent)
    {
        gl.clearColor(0, 0, 0, 0);
    }
    else
    {
        gl.clearColor(stage.backgroundColorSplit[0],stage.backgroundColorSplit[1],stage.backgroundColorSplit[2], 1);
    }


    gl.clear(gl.COLOR_BUFFER_BIT);

    this.renderDisplayObject( stage, this.projection );

    // interaction
    if(stage.interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }
    else
    {
        if(stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = false;
            stage.interactionManager.setTarget(this);
        }
    }

    /*
    //can simulate context loss in Chrome like so:
     this.view.onmousedown = function(ev) {
     console.dir(this.gl.getSupportedExtensions());
        var ext = (
            gl.getExtension("WEBGL_scompressed_texture_s3tc")
       // gl.getExtension("WEBGL_compressed_texture_s3tc") ||
       // gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
       // gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")
     );
     console.dir(ext);
     var loseCtx = this.gl.getExtension("WEBGL_lose_context");
      console.log("killing context");
      loseCtx.loseContext();
     setTimeout(function() {
          console.log("restoring context...");
          loseCtx.restoreContext();
      }.bind(this), 1000);
     }.bind(this);
     */
};

/**
 * Renders a display Object
 *
 * @method renderDIsplayObject
 * @param displayObject {DisplayObject} The DisplayObject to render
 * @param projection {Point} The projection
 * @param buffer {Array} a standard WebGL buffer 
 */
PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer)
{
    // reset the render session data..
    this.renderSession.drawCount = 0;
    this.renderSession.currentBlendMode = 9999;

    this.renderSession.projection = projection;
    this.renderSession.offset = this.offset;

    // start the sprite batch
    this.spriteBatch.begin(this.renderSession);

    // start the filter manager
    this.filterManager.begin(this.renderSession, buffer);

    // render the scene!
    displayObject._renderWebGL(this.renderSession);

    // finish the sprite batch
    this.spriteBatch.end();
};

/**
 * Updates the textures loaded into this webgl renderer
 *
 * @static
 * @method updateTextures
 * @private
 */
PIXI.WebGLRenderer.updateTextures = function()
{
    var i = 0;

    //TODO break this out into a texture manager...
    //for (i = 0; i < PIXI.texturesToUpdate.length; i++)
    //    PIXI.WebGLRenderer.updateTexture(PIXI.texturesToUpdate[i]);


    for (i=0; i < PIXI.Texture.frameUpdates.length; i++)
        PIXI.WebGLRenderer.updateTextureFrame(PIXI.Texture.frameUpdates[i]);

    for (i = 0; i < PIXI.texturesToDestroy.length; i++)
        PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);

    PIXI.texturesToUpdate.length = 0;
    PIXI.texturesToDestroy.length = 0;
    PIXI.Texture.frameUpdates.length = 0;
};

/**
 * Destroys a loaded webgl texture
 *
 * @method destroyTexture
 * @param texture {Texture} The texture to update
 * @private
 */
PIXI.WebGLRenderer.destroyTexture = function(texture)
{
    //TODO break this out into a texture manager...

    for (var i = texture._glTextures.length - 1; i >= 0; i--)
    {
        var glTexture = texture._glTextures[i];
        var gl = PIXI.glContexts[i];

        if(gl && glTexture)
        {
            gl.deleteTexture(glTexture);
        }
    }

    texture._glTextures.length = 0;
};

/**
 *
 * @method updateTextureFrame
 * @param texture {Texture} The texture to update the frame from
 * @private
 */
PIXI.WebGLRenderer.updateTextureFrame = function(texture)
{
    texture.updateFrame = false;

    // now set the uvs. Figured that the uv data sits with a texture rather than a sprite.
    // so uv data is stored on the texture itself
    texture._updateWebGLuvs();
};

/**
 * resizes the webGL view to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the webGL view
 * @param height {Number} the new height of the webGL view
 */
PIXI.WebGLRenderer.prototype.resize = function(width, height)
{
    this.width = width;
    this.height = height;

    this.view.width = width;
    this.view.height = height;

    this.gl.viewport(0, 0, this.width, this.height);

    this.projection.x =  this.width/2;
    this.projection.y =  -this.height/2;
};

/**
 * Creates a WebGL texture
 *
 * @method createWebGLTexture
 * @param texture {Texture} the texture to render
 * @param gl {webglContext} the WebGL context
 * @static
 */
PIXI.createWebGLTexture = function(texture, gl)
{


    if(texture.hasLoaded)
    {
        texture._glTextures[gl.id] = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);

        // reguler...

        if(!texture._powerOf2)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    return  texture._glTextures[gl.id];
};

/**
 * Updates a WebGL texture
 *
 * @method updateWebGLTexture
 * @param texture {Texture} the texture to update
 * @param gl {webglContext} the WebGL context
 * @private
 */
PIXI.updateWebGLTexture = function(texture, gl)
{
    if( texture._glTextures[gl.id] )
    {
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);

        // reguler...

        if(!texture._powerOf2)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    
};

/**
 * Handles a lost webgl context
 *
 * @method handleContextLost
 * @param event {Event}
 * @private
 */
PIXI.WebGLRenderer.prototype.handleContextLost = function(event)
{
    event.preventDefault();
    this.contextLost = true;
};

/**
 * Handles a restored webgl context
 *
 * @method handleContextRestored
 * @param event {Event}
 * @private
 */
PIXI.WebGLRenderer.prototype.handleContextRestored = function()
{

    //try 'experimental-webgl'
    try {
        this.gl = this.view.getContext('experimental-webgl',  this.options);
    } catch (e) {
        //try 'webgl'
        try {
            this.gl = this.view.getContext('webgl',  this.options);
        } catch (e2) {
            // fail, not able to get a context
            throw new Error(' This browser does not support webGL. Try using the canvas renderer' + this);
        }
    }

    var gl = this.gl;
    gl.id = PIXI.WebGLRenderer.glContextId ++;



    // need to set the context...
    this.shaderManager.setContext(gl);
    this.spriteBatch.setContext(gl);
    this.maskManager.setContext(gl);
    this.filterManager.setContext(gl);


    this.renderSession.gl = this.gl;

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.enable(gl.BLEND);
    gl.colorMask(true, true, true, this.transparent);

    this.gl.viewport(0, 0, this.width, this.height);

    for(var key in PIXI.TextureCache)
    {
        var texture = PIXI.TextureCache[key].baseTexture;
        texture._glTextures = [];
    }

    /**
     * Whether the context was lost 
     * @property contextLost
     * @type Boolean
     */
    this.contextLost = false;

};

/**
 * Removes everything from the renderer (event listeners, spritebatch, etc...)
 *
 * @method destroy
 */
PIXI.WebGLRenderer.prototype.destroy = function()
{

    // deal with losing context..
    
    // remove listeners
    this.view.removeEventListener('webglcontextlost', this.contextLost);
    this.view.removeEventListener('webglcontextrestored', this.contextRestoredLost);

    PIXI.glContexts[this.glContextId] = null;

    this.projection = null;
    this.offset = null;

    // time to create the render managers! each one focuses on managine a state in webGL
    this.shaderManager.destroy();
    this.spriteBatch.destroy();
    this.maskManager.destroy();
    this.filterManager.destroy();

    this.shaderManager = null;
    this.spriteBatch = null;
    this.maskManager = null;
    this.filterManager = null;
    
    this.gl = null;
    //
    this.renderSession = null;
};


PIXI.WebGLRenderer.glContextId = 0;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */
 

/**
* @class WebGLMaskManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLMaskManager = function(gl)
{
    this.maskStack = [];
    this.maskPosition = 0;

    this.setContext(gl);
};

/**
* Sets the drawing context to the one given in parameter
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLMaskManager.prototype.setContext = function(gl)
{
    this.gl = gl;
};

/**
* Applies the Mask and adds it to the current filter stack
* @method pushMask
* @param maskData {Array}
* @param renderSession {RenderSession}
*/
PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession)
{
    var gl = this.gl;

    if(this.maskStack.length === 0)
    {
        gl.enable(gl.STENCIL_TEST);
        gl.stencilFunc(gl.ALWAYS,1,1);
    }
    
  //  maskData.visible = false;

    this.maskStack.push(maskData);
    
    gl.colorMask(false, false, false, true);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);

    PIXI.WebGLGraphics.renderGraphics(maskData, renderSession);

    gl.colorMask(true, true, true, true);
    gl.stencilFunc(gl.NOTEQUAL,0, this.maskStack.length);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);
};

/**
* Removes the last filter from the filter stack and doesn't return it
* @method popMask
*
* @param renderSession {RenderSession} an object containing all the useful parameters
*/
PIXI.WebGLMaskManager.prototype.popMask = function(renderSession)
{
    var gl = this.gl;

    var maskData = this.maskStack.pop();

    if(maskData)
    {
        gl.colorMask(false, false, false, false);

        //gl.stencilFunc(gl.ALWAYS,1,1);
        gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);

        PIXI.WebGLGraphics.renderGraphics(maskData, renderSession);

        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.NOTEQUAL,0,this.maskStack.length);
        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);
    }
   
    if(this.maskStack.length === 0)gl.disable(gl.STENCIL_TEST);
};

/**
* Destroys the mask stack
* @method destroy
*/
PIXI.WebGLMaskManager.prototype.destroy = function()
{
    this.maskStack = null;
    this.gl = null;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLShaderManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @private
*/
PIXI.WebGLShaderManager = function(gl)
{

    this.maxAttibs = 10;
    this.attribState = [];
    this.tempAttribState = [];

    for (var i = 0; i < this.maxAttibs; i++) {
        this.attribState[i] = false;
    }

    this.setContext(gl);
    // the final one is used for the rendering strips
    //this.stripShader = new PIXI.StripShader(gl);
};


/**
* Initialises the context and the properties
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
* @param transparent {Boolean} Whether or not the drawing context should be transparent
*/
PIXI.WebGLShaderManager.prototype.setContext = function(gl)
{
    this.gl = gl;
    
    // the next one is used for rendering primatives
    this.primitiveShader = new PIXI.PrimitiveShader(gl);

    // this shader is used for the default sprite rendering
    this.defaultShader = new PIXI.PixiShader(gl);

    // this shader is used for the fast sprite rendering
    this.fastShader = new PIXI.PixiFastShader(gl);


    this.activateShader(this.defaultShader);
};


/**
* Takes the attributes given in parameters 
* @method setAttribs
* @param attribs {Array} attribs 
*/
PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs)
{
    // reset temp state

    var i;

    for (i = 0; i < this.tempAttribState.length; i++)
    {
        this.tempAttribState[i] = false;
    }

    // set the new attribs
    for (i = 0; i < attribs.length; i++)
    {
        var attribId = attribs[i];
        this.tempAttribState[attribId] = true;
    }

    var gl = this.gl;

    for (i = 0; i < this.attribState.length; i++)
    {

        if(this.attribState[i] !== this.tempAttribState[i])
        {
            this.attribState[i] = this.tempAttribState[i];

            if(this.tempAttribState[i])
            {
                gl.enableVertexAttribArray(i);
            }
            else
            {
                gl.disableVertexAttribArray(i);
            }
        }
    }
};

/**
* Sets-up the given shader 
*
* @method activateShader
* @param shader {Object} the shader that is going to be activated
*/
PIXI.WebGLShaderManager.prototype.activateShader = function(shader)
{
    //if(this.currentShader == shader)return;

    this.currentShader = shader;

    this.gl.useProgram(shader.program);
    this.setAttribs(shader.attributes);
  
};

/**
* Triggers the primitive shader
* @method activatePrimitiveShader
*/
PIXI.WebGLShaderManager.prototype.activatePrimitiveShader = function()
{
    var gl = this.gl;

    gl.useProgram(this.primitiveShader.program);

    this.setAttribs(this.primitiveShader.attributes);
    
};

/**
* Disable the primitive shader
* @method deactivatePrimitiveShader
*/
PIXI.WebGLShaderManager.prototype.deactivatePrimitiveShader = function()
{
    var gl = this.gl;

    gl.useProgram(this.defaultShader.program);

    this.setAttribs(this.defaultShader.attributes);
};

/**
* Destroys
* @method destroy
*/
PIXI.WebGLShaderManager.prototype.destroy = function()
{
    this.attribState = null;

    this.tempAttribState = null;

    this.primitiveShader.destroy();

    this.defaultShader.destroy();

    this.fastShader.destroy();

    this.gl = null;
};


/**
 * @author Mat Groves
 * 
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 *
 * Heavily inspired by LibGDX's WebGLSpriteBatch:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java
 */

 /**
 *
 * @class WebGLSpriteBatch
 * @private
 * @constructor
 * @param gl {WebGLContext} the current WebGL drawing context
 *
 */
PIXI.WebGLSpriteBatch = function(gl)
{

    /**
     * 
     *
     * @property vertSize
     * @type Number
     */
    this.vertSize = 6;

    /**
     * The number of images in the SpriteBatch before it flushes
     * @property size
     * @type Number
     */
    this.size = 2000;//Math.pow(2, 16) /  this.vertSize;

    //the total number of floats in our batch
    var numVerts = this.size * 4 *  this.vertSize;
    //the total number of indices in our batch
    var numIndices = this.size * 6;

    //vertex data

    /**
    * Holds the vertices
    *
    * @property vertices
    * @type Float32Array
    */
    this.vertices = new Float32Array(numVerts);

    //index data
    /**
     * Holds the indices
     *
     * @property indices
     * @type Uint16Array
     */
    this.indices = new Uint16Array(numIndices);
    
    this.lastIndexCount = 0;

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }


    this.drawing = false;
    this.currentBatchSize = 0;
    this.currentBaseTexture = null;
    
    this.setContext(gl);
};

/**
* 
* @method setContext
*
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLSpriteBatch.prototype.setContext = function(gl)
{
    this.gl = gl;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.


    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

    this.currentBlendMode = 99999;
};

/**
* 
* @method begin
*
* @param renderSession {RenderSession} the RenderSession
*/
PIXI.WebGLSpriteBatch.prototype.begin = function(renderSession)
{
    this.renderSession = renderSession;
    this.shader = this.renderSession.shaderManager.defaultShader;

    this.start();
};

/**
* 
* @method end
*
*/
PIXI.WebGLSpriteBatch.prototype.end = function()
{
    this.flush();
};

/**
* 
* @method render
* 
* @param sprite {Sprite} the sprite to render when using this spritebatch
*/
PIXI.WebGLSpriteBatch.prototype.render = function(sprite)
{
    var texture = sprite.texture;

    // check texture..
    if(texture.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size)
    {
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }


    // check blend mode
    if(sprite.blendMode !== this.currentBlendMode)
    {
        this.setBlendMode(sprite.blendMode);
    }

    // get the uvs for the texture
    var uvs = sprite._uvs || sprite.texture._uvs;
    // if the uvs have not updated then no point rendering just yet!
    if(!uvs)return;

    // get the sprites current alpha
    var alpha = sprite.worldAlpha;
    var tint = sprite.tint;

    var verticies = this.vertices;


    // TODO trim??
    var aX = sprite.anchor.x;
    var aY = sprite.anchor.y;

    var w0, w1, h0, h1;
        
    if (sprite.texture.trim)
    {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
        var trim = sprite.texture.trim;

        w1 = trim.x - aX * trim.width;
        w0 = w1 + texture.frame.width;

        h1 = trim.y - aY * trim.height;
        h0 = h1 + texture.frame.height;

    }
    else
    {
        w0 = (texture.frame.width ) * (1-aX);
        w1 = (texture.frame.width ) * -aX;

        h0 = texture.frame.height * (1-aY);
        h1 = texture.frame.height * -aY;
    }

    var index = this.currentBatchSize * 4 * this.vertSize;

    var worldTransform = sprite.worldTransform;//.toArray();

    var a = worldTransform.a;//[0];
    var b = worldTransform.c;//[3];
    var c = worldTransform.b;//[1];
    var d = worldTransform.d;//[4];
    var tx = worldTransform.tx;//[2];
    var ty = worldTransform.ty;///[5];

    // xy
    verticies[index++] = a * w1 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y0;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w0 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w0 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w1 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;
    
    // increment the batchsize
    this.currentBatchSize++;


};

/**
* Renders a tilingSprite using the spriteBatch
* @method renderTilingSprite
* 
* @param sprite {TilingSprite} the tilingSprite to render
*/
PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite)
{
    var texture = tilingSprite.tilingTexture;

    if(texture.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size)
    {
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }

     // check blend mode
    if(tilingSprite.blendMode !== this.currentBlendMode)
    {
        this.setBlendMode(tilingSprite.blendMode);
    }

     // set the textures uvs temporarily
    // TODO create a separate texture so that we can tile part of a texture

    if(!tilingSprite._uvs)tilingSprite._uvs = new PIXI.TextureUvs();

    var uvs = tilingSprite._uvs;

    tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x;
    tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y;

    var offsetX =  tilingSprite.tilePosition.x/(texture.baseTexture.width*tilingSprite.tileScaleOffset.x);
    var offsetY =  tilingSprite.tilePosition.y/(texture.baseTexture.height*tilingSprite.tileScaleOffset.y);

    var scaleX =  (tilingSprite.width / texture.baseTexture.width)  / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x);
    var scaleY =  (tilingSprite.height / texture.baseTexture.height) / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);

    uvs.x0 = 0 - offsetX;
    uvs.y0 = 0 - offsetY;

    uvs.x1 = (1 * scaleX) - offsetX;
    uvs.y1 = 0 - offsetY;

    uvs.x2 = (1 * scaleX) - offsetX;
    uvs.y2 = (1 * scaleY) - offsetY;

    uvs.x3 = 0 - offsetX;
    uvs.y3 = (1 *scaleY) - offsetY;

    // get the tilingSprites current alpha
    var alpha = tilingSprite.worldAlpha;
    var tint = tilingSprite.tint;

    var  verticies = this.vertices;

    var width = tilingSprite.width;
    var height = tilingSprite.height;

    // TODO trim??
    var aX = tilingSprite.anchor.x; // - tilingSprite.texture.trim.x
    var aY = tilingSprite.anchor.y; //- tilingSprite.texture.trim.y
    var w0 = width * (1-aX);
    var w1 = width * -aX;

    var h0 = height * (1-aY);
    var h1 = height * -aY;

    var index = this.currentBatchSize * 4 * this.vertSize;

    var worldTransform = tilingSprite.worldTransform;

    var a = worldTransform.a;//[0];
    var b = worldTransform.c;//[3];
    var c = worldTransform.b;//[1];
    var d = worldTransform.d;//[4];
    var tx = worldTransform.tx;//[2];
    var ty = worldTransform.ty;///[5];

    // xy
    verticies[index++] = a * w1 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y0;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w0 + c * h1 + tx;
    verticies[index++] = d * h1 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;
    
    // xy
    verticies[index++] = a * w0 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w0 + ty;
    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // xy
    verticies[index++] = a * w1 + c * h0 + tx;
    verticies[index++] = d * h0 + b * w1 + ty;
    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = alpha;
    verticies[index++] = tint;

    // increment the batchs
    this.currentBatchSize++;
};


/**
* Renders the content and empties the current batch
*
* @method flush
* 
*/
PIXI.WebGLSpriteBatch.prototype.flush = function()
{
    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize===0)return;

    var gl = this.gl;
    
    // bind the current texture
    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.currentBaseTexture, gl));

    // upload the verts to the buffer
    
    if(this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }

   // var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
    //gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    
    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
   
    // then reset the batch!
    this.currentBatchSize = 0;

    // increment the draw count
    this.renderSession.drawCount++;
};

/**
* 
* @method stop
*
*/
PIXI.WebGLSpriteBatch.prototype.stop = function()
{
    this.flush();
};

/**
* 
* @method start
*
*/
PIXI.WebGLSpriteBatch.prototype.start = function()
{
    var gl = this.gl;

    // bind the main texture
    gl.activeTexture(gl.TEXTURE0);

    // bind the buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // set the projection
    var projection = this.renderSession.projection;
    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);

    // set the pointers
    var stride =  this.vertSize * 4;
    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
    gl.vertexAttribPointer(this.shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);

    // set the blend mode..
    if(this.currentBlendMode !== PIXI.blendModes.NORMAL)
    {
        this.setBlendMode(PIXI.blendModes.NORMAL);
    }
};

/**
* Sets-up the given blendMode from WebGL's point of view
* @method setBlendMode 
*
* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD
*/
PIXI.WebGLSpriteBatch.prototype.setBlendMode = function(blendMode)
{
    this.flush();

    this.currentBlendMode = blendMode;
    
    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];
    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
};

/**
* Destroys the SpriteBatch
* @method destroy
*/
PIXI.WebGLSpriteBatch.prototype.destroy = function()
{

    this.vertices = null;
    this.indices = null;
    
    this.gl.deleteBuffer( this.vertexBuffer );
    this.gl.deleteBuffer( this.indexBuffer );
    
    this.currentBaseTexture = null;
    
    this.gl = null;
};


/**
 * @author Mat Groves
 * 
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 *
 * Heavily inspired by LibGDX's WebGLSpriteBatch:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java
 */

PIXI.WebGLFastSpriteBatch = function(gl)
{
   

    this.vertSize = 10;
    this.maxSize = 6000;//Math.pow(2, 16) /  this.vertSize;
    this.size = this.maxSize;

    //the total number of floats in our batch
    var numVerts = this.size * 4 *  this.vertSize;
    //the total number of indices in our batch
    var numIndices = this.maxSize * 6;

     //vertex data
    this.vertices = new Float32Array(numVerts);
    //index data
    this.indices = new Uint16Array(numIndices);
    
    this.vertexBuffer = null;
    this.indexBuffer = null;

    this.lastIndexCount = 0;

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    this.drawing = false;
    this.currentBatchSize = 0;
    this.currentBaseTexture = null;
   
    this.currentBlendMode = 0;
    this.renderSession = null;
    

    this.shader = null;

    this.matrix = null;

    this.setContext(gl);
};

PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl)
{
    this.gl = gl;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.


    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

    this.currentBlendMode = 99999;
};

PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession)
{
    this.renderSession = renderSession;
    this.shader = this.renderSession.shaderManager.fastShader;

    this.matrix = spriteBatch.worldTransform.toArray(true);

    this.start();
};

PIXI.WebGLFastSpriteBatch.prototype.end = function()
{
    this.flush();
};


PIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch)
{

    var children = spriteBatch.children;
    var sprite = children[0];

    // if the uvs have not updated then no point rendering just yet!
    
    // check texture.
    if(!sprite.texture._uvs)return;
   
    this.currentBaseTexture = sprite.texture.baseTexture;
    // check blend mode
    if(sprite.blendMode !== this.currentBlendMode)
    {
        this.setBlendMode(sprite.blendMode);
    }
    
    for(var i=0,j= children.length; i<j; i++)
    {
        this.renderSprite(children[i]);
    }

    this.flush();
};

PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite)
{
    //sprite = children[i];
    if(!sprite.visible)return;
    
    // TODO trim??
    if(sprite.texture.baseTexture !== this.currentBaseTexture)
    {
        this.flush();
        this.currentBaseTexture = sprite.texture.baseTexture;
        
        if(!sprite.texture._uvs)return;
    }

    var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index;

    uvs = sprite.texture._uvs;


    width = sprite.texture.frame.width;
    height = sprite.texture.frame.height;

    if (sprite.texture.trim)
    {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
        var trim = sprite.texture.trim;

        w1 = trim.x - sprite.anchor.x * trim.width;
        w0 = w1 + sprite.texture.frame.width;

        h1 = trim.y - sprite.anchor.y * trim.height;
        h0 = h1 + sprite.texture.frame.height;
    }
    else
    {
        w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x);
        w1 = (sprite.texture.frame.width ) * -sprite.anchor.x;

        h0 = sprite.texture.frame.height * (1-sprite.anchor.y);
        h1 = sprite.texture.frame.height * -sprite.anchor.y;
    }

    index = this.currentBatchSize * 4 * this.vertSize;

    // xy
    verticies[index++] = w1;
    verticies[index++] = h1;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

    //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x0;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = sprite.alpha;
 

    // xy
    verticies[index++] = w0;
    verticies[index++] = h1;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x1;
    verticies[index++] = uvs.y1;
    // color
    verticies[index++] = sprite.alpha;
  

    // xy
    verticies[index++] = w0;
    verticies[index++] = h0;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x2;
    verticies[index++] = uvs.y2;
    // color
    verticies[index++] = sprite.alpha;
 



    // xy
    verticies[index++] = w1;
    verticies[index++] = h0;

    verticies[index++] = sprite.position.x;
    verticies[index++] = sprite.position.y;

    //scale
    verticies[index++] = sprite.scale.x;
    verticies[index++] = sprite.scale.y;

     //rotation
    verticies[index++] = sprite.rotation;

    // uv
    verticies[index++] = uvs.x3;
    verticies[index++] = uvs.y3;
    // color
    verticies[index++] = sprite.alpha;

    // increment the batchs
    this.currentBatchSize++;

    if(this.currentBatchSize >= this.size)
    {
        this.flush();
    }
};

PIXI.WebGLFastSpriteBatch.prototype.flush = function()
{

    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize===0)return;

    var gl = this.gl;
    
    // bind the current texture

    if(!this.currentBaseTexture._glTextures[gl.id])PIXI.createWebGLTexture(this.currentBaseTexture, gl);

    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);// || PIXI.createWebGLTexture(this.currentBaseTexture, gl));

    // upload the verts to the buffer

   
    if(this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }
    
    
    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
   
    // then reset the batch!
    this.currentBatchSize = 0;

    // increment the draw count
    this.renderSession.drawCount++;
};


PIXI.WebGLFastSpriteBatch.prototype.stop = function()
{
    this.flush();
};

PIXI.WebGLFastSpriteBatch.prototype.start = function()
{
    var gl = this.gl;

    // bind the main texture
    gl.activeTexture(gl.TEXTURE0);

    // bind the buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // set the projection
    var projection = this.renderSession.projection;
    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);

    // set the matrix
    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);

    // set the pointers
    var stride =  this.vertSize * 4;

    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);
    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);
    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);
    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);
    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);

    // set the blend mode..
    if(this.currentBlendMode !== PIXI.blendModes.NORMAL)
    {
        this.setBlendMode(PIXI.blendModes.NORMAL);
    }
};

PIXI.WebGLFastSpriteBatch.prototype.setBlendMode = function(blendMode)
{
    this.flush();

    this.currentBlendMode = blendMode;
    
    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];
    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
};



/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLFilterManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @param transparent {Boolean} Whether or not the drawing context should be transparent
* @private
*/
PIXI.WebGLFilterManager = function(gl, transparent)
{
    this.transparent = transparent;

    this.filterStack = [];
    
    this.offsetX = 0;
    this.offsetY = 0;

    this.setContext(gl);
};

// API
/**
* Initialises the context and the properties
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLFilterManager.prototype.setContext = function(gl)
{
    this.gl = gl;
    this.texturePool = [];

    this.initShaderBuffers();
};

/**
* 
* @method begin
* @param renderSession {RenderSession} 
* @param buffer {ArrayBuffer} 
*/
PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer)
{
    this.renderSession = renderSession;
    this.defaultShader = renderSession.shaderManager.defaultShader;

    var projection = this.renderSession.projection;
   // console.log(this.width)
    this.width = projection.x * 2;
    this.height = -projection.y * 2;
    this.buffer = buffer;
};

/**
* Applies the filter and adds it to the current filter stack
* @method pushFilter
* @param filterBlock {Object} the filter that will be pushed to the current filter stack
*/
PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock)
{
    var gl = this.gl;

    var projection = this.renderSession.projection;
    var offset = this.renderSession.offset;

    filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();


    // filter program
    // OPTIMISATION - the first filter is free if its a simple color change?
    this.filterStack.push(filterBlock);

    var filter = filterBlock.filterPasses[0];

    this.offsetX += filterBlock._filterArea.x;
    this.offsetY += filterBlock._filterArea.y;

    var texture = this.texturePool.pop();
    if(!texture)
    {
        texture = new PIXI.FilterTexture(this.gl, this.width, this.height);
    }
    else
    {
        texture.resize(this.width, this.height);
    }

    gl.bindTexture(gl.TEXTURE_2D,  texture.texture);

    var filterArea = filterBlock._filterArea;// filterBlock.target.getBounds();///filterBlock.target.filterArea;

    var padidng = filter.padding;
    filterArea.x -= padidng;
    filterArea.y -= padidng;
    filterArea.width += padidng * 2;
    filterArea.height += padidng * 2;

    // cap filter to screen size..
    if(filterArea.x < 0)filterArea.x = 0;
    if(filterArea.width > this.width)filterArea.width = this.width;
    if(filterArea.y < 0)filterArea.y = 0;
    if(filterArea.height > this.height)filterArea.height = this.height;

    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);

    // set view port
    gl.viewport(0, 0, filterArea.width, filterArea.height);

    projection.x = filterArea.width/2;
    projection.y = -filterArea.height/2;

    offset.x = -filterArea.x;
    offset.y = -filterArea.y;

    // update projection
    gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);
    gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);

    gl.colorMask(true, true, true, true);
    gl.clearColor(0,0,0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    filterBlock._glFilterTexture = texture;

};


/**
* Removes the last filter from the filter stack and doesn't return it
* @method popFilter
*/
PIXI.WebGLFilterManager.prototype.popFilter = function()
{
    var gl = this.gl;
    var filterBlock = this.filterStack.pop();
    var filterArea = filterBlock._filterArea;
    var texture = filterBlock._glFilterTexture;
    var projection = this.renderSession.projection;
    var offset = this.renderSession.offset;

    if(filterBlock.filterPasses.length > 1)
    {
        gl.viewport(0, 0, filterArea.width, filterArea.height);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

        this.vertexArray[0] = 0;
        this.vertexArray[1] = filterArea.height;

        this.vertexArray[2] = filterArea.width;
        this.vertexArray[3] = filterArea.height;

        this.vertexArray[4] = 0;
        this.vertexArray[5] = 0;

        this.vertexArray[6] = filterArea.width;
        this.vertexArray[7] = 0;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        // now set the uvs..
        this.uvArray[2] = filterArea.width/this.width;
        this.uvArray[5] = filterArea.height/this.height;
        this.uvArray[6] = filterArea.width/this.width;
        this.uvArray[7] = filterArea.height/this.height;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);

        var inputTexture = texture;
        var outputTexture = this.texturePool.pop();
        if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);
        outputTexture.resize(this.width, this.height);

        // need to clear this FBO as it may have some left over elements from a previous filter.
        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.disable(gl.BLEND);

        for (var i = 0; i < filterBlock.filterPasses.length-1; i++)
        {
            var filterPass = filterBlock.filterPasses[i];

            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );

            // set texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

            // draw texture..
            //filterPass.applyFilterPass(filterArea.width, filterArea.height);
            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);

            // swap the textures..
            var temp = inputTexture;
            inputTexture = outputTexture;
            outputTexture = temp;
        }

        gl.enable(gl.BLEND);

        texture = inputTexture;
        this.texturePool.push(outputTexture);
    }

    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1];

    this.offsetX -= filterArea.x;
    this.offsetY -= filterArea.y;


    var sizeX = this.width;
    var sizeY = this.height;

    var offsetX = 0;
    var offsetY = 0;

    var buffer = this.buffer;

    // time to render the filters texture to the previous scene
    if(this.filterStack.length === 0)
    {
        gl.colorMask(true, true, true, true);//this.transparent);
    }
    else
    {
        var currentFilter = this.filterStack[this.filterStack.length-1];
        filterArea = currentFilter._filterArea;

        sizeX = filterArea.width;
        sizeY = filterArea.height;

        offsetX = filterArea.x;
        offsetY = filterArea.y;

        buffer =  currentFilter._glFilterTexture.frameBuffer;
    }



    // TODO need toremove thease global elements..
    projection.x = sizeX/2;
    projection.y = -sizeY/2;

    offset.x = offsetX;
    offset.y = offsetY;

    filterArea = filterBlock._filterArea;

    var x = filterArea.x-offsetX;
    var y = filterArea.y-offsetY;

    // update the buffers..
    // make sure to flip the y!
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

    this.vertexArray[0] = x;
    this.vertexArray[1] = y + filterArea.height;

    this.vertexArray[2] = x + filterArea.width;
    this.vertexArray[3] = y + filterArea.height;

    this.vertexArray[4] = x;
    this.vertexArray[5] = y;

    this.vertexArray[6] = x + filterArea.width;
    this.vertexArray[7] = y;

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);

    this.uvArray[2] = filterArea.width/this.width;
    this.uvArray[5] = filterArea.height/this.height;
    this.uvArray[6] = filterArea.width/this.width;
    this.uvArray[7] = filterArea.height/this.height;

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);

   //console.log(this.vertexArray)
   //console.log(this.uvArray)
    //console.log(sizeX + " : " + sizeY)

    gl.viewport(0, 0, sizeX, sizeY);

    // bind the buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer );

    // set the blend mode! 
    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)

    // set texture
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture.texture);

    // apply!
    this.applyFilterPass(filter, filterArea, sizeX, sizeY);

    // now restore the regular shader..
    gl.useProgram(this.defaultShader.program);
    gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);
    gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);

    // return the texture to the pool
    this.texturePool.push(texture);
    filterBlock._glFilterTexture = null;
};


/**
* Applies the filter to the specified area
* @method applyFilterPass
* @param filter {AbstractFilter} the filter that needs to be applied
* @param filterArea {texture} TODO - might need an update
* @param width {Number} the horizontal range of the filter
* @param height {Number} the vertical range of the filter
*/
PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height)
{
    // use program
    var gl = this.gl;
    var shader = filter.shaders[gl.id];

    if(!shader)
    {
        shader = new PIXI.PixiShader(gl);

        shader.fragmentSrc = filter.fragmentSrc;
        shader.uniforms = filter.uniforms;
        shader.init();

        filter.shaders[gl.id] = shader;
    }

    // set the shader
    gl.useProgram(shader.program);

    gl.uniform2f(shader.projectionVector, width/2, -height/2);
    gl.uniform2f(shader.offsetVector, 0,0);

    if(filter.uniforms.dimensions)
    {
        filter.uniforms.dimensions.value[0] = this.width;//width;
        filter.uniforms.dimensions.value[1] = this.height;//height;
        filter.uniforms.dimensions.value[2] = this.vertexArray[0];
        filter.uniforms.dimensions.value[3] = this.vertexArray[5];//filterArea.height;
    }

  //  console.log(this.uvArray )
    shader.syncUniforms();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // draw the filter...
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    this.renderSession.drawCount++;
};

/**
* Initialises the shader buffers
* @method initShaderBuffers
*/
PIXI.WebGLFilterManager.prototype.initShaderBuffers = function()
{
    var gl = this.gl;

    // create some buffers
    this.vertexBuffer = gl.createBuffer();
    this.uvBuffer = gl.createBuffer();
    this.colorBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();


    // bind and upload the vertexs..
    // keep a reference to the vertexFloatData..
    this.vertexArray = new Float32Array([0.0, 0.0,
                                         1.0, 0.0,
                                         0.0, 1.0,
                                         1.0, 1.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.vertexArray,
    gl.STATIC_DRAW);


    // bind and upload the uv buffer
    this.uvArray = new Float32Array([0.0, 0.0,
                                     1.0, 0.0,
                                     0.0, 1.0,
                                     1.0, 1.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.uvArray,
    gl.STATIC_DRAW);

    this.colorArray = new Float32Array([1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.bufferData(
    gl.ARRAY_BUFFER,
    this.colorArray,
    gl.STATIC_DRAW);

    // bind and upload the index
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(
    gl.ELEMENT_ARRAY_BUFFER,
    new Uint16Array([0, 1, 2, 1, 3, 2]),
    gl.STATIC_DRAW);
};

/**
* Destroys the filter and removes it from the filter stack
* @method destroy
*/
PIXI.WebGLFilterManager.prototype.destroy = function()
{
    var gl = this.gl;

    this.filterStack = null;
    
    this.offsetX = 0;
    this.offsetY = 0;

    // destroy textures
    for (var i = 0; i < this.texturePool.length; i++) {
        this.texturePool.destroy();
    }
    
    this.texturePool = null;

    //destroy buffers..
    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.uvBuffer);
    gl.deleteBuffer(this.colorBuffer);
    gl.deleteBuffer(this.indexBuffer);
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class FilterTexture
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @param width {Number} the horizontal range of the filter
* @param height {Number} the vertical range of the filter
* @private
*/
PIXI.FilterTexture = function(gl, width, height)
{
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    // next time to create a frame buffer and texture
    this.frameBuffer = gl.createFramebuffer();
    this.texture = gl.createTexture();

    gl.bindTexture(gl.TEXTURE_2D,  this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);

    this.resize(width, height);
};


/**
* Clears the filter texture
* @method clear
*/
PIXI.FilterTexture.prototype.clear = function()
{
    var gl = this.gl;
    
    gl.clearColor(0,0,0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/**
 * Resizes the texture to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the texture
 * @param height {Number} the new height of the texture
 */
PIXI.FilterTexture.prototype.resize = function(width, height)
{
    if(this.width === width && this.height === height) return;

    this.width = width;
    this.height = height;

    var gl = this.gl;

    gl.bindTexture(gl.TEXTURE_2D,  this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

};

/**
* Destroys the filter texture
* @method destroy
*/
PIXI.FilterTexture.prototype.destroy = function()
{
    var gl = this.gl;
    gl.deleteFramebuffer( this.frameBuffer );
    gl.deleteTexture( this.texture );

    this.frameBuffer = null;
    this.texture = null;
};

/**
 * @author Mat Groves
 * 
 * 
 */
/**
 * A set of functions used to handle masking
 *
 * @class CanvasMaskManager
 */
PIXI.CanvasMaskManager = function()
{
    
};

/**
 * This method adds it to the current stack of masks
 *
 * @method pushMask
 * @param maskData the maskData that will be pushed
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, context)
{
    context.save();
    
    var cacheAlpha = maskData.alpha;
    var transform = maskData.worldTransform;

    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);

    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);

    context.clip();

    maskData.worldAlpha = cacheAlpha;
};

/**
 * Restores the current drawing context to the state it was before the mask was applied
 *
 * @method popMask
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasMaskManager.prototype.popMask = function(context)
{
    context.restore();
};

/**
 * @author Mat Groves
 * 
 * 
 */

/**
 * @class CanvasTinter
 * @constructor
 * @static
 */
PIXI.CanvasTinter = function()
{
    /// this.textureCach
};

//PIXI.CanvasTinter.cachTint = true;
    

/**
 * Basically this method just needs a sprite and a color and tints the sprite 
 * with the given color
 * 
 * @method getTintedTexture 
 * @param sprite {Sprite} the sprite to tint
 * @param color {Number} the color to use to tint the sprite with
 */
PIXI.CanvasTinter.getTintedTexture = function(sprite, color)
{

    var texture = sprite.texture;

    color = PIXI.CanvasTinter.roundColor(color);

    var stringColor = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
   
    texture.tintCache = texture.tintCache || {};

    if(texture.tintCache[stringColor]) return texture.tintCache[stringColor];

     // clone texture..
    var canvas = PIXI.CanvasTinter.canvas || document.createElement("canvas");
    
    //PIXI.CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);

    
    PIXI.CanvasTinter.tintMethod(texture, color, canvas);

    if(PIXI.CanvasTinter.convertTintToImage)
    {
        // is this better?
        var tintImage = new Image();
        tintImage.src = canvas.toDataURL();

        texture.tintCache[stringColor] = tintImage;
    }
    else
    {
      
        texture.tintCache[stringColor] = canvas;
        // if we are not converting the texture to an image then we need to lose the reference to the canvas
        PIXI.CanvasTinter.canvas = null;

    }

    return canvas;
};

/**
 * Tint a texture using the "multiply" operation
 * @method tintWithMultiply
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;

    context.fillStyle = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
    
    context.fillRect(0, 0, frame.width, frame.height);
    
    context.globalCompositeOperation = "multiply";

    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    context.globalCompositeOperation = "destination-atop";
    
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);
};

/**
 * Tint a texture using the "overlay" operation
 * @method tintWithOverlay
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;

    
    
    context.globalCompositeOperation = "copy";
    context.fillStyle = "#" + ("00000" + ( color | 0).toString(16)).substr(-6);
    context.fillRect(0, 0, frame.width, frame.height);

    context.globalCompositeOperation = "destination-atop";
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    
    //context.globalCompositeOperation = "copy";

};

/**
 * Tint a texture pixel per pixel
 * @method tintPerPixel
 * @param texture {texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas)
{
    var context = canvas.getContext( "2d" );

    var frame = texture.frame;

    canvas.width = frame.width;
    canvas.height = frame.height;
  
    context.globalCompositeOperation = "copy";
    context.drawImage(texture.baseTexture.source,
                           frame.x,
                           frame.y,
                           frame.width,
                           frame.height,
                           0,
                           0,
                           frame.width,
                           frame.height);

    var rgbValues = PIXI.hex2rgb(color);
    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];

    var pixelData = context.getImageData(0, 0, frame.width, frame.height);

    var pixels = pixelData.data;

    for (var i = 0; i < pixels.length; i += 4)
    {
        pixels[i+0] *= r;
        pixels[i+1] *= g;
        pixels[i+2] *= b;
    }

    context.putImageData(pixelData, 0, 0);
};

/**
 * Rounds the specified color according to the PIXI.CanvasTinter.cacheStepsPerColorChannel
 * @method roundColor
 * @param color {number} the color to round, should be a hex color
 */
PIXI.CanvasTinter.roundColor = function(color)
{
    var step = PIXI.CanvasTinter.cacheStepsPerColorChannel;

    var rgbValues = PIXI.hex2rgb(color);

    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);

    return PIXI.rgb2hex(rgbValues);
};

/**
 * 
 * Number of steps which will be used as a cap when rounding colors
 *
 * @property cacheStepsPerColorChannel
 * @type Number
 */
PIXI.CanvasTinter.cacheStepsPerColorChannel = 8;
/**
 * 
 * Number of steps which will be used as a cap when rounding colors
 *
 * @property convertTintToImage
 * @type Boolean
 */
PIXI.CanvasTinter.convertTintToImage = false;

/**
 * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method
 *
 * @property canUseMultiply
 * @type Boolean
 */
PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();

PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply :  PIXI.CanvasTinter.tintWithPerPixel;


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * the CanvasRenderer draws the stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Dont forget to add the view to your DOM or you will not see anything :)
 *
 * @class CanvasRenderer
 * @constructor
 * @param width=800 {Number} the width of the canvas view
 * @param height=600 {Number} the height of the canvas view
 * @param [view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [transparent=false] {Boolean} the transparency of the render view, default false
 */
PIXI.CanvasRenderer = function(width, height, view, transparent)
{
    PIXI.defaultRenderer = PIXI.defaultRenderer || this;

    this.type = PIXI.CANVAS_RENDERER;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.
     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
     *
     * @property clearBeforeRender
     * @type Boolean
     * @default
     */
    this.clearBeforeRender = true;

    /**
     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Handy for crisp pixel art and speed on legacy devices.
     *
     * @property roundPixels
     * @type Boolean
     * @default
     */
    this.roundPixels = false;

    /**
     * Whether the render view is transparent
     *
     * @property transparent
     * @type Boolean
     */
    this.transparent = !!transparent;

    if(!PIXI.blendModesCanvas)
    {
        PIXI.blendModesCanvas = [];
        
        if(PIXI.canUseNewCanvasBlendModes())
        {
            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = "lighter"; //IS THIS OK???
            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "multiply";
            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = "screen";
            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = "overlay";
            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = "darken";
            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = "lighten";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "color-dodge";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "color-burn";
            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "hard-light";
            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "soft-light";
            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "difference";
            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "exclusion";
            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = "hue";
            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "saturation";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = "color";
            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "luminosity";
        }
        else
        {
            // this means that the browser does not support the cool new blend modes in canvas "cough" ie "cough"
            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = "lighter"; //IS THIS OK???
            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = "source-over";
            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "source-over";
        }
    }

    /**
     * The width of the canvas view
     *
     * @property width
     * @type Number
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @property height
     * @type Number
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @property view
     * @type HTMLCanvasElement
     */
    this.view = view || document.createElement( "canvas" );

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type HTMLCanvasElement 2d Context
     */
    this.context = this.view.getContext( "2d", { alpha: this.transparent } );

    this.refresh = true;
    // hack to enable some hardware acceleration!
    //this.view.style["transform"] = "translatez(0)";

    this.view.width = this.width;
    this.view.height = this.height;
    this.count = 0;

    /**
     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer
     * @property CanvasMaskManager
     * @type CanvasMaskManager
     */
    this.maskManager = new PIXI.CanvasMaskManager();

    /**
     * The render session is just a bunch of parameter used for rendering
     * @property renderSession
     * @type Object
     */
    this.renderSession = {
        context: this.context,
        maskManager: this.maskManager,
        scaleMode: null,
        smoothProperty: null
    };

    if("imageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "imageSmoothingEnabled";
    else if("webkitImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "webkitImageSmoothingEnabled";
    else if("mozImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "mozImageSmoothingEnabled";
    else if("oImageSmoothingEnabled" in this.context)
        this.renderSession.smoothProperty = "oImageSmoothingEnabled";
};

// constructor
PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;

/**
 * Renders the stage to its canvas view
 *
 * @method render
 * @param stage {Stage} the Stage element to be rendered
 */
PIXI.CanvasRenderer.prototype.render = function(stage)
{
    // update textures if need be
    PIXI.texturesToUpdate.length = 0;
    PIXI.texturesToDestroy.length = 0;

    stage.updateTransform();

    this.context.setTransform(1,0,0,1,0,0);
    this.context.globalAlpha = 1;

    if (!this.transparent && this.clearBeforeRender)
    {
        this.context.fillStyle = stage.backgroundColorString;
        this.context.fillRect(0, 0, this.width, this.height);
    }
    else if (this.transparent && this.clearBeforeRender)
    {
        this.context.clearRect(0, 0, this.width, this.height);
    }

    this.renderDisplayObject(stage);

    // run interaction!
    if(stage.interactive)
    {
        //need to add some events!
        if(!stage._interactiveEventsAdded)
        {
            stage._interactiveEventsAdded = true;
            stage.interactionManager.setTarget(this);
        }
    }

    // remove frame updates..
    if(PIXI.Texture.frameUpdates.length > 0)
    {
        PIXI.Texture.frameUpdates.length = 0;
    }
};

/**
 * Resizes the canvas view to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the canvas view
 * @param height {Number} the new height of the canvas view
 */
PIXI.CanvasRenderer.prototype.resize = function(width, height)
{
    this.width = width;
    this.height = height;

    this.view.width = width;
    this.view.height = height;
};

/**
 * Renders a display object
 *
 * @method renderDisplayObject
 * @param displayObject {DisplayObject} The displayObject to render
 * @param context {Context2D} the context 2d method of the canvas
 * @private
 */
PIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context)
{
    // no longer recursive!
    //var transform;
    //var context = this.context;

    this.renderSession.context = context || this.context;
    displayObject._renderCanvas(this.renderSession);
};

/**
 * Renders a flat strip
 *
 * @method renderStripFlat
 * @param strip {Strip} The Strip to render
 * @private
 */
PIXI.CanvasRenderer.prototype.renderStripFlat = function(strip)
{
    var context = this.context;
    var verticies = strip.verticies;

    var length = verticies.length/2;
    this.count++;

    context.beginPath();
    for (var i=1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];
        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];

        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
    }

    context.fillStyle = "#FF0000";
    context.fill();
    context.closePath();
};

/**
 * Renders a strip
 *
 * @method renderStrip
 * @param strip {Strip} The Strip to render
 * @private
 */
PIXI.CanvasRenderer.prototype.renderStrip = function(strip)
{
    var context = this.context;

    // draw triangles!!
    var verticies = strip.verticies;
    var uvs = strip.uvs;

    var length = verticies.length/2;
    this.count++;

    for (var i = 1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];
        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];

        var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;
        var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;

        context.save();
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.closePath();

        context.clip();

        // Compute matrix transform
        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;
        var deltaA = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;
        var deltaB = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;
        var deltaC = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;
        var deltaD = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;
        var deltaE = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;
        var deltaF = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;

        context.transform(deltaA / delta, deltaD / delta,
                            deltaB / delta, deltaE / delta,
                            deltaC / delta, deltaF / delta);

        context.drawImage(strip.texture.baseTexture.source, 0, 0);
        context.restore();
    }
};

/**
 * Creates a Canvas element of the given size
 *
 * @method CanvasBuffer
 * @param width {Number} the width for the newly created canvas
 * @param height {Number} the height for the newly created canvas
 * @static
 * @private
 */
PIXI.CanvasBuffer = function(width, height)
{
    this.width = width;
    this.height = height;

    this.canvas = document.createElement( "canvas" );
    this.context = this.canvas.getContext( "2d" );

    this.canvas.width = width;
    this.canvas.height = height;
};

/**
 * Clears the canvas that was created by the CanvasBuffer class
 *
 * @method clear
 * @private
 */
PIXI.CanvasBuffer.prototype.clear = function()
{
    this.context.clearRect(0,0, this.width, this.height);
};

/**
 * Resizes the canvas that was created by the CanvasBuffer class to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the canvas
 * @param height {Number} the new height of the canvas
 * @private
 */

PIXI.CanvasBuffer.prototype.resize = function(width, height)
{
    this.width = this.canvas.width = width;
    this.height = this.canvas.height = height;
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * A set of functions used by the canvas renderer to draw the primitive graphics data
 *
 * @class CanvasGraphics
 */
PIXI.CanvasGraphics = function()
{

};


/*
 * Renders the graphics object
 *
 * @static
 * @private
 * @method renderGraphics
 * @param graphics {Graphics} the actual graphics object to render
 * @param context {Context2D} the 2d drawing method of the canvas
 */
PIXI.CanvasGraphics.renderGraphics = function(graphics, context)
{
    var worldAlpha = graphics.worldAlpha;
    var color = '';

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];
        var points = data.points;

        context.strokeStyle = color = '#' + ('00000' + ( data.lineColor | 0).toString(16)).substr(-6);

        context.lineWidth = data.lineWidth;

        if(data.type === PIXI.Graphics.POLY)
        {
            context.beginPath();

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
        else if(data.type === PIXI.Graphics.RECT)
        {

            if(data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fillRect(points[0], points[1], points[2], points[3]);

            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeRect(points[0], points[1], points[2], points[3]);
            }

        }
        else if(data.type === PIXI.Graphics.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(points[0], points[1], points[2],0,2*Math.PI);
            context.closePath();

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
        else if(data.type === PIXI.Graphics.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var ellipseData =  data.points;

            var w = ellipseData[2] * 2;
            var h = ellipseData[3] * 2;

            var x = ellipseData[0] - w/2;
            var y = ellipseData[1] - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

            context.closePath();

            if(data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if(data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.stroke();
            }
        }
    }
};

/*
 * Renders a graphics mask
 *
 * @static
 * @private
 * @method renderGraphicsMask
 * @param graphics {Graphics} the graphics which will be used as a mask
 * @param context {Context2D} the context 2d method of the canvas
 */
PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context)
{
    var len = graphics.graphicsData.length;

    if(len === 0) return;

    if(len > 1)
    {
        len = 1;
        window.console.log('Pixi.js warning: masks in canvas can only mask using the first path in the graphics object');
    }

    for (var i = 0; i < 1; i++)
    {
        var data = graphics.graphicsData[i];
        var points = data.points;

        if(data.type === PIXI.Graphics.POLY)
        {
            context.beginPath();
            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

        }
        else if(data.type === PIXI.Graphics.RECT)
        {
            context.beginPath();
            context.rect(points[0], points[1], points[2], points[3]);
            context.closePath();
        }
        else if(data.type === PIXI.Graphics.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(points[0], points[1], points[2],0,2*Math.PI);
            context.closePath();
        }
        else if(data.type === PIXI.Graphics.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
            var ellipseData =  data.points;

            var w = ellipseData[2] * 2;
            var h = ellipseData[3] * 2;

            var x = ellipseData[0] - w/2;
            var y = ellipseData[1] - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
        }
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */


/**
 * The Graphics class contains a set of methods that you can use to create primitive shapes and lines.
 * It is important to know that with the webGL renderer only simple polygons can be filled at this stage
 * Complex polygons will not be filled. Heres an example of a complex polygon: http://www.goodboydigital.com/wp-content/uploads/2013/06/complexPolygon.png
 *
 * @class Graphics
 * @extends DisplayObjectContainer
 * @constructor
 */
PIXI.Graphics = function()
{
    PIXI.DisplayObjectContainer.call( this );

    this.renderable = true;

    /**
     * The alpha of the fill of this graphics object
     *
     * @property fillAlpha
     * @type Number
     */
    this.fillAlpha = 1;

    /**
     * The width of any lines drawn
     *
     * @property lineWidth
     * @type Number
     */
    this.lineWidth = 0;

    /**
     * The color of any lines drawn
     *
     * @property lineColor
     * @type String
     */
    this.lineColor = "black";

    /**
     * Graphics data
     *
     * @property graphicsData
     * @type Array
     * @private
     */
    this.graphicsData = [];


    /**
     * The tint applied to the graphic shape. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;// * Math.random();
    
    /**
     * The blend mode to be applied to the graphic shape
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;
    
    /**
     * Current path
     *
     * @property currentPath
     * @type Object
     * @private
     */
    this.currentPath = {points:[]};

    /**
     * Array containing some WebGL-related properties used by the WebGL renderer
     *
     * @property _webGL
     * @type Array
     * @private
     */
    this._webGL = [];

    /**
     * Whether this shape is being used as a mask
     *
     * @property isMask
     * @type isMask
     */
    this.isMask = false;

    /**
     * The bounds of the graphic shape as rectangle object
     *
     * @property bounds
     * @type Rectangle
     */
    this.bounds = null;

    /**
     * the bounds' padding used for bounds calculation
     *
     * @property bounds
     * @type Number
     */
    this.boundsPadding = 10;
};

// constructor
PIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );
PIXI.Graphics.prototype.constructor = PIXI.Graphics;

/**
 * If cacheAsBitmap is true the graphics object will then be rendered as if it was a sprite.
 * This is useful if your graphics element does not change often as it will speed up the rendering of the object
 * It is also usful as the graphics object will always be antialiased because it will be rendered using canvas
 * Not recommended if you are constanly redrawing the graphics element.
 *
 * @property cacheAsBitmap
 * @default false
 * @type Boolean
 * @private
 */
Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
    get: function() {
        return  this._cacheAsBitmap;
    },
    set: function(value) {
        this._cacheAsBitmap = value;

        if(this._cacheAsBitmap)
        {
            this._generateCachedSprite();
        }
        else
        {
            this.destroyCachedSprite();
            this.dirty = true;
        }

    }
});


/**
 * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
 *
 * @method lineStyle
 * @param lineWidth {Number} width of the line to draw, will update the object's stored style
 * @param color {Number} color of the line to draw, will update the object's stored style
 * @param alpha {Number} alpha of the line to draw, will update the object's stored style
 */
PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha)
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.lineWidth = lineWidth || 0;
    this.lineColor = color || 0;
    this.lineAlpha = (arguments.length < 3) ? 1 : alpha;

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};

    this.graphicsData.push(this.currentPath);

    return this;
};

/**
 * Moves the current drawing position to (x, y).
 *
 * @method moveTo
 * @param x {Number} the X coordinate to move to
 * @param y {Number} the Y coordinate to move to
 */
PIXI.Graphics.prototype.moveTo = function(x, y)
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};

    this.currentPath.points.push(x, y);

    this.graphicsData.push(this.currentPath);

    return this;
};

/**
 * Draws a line using the current line style from the current drawing position to (x, y);
 * the current drawing position is then set to (x, y).
 *
 * @method lineTo
 * @param x {Number} the X coordinate to draw to
 * @param y {Number} the Y coordinate to draw to
 */
PIXI.Graphics.prototype.lineTo = function(x, y)
{
    this.currentPath.points.push(x, y);
    this.dirty = true;

    return this;
};

/**
 * Specifies a simple one-color fill that subsequent calls to other Graphics methods
 * (such as lineTo() or drawCircle()) use when drawing.
 *
 * @method beginFill
 * @param color {Number} the color of the fill
 * @param alpha {Number} the alpha of the fill
 */
PIXI.Graphics.prototype.beginFill = function(color, alpha)
{

    this.filling = true;
    this.fillColor = color || 0;
    this.fillAlpha = (arguments.length < 2) ? 1 : alpha;

    return this;
};

/**
 * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
 *
 * @method endFill
 */
PIXI.Graphics.prototype.endFill = function()
{
    this.filling = false;
    this.fillColor = null;
    this.fillAlpha = 1;

    return this;
};

/**
 * @method drawRect
 *
 * @param x {Number} The X coord of the top-left of the rectangle
 * @param y {Number} The Y coord of the top-left of the rectangle
 * @param width {Number} The width of the rectangle
 * @param height {Number} The height of the rectangle
 */
PIXI.Graphics.prototype.drawRect = function( x, y, width, height )
{
    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, width, height], type:PIXI.Graphics.RECT};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Draws a circle.
 *
 * @method drawCircle
 * @param x {Number} The X coordinate of the center of the circle
 * @param y {Number} The Y coordinate of the center of the circle
 * @param radius {Number} The radius of the circle
 */
PIXI.Graphics.prototype.drawCircle = function( x, y, radius)
{

    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, radius, radius], type:PIXI.Graphics.CIRC};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Draws an ellipse.
 *
 * @method drawEllipse
 * @param x {Number} The X coordinate of the upper-left corner of the framing rectangle of this ellipse
 * @param y {Number} The Y coordinate of the upper-left corner of the framing rectangle of this ellipse
 * @param width {Number} The width of the ellipse
 * @param height {Number} The height of the ellipse
 */
PIXI.Graphics.prototype.drawEllipse = function( x, y, width, height)
{

    if (!this.currentPath.points.length) this.graphicsData.pop();

    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,
                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,
                        points:[x, y, width, height], type:PIXI.Graphics.ELIP};

    this.graphicsData.push(this.currentPath);
    this.dirty = true;

    return this;
};

/**
 * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
 *
 * @method clear
 */
PIXI.Graphics.prototype.clear = function()
{
    this.lineWidth = 0;
    this.filling = false;

    this.dirty = true;
    this.clearDirty = true;
    this.graphicsData = [];

    this.bounds = null; //new PIXI.Rectangle();

    return this;
};

/**
 * Useful function that returns a texture of the graphics object that can then be used to create sprites
 * This can be quite useful if your geometry is complicated and needs to be reused multiple times.
 *
 * @method generateTexture
 * @return {Texture} a texture of the graphics object
 */
PIXI.Graphics.prototype.generateTexture = function()
{
    var bounds = this.getBounds();

    var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
    var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);

    canvasBuffer.context.translate(-bounds.x,-bounds.y);
    
    PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);

    return texture;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Graphics.prototype._renderWebGL = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;
    
    if(this._cacheAsBitmap)
    {
       
        if(this.dirty)
        {
            this._generateCachedSprite();
            // we will also need to update the texture on the gpu too!
            PIXI.updateWebGLTexture(this._cachedSprite.texture.baseTexture, renderSession.gl);
            
            this.dirty =  false;
        }

        this._cachedSprite.alpha = this.alpha;
        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);

        return;
    }
    else
    {
        renderSession.spriteBatch.stop();

        if(this._mask)renderSession.maskManager.pushMask(this.mask, renderSession);
        if(this._filters)renderSession.filterManager.pushFilter(this._filterBlock);
      
        // check blend mode
        if(this.blendMode !== renderSession.spriteBatch.currentBlendMode)
        {
            renderSession.spriteBatch.currentBlendMode = this.blendMode;
            var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];
            renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
        }
     
        PIXI.WebGLGraphics.renderGraphics(this, renderSession);
        
        // only render if it has children!
        if(this.children.length)
        {
            renderSession.spriteBatch.start();

             // simple render children!
            for(var i=0, j=this.children.length; i<j; i++)
            {
                this.children[i]._renderWebGL(renderSession);
            }

            renderSession.spriteBatch.stop();
        }

        if(this._filters)renderSession.filterManager.popFilter();
        if(this._mask)renderSession.maskManager.popMask(renderSession);
          
        renderSession.drawCount++;

        renderSession.spriteBatch.start();
    }
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.Graphics.prototype._renderCanvas = function(renderSession)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;
    
    var context = renderSession.context;
    var transform = this.worldTransform;
    
    if(this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
    PIXI.CanvasGraphics.renderGraphics(this, context);

     // simple render children!
    for(var i=0, j=this.children.length; i<j; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }
};

/**
 * Retrieves the bounds of the graphic shape as a rectangle object
 *
 * @method getBounds
 * @return {Rectangle} the rectangular bounding area
 */
PIXI.Graphics.prototype.getBounds = function( matrix )
{
    if(!this.bounds)this.updateBounds();

    var w0 = this.bounds.x;
    var w1 = this.bounds.width + this.bounds.x;

    var h0 = this.bounds.y;
    var h1 = this.bounds.height + this.bounds.y;

    var worldTransform = matrix || this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    minX = x1 < minX ? x1 : minX;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1 < minY ? y1 : minY;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1 > maxX ? x1 : maxX;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1 > maxY ? y1 : maxY;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    return bounds;
};

/**
 * Update the bounds of the object
 *
 * @method updateBounds
 */
PIXI.Graphics.prototype.updateBounds = function()
{
    
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    var points, x, y, w, h;

    for (var i = 0; i < this.graphicsData.length; i++) {
        var data = this.graphicsData[i];
        var type = data.type;
        var lineWidth = data.lineWidth;

        points = data.points;

        if(type === PIXI.Graphics.RECT)
        {
            x = points[0] - lineWidth/2;
            y = points[1] - lineWidth/2;
            w = points[2] + lineWidth;
            h = points[3] + lineWidth;

            minX = x < minX ? x : minX;
            maxX = x + w > maxX ? x + w : maxX;

            minY = y < minY ? x : minY;
            maxY = y + h > maxY ? y + h : maxY;
        }
        else if(type === PIXI.Graphics.CIRC || type === PIXI.Graphics.ELIP)
        {
            x = points[0];
            y = points[1];
            w = points[2] + lineWidth/2;
            h = points[3] + lineWidth/2;

            minX = x - w < minX ? x - w : minX;
            maxX = x + w > maxX ? x + w : maxX;

            minY = y - h < minY ? y - h : minY;
            maxY = y + h > maxY ? y + h : maxY;
        }
        else
        {
            // POLY
            for (var j = 0; j < points.length; j+=2)
            {

                x = points[j];
                y = points[j+1];
                minX = x-lineWidth < minX ? x-lineWidth : minX;
                maxX = x+lineWidth > maxX ? x+lineWidth : maxX;

                minY = y-lineWidth < minY ? y-lineWidth : minY;
                maxY = y+lineWidth > maxY ? y+lineWidth : maxY;
            }
        }
    }

    var padding = this.boundsPadding;
    this.bounds = new PIXI.Rectangle(minX - padding, minY - padding, (maxX - minX) + padding * 2, (maxY - minY) + padding * 2);
};


/**
 * Generates the cached sprite when the sprite has cacheAsBitmap = true
 *
 * @method _generateCachedSprite
 * @private
 */
PIXI.Graphics.prototype._generateCachedSprite = function()
{
    var bounds = this.getLocalBounds();

    if(!this._cachedSprite)
    {
        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
        
        this._cachedSprite = new PIXI.Sprite(texture);
        this._cachedSprite.buffer = canvasBuffer;

        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.buffer.resize(bounds.width, bounds.height);
    }

    // leverage the anchor to account for the offset of the element
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

   // this._cachedSprite.buffer.context.save();
    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);
    
    PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
    this._cachedSprite.alpha = this.alpha;

   // this._cachedSprite.buffer.context.restore();
};

PIXI.Graphics.prototype.destroyCachedSprite = function()
{
    this._cachedSprite.texture.destroy(true);

    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};


// SOME TYPES:
PIXI.Graphics.POLY = 0;
PIXI.Graphics.RECT = 1;
PIXI.Graphics.CIRC = 2;
PIXI.Graphics.ELIP = 3;

/**
 * @author Mat Groves http://matgroves.com/
 */

 /**
 * 
 * @class Strip
 * @extends DisplayObjectContainer
 * @constructor
 * @param texture {Texture} The texture to use
 * @param width {Number} the width 
 * @param height {Number} the height
 * 
 */
PIXI.Strip = function(texture, width, height)
{
    PIXI.DisplayObjectContainer.call( this );
    this.texture = texture;
    this.blendMode = PIXI.blendModes.NORMAL;

    try
    {
        this.uvs = new Float32Array([0, 1,
                1, 1,
                1, 0, 0,1]);

        this.verticies = new Float32Array([0, 0,
                          0,0,
                          0,0, 0,
                          0, 0]);

        this.colors = new Float32Array([1, 1, 1, 1]);

        this.indices = new Uint16Array([0, 1, 2, 3]);
    }
    catch(error)
    {
        this.uvs = [0, 1,
                1, 1,
                1, 0, 0,1];

        this.verticies = [0, 0,
                          0,0,
                          0,0, 0,
                          0, 0];

        this.colors = [1, 1, 1, 1];

        this.indices = [0, 1, 2, 3];
    }


    /*
    this.uvs = new Float32Array()
    this.verticies = new Float32Array()
    this.colors = new Float32Array()
    this.indices = new Uint16Array()
    */
    
    this.width = width;
    this.height = height;

    // load the texture!
    if(texture.baseTexture.hasLoaded)
    {
        this.width   = this.texture.frame.width;
        this.height  = this.texture.frame.height;
        this.updateFrame = true;
    }
    else
    {
        this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
        this.texture.addEventListener( 'update', this.onTextureUpdateBind );
    }

    this.renderable = true;
};

// constructor
PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.Strip.prototype.constructor = PIXI.Strip;

/*
 * Sets the texture that the Strip will use 
 *
 * @method setTexture
 * @param texture {Texture} the texture that will be used
 * @private
 */
PIXI.Strip.prototype.setTexture = function(texture)
{
    //TODO SET THE TEXTURES
    //TODO VISIBILITY

    // stop current texture
    this.texture = texture;
    this.width   = texture.frame.width;
    this.height  = texture.frame.height;
    this.updateFrame = true;
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */
PIXI.Strip.prototype.onTextureUpdate = function()
{
    this.updateFrame = true;
};
/* @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * 
 * @class Rope
 * @constructor
 * @param texture {Texture} The texture to use
 * @param points {Array}
 * 
 */
PIXI.Rope = function(texture, points)
{
    PIXI.Strip.call( this, texture );
    this.points = points;

    try
    {
        this.verticies = new Float32Array(points.length * 4);
        this.uvs = new Float32Array(points.length * 4);
        this.colors = new Float32Array(points.length * 2);
        this.indices = new Uint16Array(points.length * 2);
    }
    catch(error)
    {
        this.verticies = new Array(points.length * 4);
        this.uvs = new Array(points.length * 4);
        this.colors = new Array(points.length * 2);
        this.indices = new Array(points.length * 2);
    }

    this.refresh();
};


// constructor
PIXI.Rope.prototype = Object.create( PIXI.Strip.prototype );
PIXI.Rope.prototype.constructor = PIXI.Rope;

/*
 * Refreshes 
 *
 * @method refresh
 */
PIXI.Rope.prototype.refresh = function()
{
    var points = this.points;
    if(points.length < 1) return;

    var uvs = this.uvs;

    var lastPoint = points[0];
    var indices = this.indices;
    var colors = this.colors;

    this.count-=0.2;


    uvs[0] = 0;
    uvs[1] = 1;
    uvs[2] = 0;
    uvs[3] = 1;

    colors[0] = 1;
    colors[1] = 1;

    indices[0] = 0;
    indices[1] = 1;

    var total = points.length,
        point, index, amount;

    for (var i = 1; i < total; i++)
    {

        point = points[i];
        index = i * 4;
        // time to do some smart drawing!
        amount = i / (total-1);

        if(i%2)
        {
            uvs[index] = amount;
            uvs[index+1] = 0;

            uvs[index+2] = amount;
            uvs[index+3] = 1;

        }
        else
        {
            uvs[index] = amount;
            uvs[index+1] = 0;

            uvs[index+2] = amount;
            uvs[index+3] = 1;
        }

        index = i * 2;
        colors[index] = 1;
        colors[index+1] = 1;

        index = i * 2;
        indices[index] = index;
        indices[index + 1] = index + 1;

        lastPoint = point;
    }
};

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Rope.prototype.updateTransform = function()
{

    var points = this.points;
    if(points.length < 1)return;

    var lastPoint = points[0];
    var nextPoint;
    var perp = {x:0, y:0};

    this.count-=0.2;

    var verticies = this.verticies;
    verticies[0] = lastPoint.x + perp.x;
    verticies[1] = lastPoint.y + perp.y; //+ 200
    verticies[2] = lastPoint.x - perp.x;
    verticies[3] = lastPoint.y - perp.y;//+200
    // time to do some smart drawing!

    var total = points.length,
        point, index, ratio, perpLength, num;

    for (var i = 1; i < total; i++)
    {
        point = points[i];
        index = i * 4;

        if(i < points.length-1)
        {
            nextPoint = points[i+1];
        }
        else
        {
            nextPoint = point;
        }

        perp.y = -(nextPoint.x - lastPoint.x);
        perp.x = nextPoint.y - lastPoint.y;

        ratio = (1 - (i / (total-1))) * 10;

        if(ratio > 1) ratio = 1;

        perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);
        num = this.texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
        perp.x /= perpLength;
        perp.y /= perpLength;

        perp.x *= num;
        perp.y *= num;

        verticies[index] = point.x + perp.x;
        verticies[index+1] = point.y + perp.y;
        verticies[index+2] = point.x - perp.x;
        verticies[index+3] = point.y - perp.y;

        lastPoint = point;
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );
};
/*
 * Sets the texture that the Rope will use 
 *
 * @method setTexture
 * @param texture {Texture} the texture that will be used
 */
PIXI.Rope.prototype.setTexture = function(texture)
{
    // stop current texture
    this.texture = texture;
    this.updateFrame = true;
};

/**
 * @author Mat Groves http://matgroves.com/
 */

/**
 * A tiling sprite is a fast way of rendering a tiling image
 *
 * @class TilingSprite
 * @extends Sprite
 * @constructor
 * @param texture {Texture} the texture of the tiling sprite
 * @param width {Number}  the width of the tiling sprite
 * @param height {Number} the height of the tiling sprite
 */
PIXI.TilingSprite = function(texture, width, height)
{
    PIXI.Sprite.call( this, texture);

    /**
     * The with of the tiling sprite
     *
     * @property width
     * @type Number
     */
    this.width = width || 100;

    /**
     * The height of the tiling sprite
     *
     * @property height
     * @type Number
     */
    this.height = height || 100;

    /**
     * The scaling of the image that is being tiled
     *
     * @property tileScale
     * @type Point
     */
    this.tileScale = new PIXI.Point(1,1);

    /**
     * A point that represents the scale of the texture object
     *
     * @property tileScaleOffset
     * @type Point
     */
    this.tileScaleOffset = new PIXI.Point(1,1);
    
    /**
     * The offset position of the image that is being tiled
     *
     * @property tilePosition
     * @type Point
     */
    this.tilePosition = new PIXI.Point(0,0);


    /**
     * Whether this sprite is renderable or not
     *
     * @property renderable
     * @type Boolean
     * @default true
     */
    this.renderable = true;

    /**
     * The tint applied to the sprite. This is a hex value
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;
    
    /**
     * The blend mode to be applied to the sprite
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;
};

// constructor
PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);
PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;


/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.TilingSprite.prototype, 'width', {
    get: function() {
        return this._width;
    },
    set: function(value) {
        
        this._width = value;
    }
});

/**
 * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.TilingSprite.prototype, 'height', {
    get: function() {
        return  this._height;
    },
    set: function(value) {
        this._height = value;
    }
});

/**
 * When the texture is updated, this event will be fired to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */
PIXI.TilingSprite.prototype.onTextureUpdate = function()
{
    this.updateFrame = true;
};

PIXI.TilingSprite.prototype.setTexture = function(texture)
{
    if(this.texture === texture)return;

    this.texture = texture;

    this.refreshTexture = true;
    /*
    if(this.tilingTexture)
    {
        this.generateTilingTexture(true);
    }
*/

    /*
    // stop current texture;
    if(this.texture.baseTexture !== texture.baseTexture)
    {
        this.textureChange = true;
        this.texture = texture;
    }
    else
    {
        this.texture = texture;
    }

    this.updateFrame = true;*/
    this.cachedTint = 0xFFFFFF;
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.TilingSprite.prototype._renderWebGL = function(renderSession)
{

    if(this.visible === false || this.alpha === 0)return;
    
    var i,j;

    if(this.mask)
    {
        renderSession.spriteBatch.stop();
        renderSession.maskManager.pushMask(this.mask, renderSession);
        renderSession.spriteBatch.start();
    }

    if(this.filters)
    {
        renderSession.spriteBatch.flush();
        renderSession.filterManager.pushFilter(this._filterBlock);
    }


    if(!this.tilingTexture || this.refreshTexture)
    {
        this.generateTilingTexture(true);
        if(this.tilingTexture && this.tilingTexture.needsUpdate)
        {
            //TODO - tweaking
            PIXI.updateWebGLTexture(this.tilingTexture.baseTexture, renderSession.gl);
            this.tilingTexture.needsUpdate = false;
           // this.tilingTexture._uvs = null;
        }
    }
    else renderSession.spriteBatch.renderTilingSprite(this);
    

    // simple render children!
    for(i=0,j=this.children.length; i<j; i++)
    {
        this.children[i]._renderWebGL(renderSession);
    }

    renderSession.spriteBatch.stop();

    if(this.filters)renderSession.filterManager.popFilter();
    if(this.mask)renderSession.maskManager.popMask(renderSession);
    
    renderSession.spriteBatch.start();
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.TilingSprite.prototype._renderCanvas = function(renderSession)
{
    if(this.visible === false || this.alpha === 0)return;
    
    var context = renderSession.context;

    if(this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, context);
    }

    context.globalAlpha = this.worldAlpha;

    
    var transform = this.worldTransform;

    // allow for trimming
//(this.anchor.x) * -frame.width,
//                               (this.anchor.y) * -frame.height,

         
    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx , transform.ty);


    if(!this.__tilePattern ||  this.refreshTexture)
    {
        this.generateTilingTexture(false);
    
        if(this.tilingTexture)
        {
            this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, 'repeat');
        }
        else
        {
            return;
        }
    }

    // check blend mode
    if(this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    context.beginPath();

    var tilePosition = this.tilePosition;
    var tileScale = this.tileScale;

    tilePosition.x %= this.tilingTexture.baseTexture.width;
    tilePosition.y %= this.tilingTexture.baseTexture.height;

    // offset
    context.scale(tileScale.x,tileScale.y);
    context.translate(tilePosition.x, tilePosition.y);

    context.fillStyle = this.__tilePattern;

    // make sure to account for the anchor point..
    context.fillRect(-tilePosition.x + (this.anchor.x * -this._width),-tilePosition.y + (this.anchor.y * -this._height),
                        this._width / tileScale.x, this._height / tileScale.y);

    context.scale(1/tileScale.x, 1/tileScale.y);
    context.translate(-tilePosition.x, -tilePosition.y);

    context.closePath();

    if(this._mask)
    {
        renderSession.maskManager.popMask(renderSession.context);
    }
};


/**
* Returns the framing rectangle of the sprite as a PIXI.Rectangle object
*
* @method getBounds
* @return {Rectangle} the framing rectangle
*/
PIXI.TilingSprite.prototype.getBounds = function()
{

    var width = this._width;
    var height = this._height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.c;
    var c = worldTransform.b;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;
    
    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    minX = x1 < minX ? x1 : minX;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1 < minY ? y1 : minY;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1 > maxX ? x1 : maxX;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1 > maxY ? y1 : maxY;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
* 
* @method generateTilingTexture
* 
* @param forcePowerOfTwo {Boolean} Whether we want to force the texture to be a power of two
*/
PIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo)
{
    var texture = this.texture;

    if(!texture.baseTexture.hasLoaded)return;

    var baseTexture = texture.baseTexture;
    var frame = texture.frame;

    var targetWidth, targetHeight;

    // check that the frame is the same size as the base texture.
    var isFrame = frame.width !== baseTexture.width || frame.height !== baseTexture.height;

    var newTextureRequired = false;

    if(!forcePowerOfTwo)
    {
        if(isFrame)
        {
            targetWidth = frame.width;
            targetHeight = frame.height;
           
            newTextureRequired = true;
            
        }
    }
    else
    {
        targetWidth = PIXI.getNextPowerOfTwo(frame.width);
        targetHeight = PIXI.getNextPowerOfTwo(frame.height);
        if(frame.width !== targetWidth && frame.height !== targetHeight)newTextureRequired = true;
    }

    if(newTextureRequired)
    {
        var canvasBuffer;

        if(this.tilingTexture && this.tilingTexture.isTiling)
        {
            canvasBuffer = this.tilingTexture.canvasBuffer;
            canvasBuffer.resize(targetWidth, targetHeight);
            this.tilingTexture.baseTexture.width = targetWidth;
            this.tilingTexture.baseTexture.height = targetHeight;
            this.tilingTexture.needsUpdate = true;
        }
        else
        {
            canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);

            this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
            this.tilingTexture.canvasBuffer = canvasBuffer;
            this.tilingTexture.isTiling = true;

        }
        
        canvasBuffer.context.drawImage(texture.baseTexture.source,
                                           frame.x,
                                           frame.y,
                                           frame.width,
                                           frame.height,
                                           0,
                                           0,
                                           targetWidth,
                                           targetHeight);

        this.tileScaleOffset.x = frame.width / targetWidth;
        this.tileScaleOffset.y = frame.height / targetHeight;

    }
    else
    {
        //TODO - switching?
        if(this.tilingTexture && this.tilingTexture.isTiling)
        {
            // destroy the tiling texture!
            // TODO could store this somewhere?
            this.tilingTexture.destroy(true);
        }

        this.tileScaleOffset.x = 1;
        this.tileScaleOffset.y = 1;
        this.tilingTexture = texture;
    }
    this.refreshTexture = false;
    this.tilingTexture.baseTexture._powerOf2 = true;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi
 *
 * Awesome JS run time provided by EsotericSoftware
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */

/*
 * Awesome JS run time provided by EsotericSoftware
 *
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */



var spine = {};

spine.BoneData = function (name, parent) {
    this.name = name;
    this.parent = parent;
};
spine.BoneData.prototype = {
    length: 0,
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1
};

spine.SlotData = function (name, boneData) {
    this.name = name;
    this.boneData = boneData;
};
spine.SlotData.prototype = {
    r: 1, g: 1, b: 1, a: 1,
    attachmentName: null
};

spine.Bone = function (boneData, parent) {
    this.data = boneData;
    this.parent = parent;
    this.setToSetupPose();
};
spine.Bone.yDown = false;
spine.Bone.prototype = {
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1,
    m00: 0, m01: 0, worldX: 0, // a b x
    m10: 0, m11: 0, worldY: 0, // c d y
    worldRotation: 0,
    worldScaleX: 1, worldScaleY: 1,
    updateWorldTransform: function (flipX, flipY) {
        var parent = this.parent;
        if (parent != null) {
            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
            this.worldScaleX = parent.worldScaleX * this.scaleX;
            this.worldScaleY = parent.worldScaleY * this.scaleY;
            this.worldRotation = parent.worldRotation + this.rotation;
        } else {
            this.worldX = this.x;
            this.worldY = this.y;
            this.worldScaleX = this.scaleX;
            this.worldScaleY = this.scaleY;
            this.worldRotation = this.rotation;
        }
        var radians = this.worldRotation * Math.PI / 180;
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        this.m00 = cos * this.worldScaleX;
        this.m10 = sin * this.worldScaleX;
        this.m01 = -sin * this.worldScaleY;
        this.m11 = cos * this.worldScaleY;
        if (flipX) {
            this.m00 = -this.m00;
            this.m01 = -this.m01;
        }
        if (flipY) {
            this.m10 = -this.m10;
            this.m11 = -this.m11;
        }
        if (spine.Bone.yDown) {
            this.m10 = -this.m10;
            this.m11 = -this.m11;
        }
    },
    setToSetupPose: function () {
        var data = this.data;
        this.x = data.x;
        this.y = data.y;
        this.rotation = data.rotation;
        this.scaleX = data.scaleX;
        this.scaleY = data.scaleY;
    }
};

spine.Slot = function (slotData, skeleton, bone) {
    this.data = slotData;
    this.skeleton = skeleton;
    this.bone = bone;
    this.setToSetupPose();
};
spine.Slot.prototype = {
    r: 1, g: 1, b: 1, a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function (attachment) {
        this.attachment = attachment;
        this._attachmentTime = this.skeleton.time;
    },
    setAttachmentTime: function (time) {
        this._attachmentTime = this.skeleton.time - time;
    },
    getAttachmentTime: function () {
        return this.skeleton.time - this._attachmentTime;
    },
    setToSetupPose: function () {
        var data = this.data;
        this.r = data.r;
        this.g = data.g;
        this.b = data.b;
        this.a = data.a;

        var slotDatas = this.skeleton.data.slots;
        for (var i = 0, n = slotDatas.length; i < n; i++) {
            if (slotDatas[i] == data) {
                this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
                break;
            }
        }
    }
};

spine.Skin = function (name) {
    this.name = name;
    this.attachments = {};
};
spine.Skin.prototype = {
    addAttachment: function (slotIndex, name, attachment) {
        this.attachments[slotIndex + ":" + name] = attachment;
    },
    getAttachment: function (slotIndex, name) {
        return this.attachments[slotIndex + ":" + name];
    },
    _attachAll: function (skeleton, oldSkin) {
        for (var key in oldSkin.attachments) {
            var colon = key.indexOf(":");
            var slotIndex = parseInt(key.substring(0, colon), 10);
            var name = key.substring(colon + 1);
            var slot = skeleton.slots[slotIndex];
            if (slot.attachment && slot.attachment.name == name) {
                var attachment = this.getAttachment(slotIndex, name);
                if (attachment) slot.setAttachment(attachment);
            }
        }
    }
};

spine.Animation = function (name, timelines, duration) {
    this.name = name;
    this.timelines = timelines;
    this.duration = duration;
};
spine.Animation.prototype = {
    apply: function (skeleton, time, loop) {
        if (loop && this.duration) time %= this.duration;
        var timelines = this.timelines;
        for (var i = 0, n = timelines.length; i < n; i++)
            timelines[i].apply(skeleton, time, 1);
    },
    mix: function (skeleton, time, loop, alpha) {
        if (loop && this.duration) time %= this.duration;
        var timelines = this.timelines;
        for (var i = 0, n = timelines.length; i < n; i++)
            timelines[i].apply(skeleton, time, alpha);
    }
};

spine.binarySearch = function (values, target, step) {
    var low = 0;
    var high = Math.floor(values.length / step) - 2;
    if (!high) return step;
    var current = high >>> 1;
    while (true) {
        if (values[(current + 1) * step] <= target)
            low = current + 1;
        else
            high = current;
        if (low == high) return (low + 1) * step;
        current = (low + high) >>> 1;
    }
};
spine.linearSearch = function (values, target, step) {
    for (var i = 0, last = values.length - step; i <= last; i += step)
        if (values[i] > target) return i;
    return -1;
};

spine.Curves = function (frameCount) {
    this.curves = []; // dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...
    this.curves.length = (frameCount - 1) * 6;
};
spine.Curves.prototype = {
    setLinear: function (frameIndex) {
        this.curves[frameIndex * 6] = 0/*LINEAR*/;
    },
    setStepped: function (frameIndex) {
        this.curves[frameIndex * 6] = -1/*STEPPED*/;
    },
    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
     * the difference between the keyframe's values. */
    setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
        var subdiv_step = 1 / 10/*BEZIER_SEGMENTS*/;
        var subdiv_step2 = subdiv_step * subdiv_step;
        var subdiv_step3 = subdiv_step2 * subdiv_step;
        var pre1 = 3 * subdiv_step;
        var pre2 = 3 * subdiv_step2;
        var pre4 = 6 * subdiv_step2;
        var pre5 = 6 * subdiv_step3;
        var tmp1x = -cx1 * 2 + cx2;
        var tmp1y = -cy1 * 2 + cy2;
        var tmp2x = (cx1 - cx2) * 3 + 1;
        var tmp2y = (cy1 - cy2) * 3 + 1;
        var i = frameIndex * 6;
        var curves = this.curves;
        curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
        curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
        curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
        curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
        curves[i + 4] = tmp2x * pre5;
        curves[i + 5] = tmp2y * pre5;
    },
    getCurvePercent: function (frameIndex, percent) {
        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);
        var curveIndex = frameIndex * 6;
        var curves = this.curves;
        var dfx = curves[curveIndex];
        if (!dfx/*LINEAR*/) return percent;
        if (dfx == -1/*STEPPED*/) return 0;
        var dfy = curves[curveIndex + 1];
        var ddfx = curves[curveIndex + 2];
        var ddfy = curves[curveIndex + 3];
        var dddfx = curves[curveIndex + 4];
        var dddfy = curves[curveIndex + 5];
        var x = dfx, y = dfy;
        var i = 10/*BEZIER_SEGMENTS*/ - 2;
        while (true) {
            if (x >= percent) {
                var lastX = x - dfx;
                var lastY = y - dfy;
                return lastY + (y - lastY) * (percent - lastX) / (x - lastX);
            }
            if (!i) break;
            i--;
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            x += dfx;
            y += dfy;
        }
        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
    }
};

spine.RotateTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, angle, ...
    this.frames.length = frameCount * 2;
};
spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 2;
    },
    setFrame: function (frameIndex, time, angle) {
        frameIndex *= 2;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = angle;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames,
            amount;

        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 2]) { // Time is after last frame.
            amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
            while (amount > 180)
                amount -= 360;
            while (amount < -180)
                amount += 360;
            bone.rotation += amount * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 2);
        var lastFrameValue = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);

        amount = frames[frameIndex + 1/*FRAME_VALUE*/] - lastFrameValue;
        while (amount > 180)
            amount -= 360;
        while (amount < -180)
            amount += 360;
        amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;
        while (amount > 180)
            amount -= 360;
        while (amount < -180)
            amount += 360;
        bone.rotation += amount * alpha;
    }
};

spine.TranslateTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y) {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3]) { // Time is after last frame.
            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 3);
        var lastFrameX = frames[frameIndex - 2];
        var lastFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.x) * alpha;
        bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.y) * alpha;
    }
};

spine.ScaleTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, x, y, ...
    this.frames.length = frameCount * 3;
};
spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 3;
    },
    setFrame: function (frameIndex, time, x, y) {
        frameIndex *= 3;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = x;
        this.frames[frameIndex + 2] = y;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3]) { // Time is after last frame.
            bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 3);
        var lastFrameX = frames[frameIndex - 2];
        var lastFrameY = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

        bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.scaleX) * alpha;
        bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.scaleY) * alpha;
    }
};

spine.ColorTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, r, g, b, a, ...
    this.frames.length = frameCount * 5;
};
spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function () {
        return this.frames.length / 2;
    },
    setFrame: function (frameIndex, time, x, y) {
        frameIndex *= 5;
        this.frames[frameIndex] = time;
        this.frames[frameIndex + 1] = r;
        this.frames[frameIndex + 2] = g;
        this.frames[frameIndex + 3] = b;
        this.frames[frameIndex + 4] = a;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var slot = skeleton.slots[this.slotIndex];

        if (time >= frames[frames.length - 5]) { // Time is after last frame.
            var i = frames.length - 1;
            slot.r = frames[i - 3];
            slot.g = frames[i - 2];
            slot.b = frames[i - 1];
            slot.a = frames[i];
            return;
        }

        // Interpolate between the last frame and the current frame.
        var frameIndex = spine.binarySearch(frames, time, 5);
        var lastFrameR = frames[frameIndex - 4];
        var lastFrameG = frames[frameIndex - 3];
        var lastFrameB = frames[frameIndex - 2];
        var lastFrameA = frames[frameIndex - 1];
        var frameTime = frames[frameIndex];
        var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*LAST_FRAME_TIME*/] - frameTime);
        percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);

        var r = lastFrameR + (frames[frameIndex + 1/*FRAME_R*/] - lastFrameR) * percent;
        var g = lastFrameG + (frames[frameIndex + 2/*FRAME_G*/] - lastFrameG) * percent;
        var b = lastFrameB + (frames[frameIndex + 3/*FRAME_B*/] - lastFrameB) * percent;
        var a = lastFrameA + (frames[frameIndex + 4/*FRAME_A*/] - lastFrameA) * percent;
        if (alpha < 1) {
            slot.r += (r - slot.r) * alpha;
            slot.g += (g - slot.g) * alpha;
            slot.b += (b - slot.b) * alpha;
            slot.a += (a - slot.a) * alpha;
        } else {
            slot.r = r;
            slot.g = g;
            slot.b = b;
            slot.a = a;
        }
    }
};

spine.AttachmentTimeline = function (frameCount) {
    this.curves = new spine.Curves(frameCount);
    this.frames = []; // time, ...
    this.frames.length = frameCount;
    this.attachmentNames = []; // time, ...
    this.attachmentNames.length = frameCount;
};
spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function () {
            return this.frames.length;
    },
    setFrame: function (frameIndex, time, attachmentName) {
        this.frames[frameIndex] = time;
        this.attachmentNames[frameIndex] = attachmentName;
    },
    apply: function (skeleton, time, alpha) {
        var frames = this.frames;
        if (time < frames[0]) return; // Time is before first frame.

        var frameIndex;
        if (time >= frames[frames.length - 1]) // Time is after last frame.
            frameIndex = frames.length - 1;
        else
            frameIndex = spine.binarySearch(frames, time, 1) - 1;

        var attachmentName = this.attachmentNames[frameIndex];
        skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
    }
};

spine.SkeletonData = function () {
    this.bones = [];
    this.slots = [];
    this.skins = [];
    this.animations = [];
};
spine.SkeletonData.prototype = {
    defaultSkin: null,
    /** @return May be null. */
    findBone: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].name == boneName) return bones[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].name == boneName) return i;
        return -1;
    },
    /** @return May be null. */
    findSlot: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++) {
            if (slots[i].name == slotName) return slot[i];
        }
        return null;
    },
    /** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].name == slotName) return i;
        return -1;
    },
    /** @return May be null. */
    findSkin: function (skinName) {
        var skins = this.skins;
        for (var i = 0, n = skins.length; i < n; i++)
            if (skins[i].name == skinName) return skins[i];
        return null;
    },
    /** @return May be null. */
    findAnimation: function (animationName) {
        var animations = this.animations;
        for (var i = 0, n = animations.length; i < n; i++)
            if (animations[i].name == animationName) return animations[i];
        return null;
    }
};

spine.Skeleton = function (skeletonData) {
    this.data = skeletonData;

    this.bones = [];
    for (var i = 0, n = skeletonData.bones.length; i < n; i++) {
        var boneData = skeletonData.bones[i];
        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
        this.bones.push(new spine.Bone(boneData, parent));
    }

    this.slots = [];
    this.drawOrder = [];
    for (i = 0, n = skeletonData.slots.length; i < n; i++) {
        var slotData = skeletonData.slots[i];
        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
        var slot = new spine.Slot(slotData, this, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
    }
};
spine.Skeleton.prototype = {
    x: 0, y: 0,
    skin: null,
    r: 1, g: 1, b: 1, a: 1,
    time: 0,
    flipX: false, flipY: false,
    /** Updates the world transform for each bone. */
    updateWorldTransform: function () {
        var flipX = this.flipX;
        var flipY = this.flipY;
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            bones[i].updateWorldTransform(flipX, flipY);
    },
    /** Sets the bones and slots to their setup pose values. */
    setToSetupPose: function () {
        this.setBonesToSetupPose();
        this.setSlotsToSetupPose();
    },
    setBonesToSetupPose: function () {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            bones[i].setToSetupPose();
    },
    setSlotsToSetupPose: function () {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            slots[i].setToSetupPose(i);
    },
    /** @return May return null. */
    getRootBone: function () {
        return this.bones.length ? this.bones[0] : null;
    },
    /** @return May be null. */
    findBone: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].data.name == boneName) return bones[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName) {
        var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
            if (bones[i].data.name == boneName) return i;
        return -1;
    },
    /** @return May be null. */
    findSlot: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].data.name == slotName) return slots[i];
        return null;
    },
    /** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName) {
        var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
            if (slots[i].data.name == slotName) return i;
        return -1;
    },
    setSkinByName: function (skinName) {
        var skin = this.data.findSkin(skinName);
        if (!skin) throw "Skin not found: " + skinName;
        this.setSkin(skin);
    },
    /** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments
     * from the new skin are attached if the corresponding attachment from the old skin was attached.
     * @param newSkin May be null. */
    setSkin: function (newSkin) {
        if (this.skin && newSkin) newSkin._attachAll(this, this.skin);
        this.skin = newSkin;
    },
    /** @return May be null. */
    getAttachmentBySlotName: function (slotName, attachmentName) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
    },
    /** @return May be null. */
    getAttachmentBySlotIndex: function (slotIndex, attachmentName) {
        if (this.skin) {
            var attachment = this.skin.getAttachment(slotIndex, attachmentName);
            if (attachment) return attachment;
        }
        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
        return null;
    },
    /** @param attachmentName May be null. */
    setAttachment: function (slotName, attachmentName) {
        var slots = this.slots;
        for (var i = 0, n = slots.size; i < n; i++) {
            var slot = slots[i];
            if (slot.data.name == slotName) {
                var attachment = null;
                if (attachmentName) {
                    attachment = this.getAttachment(i, attachmentName);
                    if (attachment == null) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName;
                }
                slot.setAttachment(attachment);
                return;
            }
        }
        throw "Slot not found: " + slotName;
    },
    update: function (delta) {
        time += delta;
    }
};

spine.AttachmentType = {
    region: 0
};

spine.RegionAttachment = function () {
    this.offset = [];
    this.offset.length = 8;
    this.uvs = [];
    this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
    x: 0, y: 0,
    rotation: 0,
    scaleX: 1, scaleY: 1,
    width: 0, height: 0,
    rendererObject: null,
    regionOffsetX: 0, regionOffsetY: 0,
    regionWidth: 0, regionHeight: 0,
    regionOriginalWidth: 0, regionOriginalHeight: 0,
    setUVs: function (u, v, u2, v2, rotate) {
        var uvs = this.uvs;
        if (rotate) {
            uvs[2/*X2*/] = u;
            uvs[3/*Y2*/] = v2;
            uvs[4/*X3*/] = u;
            uvs[5/*Y3*/] = v;
            uvs[6/*X4*/] = u2;
            uvs[7/*Y4*/] = v;
            uvs[0/*X1*/] = u2;
            uvs[1/*Y1*/] = v2;
        } else {
            uvs[0/*X1*/] = u;
            uvs[1/*Y1*/] = v2;
            uvs[2/*X2*/] = u;
            uvs[3/*Y2*/] = v;
            uvs[4/*X3*/] = u2;
            uvs[5/*Y3*/] = v;
            uvs[6/*X4*/] = u2;
            uvs[7/*Y4*/] = v2;
        }
    },
    updateOffset: function () {
        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
        var localX2 = localX + this.regionWidth * regionScaleX;
        var localY2 = localY + this.regionHeight * regionScaleY;
        var radians = this.rotation * Math.PI / 180;
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        var localXCos = localX * cos + this.x;
        var localXSin = localX * sin;
        var localYCos = localY * cos + this.y;
        var localYSin = localY * sin;
        var localX2Cos = localX2 * cos + this.x;
        var localX2Sin = localX2 * sin;
        var localY2Cos = localY2 * cos + this.y;
        var localY2Sin = localY2 * sin;
        var offset = this.offset;
        offset[0/*X1*/] = localXCos - localYSin;
        offset[1/*Y1*/] = localYCos + localXSin;
        offset[2/*X2*/] = localXCos - localY2Sin;
        offset[3/*Y2*/] = localY2Cos + localXSin;
        offset[4/*X3*/] = localX2Cos - localY2Sin;
        offset[5/*Y3*/] = localY2Cos + localX2Sin;
        offset[6/*X4*/] = localX2Cos - localYSin;
        offset[7/*Y4*/] = localYCos + localX2Sin;
    },
    computeVertices: function (x, y, bone, vertices) {
        x += bone.worldX;
        y += bone.worldY;
        var m00 = bone.m00;
        var m01 = bone.m01;
        var m10 = bone.m10;
        var m11 = bone.m11;
        var offset = this.offset;
        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;
        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;
        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;
        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;
        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;
        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;
        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;
        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;
    }
}

spine.AnimationStateData = function (skeletonData) {
    this.skeletonData = skeletonData;
    this.animationToMixTime = {};
};
spine.AnimationStateData.prototype = {
        defaultMix: 0,
    setMixByName: function (fromName, toName, duration) {
        var from = this.skeletonData.findAnimation(fromName);
        if (!from) throw "Animation not found: " + fromName;
        var to = this.skeletonData.findAnimation(toName);
        if (!to) throw "Animation not found: " + toName;
        this.setMix(from, to, duration);
    },
    setMix: function (from, to, duration) {
        this.animationToMixTime[from.name + ":" + to.name] = duration;
    },
    getMix: function (from, to) {
        var time = this.animationToMixTime[from.name + ":" + to.name];
            return time ? time : this.defaultMix;
    }
};

spine.AnimationState = function (stateData) {
    this.data = stateData;
    this.queue = [];
};
spine.AnimationState.prototype = {
    current: null,
    previous: null,
    currentTime: 0,
    previousTime: 0,
    currentLoop: false,
    previousLoop: false,
    mixTime: 0,
    mixDuration: 0,
    update: function (delta) {
        this.currentTime += delta;
        this.previousTime += delta;
        this.mixTime += delta;

        if (this.queue.length > 0) {
            var entry = this.queue[0];
            if (this.currentTime >= entry.delay) {
                this._setAnimation(entry.animation, entry.loop);
                this.queue.shift();
            }
        }
    },
    apply: function (skeleton) {
        if (!this.current) return;
        if (this.previous) {
            this.previous.apply(skeleton, this.previousTime, this.previousLoop);
            var alpha = this.mixTime / this.mixDuration;
            if (alpha >= 1) {
                alpha = 1;
                this.previous = null;
            }
            this.current.mix(skeleton, this.currentTime, this.currentLoop, alpha);
        } else
            this.current.apply(skeleton, this.currentTime, this.currentLoop);
    },
    clearAnimation: function () {
        this.previous = null;
        this.current = null;
        this.queue.length = 0;
    },
    _setAnimation: function (animation, loop) {
        this.previous = null;
        if (animation && this.current) {
            this.mixDuration = this.data.getMix(this.current, animation);
            if (this.mixDuration > 0) {
                this.mixTime = 0;
                this.previous = this.current;
                this.previousTime = this.currentTime;
                this.previousLoop = this.currentLoop;
            }
        }
        this.current = animation;
        this.currentLoop = loop;
        this.currentTime = 0;
    },
    /** @see #setAnimation(Animation, Boolean) */
    setAnimationByName: function (animationName, loop) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation) throw "Animation not found: " + animationName;
        this.setAnimation(animation, loop);
    },
    /** Set the current animation. Any queued animations are cleared and the current animation time is set to 0.
     * @param animation May be null. */
    setAnimation: function (animation, loop) {
        this.queue.length = 0;
        this._setAnimation(animation, loop);
    },
    /** @see #addAnimation(Animation, Boolean, Number) */
    addAnimationByName: function (animationName, loop, delay) {
        var animation = this.data.skeletonData.findAnimation(animationName);
        if (!animation) throw "Animation not found: " + animationName;
        this.addAnimation(animation, loop, delay);
    },
    /** Adds an animation to be played delay seconds after the current or last queued animation.
     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */
    addAnimation: function (animation, loop, delay) {
        var entry = {};
        entry.animation = animation;
        entry.loop = loop;

        if (!delay || delay <= 0) {
            var previousAnimation = this.queue.length ? this.queue[this.queue.length - 1].animation : this.current;
            if (previousAnimation != null)
                delay = previousAnimation.duration - this.data.getMix(previousAnimation, animation) + (delay || 0);
            else
                delay = 0;
        }
        entry.delay = delay;

        this.queue.push(entry);
    },
    /** Returns true if no animation is set or if the current time is greater than the animation duration, regardless of looping. */
    isComplete: function () {
        return !this.current || this.currentTime >= this.current.duration;
    }
};

spine.SkeletonJson = function (attachmentLoader) {
    this.attachmentLoader = attachmentLoader;
};
spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function (root) {
        /*jshint -W069*/
        var skeletonData = new spine.SkeletonData(),
            boneData;

        // Bones.
        var bones = root["bones"];
        for (var i = 0, n = bones.length; i < n; i++) {
            var boneMap = bones[i];
            var parent = null;
            if (boneMap["parent"]) {
                parent = skeletonData.findBone(boneMap["parent"]);
                if (!parent) throw "Parent bone not found: " + boneMap["parent"];
            }
            boneData = new spine.BoneData(boneMap["name"], parent);
            boneData.length = (boneMap["length"] || 0) * this.scale;
            boneData.x = (boneMap["x"] || 0) * this.scale;
            boneData.y = (boneMap["y"] || 0) * this.scale;
            boneData.rotation = (boneMap["rotation"] || 0);
            boneData.scaleX = boneMap["scaleX"] || 1;
            boneData.scaleY = boneMap["scaleY"] || 1;
            skeletonData.bones.push(boneData);
        }

        // Slots.
        var slots = root["slots"];
        for (i = 0, n = slots.length; i < n; i++) {
            var slotMap = slots[i];
            boneData = skeletonData.findBone(slotMap["bone"]);
            if (!boneData) throw "Slot bone not found: " + slotMap["bone"];
            var slotData = new spine.SlotData(slotMap["name"], boneData);

            var color = slotMap["color"];
            if (color) {
                slotData.r = spine.SkeletonJson.toColor(color, 0);
                slotData.g = spine.SkeletonJson.toColor(color, 1);
                slotData.b = spine.SkeletonJson.toColor(color, 2);
                slotData.a = spine.SkeletonJson.toColor(color, 3);
            }

            slotData.attachmentName = slotMap["attachment"];

            skeletonData.slots.push(slotData);
        }

        // Skins.
        var skins = root["skins"];
        for (var skinName in skins) {
            if (!skins.hasOwnProperty(skinName)) continue;
            var skinMap = skins[skinName];
            var skin = new spine.Skin(skinName);
            for (var slotName in skinMap) {
                if (!skinMap.hasOwnProperty(slotName)) continue;
                var slotIndex = skeletonData.findSlotIndex(slotName);
                var slotEntry = skinMap[slotName];
                for (var attachmentName in slotEntry) {
                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;
                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
                    if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);
                }
            }
            skeletonData.skins.push(skin);
            if (skin.name == "default") skeletonData.defaultSkin = skin;
        }

        // Animations.
        var animations = root["animations"];
        for (var animationName in animations) {
            if (!animations.hasOwnProperty(animationName)) continue;
            this.readAnimation(animationName, animations[animationName], skeletonData);
        }

        return skeletonData;
    },
    readAttachment: function (skin, name, map) {
        /*jshint -W069*/
        name = map["name"] || name;

        var type = spine.AttachmentType[map["type"] || "region"];

        if (type == spine.AttachmentType.region) {
            var attachment = new spine.RegionAttachment();
            attachment.x = (map["x"] || 0) * this.scale;
            attachment.y = (map["y"] || 0) * this.scale;
            attachment.scaleX = map["scaleX"] || 1;
            attachment.scaleY = map["scaleY"] || 1;
            attachment.rotation = map["rotation"] || 0;
            attachment.width = (map["width"] || 32) * this.scale;
            attachment.height = (map["height"] || 32) * this.scale;
            attachment.updateOffset();

            attachment.rendererObject = {};
            attachment.rendererObject.name = name;
            attachment.rendererObject.scale = {};
            attachment.rendererObject.scale.x = attachment.scaleX;
            attachment.rendererObject.scale.y = attachment.scaleY;
            attachment.rendererObject.rotation = -attachment.rotation * Math.PI / 180;
            return attachment;
        }

            throw "Unknown attachment type: " + type;
    },

    readAnimation: function (name, map, skeletonData) {
        /*jshint -W069*/
        var timelines = [];
        var duration = 0;
        var frameIndex, timeline, timelineName, valueMap, values,
            i, n;

        var bones = map["bones"];
        for (var boneName in bones) {
            if (!bones.hasOwnProperty(boneName)) continue;
            var boneIndex = skeletonData.findBoneIndex(boneName);
            if (boneIndex == -1) throw "Bone not found: " + boneName;
            var boneMap = bones[boneName];

            for (timelineName in boneMap) {
                if (!boneMap.hasOwnProperty(timelineName)) continue;
                values = boneMap[timelineName];
                if (timelineName == "rotate") {
                    timeline = new spine.RotateTimeline(values.length);
                    timeline.boneIndex = boneIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);

                } else if (timelineName == "translate" || timelineName == "scale") {
                    var timelineScale = 1;
                    if (timelineName == "scale")
                        timeline = new spine.ScaleTimeline(values.length);
                    else {
                        timeline = new spine.TranslateTimeline(values.length);
                        timelineScale = this.scale;
                    }
                    timeline.boneIndex = boneIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        var x = (valueMap["x"] || 0) * timelineScale;
                        var y = (valueMap["y"] || 0) * timelineScale;
                        timeline.setFrame(frameIndex, valueMap["time"], x, y);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);

                } else
                    throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
            }
        }
        var slots = map["slots"];
        for (var slotName in slots) {
            if (!slots.hasOwnProperty(slotName)) continue;
            var slotMap = slots[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);

            for (timelineName in slotMap) {
                if (!slotMap.hasOwnProperty(timelineName)) continue;
                values = slotMap[timelineName];
                if (timelineName == "color") {
                    timeline = new spine.ColorTimeline(values.length);
                    timeline.slotIndex = slotIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        var color = valueMap["color"];
                        var r = spine.SkeletonJson.toColor(color, 0);
                        var g = spine.SkeletonJson.toColor(color, 1);
                        var b = spine.SkeletonJson.toColor(color, 2);
                        var a = spine.SkeletonJson.toColor(color, 3);
                        timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
                        spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
                        frameIndex++;
                    }
                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);

                } else if (timelineName == "attachment") {
                    timeline = new spine.AttachmentTimeline(values.length);
                    timeline.slotIndex = slotIndex;

                    frameIndex = 0;
                    for (i = 0, n = values.length; i < n; i++) {
                        valueMap = values[i];
                        timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
                    }
                    timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);

                } else
                    throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
            }
        }
        skeletonData.animations.push(new spine.Animation(name, timelines, duration));
    }
};
spine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {
    /*jshint -W069*/
    var curve = valueMap["curve"];
    if (!curve) return;
    if (curve == "stepped")
        timeline.curves.setStepped(frameIndex);
    else if (curve instanceof Array)
        timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
};
spine.SkeletonJson.toColor = function (hexString, colorIndex) {
    if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString;
    return parseInt(hexString.substring(colorIndex * 2, 2), 16) / 255;
};

spine.Atlas = function (atlasText, textureLoader) {
    this.textureLoader = textureLoader;
    this.pages = [];
    this.regions = [];

    var reader = new spine.AtlasReader(atlasText);
    var tuple = [];
    tuple.length = 4;
    var page = null;
    while (true) {
        var line = reader.readLine();
        if (line == null) break;
        line = reader.trim(line);
        if (!line.length)
            page = null;
        else if (!page) {
            page = new spine.AtlasPage();
            page.name = line;

            page.format = spine.Atlas.Format[reader.readValue()];

            reader.readTuple(tuple);
            page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
            page.magFilter = spine.Atlas.TextureFilter[tuple[1]];

            var direction = reader.readValue();
            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
            if (direction == "x")
                page.uWrap = spine.Atlas.TextureWrap.repeat;
            else if (direction == "y")
                page.vWrap = spine.Atlas.TextureWrap.repeat;
            else if (direction == "xy")
                page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;

            textureLoader.load(page, line);

            this.pages.push(page);

        } else {
            var region = new spine.AtlasRegion();
            region.name = line;
            region.page = page;

            region.rotate = reader.readValue() == "true";

            reader.readTuple(tuple);
            var x = parseInt(tuple[0], 10);
            var y = parseInt(tuple[1], 10);

            reader.readTuple(tuple);
            var width = parseInt(tuple[0], 10);
            var height = parseInt(tuple[1], 10);

            region.u = x / page.width;
            region.v = y / page.height;
            if (region.rotate) {
                region.u2 = (x + height) / page.width;
                region.v2 = (y + width) / page.height;
            } else {
                region.u2 = (x + width) / page.width;
                region.v2 = (y + height) / page.height;
            }
            region.x = x;
            region.y = y;
            region.width = Math.abs(width);
            region.height = Math.abs(height);

            if (reader.readTuple(tuple) == 4) { // split is optional
                region.splits = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];

                if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits
                    region.pads = [parseInt(tuple[0], 10), parseInt(tuple[1], 10), parseInt(tuple[2], 10), parseInt(tuple[3], 10)];

                    reader.readTuple(tuple);
                }
            }

            region.originalWidth = parseInt(tuple[0], 10);
            region.originalHeight = parseInt(tuple[1], 10);

            reader.readTuple(tuple);
            region.offsetX = parseInt(tuple[0], 10);
            region.offsetY = parseInt(tuple[1], 10);

            region.index = parseInt(reader.readValue(), 10);

            this.regions.push(region);
        }
    }
};
spine.Atlas.prototype = {
    findRegion: function (name) {
        var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++)
            if (regions[i].name == name) return regions[i];
        return null;
    },
    dispose: function () {
        var pages = this.pages;
        for (var i = 0, n = pages.length; i < n; i++)
            this.textureLoader.unload(pages[i].rendererObject);
    },
    updateUVs: function (page) {
        var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++) {
            var region = regions[i];
            if (region.page != page) continue;
            region.u = region.x / page.width;
            region.v = region.y / page.height;
            if (region.rotate) {
                region.u2 = (region.x + region.height) / page.width;
                region.v2 = (region.y + region.width) / page.height;
            } else {
                region.u2 = (region.x + region.width) / page.width;
                region.v2 = (region.y + region.height) / page.height;
            }
        }
    }
};

spine.Atlas.Format = {
    alpha: 0,
    intensity: 1,
    luminanceAlpha: 2,
    rgb565: 3,
    rgba4444: 4,
    rgb888: 5,
    rgba8888: 6
};

spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
};

spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
};

spine.AtlasPage = function () {};
spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
};

spine.AtlasRegion = function () {};
spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0, y: 0,
    width: 0, height: 0,
    u: 0, v: 0, u2: 0, v2: 0,
    offsetX: 0, offsetY: 0,
    originalWidth: 0, originalHeight: 0,
    index: 0,
    rotate: false,
    splits: null,
    pads: null,
};

spine.AtlasReader = function (text) {
    this.lines = text.split(/\r\n|\r|\n/);
};
spine.AtlasReader.prototype = {
    index: 0,
    trim: function (value) {
        return value.replace(/^\s+|\s+$/g, "");
    },
    readLine: function () {
        if (this.index >= this.lines.length) return null;
        return this.lines[this.index++];
    },
    readValue: function () {
        var line = this.readLine();
        var colon = line.indexOf(":");
        if (colon == -1) throw "Invalid line: " + line;
        return this.trim(line.substring(colon + 1));
    },
    /** Returns the number of tuple values read (2 or 4). */
    readTuple: function (tuple) {
        var line = this.readLine();
        var colon = line.indexOf(":");
        if (colon == -1) throw "Invalid line: " + line;
        var i = 0, lastMatch= colon + 1;
        for (; i < 3; i++) {
            var comma = line.indexOf(",", lastMatch);
            if (comma == -1) {
                if (!i) throw "Invalid line: " + line;
                break;
            }
            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
            lastMatch = comma + 1;
        }
        tuple[i] = this.trim(line.substring(lastMatch));
        return i + 1;
    }
}

spine.AtlasAttachmentLoader = function (atlas) {
    this.atlas = atlas;
}
spine.AtlasAttachmentLoader.prototype = {
    newAttachment: function (skin, type, name) {
        switch (type) {
        case spine.AttachmentType.region:
            var region = this.atlas.findRegion(name);
            if (!region) throw "Region not found in atlas: " + name + " (" + type + ")";
            var attachment = new spine.RegionAttachment(name);
            attachment.rendererObject = region;
            attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
            attachment.regionOffsetX = region.offsetX;
            attachment.regionOffsetY = region.offsetY;
            attachment.regionWidth = region.width;
            attachment.regionHeight = region.height;
            attachment.regionOriginalWidth = region.originalWidth;
            attachment.regionOriginalHeight = region.originalHeight;
            return attachment;
        }
        throw "Unknown attachment type: " + type;
    }
}

spine.Bone.yDown = true;
PIXI.AnimCache = {};

/**
 * A class that enables the you to import and run your spine animations in pixi.
 * Spine animation data needs to be loaded using the PIXI.AssetLoader or PIXI.SpineLoader before it can be used by this class
 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
 *
 * @class Spine
 * @extends DisplayObjectContainer
 * @constructor
 * @param url {String} The url of the spine anim file to be used
 */
PIXI.Spine = function (url) {
    PIXI.DisplayObjectContainer.call(this);

    this.spineData = PIXI.AnimCache[url];

    if (!this.spineData) {
        throw new Error("Spine data must be preloaded using PIXI.SpineLoader or PIXI.AssetLoader: " + url);
    }

    this.skeleton = new spine.Skeleton(this.spineData);
    this.skeleton.updateWorldTransform();

    this.stateData = new spine.AnimationStateData(this.spineData);
    this.state = new spine.AnimationState(this.stateData);

    this.slotContainers = [];

    for (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++) {
        var slot = this.skeleton.drawOrder[i];
        var attachment = slot.attachment;
        var slotContainer = new PIXI.DisplayObjectContainer();
        this.slotContainers.push(slotContainer);
        this.addChild(slotContainer);
        if (!(attachment instanceof spine.RegionAttachment)) {
            continue;
        }
        var spriteName = attachment.rendererObject.name;
        var sprite = this.createSprite(slot, attachment.rendererObject);
        slot.currentSprite = sprite;
        slot.currentSpriteName = spriteName;
        slotContainer.addChild(sprite);
    }
};

PIXI.Spine.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.Spine.prototype.constructor = PIXI.Spine;

/*
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.Spine.prototype.updateTransform = function () {
    this.lastTime = this.lastTime || Date.now();
    var timeDelta = (Date.now() - this.lastTime) * 0.001;
    this.lastTime = Date.now();
    this.state.update(timeDelta);
    this.state.apply(this.skeleton);
    this.skeleton.updateWorldTransform();

    var drawOrder = this.skeleton.drawOrder;
    for (var i = 0, n = drawOrder.length; i < n; i++) {
        var slot = drawOrder[i];
        var attachment = slot.attachment;
        var slotContainer = this.slotContainers[i];
        if (!(attachment instanceof spine.RegionAttachment)) {
            slotContainer.visible = false;
            continue;
        }

        if (attachment.rendererObject) {
            if (!slot.currentSpriteName || slot.currentSpriteName != attachment.name) {
                var spriteName = attachment.rendererObject.name;
                if (slot.currentSprite !== undefined) {
                    slot.currentSprite.visible = false;
                }
                slot.sprites = slot.sprites || {};
                if (slot.sprites[spriteName] !== undefined) {
                    slot.sprites[spriteName].visible = true;
                } else {
                    var sprite = this.createSprite(slot, attachment.rendererObject);
                    slotContainer.addChild(sprite);
                }
                slot.currentSprite = slot.sprites[spriteName];
                slot.currentSpriteName = spriteName;
            }
        }
        slotContainer.visible = true;

        var bone = slot.bone;

        slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;
        slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;
        slotContainer.scale.x = bone.worldScaleX;
        slotContainer.scale.y = bone.worldScaleY;

        slotContainer.rotation = -(slot.bone.worldRotation * Math.PI / 180);
    }

    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
};


PIXI.Spine.prototype.createSprite = function (slot, descriptor) {
    var name = PIXI.TextureCache[descriptor.name] ? descriptor.name : descriptor.name + ".png";
    var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(name));
    sprite.scale = descriptor.scale;
    sprite.rotation = descriptor.rotation;
    sprite.anchor.x = sprite.anchor.y = 0.5;

    slot.sprites = slot.sprites || {};
    slot.sprites[descriptor.name] = sprite;
    return sprite;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BaseTextureCache = {};
PIXI.texturesToUpdate = [];
PIXI.texturesToDestroy = [];

PIXI.BaseTextureCacheIdGenerator = 0;

/**
 * A texture stores the information that represents an image. All textures have a base texture
 *
 * @class BaseTexture
 * @uses EventTarget
 * @constructor
 * @param source {String} the source object (image or canvas)
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 */
PIXI.BaseTexture = function(source, scaleMode)
{
    PIXI.EventTarget.call( this );

    /**
     * [read-only] The width of the base texture set when the image has loaded
     *
     * @property width
     * @type Number
     * @readOnly
     */
    this.width = 100;

    /**
     * [read-only] The height of the base texture set when the image has loaded
     *
     * @property height
     * @type Number
     * @readOnly
     */
    this.height = 100;

    /**
     * The scale mode to apply when scaling this texture
     * @property scaleMode
     * @type PIXI.scaleModes
     * @default PIXI.scaleModes.LINEAR
     */
    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;

    /**
     * [read-only] Describes if the base texture has loaded or not
     *
     * @property hasLoaded
     * @type Boolean
     * @readOnly
     */
    this.hasLoaded = false;

    /**
     * The source that is loaded to create the texture
     *
     * @property source
     * @type Image
     */
    this.source = source;

    //TODO will be used for futer pixi 1.5...
    this.id = PIXI.BaseTextureCacheIdGenerator++;

    // used for webGL
    this._glTextures = [];
    
    if(!source)return;

    if(this.source.complete || this.source.getContext)
    {
        this.hasLoaded = true;
        this.width = this.source.width;
        this.height = this.source.height;

        PIXI.texturesToUpdate.push(this);
    }
    else
    {

        var scope = this;
        this.source.onload = function() {

            scope.hasLoaded = true;
            scope.width = scope.source.width;
            scope.height = scope.source.height;

            // add it to somewhere...
            PIXI.texturesToUpdate.push(scope);
            scope.dispatchEvent( { type: 'loaded', content: scope } );
        };
    }

    this.imageUrl = null;
    this._powerOf2 = false;

    

};

PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;

/**
 * Destroys this base texture
 *
 * @method destroy
 */
PIXI.BaseTexture.prototype.destroy = function()
{
    if(this.imageUrl)
    {
        delete PIXI.BaseTextureCache[this.imageUrl];
        this.imageUrl = null;
        this.source.src = null;
    }
    this.source = null;
    PIXI.texturesToDestroy.push(this);
};

/**
 * Changes the source image of the texture
 *
 * @method updateSourceImage
 * @param newSrc {String} the path of the image
 */
PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc)
{
    this.hasLoaded = false;
    this.source.src = null;
    this.source.src = newSrc;
};

/**
 * Helper function that returns a base texture based on an image url
 * If the image is not in the base texture cache it will be created and loaded
 *
 * @static
 * @method fromImage
 * @param imageUrl {String} The image url of the texture
 * @param crossorigin {Boolean} 
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return BaseTexture
 */
PIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode)
{
    var baseTexture = PIXI.BaseTextureCache[imageUrl];
    
    if(crossorigin === undefined)crossorigin = true;

    if(!baseTexture)
    {
        // new Image() breaks tex loading in some versions of Chrome.
        // See https://code.google.com/p/chromium/issues/detail?id=238071
        var image = new Image();//document.createElement('img');
        if (crossorigin)
        {
            image.crossOrigin = '';
        }
        image.src = imageUrl;
        baseTexture = new PIXI.BaseTexture(image, scaleMode);
        baseTexture.imageUrl = imageUrl;
        PIXI.BaseTextureCache[imageUrl] = baseTexture;
    }

    return baseTexture;
};

/**
 * Helper function that returns a base texture based on a canvas element
 * If the image is not in the base texture cache it will be created and loaded
 *
 * @static
 * @method fromCanvas
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return BaseTexture
 */
PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode)
{
    if(!canvas._pixiId)
    {
        canvas._pixiId = 'canvas_' + PIXI.TextureCacheIdGenerator++;
    }

    var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];

    if(!baseTexture)
    {
        baseTexture = new PIXI.BaseTexture(canvas, scaleMode);
        PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;
    }

    return baseTexture;
};



/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.TextureCache = {};
PIXI.FrameCache = {};

PIXI.TextureCacheIdGenerator = 0;

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. To do this use PIXI.Sprite. If no frame is provided then the whole image is used
 *
 * @class Texture
 * @uses EventTarget
 * @constructor
 * @param baseTexture {BaseTexture} The base texture source to create the texture from
 * @param frame {Rectangle} The rectangle frame of the texture to show
 */
PIXI.Texture = function(baseTexture, frame)
{
    PIXI.EventTarget.call( this );

    if(!frame)
    {
        this.noFrame = true;
        frame = new PIXI.Rectangle(0,0,1,1);
    }

    if(baseTexture instanceof PIXI.Texture)
        baseTexture = baseTexture.baseTexture;

    /**
     * The base texture of that this texture uses
     *
     * @property baseTexture
     * @type BaseTexture
     */
    this.baseTexture = baseTexture;

    /**
     * The frame specifies the region of the base texture that this texture uses
     *
     * @property frame
     * @type Rectangle
     */
    this.frame = frame;

    /**
     * The trim point
     *
     * @property trim
     * @type Rectangle
     */
    this.trim = null;
  
    this.scope = this;

    this._uvs = null;
    
    if(baseTexture.hasLoaded)
    {
        if(this.noFrame)frame = new PIXI.Rectangle(0,0, baseTexture.width, baseTexture.height);
      
        this.setFrame(frame);
    }
    else
    {
        var scope = this;
        baseTexture.addEventListener('loaded', function(){ scope.onBaseTextureLoaded(); });
    }
};

PIXI.Texture.prototype.constructor = PIXI.Texture;

/**
 * Called when the base texture is loaded
 *
 * @method onBaseTextureLoaded
 * @param event
 * @private
 */
PIXI.Texture.prototype.onBaseTextureLoaded = function()
{
    var baseTexture = this.baseTexture;
    baseTexture.removeEventListener( 'loaded', this.onLoaded );

    if(this.noFrame)this.frame = new PIXI.Rectangle(0,0, baseTexture.width, baseTexture.height);
    
    this.setFrame(this.frame);

    this.scope.dispatchEvent( { type: 'update', content: this } );
};

/**
 * Destroys this texture
 *
 * @method destroy
 * @param destroyBase {Boolean} Whether to destroy the base texture as well
 */
PIXI.Texture.prototype.destroy = function(destroyBase)
{
    if(destroyBase) this.baseTexture.destroy();
};

/**
 * Specifies the rectangle region of the baseTexture
 *
 * @method setFrame
 * @param frame {Rectangle} The frame of the texture to set it to
 */
PIXI.Texture.prototype.setFrame = function(frame)
{
    this.frame = frame;
    this.width = frame.width;
    this.height = frame.height;

    if(frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)
    {
        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
    }

    this.updateFrame = true;

    PIXI.Texture.frameUpdates.push(this);


    //this.dispatchEvent( { type: 'update', content: this } );
};

PIXI.Texture.prototype._updateWebGLuvs = function()
{
    if(!this._uvs)this._uvs = new PIXI.TextureUvs();

    var frame = this.frame;
    var tw = this.baseTexture.width;
    var th = this.baseTexture.height;

    this._uvs.x0 = frame.x / tw;
    this._uvs.y0 = frame.y / th;

    this._uvs.x1 = (frame.x + frame.width) / tw;
    this._uvs.y1 = frame.y / th;

    this._uvs.x2 = (frame.x + frame.width) / tw;
    this._uvs.y2 = (frame.y + frame.height) / th;

    this._uvs.x3 = frame.x / tw;
    this._uvs.y3 = (frame.y + frame.height) / th;
};

/**
 * Helper function that returns a texture based on an image url
 * If the image is not in the texture cache it will be  created and loaded
 *
 * @static
 * @method fromImage
 * @param imageUrl {String} The image url of the texture
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return Texture
 */
PIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode)
{
    var texture = PIXI.TextureCache[imageUrl];

    if(!texture)
    {
        texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
        PIXI.TextureCache[imageUrl] = texture;
    }

    return texture;
};

/**
 * Helper function that returns a texture based on a frame id
 * If the frame id is not in the texture cache an error will be thrown
 *
 * @static
 * @method fromFrame
 * @param frameId {String} The frame id of the texture
 * @return Texture
 */
PIXI.Texture.fromFrame = function(frameId)
{
    var texture = PIXI.TextureCache[frameId];
    if(!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ');
    return texture;
};

/**
 * Helper function that returns a texture based on a canvas element
 * If the canvas is not in the texture cache it will be  created and loaded
 *
 * @static
 * @method fromCanvas
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts
 * @return Texture
 */
PIXI.Texture.fromCanvas = function(canvas, scaleMode)
{
    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);

    return new PIXI.Texture( baseTexture );

};


/**
 * Adds a texture to the textureCache.
 *
 * @static
 * @method addTextureToCache
 * @param texture {Texture}
 * @param id {String} the id that the texture will be stored against.
 */
PIXI.Texture.addTextureToCache = function(texture, id)
{
    PIXI.TextureCache[id] = texture;
};

/**
 * Remove a texture from the textureCache.
 *
 * @static
 * @method removeTextureFromCache
 * @param id {String} the id of the texture to be removed
 * @return {Texture} the texture that was removed
 */
PIXI.Texture.removeTextureFromCache = function(id)
{
    var texture = PIXI.TextureCache[id];
    delete PIXI.TextureCache[id];
    delete PIXI.BaseTextureCache[id];
    return texture;
};

// this is more for webGL.. it contains updated frames..
PIXI.Texture.frameUpdates = [];

PIXI.TextureUvs = function()
{
    this.x0 = 0;
    this.y0 = 0;

    this.x1 = 0;
    this.y1 = 0;

    this.x2 = 0;
    this.y2 = 0;

    this.x3 = 0;
    this.y4 = 0;


};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 A RenderTexture is a special texture that allows any pixi displayObject to be rendered to it.

 __Hint__: All DisplayObjects (exmpl. Sprites) that render on RenderTexture should be preloaded.
 Otherwise black rectangles will be drawn instead.

 RenderTexture takes snapshot of DisplayObject passed to render method. If DisplayObject is passed to render method, position and rotation of it will be ignored. For example:

    var renderTexture = new PIXI.RenderTexture(800, 600);
    var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
    sprite.position.x = 800/2;
    sprite.position.y = 600/2;
    sprite.anchor.x = 0.5;
    sprite.anchor.y = 0.5;
    renderTexture.render(sprite);

 Sprite in this case will be rendered to 0,0 position. To render this sprite at center DisplayObjectContainer should be used:

    var doc = new PIXI.DisplayObjectContainer();
    doc.addChild(sprite);
    renderTexture.render(doc);  // Renders to center of renderTexture

 * @class RenderTexture
 * @extends Texture
 * @constructor
 * @param width {Number} The width of the render texture
 * @param height {Number} The height of the render texture
 */
PIXI.RenderTexture = function(width, height, renderer)
{
    PIXI.EventTarget.call( this );

    /**
     * The with of the render texture
     *
     * @property width
     * @type Number
     */
    this.width = width || 100;
    /**
     * The height of the render texture
     *
     * @property height
     * @type Number
     */
    this.height = height || 100;

    /**
     * The framing rectangle of the render texture
     *
     * @property frame
     * @type Rectangle
     */
    this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);

    /**
     * The base texture object that this texture uses
     *
     * @property baseTexture
     * @type BaseTexture
     */
    this.baseTexture = new PIXI.BaseTexture();
    this.baseTexture.width = this.width;
    this.baseTexture.height = this.height;
    this.baseTexture._glTextures = [];

    this.baseTexture.hasLoaded = true;

    // each render texture can only belong to one renderer at the moment if its webGL
    this.renderer = renderer || PIXI.defaultRenderer;

    if(this.renderer.type === PIXI.WEBGL_RENDERER)
    {
        var gl = this.renderer.gl;

        this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height);
        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;

        this.render = this.renderWebGL;
        this.projection = new PIXI.Point(this.width/2 , -this.height/2);
    }
    else
    {
        this.render = this.renderCanvas;
        this.textureBuffer = new PIXI.CanvasBuffer(this.width, this.height);
        this.baseTexture.source = this.textureBuffer.canvas;
    }

    PIXI.Texture.frameUpdates.push(this);


};

PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);
PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;

PIXI.RenderTexture.prototype.resize = function(width, height)
{
    this.width = width;
    this.height = height;

    this.frame.width = this.width;
    this.frame.height = this.height;

    if(this.renderer.type === PIXI.WEBGL_RENDERER)
    {
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;

        var gl = this.renderer.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.baseTexture._glTextures[gl.id]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width,  this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    else
    {
        this.textureBuffer.resize(this.width, this.height);
    }

    PIXI.Texture.frameUpdates.push(this);
};

/**
 * This function will draw the display object to the texture.
 *
 * @method renderWebGL
 * @param displayObject {DisplayObject} The display object to render this texture on
 * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn
 * @private
 */
PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear)
{
    //TOOD replace position with matrix..
    var gl = this.renderer.gl;

    gl.colorMask(true, true, true, true);

    gl.viewport(0, 0, this.width, this.height);

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer );

    if(clear)this.textureBuffer.clear();

    // THIS WILL MESS WITH HIT TESTING!
    var children = displayObject.children;

    //TODO -? create a new one??? dont think so!
    var originalWorldTransform = displayObject.worldTransform;
    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
    // modify to flip...
    displayObject.worldTransform.d = -1;
    displayObject.worldTransform.ty = this.projection.y * -2;

    if(position)
    {
        displayObject.worldTransform.tx = position.x;
        displayObject.worldTransform.ty -= position.y;
    }

    for(var i=0,j=children.length; i<j; i++)
    {
        children[i].updateTransform();
    }

    // update the textures!
    PIXI.WebGLRenderer.updateTextures();

    // 
    this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer);

    displayObject.worldTransform = originalWorldTransform;
};


/**
 * This function will draw the display object to the texture.
 *
 * @method renderCanvas
 * @param displayObject {DisplayObject} The display object to render this texture on
 * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn
 * @private
 */
PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear)
{
    var children = displayObject.children;

    var originalWorldTransform = displayObject.worldTransform;

    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;

    if(position)
    {
        displayObject.worldTransform.tx = position.x;
        displayObject.worldTransform.ty = position.y;
    }

    for(var i = 0, j = children.length; i < j; i++)
    {
        children[i].updateTransform();
    }

    if(clear)this.textureBuffer.clear();

    var context = this.textureBuffer.context;

    this.renderer.renderDisplayObject(displayObject, context);

    context.setTransform(1,0,0,1,0,0);

    displayObject.worldTransform = originalWorldTransform;
};

PIXI.RenderTexture.tempMatrix = new PIXI.Matrix();


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A Class that loads a bunch of images / sprite sheet / bitmap font files. Once the
 * assets have been loaded they are added to the PIXI Texture cache and can be accessed
 * easily through PIXI.Texture.fromImage() and PIXI.Sprite.fromImage()
 * When all items have been loaded this class will dispatch a 'onLoaded' event
 * As each individual item is loaded this class will dispatch a 'onProgress' event
 *
 * @class AssetLoader
 * @constructor
 * @uses EventTarget
 * @param {Array<String>} assetURLs an array of image/sprite sheet urls that you would like loaded
 *      supported. Supported image formats include 'jpeg', 'jpg', 'png', 'gif'. Supported
 *      sprite sheet data formats only include 'JSON' at this time. Supported bitmap font
 *      data formats include 'xml' and 'fnt'.
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.AssetLoader = function(assetURLs, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The array of asset URLs that are going to be loaded
     *
     * @property assetURLs
     * @type Array<String>
     */
    this.assetURLs = assetURLs;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * Maps file extension to loader types
     *
     * @property loadersByType
     * @type Object
     */
    this.loadersByType = {
        'jpg':  PIXI.ImageLoader,
        'jpeg': PIXI.ImageLoader,
        'png':  PIXI.ImageLoader,
        'gif':  PIXI.ImageLoader,
        'json': PIXI.JsonLoader,
        'atlas': PIXI.AtlasLoader,
        'anim': PIXI.SpineLoader,
        'xml':  PIXI.BitmapFontLoader,
        'fnt':  PIXI.BitmapFontLoader
    };
};

/**
 * Fired when an item has loaded
 * @event onProgress
 */

/**
 * Fired when all the assets have loaded
 * @event onComplete
 */

// constructor
PIXI.AssetLoader.prototype.constructor = PIXI.AssetLoader;

/**
 * Given a filename, returns its extension, wil
 *
 * @method _getDataType
 * @param str {String} the name of the asset
 */
PIXI.AssetLoader.prototype._getDataType = function(str)
{
    var test = 'data:';
    //starts with 'data:'
    var start = str.slice(0, test.length).toLowerCase();
    if (start === test) {
        var data = str.slice(test.length);

        var sepIdx = data.indexOf(',');
        if (sepIdx === -1) //malformed data URI scheme
            return null;

        //e.g. 'image/gif;base64' => 'image/gif'
        var info = data.slice(0, sepIdx).split(';')[0];

        //We might need to handle some special cases here...
        //standardize text/plain to 'txt' file extension
        if (!info || info.toLowerCase() === 'text/plain')
            return 'txt';

        //User specified mime type, try splitting it by '/'
        return info.split('/').pop().toLowerCase();
    }

    return null;
};

/**
 * Starts loading the assets sequentially
 *
 * @method load
 */
PIXI.AssetLoader.prototype.load = function()
{
    var scope = this;

    function onLoad(evt) {
        scope.onAssetLoaded(evt.content);
    }

    this.loadCount = this.assetURLs.length;

    for (var i=0; i < this.assetURLs.length; i++)
    {
        var fileName = this.assetURLs[i];
        //first see if we have a data URI scheme..
        var fileType = this._getDataType(fileName);

        //if not, assume it's a file URI
        if (!fileType)
            fileType = fileName.split('?').shift().split('.').pop().toLowerCase();

        var Constructor = this.loadersByType[fileType];
        if(!Constructor)
            throw new Error(fileType + ' is an unsupported file type');

        var loader = new Constructor(fileName, this.crossorigin);

        loader.addEventListener('loaded', onLoad);
        loader.load();
    }
};

/**
 * Invoked after each file is loaded
 *
 * @method onAssetLoaded
 * @private
 */
PIXI.AssetLoader.prototype.onAssetLoaded = function(loader)
{
    this.loadCount--;
    this.dispatchEvent({ type: 'onProgress', content: this, loader: loader });
    if (this.onProgress) this.onProgress(loader);

    if (!this.loadCount)
    {
        this.dispatchEvent({type: 'onComplete', content: this});
        if(this.onComplete) this.onComplete();
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The json file loader is used to load in JSON data and parse it
 * When loaded this class will dispatch a 'loaded' event
 * If loading fails this class will dispatch an 'error' event
 *
 * @class JsonLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.JsonLoader = function (url, crossorigin) {
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * [read-only] Whether the data has loaded yet
     *
     * @property loaded
     * @type Boolean
     * @readOnly
     */
    this.loaded = false;

};

// constructor
PIXI.JsonLoader.prototype.constructor = PIXI.JsonLoader;

/**
 * Loads the JSON data
 *
 * @method load
 */
PIXI.JsonLoader.prototype.load = function () {


    if(window.XDomainRequest)
    {
        this.ajaxRequest = new window.XDomainRequest();
    }
    else if (window.XMLHttpRequest)
    {
        this.ajaxRequest = new window.XMLHttpRequest();
    }
    else
    {
        this.ajaxRequest = new window.ActiveXObject('Microsoft.XMLHTTP');
    }

    


   // this.ajaxRequest = new PIXI.AjaxRequest(this.crossorigin);
    var scope = this;
    

    

    this.ajaxRequest.onload = function () {
        scope.onJSONLoaded();
    };

   // this.ajaxRequest.open('GET', this.url, true);
  //  if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/json');
  //  this.ajaxRequest.send(null);

    this.ajaxRequest.open('GET',this.url,false);
    this.ajaxRequest.send();
};

/**
 * Invoke when JSON file is loaded
 *
 * @method onJSONLoaded
 * @private
 */
PIXI.JsonLoader.prototype.onJSONLoaded = function () {
   // if (this.ajaxRequest.readyState === 4) {
     //   if (this.ajaxRequest.status === 200 || window.location.protocol.indexOf('http') === -1) {
    this.json = JSON.parse(this.ajaxRequest.responseText);

    if(this.json.frames)
    {
        // sprite sheet
        var scope = this;
        var textureUrl = this.baseUrl + this.json.meta.image;
        var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
        var frameData = this.json.frames;

        this.texture = image.texture.baseTexture;
        image.addEventListener('loaded', function() {
            scope.onLoaded();
        });

        for (var i in frameData) {
            var rect = frameData[i].frame;
            if (rect) {
                PIXI.TextureCache[i] = new PIXI.Texture(this.texture, {
                    x: rect.x,
                    y: rect.y,
                    width: rect.w,
                    height: rect.h
                });

                // check to see ifthe sprite ha been trimmed..
                if (frameData[i].trimmed) {

                    var texture =  PIXI.TextureCache[i];
                    
                    var actualSize = frameData[i].sourceSize;
                    var realSize = frameData[i].spriteSourceSize;

                    texture.trim = new PIXI.Rectangle(realSize.x, realSize.y, actualSize.w, actualSize.h);
                }
            }
        }

        image.load();

    }
    else if(this.json.bones)
    {
        // spine animation
        var spineJsonParser = new spine.SkeletonJson();
        var skeletonData = spineJsonParser.readSkeletonData(this.json);
        PIXI.AnimCache[this.url] = skeletonData;
        this.onLoaded();
    }
    else
    {
        this.onLoaded();
    }
     //   }
      //  else
        //{
          //  this.onError();
       // / }
   // }
};

/**
 * Invoke when json file loaded
 *
 * @method onLoaded
 * @private
 */
PIXI.JsonLoader.prototype.onLoaded = function () {
    this.loaded = true;
    this.dispatchEvent({
        type: 'loaded',
        content: this
    });
};

/**
 * Invoke when error occured
 *
 * @method onError
 * @private
 */
PIXI.JsonLoader.prototype.onError = function () {
    this.dispatchEvent({
        type: 'error',
        content: this
    });
};
/**
 * @author Martin Kelm http://mkelm.github.com
 */

/**
 * The atlas file loader is used to load in Atlas data and parse it
 * When loaded this class will dispatch a 'loaded' event
 * If loading fails this class will dispatch an 'error' event
 * @class AtlasLoader
 * @extends EventTarget
 * @constructor
 * @param {String} url the url of the JSON file
 * @param {Boolean} crossorigin
 */

PIXI.AtlasLoader = function (url, crossorigin) {
    PIXI.EventTarget.call(this);
    this.url = url;
    this.baseUrl = url.replace(/[^\/]*$/, '');
    this.crossorigin = crossorigin;
    this.loaded = false;

};

// constructor
PIXI.AtlasLoader.constructor = PIXI.AtlasLoader;


 /**
 * Starts loading the JSON file
 *
 * @method load
 */
PIXI.AtlasLoader.prototype.load = function () {
    this.ajaxRequest = new PIXI.AjaxRequest();
    this.ajaxRequest.onreadystatechange = this.onAtlasLoaded.bind(this);

    this.ajaxRequest.open('GET', this.url, true);
    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/json');
    this.ajaxRequest.send(null);
};

/**
 * Invoke when JSON file is loaded
 * @method onAtlasLoaded
 * @private
 */
PIXI.AtlasLoader.prototype.onAtlasLoaded = function () {
    if (this.ajaxRequest.readyState === 4) {
        if (this.ajaxRequest.status === 200 || window.location.href.indexOf('http') === -1) {
            this.atlas = {
                meta : {
                    image : []
                },
                frames : []
            };
            var result = this.ajaxRequest.responseText.split(/\r?\n/);
            var lineCount = -3;

            var currentImageId = 0;
            var currentFrame = null;
            var nameInNextLine = false;

            var i = 0,
                j = 0,
                selfOnLoaded = this.onLoaded.bind(this);

            // parser without rotation support yet!
            for (i = 0; i < result.length; i++) {
                result[i] = result[i].replace(/^\s+|\s+$/g, '');
                if (result[i] === '') {
                    nameInNextLine = i+1;
                }
                if (result[i].length > 0) {
                    if (nameInNextLine === i) {
                        this.atlas.meta.image.push(result[i]);
                        currentImageId = this.atlas.meta.image.length - 1;
                        this.atlas.frames.push({});
                        lineCount = -3;
                    } else if (lineCount > 0) {
                        if (lineCount % 7 === 1) { // frame name
                            if (currentFrame != null) { //jshint ignore:line
                                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;
                            }
                            currentFrame = { name: result[i], frame : {} };
                        } else {
                            var text = result[i].split(' ');
                            if (lineCount % 7 === 3) { // position
                                currentFrame.frame.x = Number(text[1].replace(',', ''));
                                currentFrame.frame.y = Number(text[2]);
                            } else if (lineCount % 7 === 4) { // size
                                currentFrame.frame.w = Number(text[1].replace(',', ''));
                                currentFrame.frame.h = Number(text[2]);
                            } else if (lineCount % 7 === 5) { // real size
                                var realSize = {
                                    x : 0,
                                    y : 0,
                                    w : Number(text[1].replace(',', '')),
                                    h : Number(text[2])
                                };

                                if (realSize.w > currentFrame.frame.w || realSize.h > currentFrame.frame.h) {
                                    currentFrame.trimmed = true;
                                    currentFrame.realSize = realSize;
                                } else {
                                    currentFrame.trimmed = false;
                                }
                            }
                        }
                    }
                    lineCount++;
                }
            }

            if (currentFrame != null) { //jshint ignore:line
                this.atlas.frames[currentImageId][currentFrame.name] = currentFrame;
            }

            if (this.atlas.meta.image.length > 0) {
                this.images = [];
                for (j = 0; j < this.atlas.meta.image.length; j++) {
                    // sprite sheet
                    var textureUrl = this.baseUrl + this.atlas.meta.image[j];
                    var frameData = this.atlas.frames[j];
                    this.images.push(new PIXI.ImageLoader(textureUrl, this.crossorigin));

                    for (i in frameData) {
                        var rect = frameData[i].frame;
                        if (rect) {
                            PIXI.TextureCache[i] = new PIXI.Texture(this.images[j].texture.baseTexture, {
                                x: rect.x,
                                y: rect.y,
                                width: rect.w,
                                height: rect.h
                            });
                            if (frameData[i].trimmed) {
                                PIXI.TextureCache[i].realSize = frameData[i].realSize;
                                // trim in pixi not supported yet, todo update trim properties if it is done ...
                                PIXI.TextureCache[i].trim.x = 0;
                                PIXI.TextureCache[i].trim.y = 0;
                            }
                        }
                    }
                }

                this.currentImageId = 0;
                for (j = 0; j < this.images.length; j++) {
                    this.images[j].addEventListener('loaded', selfOnLoaded);
                }
                this.images[this.currentImageId].load();

            } else {
                this.onLoaded();
            }

        } else {
            this.onError();
        }
    }
};

/**
 * Invoke when json file has loaded
 * @method onLoaded
 * @private
 */
PIXI.AtlasLoader.prototype.onLoaded = function () {
    if (this.images.length - 1 > this.currentImageId) {
        this.currentImageId++;
        this.images[this.currentImageId].load();
    } else {
        this.loaded = true;
        this.dispatchEvent({
            type: 'loaded',
            content: this
        });
    }
};

/**
 * Invoke when error occured
 * @method onError
 * @private
 */
PIXI.AtlasLoader.prototype.onError = function () {
    this.dispatchEvent({
        type: 'error',
        content: this
    });
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The sprite sheet loader is used to load in JSON sprite sheet data
 * To generate the data you can use http://www.codeandweb.com/texturepacker and publish in the 'JSON' format
 * There is a free version so thats nice, although the paid version is great value for money.
 * It is highly recommended to use Sprite sheets (also know as a 'texture atlas') as it means sprites can be batched and drawn together for highly increased rendering speed.
 * Once the data has been loaded the frames are stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()
 * This loader will load the image file that the Spritesheet points to as well as the data.
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class SpriteSheetLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the sprite sheet JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.SpriteSheetLoader = function (url, crossorigin) {
    /*
     * i use texture packer to load the assets..
     * http://www.codeandweb.com/texturepacker
     * make sure to set the format as 'JSON'
     */
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * The texture being loaded
     *
     * @property texture
     * @type Texture
     */
    this.texture = null;

    /**
     * The frames of the sprite sheet
     *
     * @property frames
     * @type Object
     */
    this.frames = {};
};

// constructor
PIXI.SpriteSheetLoader.prototype.constructor = PIXI.SpriteSheetLoader;

/**
 * This will begin loading the JSON file
 *
 * @method load
 */
PIXI.SpriteSheetLoader.prototype.load = function () {
    var scope = this;
    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);
    jsonLoader.addEventListener('loaded', function (event) {
        scope.json = event.content.json;
        scope.onLoaded();
    });
    jsonLoader.load();
};

/**
 * Invoke when all files are loaded (json and texture)
 *
 * @method onLoaded
 * @private
 */
PIXI.SpriteSheetLoader.prototype.onLoaded = function () {
    this.dispatchEvent({
        type: 'loaded',
        content: this
    });
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The image loader class is responsible for loading images file formats ('jpeg', 'jpg', 'png' and 'gif')
 * Once the image has been loaded it is stored in the PIXI texture cache and can be accessed though PIXI.Texture.fromFrameId() and PIXI.Sprite.fromFrameId()
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class ImageLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the image
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.ImageLoader = function(url, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The texture being loaded
     *
     * @property texture
     * @type Texture
     */
    this.texture = PIXI.Texture.fromImage(url, crossorigin);

    /**
     * if the image is loaded with loadFramedSpriteSheet
     * frames will contain the sprite sheet frames
     *
     */
    this.frames = [];
};

// constructor
PIXI.ImageLoader.prototype.constructor = PIXI.ImageLoader;

/**
 * Loads image or takes it from cache
 *
 * @method load
 */
PIXI.ImageLoader.prototype.load = function()
{
    if(!this.texture.baseTexture.hasLoaded)
    {
        var scope = this;
        this.texture.baseTexture.addEventListener('loaded', function()
        {
            scope.onLoaded();
        });
    }
    else
    {
        this.onLoaded();
    }
};

/**
 * Invoked when image file is loaded or it is already cached and ready to use
 *
 * @method onLoaded
 * @private
 */
PIXI.ImageLoader.prototype.onLoaded = function()
{
    this.dispatchEvent({type: 'loaded', content: this});
};

/**
 * Loads image and split it to uniform sized frames
 *
 *
 * @method loadFramedSpriteSheet
 * @param frameWidth {Number} width of each frame
 * @param frameHeight {Number} height of each frame
 * @param textureName {String} if given, the frames will be cached in <textureName>-<ord> format
 */
PIXI.ImageLoader.prototype.loadFramedSpriteSheet = function(frameWidth, frameHeight, textureName)
{
    this.frames = [];
    var cols = Math.floor(this.texture.width / frameWidth);
    var rows = Math.floor(this.texture.height / frameHeight);

    var i=0;
    for (var y=0; y<rows; y++)
    {
        for (var x=0; x<cols; x++,i++)
        {
            var texture = new PIXI.Texture(this.texture, {
                x: x*frameWidth,
                y: y*frameHeight,
                width: frameWidth,
                height: frameHeight
            });

            this.frames.push(texture);
            if (textureName) PIXI.TextureCache[textureName + '-' + i] = texture;
        }
    }

    if(!this.texture.baseTexture.hasLoaded)
    {
        var scope = this;
        this.texture.baseTexture.addEventListener('loaded', function() {
            scope.onLoaded();
        });
    }
    else
    {
        this.onLoaded();
    }
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The xml loader is used to load in XML bitmap font data ('xml' or 'fnt')
 * To generate the data you can use http://www.angelcode.com/products/bmfont/
 * This loader will also load the image file as the data.
 * When loaded this class will dispatch a 'loaded' event
 *
 * @class BitmapFontLoader
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the sprite sheet JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.BitmapFontLoader = function(url, crossorigin)
{
    /*
     * I use texture packer to load the assets..
     * http://www.codeandweb.com/texturepacker
     * make sure to set the format as 'JSON'
     */
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] The base url of the bitmap font data
     *
     * @property baseUrl
     * @type String
     * @readOnly
     */
    this.baseUrl = url.replace(/[^\/]*$/, '');

    /**
     * [read-only] The texture of the bitmap font
     *
     * @property baseUrl
     * @type String
     */
    this.texture = null;
};

// constructor
PIXI.BitmapFontLoader.prototype.constructor = PIXI.BitmapFontLoader;

/**
 * Loads the XML font data
 *
 * @method load
 */
PIXI.BitmapFontLoader.prototype.load = function()
{
    this.ajaxRequest = new PIXI.AjaxRequest();
    var scope = this;
    this.ajaxRequest.onreadystatechange = function()
    {
        scope.onXMLLoaded();
    };

    this.ajaxRequest.open('GET', this.url, true);
    if (this.ajaxRequest.overrideMimeType) this.ajaxRequest.overrideMimeType('application/xml');
    this.ajaxRequest.send(null);
};

/**
 * Invoked when the XML file is loaded, parses the data
 *
 * @method onXMLLoaded
 * @private
 */
PIXI.BitmapFontLoader.prototype.onXMLLoaded = function()
{
    if (this.ajaxRequest.readyState === 4)
    {
        if (this.ajaxRequest.status === 200 || window.location.protocol.indexOf('http') === -1)
        {
            var responseXML = this.ajaxRequest.responseXML;
            if(!responseXML || /MSIE 9/i.test(navigator.userAgent) || navigator.isCocoonJS) {
                if(typeof(window.DOMParser) === 'function') {
                    var domparser = new DOMParser();
                    responseXML = domparser.parseFromString(this.ajaxRequest.responseText, 'text/xml');
                } else {
                    var div = document.createElement('div');
                    div.innerHTML = this.ajaxRequest.responseText;
                    responseXML = div;
                }
            }

            var textureUrl = this.baseUrl + responseXML.getElementsByTagName('page')[0].getAttribute('file');
            var image = new PIXI.ImageLoader(textureUrl, this.crossorigin);
            this.texture = image.texture.baseTexture;

            var data = {};
            var info = responseXML.getElementsByTagName('info')[0];
            var common = responseXML.getElementsByTagName('common')[0];
            data.font = info.getAttribute('face');
            data.size = parseInt(info.getAttribute('size'), 10);
            data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
            data.chars = {};

            //parse letters
            var letters = responseXML.getElementsByTagName('char');

            for (var i = 0; i < letters.length; i++)
            {
                var charCode = parseInt(letters[i].getAttribute('id'), 10);

                var textureRect = new PIXI.Rectangle(
                    parseInt(letters[i].getAttribute('x'), 10),
                    parseInt(letters[i].getAttribute('y'), 10),
                    parseInt(letters[i].getAttribute('width'), 10),
                    parseInt(letters[i].getAttribute('height'), 10)
                );

                data.chars[charCode] = {
                    xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
                    yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
                    xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
                    kerning: {},
                    texture: PIXI.TextureCache[charCode] = new PIXI.Texture(this.texture, textureRect)

                };
            }

            //parse kernings
            var kernings = responseXML.getElementsByTagName('kerning');
            for (i = 0; i < kernings.length; i++)
            {
                var first = parseInt(kernings[i].getAttribute('first'), 10);
                var second = parseInt(kernings[i].getAttribute('second'), 10);
                var amount = parseInt(kernings[i].getAttribute('amount'), 10);

                data.chars[second].kerning[first] = amount;

            }

            PIXI.BitmapText.fonts[data.font] = data;

            var scope = this;
            image.addEventListener('loaded', function() {
                scope.onLoaded();
            });
            image.load();
        }
    }
};

/**
 * Invoked when all files are loaded (xml/fnt and texture)
 *
 * @method onLoaded
 * @private
 */
PIXI.BitmapFontLoader.prototype.onLoaded = function()
{
    this.dispatchEvent({type: 'loaded', content: this});
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * based on pixi impact spine implementation made by Eemeli Kelokorpi (@ekelokorpi) https://github.com/ekelokorpi
 *
 * Awesome JS run time provided by EsotericSoftware
 * https://github.com/EsotericSoftware/spine-runtimes
 *
 */

/**
 * The Spine loader is used to load in JSON spine data
 * To generate the data you need to use http://esotericsoftware.com/ and export in the "JSON" format
 * Due to a clash of names  You will need to change the extension of the spine file from *.json to *.anim for it to load
 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
 * You will need to generate a sprite sheet to accompany the spine data
 * When loaded this class will dispatch a "loaded" event
 *
 * @class Spine
 * @uses EventTarget
 * @constructor
 * @param url {String} The url of the JSON file
 * @param crossorigin {Boolean} Whether requests should be treated as crossorigin
 */
PIXI.SpineLoader = function(url, crossorigin)
{
    PIXI.EventTarget.call(this);

    /**
     * The url of the bitmap font data
     *
     * @property url
     * @type String
     */
    this.url = url;

    /**
     * Whether the requests should be treated as cross origin
     *
     * @property crossorigin
     * @type Boolean
     */
    this.crossorigin = crossorigin;

    /**
     * [read-only] Whether the data has loaded yet
     *
     * @property loaded
     * @type Boolean
     * @readOnly
     */
    this.loaded = false;
};

PIXI.SpineLoader.prototype.constructor = PIXI.SpineLoader;

/**
 * Loads the JSON data
 *
 * @method load
 */
PIXI.SpineLoader.prototype.load = function () {

    var scope = this;
    var jsonLoader = new PIXI.JsonLoader(this.url, this.crossorigin);
    jsonLoader.addEventListener("loaded", function (event) {
        scope.json = event.content.json;
        scope.onLoaded();
    });
    jsonLoader.load();
};

/**
 * Invoke when JSON file is loaded
 *
 * @method onLoaded
 * @private
 */
PIXI.SpineLoader.prototype.onLoaded = function () {
    this.loaded = true;
    this.dispatchEvent({type: "loaded", content: this});
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * This is the base class for creating a pixi.js filter. Currently only webGL supports filters.
 * If you want to make a custom filter this should be your base class.
 * @class AbstractFilter
 * @constructor
 * @param fragmentSrc
 * @param uniforms
 */
PIXI.AbstractFilter = function(fragmentSrc, uniforms)
{
    /**
    * An array of passes - some filters contain a few steps this array simply stores the steps in a liniear fashion.
    * For example the blur filter has two passes blurX and blurY.
    * @property passes
    * @type Array an array of filter objects
    * @private
    */
    this.passes = [this];

    /**
    * @property shaders
    * @type Array an array of shaders
    * @private
    */
    this.shaders = [];
    
    this.dirty = true;
    this.padding = 0;

    /**
    * @property uniforms
    * @type object
    * @private
    */
    this.uniforms = uniforms || {};
    /**
    * @property fragmentSrc
    * @type Array
    * @private
    */
    this.fragmentSrc = fragmentSrc || [];
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The AlphaMaskFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used to offset the x and the g propery of the texture is used to offset the y.
 * @class AlphaMaskFilter
 * @contructor
 * @param texture {Texture} The texture used for the displacemtent map * must be power of 2 texture at the moment
 */
PIXI.AlphaMaskFilter = function(texture)
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];
    texture.baseTexture._powerOf2 = true;

    // set the uniforms
    this.uniforms = {
        mask: {type: 'sampler2D', value:texture},
        mapDimensions:   {type: '2f', value:{x:1, y:5112}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    if(texture.baseTexture.hasLoaded)
    {
        this.uniforms.mask.value.x = texture.width;
        this.uniforms.mask.value.y = texture.height;
    }
    else
    {
        this.boundLoadedFunction = this.onTextureLoaded.bind(this);

        texture.baseTexture.on('loaded', this.boundLoadedFunction);
    }

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D mask;',
        'uniform sampler2D uSampler;',
        'uniform vec2 offset;',
        'uniform vec4 dimensions;',
        'uniform vec2 mapDimensions;',

        'void main(void) {',
        '   vec2 mapCords = vTextureCoord.xy;',
        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',
        '   mapCords.y *= -1.0;',
        '   mapCords.y += 1.0;',
        '   mapCords *= dimensions.xy / mapDimensions;',

        '   vec4 original =  texture2D(uSampler, vTextureCoord);',
        '   float maskAlpha =  texture2D(mask, mapCords).r;',
        '   original *= maskAlpha;',
        //'   original.rgb *= maskAlpha;',
        '   gl_FragColor =  original;',
        //'   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.AlphaMaskFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.AlphaMaskFilter.prototype.constructor = PIXI.AlphaMaskFilter;

PIXI.AlphaMaskFilter.prototype.onTextureLoaded = function()
{
    this.uniforms.mapDimensions.value.x = this.uniforms.mask.value.width;
    this.uniforms.mapDimensions.value.y = this.uniforms.mask.value.height;

    this.uniforms.mask.value.baseTexture.off('loaded', this.boundLoadedFunction);
};

/**
 * The texture used for the displacemtent map * must be power of 2 texture at the moment
 *
 * @property map
 * @type Texture
 */
Object.defineProperty(PIXI.AlphaMaskFilter.prototype, 'map', {
    get: function() {
        return this.uniforms.mask.value;
    },
    set: function(value) {
        this.uniforms.mask.value = value;
    }
});


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. Its pretty powerful!
 * @class ColorMatrixFilter
 * @contructor
 */
PIXI.ColorMatrixFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        matrix: {type: 'mat4', value: [1,0,0,0,
                                       0,1,0,0,
                                       0,0,1,0,
                                       0,0,0,1]},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float invert;',
        'uniform mat4 matrix;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * matrix;',
      //  '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.ColorMatrixFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.ColorMatrixFilter.prototype.constructor = PIXI.ColorMatrixFilter;

/**
 * Sets the matrix of the color matrix filter
 *
 * @property matrix
 * @type Array and array of 26 numbers
 * @default [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
 */
Object.defineProperty(PIXI.ColorMatrixFilter.prototype, 'matrix', {
    get: function() {
        return this.uniforms.matrix.value;
    },
    set: function(value) {
        this.uniforms.matrix.value = value;
    }
});
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This turns your displayObjects to black and white.
 * @class GrayFilter
 * @contructor
 */
PIXI.GrayFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        gray: {type: '1f', value: 1},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'uniform float gray;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);',
     //   '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.GrayFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.GrayFilter.prototype.constructor = PIXI.GrayFilter;

/**
The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color
@property gray
*/
Object.defineProperty(PIXI.GrayFilter.prototype, 'gray', {
    get: function() {
        return this.uniforms.gray.value;
    },
    set: function(value) {
        this.uniforms.gray.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used offset the x and the g propery of the texture is used to offset the y.
 * @class DisplacementFilter
 * @contructor
 * @param texture {Texture} The texture used for the displacemtent map * must be power of 2 texture at the moment
 */
PIXI.DisplacementFilter = function(texture)
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];
    texture.baseTexture._powerOf2 = true;

    // set the uniforms
    this.uniforms = {
        displacementMap: {type: 'sampler2D', value:texture},
        scale:           {type: '2f', value:{x:30, y:30}},
        offset:          {type: '2f', value:{x:0, y:0}},
        mapDimensions:   {type: '2f', value:{x:1, y:5112}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    if(texture.baseTexture.hasLoaded)
    {
        this.uniforms.mapDimensions.value.x = texture.width;
        this.uniforms.mapDimensions.value.y = texture.height;
    }
    else
    {
        this.boundLoadedFunction = this.onTextureLoaded.bind(this);

        texture.baseTexture.on('loaded', this.boundLoadedFunction);
    }

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D displacementMap;',
        'uniform sampler2D uSampler;',
        'uniform vec2 scale;',
        'uniform vec2 offset;',
        'uniform vec4 dimensions;',
        'uniform vec2 mapDimensions;',// = vec2(256.0, 256.0);',
        // 'const vec2 textureDimensions = vec2(750.0, 750.0);',

        'void main(void) {',
        '   vec2 mapCords = vTextureCoord.xy;',
        //'   mapCords -= ;',
        '   mapCords += (dimensions.zw + offset)/ dimensions.xy ;',
        '   mapCords.y *= -1.0;',
        '   mapCords.y += 1.0;',
        '   vec2 matSample = texture2D(displacementMap, mapCords).xy;',
        '   matSample -= 0.5;',
        '   matSample *= scale;',
        '   matSample /= mapDimensions;',
        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + matSample.x, vTextureCoord.y + matSample.y));',
        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb, 1.0);',
        '   vec2 cord = vTextureCoord;',

        //'   gl_FragColor =  texture2D(displacementMap, cord);',
     //   '   gl_FragColor = gl_FragColor;',
        '}'
    ];
};

PIXI.DisplacementFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.DisplacementFilter.prototype.constructor = PIXI.DisplacementFilter;

PIXI.DisplacementFilter.prototype.onTextureLoaded = function()
{
    this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width;
    this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height;

    this.uniforms.displacementMap.value.baseTexture.off('loaded', this.boundLoadedFunction);
};

/**
 * The texture used for the displacemtent map * must be power of 2 texture at the moment
 *
 * @property map
 * @type Texture
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'map', {
    get: function() {
        return this.uniforms.displacementMap.value;
    },
    set: function(value) {
        this.uniforms.displacementMap.value = value;
    }
});

/**
 * The multiplier used to scale the displacement result from the map calculation.
 *
 * @property scale
 * @type Point
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'scale', {
    get: function() {
        return this.uniforms.scale.value;
    },
    set: function(value) {
        this.uniforms.scale.value = value;
    }
});

/**
 * The offset used to move the displacement map.
 *
 * @property offset
 * @type Point
 */
Object.defineProperty(PIXI.DisplacementFilter.prototype, 'offset', {
    get: function() {
        return this.uniforms.offset.value;
    },
    set: function(value) {
        this.uniforms.offset.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This filter applies a pixelate effect making display objects appear 'blocky'
 * @class PixelateFilter
 * @contructor
 */
PIXI.PixelateFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        invert: {type: '1f', value: 0},
        dimensions: {type: '4fv', value:new Float32Array([10000, 100, 10, 10])},
        pixelSize: {type: '2f', value:{x:10, y:10}},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec2 testDim;',
        'uniform vec4 dimensions;',
        'uniform vec2 pixelSize;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec2 coord = vTextureCoord;',

        '   vec2 size = dimensions.xy/pixelSize;',

        '   vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;',
        '   gl_FragColor = texture2D(uSampler, color);',
        '}'
    ];
};

PIXI.PixelateFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.PixelateFilter.prototype.constructor = PIXI.PixelateFilter;

/**
 *
 * This a point that describes the size of the blocs. x is the width of the block and y is the the height
 * @property size
 * @type Point
 */
Object.defineProperty(PIXI.PixelateFilter.prototype, 'size', {
    get: function() {
        return this.uniforms.pixelSize.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.pixelSize.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BlurXFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1/512},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec4 sum = vec4(0.0);',

        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 4.0*blur, vTextureCoord.y)) * 0.05;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 3.0*blur, vTextureCoord.y)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - 2.0*blur, vTextureCoord.y)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x - blur, vTextureCoord.y)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + blur, vTextureCoord.y)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 2.0*blur, vTextureCoord.y)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 3.0*blur, vTextureCoord.y)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x + 4.0*blur, vTextureCoord.y)) * 0.05;',

        '   gl_FragColor = sum;',
        '}'
    ];
};

PIXI.BlurXFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.BlurXFilter.prototype.constructor = PIXI.BlurXFilter;

Object.defineProperty(PIXI.BlurXFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {

        this.dirty = true;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.BlurYFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1/512},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   vec4 sum = vec4(0.0);',

        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 4.0*blur)) * 0.05;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 3.0*blur)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - 2.0*blur)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - blur)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * 0.16;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + blur)) * 0.15;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 2.0*blur)) * 0.12;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 3.0*blur)) * 0.09;',
        '   sum += texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + 4.0*blur)) * 0.05;',

        '   gl_FragColor = sum;',
        '}'
    ];
};

PIXI.BlurYFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.BlurYFilter.prototype.constructor = PIXI.BlurYFilter;

Object.defineProperty(PIXI.BlurYFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * The BlurFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately (always relative to the stage).
 *
 * @class BlurFilter
 * @contructor
 */
PIXI.BlurFilter = function()
{
    this.blurXFilter = new PIXI.BlurXFilter();
    this.blurYFilter = new PIXI.BlurYFilter();

    this.passes =[this.blurXFilter, this.blurYFilter];
};

/**
 * Sets the strength of both the blurX and blurY properties simultaneously
 *
 * @property blur
 * @type Number the strength of the blur
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blur', {
    get: function() {
        return this.blurXFilter.blur;
    },
    set: function(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
    }
});

/**
 * Sets the strength of the blurX property
 *
 * @property blurX
 * @type Number the strength of the blurX
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blurX', {
    get: function() {
        return this.blurXFilter.blur;
    },
    set: function(value) {
        this.blurXFilter.blur = value;
    }
});

/**
 * Sets the strength of the blurX property
 *
 * @property blurY
 * @type Number the strength of the blurY
 * @default 2
 */
Object.defineProperty(PIXI.BlurFilter.prototype, 'blurY', {
    get: function() {
        return this.blurYFilter.blur;
    },
    set: function(value) {
        this.blurYFilter.blur = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This inverts your displayObjects colors.
 * @class InvertFilter
 * @contructor
 */
PIXI.InvertFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        invert: {type: '1f', value: 1},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float invert;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);',
        //'   gl_FragColor.rgb = gl_FragColor.rgb  * gl_FragColor.a;',
      //  '   gl_FragColor = gl_FragColor * vColor;',
        '}'
    ];
};

PIXI.InvertFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.InvertFilter.prototype.constructor = PIXI.InvertFilter;

/**
The strength of the invert. 1 will fully invert the colors, 0 will make the object its normal color
@property invert
*/
Object.defineProperty(PIXI.InvertFilter.prototype, 'invert', {
    get: function() {
        return this.uniforms.invert.value;
    },
    set: function(value) {
        this.uniforms.invert.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This applies a sepia effect to your displayObjects.
 * @class SepiaFilter
 * @contructor
 */
PIXI.SepiaFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        sepia: {type: '1f', value: 1},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float sepia;',
        'uniform sampler2D uSampler;',

        'const mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);',

        'void main(void) {',
        '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
        '   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);',
       // '   gl_FragColor = gl_FragColor * vColor;',
        '}'
    ];
};

PIXI.SepiaFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.SepiaFilter.prototype.constructor = PIXI.SepiaFilter;

/**
The strength of the sepia. 1 will apply the full sepia effect, 0 will make the object its normal color
@property sepia
*/
Object.defineProperty(PIXI.SepiaFilter.prototype, 'sepia', {
    get: function() {
        return this.uniforms.sepia.value;
    },
    set: function(value) {
        this.uniforms.sepia.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This filter applies a twist effect making display objects appear twisted in the given direction
 * @class TwistFilter
 * @contructor
 */
PIXI.TwistFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        radius: {type: '1f', value:0.5},
        angle: {type: '1f', value:5},
        offset: {type: '2f', value:{x:0.5, y:0.5}},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'uniform float radius;',
        'uniform float angle;',
        'uniform vec2 offset;',

        'void main(void) {',
        '   vec2 coord = vTextureCoord - offset;',
        '   float distance = length(coord);',

        '   if (distance < radius) {',
        '       float ratio = (radius - distance) / radius;',
        '       float angleMod = ratio * ratio * angle;',
        '       float s = sin(angleMod);',
        '       float c = cos(angleMod);',
        '       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);',
        '   }',

        '   gl_FragColor = texture2D(uSampler, coord+offset);',
        '}'
    ];
};

PIXI.TwistFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.TwistFilter.prototype.constructor = PIXI.TwistFilter;

/**
 *
 * This point describes the the offset of the twist
 * @property size
 * @type Point
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'offset', {
    get: function() {
        return this.uniforms.offset.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.offset.value = value;
    }
});

/**
 *
 * This radius describes size of the twist
 * @property size
 * @type Number
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'radius', {
    get: function() {
        return this.uniforms.radius.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.radius.value = value;
    }
});

/**
 *
 * This radius describes angle of the twist
 * @property angle
 * @type Number
 */
Object.defineProperty(PIXI.TwistFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.angle.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.angle.value = value;
    }
});
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 *
 * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.
 * @class ColorStepFilter
 * @contructor
 */
PIXI.ColorStepFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        step: {type: '1f', value: 5},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform sampler2D uSampler;',
        'uniform float step;',

        'void main(void) {',
        '   vec4 color = texture2D(uSampler, vTextureCoord);',
        '   color = floor(color * step) / step;',
        '   gl_FragColor = color;',
        '}'
    ];
};

PIXI.ColorStepFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.ColorStepFilter.prototype.constructor = PIXI.ColorStepFilter;

/**
The number of steps.
@property step
*/
Object.defineProperty(PIXI.ColorStepFilter.prototype, 'step', {
    get: function() {
        return this.uniforms.step.value;
    },
    set: function(value) {
        this.uniforms.step.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js
 */

/**
 *
 * This filter applies a dotscreen effect making display objects appear to be made out of black and white halftone dots like an old printer
 * @class DotScreenFilter
 * @contructor
 */
PIXI.DotScreenFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        scale: {type: '1f', value:1},
        angle: {type: '1f', value:5},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'uniform float angle;',
        'uniform float scale;',

        'float pattern() {',
        '   float s = sin(angle), c = cos(angle);',
        '   vec2 tex = vTextureCoord * dimensions.xy;',
        '   vec2 point = vec2(',
        '       c * tex.x - s * tex.y,',
        '       s * tex.x + c * tex.y',
        '   ) * scale;',
        '   return (sin(point.x) * sin(point.y)) * 4.0;',
        '}',

        'void main() {',
        '   vec4 color = texture2D(uSampler, vTextureCoord);',
        '   float average = (color.r + color.g + color.b) / 3.0;',
        '   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);',
        '}'
    ];
};

PIXI.DotScreenFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.DotScreenFilter.prototype.constructor = PIXI.DotScreenFilter;

/**
 *
 * This describes the the scale
 * @property scale
 * @type Number
 */
Object.defineProperty(PIXI.DotScreenFilter.prototype, 'scale', {
    get: function() {
        return this.uniforms.scale.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.scale.value = value;
    }
});

/**
 *
 * This radius describes angle
 * @property angle
 * @type Number
 */
Object.defineProperty(PIXI.DotScreenFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.angle.value;
    },
    set: function(value) {
        this.dirty = true;
        this.uniforms.angle.value = value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.CrossHatchFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        blur: {type: '1f', value: 1 / 512},
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform float blur;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);',

        '    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);',

        '    if (lum < 1.00) {',
        '        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.75) {',
        '        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.50) {',
        '        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',

        '    if (lum < 0.3) {',
        '        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {',
        '            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
        '        }',
        '    }',
        '}'
    ];
};

PIXI.CrossHatchFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.CrossHatchFilter.prototype.constructor = PIXI.BlurYFilter;

Object.defineProperty(PIXI.CrossHatchFilter.prototype, 'blur', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.RGBSplitFilter = function()
{
    PIXI.AbstractFilter.call( this );

    this.passes = [this];

    // set the uniforms
    this.uniforms = {
        red: {type: '2f', value: {x:20, y:20}},
        green: {type: '2f', value: {x:-20, y:20}},
        blue: {type: '2f', value: {x:20, y:-20}},
        dimensions:   {type: '4fv', value:[0,0,0,0]}
    };

    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'uniform vec2 red;',
        'uniform vec2 green;',
        'uniform vec2 blue;',
        'uniform vec4 dimensions;',
        'uniform sampler2D uSampler;',

        'void main(void) {',
        '   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;',
        '   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;',
        '   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;',
        '   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;',
        '}'
    ];
};

PIXI.RGBSplitFilter.prototype = Object.create( PIXI.AbstractFilter.prototype );
PIXI.RGBSplitFilter.prototype.constructor = PIXI.RGBSplitFilter;

Object.defineProperty(PIXI.RGBSplitFilter.prototype, 'angle', {
    get: function() {
        return this.uniforms.blur.value / (1/7000);
    },
    set: function(value) {
        //this.padding = value;
        this.uniforms.blur.value = (1/7000) * value;
    }
});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = PIXI;
        }
        exports.PIXI = PIXI;
    } else if (typeof define !== 'undefined' && define.amd) {
        define(PIXI);
    } else {
        root.PIXI = PIXI;
    }
    module.exports = PIXI;
}).call(this);


},{}],10:[function(require,module,exports){
"use strict";

var Box2D = require('./box2dweb/Box2dWeb-2.1.a.3.js');
var b2 = require('../utils/b2Helpers.js');

var rubeFileLoader = function () {
  var that = {};

  Object.prototype.hasOwnProperty = function (property) {
    return typeof(this[property]) !== 'undefined';
  };

  var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
    b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
    b2Vec2 = Box2D.Common.Math.b2Vec2,
    b2BodyDef = Box2D.Dynamics.b2BodyDef,
    b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
    b2World = Box2D.Dynamics.b2World,
    Features = Box2D.Collision.Features;

  that.loadBodyFromRUBE = function (bodyJso, world, loadingIndex) {

    if (!bodyJso.hasOwnProperty('type')) {
      console.log("Body does not have a 'type' property");
      return null;
    }

    var bd = new b2BodyDef();
    if (bodyJso.type == 2)
      bd.type = b2.dyn.b2Body.b2_dynamicBody;
    else if (bodyJso.type == 1)
      bd.type = b2.dyn.b2Body.b2_kinematicBody;
    if (bodyJso.hasOwnProperty('angle'))
      bd.angle = bodyJso.angle;
    if (bodyJso.hasOwnProperty('angularVelocity'))
      bd.angularVelocity = bodyJso.angularVelocity;
    if (bodyJso.hasOwnProperty('active'))
      bd.awake = bodyJso.active;
    if (bodyJso.hasOwnProperty('fixedRotation'))
      bd.fixedRotation = bodyJso.fixedRotation;
    if (bodyJso.hasOwnProperty('linearVelocity') && bodyJso.linearVelocity instanceof Object)
      bd.linearVelocity.SetV(bodyJso.linearVelocity);
    if (bodyJso.hasOwnProperty('position') && bodyJso.position instanceof Object) {
      bd.position.y = bd.position.y;
      bd.position.SetV(bodyJso.position);
    }
    if (bodyJso.hasOwnProperty('awake'))
      bd.awake = bodyJso.awake;
    else
      bd.awake = false;
    var body = world.CreateBody(bd);
    if (bodyJso.hasOwnProperty('fixture')) {
      for (var k = 0; k < bodyJso.fixture.length; k++) {
        var fixtureJso = bodyJso.fixture[k];
        that.loadFixtureFromRUBE(body, fixtureJso);
      }
    }
    if (bodyJso.hasOwnProperty('name'))
      body.name = bodyJso.name;
    if (bodyJso.hasOwnProperty('customProperties')) {
      // add the loadingIndex if applicable
      that.setCustomProperty(bodyJso, 'int', 'loadingIndex', loadingIndex);

      body.customProperties = bodyJso.customProperties;
    }
    return body;
  }

  that.loadFixtureFromRUBE = function (body, fixtureJso) {
    var fd = new b2FixtureDef();
    if (fixtureJso.hasOwnProperty('friction'))
      fd.friction = fixtureJso.friction;
    if (fixtureJso.hasOwnProperty('density'))
      fd.density = fixtureJso.density;
    if (fixtureJso.hasOwnProperty('restitution'))
      fd.restitution = fixtureJso.restitution;
    if (fixtureJso.hasOwnProperty('sensor'))
      fd.isSensor = fixtureJso.sensor;
    if (fixtureJso.hasOwnProperty('filter-categoryBits'))
      fd.filter.categoryBits = fixtureJso['filter-categoryBits'];
    if (fixtureJso.hasOwnProperty('filter-maskBits'))
      fd.filter.maskBits = fixtureJso['filter-maskBits'];
    if (fixtureJso.hasOwnProperty('filter-groupIndex'))
      fd.filter.groupIndex = fixtureJso['filter-groupIndex'];
    var fixture;
    if (fixtureJso.hasOwnProperty('circle')) {
      fd.shape = new b2CircleShape();
      fd.shape.m_radius = fixtureJso.circle.radius;
      if (fixtureJso.circle.center)
        fd.shape.m_p.SetV(fixtureJso.circle.center);
      fixture = body.CreateFixture(fd);
      if (fixtureJso.name)
        fixture.name = fixtureJso.name;
    }
    else if (fixtureJso.hasOwnProperty('polygon')) {
      fd.shape = new b2PolygonShape();
      var verts = [];
      for (var v = 0; v < fixtureJso.polygon.vertices.x.length; v++)
        verts.push(new b2Vec2(fixtureJso.polygon.vertices.x[v], fixtureJso.polygon.vertices.y[v]));
      fd.shape.SetAsArray(verts, verts.length);
      fixture = body.CreateFixture(fd);
      if (fixture && fixtureJso.name)
        fixture.name = fixtureJso.name;
    }
    else if (fixtureJso.hasOwnProperty('chain')) {
      fd.shape = new b2PolygonShape();
      var lastVertex = new b2Vec2();
      for (var v = 0; v < fixtureJso.chain.vertices.x.length; v++) {
        var thisVertex = new b2Vec2(fixtureJso.chain.vertices.x[v], fixtureJso.chain.vertices.y[v]);
        if (v > 0) {
          fd.shape.SetAsEdge(lastVertex, thisVertex);
          fixture = body.CreateFixture(fd);
          if (fixtureJso.name)
            fixture.name = fixtureJso.name;
        }
        lastVertex = thisVertex;
      }
    }
    else {
      console.log("Could not find shape type for fixture");
    }
    if (fixtureJso.hasOwnProperty('customProperties')) {
      fixture.customProperties = fixtureJso.customProperties;
    }
  }

  that.getVectorValue = function (val) {
    if (val instanceof Object) {
      return val;
    }
    else
      return {
        x: 0,
        y: 0
      };
  }

  that.loadJointCommonProperties = function (jd, jointJso, loadedBodies, loadingIndex) {

    //jointJso
    //console.log(loadedBodies);
    jd.bodyA = loadedBodies[jointJso.bodyA];
    jd.bodyB = loadedBodies[jointJso.bodyB];
    jd.localAnchorA.SetV(that.getVectorValue(jointJso.anchorA));
    jd.localAnchorB.SetV(that.getVectorValue(jointJso.anchorB));
    if (jointJso.collideConnected)
      jd.collideConnected = jointJso.collideConnected;

  }

  that.loadJointFromRUBE = function (jointJso, world, loadedBodies, loadingIndex) {
    if (!jointJso.hasOwnProperty('type')) {
      console.log("Joint does not have a 'type' property");
      return null;
    }
    if (jointJso.bodyA >= loadedBodies.length) {
      console.log("Index for bodyA is invalid: " + jointJso.bodyA);
      return null;
    }
    if (jointJso.bodyB >= loadedBodies.length) {
      console.log("Index for bodyB is invalid: " + jointJso.bodyB);
      return null;
    }

    var joint = null;
    var jd;
    if (jointJso.type == "revolute") {
      jd = new b2.joints.b2RevoluteJointDef();
      that.loadJointCommonProperties(jd, jointJso, loadedBodies, loadingIndex);
      //console.log('jd : ', jd);
      if (jointJso.hasOwnProperty('refAngle'))
        jd.referenceAngle = jointJso.refAngle;
      if (jointJso.hasOwnProperty('lowerLimit'))
        jd.lowerAngle = jointJso.lowerLimit;
      if (jointJso.hasOwnProperty('upperLimit'))
        jd.upperAngle = jointJso.upperLimit;
      if (jointJso.hasOwnProperty('maxMotorTorque'))
        jd.maxMotorTorque = jointJso.maxMotorTorque;
      if (jointJso.hasOwnProperty('motorSpeed'))
        jd.motorSpeed = jointJso.motorSpeed;
      if (jointJso.hasOwnProperty('enableLimit'))
        jd.enableLimit = jointJso.enableLimit;
      if (jointJso.hasOwnProperty('enableMotor'))
        jd.enableMotor = jointJso.enableMotor;

      jd.lowerAngle = 0;
      jd.upperAngle = 0;
      jd.referenceAngle = 0;


      joint = world.CreateJoint(jd);
    }
    else if (jointJso.type == "distance" || jointJso.type == "rope") {
      if (jointJso.type == "rope")
        console.log("Replacing unsupported rope joint with distance joint!");
      jd = new b2DistanceJointDef();
      that.loadJointCommonProperties(jd, jointJso, loadedBodies, loadingIndex);
      if (jointJso.hasOwnProperty('length'))
        jd.length = jointJso.length;
      if (jointJso.hasOwnProperty('dampingRatio'))
        jd.dampingRatio = jointJso.dampingRatio;
      if (jointJso.hasOwnProperty('frequency'))
        jd.frequencyHz = jointJso.frequency;
      joint = world.CreateJoint(jd);
    }
    else if (jointJso.type == "prismatic") {
      jd = new b2PrismaticJointDef();
      that.loadJointCommonProperties(jd, jointJso, loadedBodies, loadingIndex);
      if (jointJso.hasOwnProperty('localAxisA'))
        jd.localAxisA.SetV(that.getVectorValue(jointJso.localAxisA));
      if (jointJso.hasOwnProperty('refAngle'))
        jd.referenceAngle = jointJso.refAngle;
      if (jointJso.hasOwnProperty('enableLimit'))
        jd.enableLimit = jointJso.enableLimit;
      if (jointJso.hasOwnProperty('lowerLimit'))
        jd.lowerTranslation = jointJso.lowerLimit;
      if (jointJso.hasOwnProperty('upperLimit'))
        jd.upperTranslation = jointJso.upperLimit;
      if (jointJso.hasOwnProperty('enableMotor'))
        jd.enableMotor = jointJso.enableMotor;
      if (jointJso.hasOwnProperty('maxMotorForce'))
        jd.maxMotorForce = jointJso.maxMotorForce;
      if (jointJso.hasOwnProperty('motorSpeed'))
        jd.motorSpeed = jointJso.motorSpeed;
      joint = world.CreateJoint(jd);
    }
    else if (jointJso.type == "wheel") {
      //Make a fake wheel joint using a line joint and a distance joint.
      //Return the line joint because it has the linear motor controls.
      //Use ApplyTorque on the bodies to spin the wheel...

      jd = new b2DistanceJointDef();
      that.loadJointCommonProperties(jd, jointJso, loadedBodies, loadingIndex);
      jd.length = 0.0;
      if (jointJso.hasOwnProperty('springDampingRatio'))
        jd.dampingRatio = jointJso.springDampingRatio;
      if (jointJso.hasOwnProperty('springFrequency'))
        jd.frequencyHz = jointJso.springFrequency;
      world.CreateJoint(jd);

      jd = new b2LineJointDef();
      that.loadJointCommonProperties(jd, jointJso, loadedBodies, loadingIndex);
      if (jointJso.hasOwnProperty('localAxisA'))
        jd.localAxisA.SetV(that.getVectorValue(jointJso.localAxisA));

      joint = world.CreateJoint(jd);
    }
    else if (jointJso.type == "friction") {
      jd = new b2FrictionJointDef();
      that.loadJointCommonProperties(jd, jointJso, loadedBodies, loadingIndex);
      if (jointJso.hasOwnProperty('maxForce'))
        jd.maxForce = jointJso.maxForce;
      if (jointJso.hasOwnProperty('maxTorque'))
        jd.maxTorque = jointJso.maxTorque;
      joint = world.CreateJoint(jd);
    }
    else if (jointJso.type == "weld") {
      jd = new b2.joints.b2WeldJointDef();
      that.loadJointCommonProperties(jd, jointJso, loadedBodies, loadingIndex);
      if (jointJso.hasOwnProperty('referenceAngle'))
        jd.referenceAngle = jointJso.referenceAngle;
      joint = world.CreateJoint(jd);
    }
    else {
      console.log("Unsupported joint type: " + jointJso.type);
      console.log(jointJso);
    }
    if (joint && jointJso.name)
      joint.name = jointJso.name;


    if (jointJso.hasOwnProperty('customProperties')) {
      // add the loadingIndex if applicable
      that.setCustomProperty(jointJso, 'int', 'loadingIndex', loadingIndex);

      joint.customProperties = jointJso.customProperties;
    }

    //console.log(joint);
    return joint;
  }

  that.makeClone = function (obj) {
    var newObj = (obj instanceof Array) ? [] : {};
    for (var i in obj) {
      if (obj[i] && typeof obj[i] == "object")
        newObj[i] = that.makeClone(obj[i]);
      else
        newObj[i] = obj[i];
    }
    return newObj;
  }

  that.loadImageFromRUBE = function (imageJso, world, loadedBodies) {
    var image = that.makeClone(imageJso);

    if (image.hasOwnProperty('body') && image.body >= 0)
      image.body = loadedBodies[image.body];//change index to the actual body
    else
      image.body = null;

    image.center = new b2Vec2();
    image.center.SetV(that.getVectorValue(imageJso.center));

    return image;
  }

//mainly just a convenience for the testbed - uses global 'world' variable
  that.loadSceneFromRUBE = function (worldJso) {
    return that.loadSceneIntoWorld(worldJso, world);
  }

//load the scene into an already existing world variable
  that.loadSceneIntoWorld = function (worldJso, world, loadingIndex) {
    var success = true;
    var loadedBodies = [];
    if (worldJso.hasOwnProperty('body')) {
      for (var i = 0; i < worldJso.body.length; i++) {
        var bodyJso = worldJso.body[i];
        var body = that.loadBodyFromRUBE(bodyJso, world, loadingIndex);
        if (body)
          loadedBodies.push(body);
        else
          success = false;
      }
    }

    var loadedJoints = [];
    if (worldJso.hasOwnProperty('joint')) {
      for (var j = 0; j < worldJso.joint.length; j++) {
        var jointJso = worldJso.joint[j];
        var joint = that.loadJointFromRUBE(jointJso, world, loadedBodies, loadingIndex);
        if (joint)
          loadedJoints.push(joint);
        //else
        //    success = false;
      }
    }

    var loadedImages = [];
    if (worldJso.hasOwnProperty('image')) {
      for (var k = 0; k < worldJso.image.length; k++) {
        var imageJso = worldJso.image[k];
        var image = that.loadImageFromRUBE(imageJso, world, loadedBodies);
        if (image)
          loadedImages.push(image);
        else
          success = false;
      }
      world.images = loadedImages;
    }

    return success;
  }

//create a world variable and return it if loading succeeds
// loadingIndex should be filled in in bodies and joints elements loaded in order to track them in the
// case of multiple worlds imports
  that.loadWorldFromRUBE = function (worldJso, inputWorld, loadingIndex) {
    //console.log("LoadingIndex: ", loadingIndex);
    var gravity = new b2Vec2(0, 0);
    if (worldJso.hasOwnProperty('gravity') && worldJso.gravity instanceof Object)
      gravity.SetV(worldJso.gravity);
    var world;
    //typeof inputWorld
    if (typeof inputWorld !== "undefined" && inputWorld !== null) {
      world = inputWorld;
    }
    else
      world = new b2World(gravity);

    if (!that.loadSceneIntoWorld(worldJso, world, loadingIndex))
      return false;
    return world;
  }

  that.getNamedBodies = function (world, name) {
    var bodies = [];
    for (var b = world.m_bodyList; b; b = b.m_next) {
      if (b.name == name)
        bodies.push(b);
    }
    return bodies;
  }

  that.getBodiesWithNamesStartingWith = function (world, startName) {
    var bodies = [];
    for (var b = world.m_bodyList; b; b = b.m_next) {
      if (typeof b.name !== "undefined" && b.name.indexOf(startName) === 0)
        bodies.push(b);
    }
    return bodies;
  }

  that.getBodies = function (world) {
    var bodies = [];
    for (var b = world.m_bodyList; b; b = b.m_next) {
      bodies.push(b);
    }
    return bodies;
  }

  that.getNamedFixtures = function (world, name) {
    var fixtures = [];
    for (var b = world.m_bodyList; b; b = b.m_next) {
      for (var f = b.m_fixtureList; f; f = f.m_next) {
        if (f.name == name)
          fixtures.push(f);
      }
    }
    return fixtures;
  }

  that.getNamedJoints = function (world, name) {
    var joints = [];
    for (var j = world.m_jointList; j; j = j.m_next) {
      if (j.name == name)
        joints.push(j);
    }
    return joints;
  }

  that.getNamedImages = function (world, name) {
    var images = [];
    for (var i = 0; i < world.images.length; i++) {
      if (world.images[i].name == name)
        images.push(world.images[i].name);
    }
    return images;
  }

//custom properties
  that.getBodiesByCustomProperty = function (world, propertyType, propertyName, valueToMatch) {
    var bodies = [];
    for (var b = world.m_bodyList; b; b = b.m_next) {
      if (!b.hasOwnProperty('customProperties'))
        continue;
      for (var i = 0; i < b.customProperties.length; i++) {
        if (!b.customProperties[i].hasOwnProperty("name"))
          continue;
        if (!b.customProperties[i].hasOwnProperty(propertyType))
          continue;
        if (b.customProperties[i].name == propertyName &&
          b.customProperties[i][propertyType] == valueToMatch)
          bodies.push(b);
      }
    }
    return bodies;
  }

//custom properties
  that.filterElementsByCustomProperty = function (inputElements, propertyType, propertyName, valueToMatch) {
    //console.log('inputElements : ', inputElements, 'searching for ', valueToMatch);
    var elements = [];
    for (var i in inputElements) {
      var b = inputElements[i];
      if (!b.hasOwnProperty('customProperties'))
        continue;
      for (var i = 0; i < b.customProperties.length; i++) {
        if (!b.customProperties[i].hasOwnProperty("name"))
          continue;
        if (!b.customProperties[i].hasOwnProperty(propertyType))
          continue;
        if (b.customProperties[i].name == propertyName &&
          b.customProperties[i][propertyType] == valueToMatch)
          elements.push(b);
      }
    }
    //console.log('I Found  : ', elements);
    return elements;
  }

  that.hasCustomProperty = function (item, propertyType, propertyName) {
    if (!item.hasOwnProperty('customProperties'))
      return false;
    for (var i = 0; i < item.customProperties.length; i++) {
      if (!item.customProperties[i].hasOwnProperty("name"))
        continue;
      if (!item.customProperties[i].hasOwnProperty(propertyType))
        continue;
      return true;
    }
    return false;
  }

  that.getCustomProperty = function (item, propertyType, propertyName, defaultValue) {
    if (!item.hasOwnProperty('customProperties'))
      return defaultValue;
    for (var i = 0; i < item.customProperties.length; i++) {
      if (!item.customProperties[i].hasOwnProperty("name"))
        continue;
      if (!item.customProperties[i].hasOwnProperty(propertyType))
        continue;
      if (item.customProperties[i].name == propertyName)
        return item.customProperties[i][propertyType];
    }
    return defaultValue;
  }

  that.setCustomProperty = function (item, propertyType, propertyName, value) {
    if (!item.hasOwnProperty('customProperties'))
      return value;
    for (var i = 0; i < item.customProperties.length; i++) {
      if (!item.customProperties[i].hasOwnProperty("name"))
        continue;
      if (!item.customProperties[i].hasOwnProperty(propertyType))
        continue;
      if (item.customProperties[i].name == propertyName)
        item.customProperties[i][propertyType] = value;
    }
    return value;
  }


  return that;
};

module.exports = rubeFileLoader();
},{"../utils/b2Helpers.js":13,"./box2dweb/Box2dWeb-2.1.a.3.js":8}],11:[function(require,module,exports){
"use strict";

var b2 = require('./utils/b2Helpers.js');
var configs = require('./configs.js');

var playerCarMaker = function (car) {

  var that = car;

  that.localBrakeVector = b2.math.MulFV(-0.5, that.localAccelerationVector);
  that.localHandBrakeVector = b2.math.MulFV(-0.5, that.localAccelerationVector);


  that.desiredAngle = 0;

  that.handleKeyboard = function (keyboardData) {
    if (keyboardData.accelerate) {
      that.accelerate();
    }
    if (keyboardData.handbrake) {
      that.handBrake();
    } else {
      that.handBrakeRelease();
    }
    if (keyboardData.brake) {
      that.brake();
    }
    that.updateSteering(keyboardData);
  };

  that.updateSteering = function (keyboardData) {
    var angleNow, angleToTurn, newAngle, position;
    if (keyboardData.right && !that.puddleEffect) {
      that.desiredAngle = that.lockAngleDeg * that.consts.DEGTORAD;
    } else if (keyboardData.left && !that.puddleEffect) {
      that.desiredAngle = -that.lockAngleDeg * that.consts.DEGTORAD;
    } else {
      that.desiredAngle = 0;
    }
    angleNow = that.directionJoints[0].GetJointAngle();
    angleToTurn = that.desiredAngle - angleNow;
    if (Math.abs(angleNow) > that.lockAngleDeg) {
      angleToTurn = -angleNow;
    } else {
      angleToTurn = b2.math.Clamp(angleToTurn, -that.turnPerTimeStep, that.turnPerTimeStep);
    }
    newAngle = angleNow + angleToTurn;
    that.directionJoints[0].SetLimits(newAngle, newAngle);
    that.directionJoints[1].SetLimits(newAngle, newAngle);
    that.updateFriction();
    position = that.b2Body.GetPosition();
    that.pixiSprite.position.x = position.x * configs.consts.METER;
    that.pixiSprite.position.y = position.y * configs.consts.METER;
    that.pixiSprite.rotation = that.b2Body.GetAngle();
  };

  that.accelerate = function () {
    var i, tires;
    tires = that.tires;
    for (i in tires) {
      b2.applyForceToCenter(tires[i], that.localAccelerationVector);
    }
  };

  that.brake = function () {
    var i, tires;
    tires = that.tires;
    for (i in tires) {
      b2.applyForceToCenter(tires[i], that.localBrakeVector);
    }
  };

  that.handBrake = function () {
    var i, tires;
    tires = that.tires;
    for (i in tires) {
      b2.applyForceToCenter(tires[i], that.localHandBrakeVector);
      that.drifting = true;
    }
  };

  that.handBrakeRelease = function () {
    that.drifting = false;
  };

  return that;
};

module.exports = playerCarMaker;
},{"./configs.js":3,"./utils/b2Helpers.js":13}],12:[function(require,module,exports){
"use strict";

var linkedListMaker = require('./utils/linkedList.js');
var keyboardHandler = require('./keyboardHandler.js');
var b2 = require('./utils/b2Helpers.js');
var worldSetup = require('./worldSetup.js');
var configs =  require('./configs.js');
var carMaker = require('./carMaker.js');
var playerCarMaker = require('./playerCarMaker.js');
var checkpointManagerMaker = require('./checkpointManagerMaker.js');
var contactManagerMaker = require('./contactManagerMaker.js');
var dat = require('dat-gui');
var rubeFileLoader = require('./libs/rubeFileLoader.js');

var universe_maker = function (_pixiStage, _trackId, _carIds, gameStepCallback) {

  var that = {};
  var contactListener, puddleRandomDirectionArray;
  that._pixiStage = _pixiStage;
  that._trackId = _trackId;
  that._carIds = _carIds;
  that.gameStepCallback = gameStepCallback;

  that.trackId = that._trackId;
  that.carIds = that._carIds;
  that.world = new b2.dyn.b2World(new b2.cMath.b2Vec2(0, 0), true);
  contactListener = new b2.dyn.b2ContactListener();
  that.playerCar = null;
  that.iaCars = [];
  puddleRandomDirectionArray = new Array(1, -1);
  that.jsonsAssetsList = null;
  that.pixiStage = that._pixiStage;
  that.contactManager = null;
  that.positioning = 0;
  that.pixiRenderer = null;

  that.setPixiRenderer = function (_pixiRenderer) {
    that._pixiRenderer = _pixiRenderer;
    return that.pixiRenderer = that._pixiRenderer;
  };

  that.loadBox2d = function () {
    var carId, j, len, loadingIndex, ref, worldSettingUp;

    that.jsonsAssetsList = linkedListMaker();
    that.jsonsAssetsList.add(configs.tracks[that.trackId].jsonPath, 'track');
    ref = that.carIds;
    for (loadingIndex = j = 0, len = ref.length; j < len; loadingIndex = ++j) {
      carId = ref[loadingIndex];
      that.jsonsAssetsList.add(configs.cars[carId].jsonPath, 'car');
      if (loadingIndex !== 0) {
        that.jsonsAssetsList.add(configs.cars[carId].probesSystemPath, 'probeSystem');
      }
    }
    worldSettingUp = worldSetup(that.jsonsAssetsList);
    worldSettingUp.setWorld(that.world);
    worldSettingUp.launchMultiLoad(that.box2dLoaded);
  };

  /*
   * loaderTrackWallsSet is an array of box2d bodies representing the walls
   * playerCarSet is an object reprensenting the player car, it's built like so:
   {
   carBody : box2dbody,
   rearTires : box2dbody[],
   frontTires : box2dbody[],
   directionJoints : box2dJoint
   }
   * otherCarsSets is an array of such objects
   */
  that.box2dLoaded = function (loaderTrackWallsSet, playerCarSet, otherCarsSets) {
    var carSet, i, ia, j, len, ref, baseCar;
    that.loaderTrackWallsSet = loaderTrackWallsSet;
    that.playerCarSet = playerCarSet;
    that.otherCarsSets = otherCarsSets;

    baseCar = carMaker(0);
    that.playerCar = playerCarMaker(baseCar);
    that.playerCar.checkPointManager = checkpointManagerMaker(3);
    that.playerCar.setBox2dData(that.playerCarSet);

    that.setUpDatGui(that.playerCar);
    that.contactManager = contactManagerMaker(that.world, [that.playerCar]);
    ref = that.otherCarsSets;
    //for (i = j = 0, len = ref.length; j < len; i = ++j) {
    //  carSet = ref[i];
    //  ia = new iaCar(that.consts, 0, CarsConfig[that.carIds[i]]);
    //  ia.setBox2dData(carSet);
    //  that.positionCar(ia, that.pixiStage);
    //  that.iaCars.push(ia);
    //}

    that.pixiStage.addChild(that.playerCar.pixiSprite);
    that.positionCar(that.playerCar, that.pixiStage);
    that.positionTrack(that.loaderTrackWallsSet);
    document.onkeydown = keyboardHandler.handleKeyDown;
    document.onkeyup = keyboardHandler.handleKeyUp;
    that.update();
  };

  that.update = function () {
    var car, j, len, ref;
    requestAnimationFrame(that.update);
    that.world.Step(1 / 60, 3, 3);
    that.world.ClearForces();
    that.world.DrawDebugData();
    that.playerCar.updateData();
    that.playerCar.handleKeyboard(keyboardHandler.keys);
    ref = that.iaCars;
    for (j = 0, len = ref.length; j < len; j++) {
      car = ref[j];
      console.log(car);
      car.updateData();
      car.updateFriction();
    }
    that.gameStepCallback();
  };

  that.positionTrack = function (trackWalls) {
    var j, len, position, trackWall;
    for (j = 0, len = trackWalls.length; j < len; j++) {
      trackWall = trackWalls[j];
      position = trackWall.GetPosition();
      trackWall.SetPosition(b2.math.AddVV(configs.consts.ScreenCenterVector, position));
    }
  };

  that.positionCar = function (carInstance) {
    var pos, startPositions;
    startPositions = rubeFileLoader.getBodiesWithNamesStartingWith(that.world, "start");
    pos = startPositions[that.positioning++].GetPosition();
    carInstance.setPosition(b2.math.AddVV(configs.consts.ScreenCenterVector, pos));
  };

  that.setUpDatGui = function (refObject) {
    var f1, gui;
    gui = new dat.GUI();
    f1 = gui.addFolder('Car Behaviour');
    f1.add(refObject, 'accelerationFactor', 0.05, 0.2);
    f1.add(refObject, 'lockAngleDeg', 20, 50);
    f1.add(refObject, 'driftTrigger', 0.001, 0.01);
    f1.open();
  };

  return that;
};

module.exports = universe_maker;
},{"./carMaker.js":1,"./checkpointManagerMaker.js":2,"./configs.js":3,"./contactManagerMaker.js":4,"./keyboardHandler.js":6,"./libs/rubeFileLoader.js":10,"./playerCarMaker.js":11,"./utils/b2Helpers.js":13,"./utils/linkedList.js":14,"./worldSetup.js":16,"dat-gui":17}],13:[function(require,module,exports){
var Box2D = require('../libs/box2dweb/Box2dWeb-2.1.a.3.js');

var b2 = function () {
  var that = {};


  that.dyn = Box2D.Dynamics;

  that.shapes = Box2D.Collision.Shapes;

  that.cMath = Box2D.Common.Math;

  that.math = Box2D.Common.Math.b2Math;

  that.joints = Box2D.Dynamics.Joints;

  that.findCustomPropertyValue = function (b2Body, cPropertyName, typeName) {
    var i, len, property, ref;
    if (b2Body.customProperties != null) {
      ref = b2Body.customProperties;
      for (i = 0, len = ref.length; i < len; i++) {
        property = ref[i];
        if (property.name === cPropertyName) {
          return property[typeName];
        }
      }
    }
  };

  that.applyForceToCenter = function (b2Body, vector2) {
    return b2Body.ApplyForce(b2Body.GetWorldVector(vector2), b2Body.GetWorldCenter());
  };

  return that;
};

module.exports = b2();

},{"../libs/box2dweb/Box2dWeb-2.1.a.3.js":8}],14:[function(require,module,exports){
var linkedList_maker = function () {

  var that = {};

  that.firstNode = null;
  that.lastNode = null;
  that.size = 0;

  that.add = function (data, dataType) {
    var newNode = {
      data: data,
      next: null,
      dataType: dataType
    };

    if (that.firstNode === null) {
      that.firstNode = newNode;
      that.lastNode = newNode;
    } else {
      that.lastNode.next = newNode;
      that.lastNode = newNode;
    }
    that.size += 1;
    return that.size;
  };

  return that;

};

module.exports = linkedList_maker;
},{}],15:[function(require,module,exports){
"use strict";

var urlHelper = function(){
  var that = {};

  that.loadQueryConfig = function () {
    var queryParams, urlParams;

    urlParams = that.parseQueryString();
    queryParams = {};
    if (urlParams.hasOwnProperty('track')) {
      queryParams.track = urlParams.track;
    } else {
      queryParams.track = 0;
    }
    if (urlParams.hasOwnProperty('cars')) {
      queryParams.cars = urlParams.cars.split(',');
    } else {
      queryParams.cars = [0, 0];
    }
    return queryParams;
  };

  that.parseQueryString = function () {
    var assoc, decode, i, key, keyValues, len, val;
    assoc = {};
    keyValues = location.search.slice(1).split('&');
    decode = function (s) {
      return decodeURIComponent(s.replace(/\+/g, ' '));
    };
    for (i = 0, len = keyValues.length; i < len; i++) {
      val = keyValues[i];
      key = val.split('=');
      if (1 < key.length) {
        assoc[decode(key[0])] = decode(key[1]);
      }
    }
    return assoc;
  };


  return that;
}

module.exports = urlHelper();
},{}],16:[function(require,module,exports){
var rubeFileLoader = require('./libs/rubeFileLoader.js');
var b2 = require('./utils/b2Helpers.js');

var worldSetup = function (resourcesList) {

  console.log(resourcesList);
  var that = {};
  that.jsonLinkedList = resourcesList;
  that.playerCar = null;
  that.otherCars = [];
  that.iaProbeSystems = [];
  that.trackWalls = [];
  that.trackStartPositions = [];
  that.mainLoaderCallback = null;
  that.refWorld = null;
  that.firstCarLoaded = false;
  that.resourceLoadingIndex = 0;

  that.launchMultiLoad = function (callback) {
    that.mainLoaderCallback = callback;
    that.loadResource(that.jsonLinkedList.firstNode);
  };

  that.setWorld = function (world) {
    that.refWorld = world;
  };

  that.loadResource = function (resourceNode) {
    if (resourceNode.data === "") {
      that.loadResource(resourceNode.next);
    }
    return that.loadJSON(resourceNode.data, (function (_that) {
      return function (rawJson) {
        var carBody, carFrontTires, carRearTires, carSet, carsInWorld, dirJoints, dirJointsInWorld, frontTiresInWorld, iaBoundDef, iaCarBody, joint, parsedJson, probeSystem, probeSystemsInWorld, rearTiresInWorld;
        parsedJson = JSON.parse(rawJson);
        parsedJson = _that.preprocessRube(parsedJson);
        _that.refWorld = rubeFileLoader.loadWorldFromRUBE(parsedJson, _that.refWorld, _that.resourceLoadingIndex);
        if (resourceNode.dataType === "car") {
          carsInWorld = rubeFileLoader.getBodiesByCustomProperty(_that.refWorld, "string", "category", "car_body");
          rearTiresInWorld = rubeFileLoader.getBodiesByCustomProperty(_that.refWorld, "string", "category", "wheel_rear");
          frontTiresInWorld = rubeFileLoader.getBodiesByCustomProperty(_that.refWorld, "string", "category", "wheel_front");
          dirJointsInWorld = rubeFileLoader.getNamedJoints(_that.refWorld, "direction");
          carBody = rubeFileLoader.filterElementsByCustomProperty(carsInWorld, 'int', 'loadingIndex', _that.resourceLoadingIndex)[0];
          carRearTires = rubeFileLoader.filterElementsByCustomProperty(rearTiresInWorld, 'int', 'loadingIndex', _that.resourceLoadingIndex);
          carFrontTires = rubeFileLoader.filterElementsByCustomProperty(frontTiresInWorld, 'int', 'loadingIndex', _that.resourceLoadingIndex);
          dirJoints = rubeFileLoader.filterElementsByCustomProperty(dirJointsInWorld, 'int', 'loadingIndex', _that.resourceLoadingIndex);
          carSet = {
            carBody: carBody,
            rearTires: carRearTires,
            frontTires: carFrontTires,
            directionJoints: dirJoints
          };
          if (!_that.firstCarLoaded) {
            _that.playerCar = carSet;
            _that.firstCarLoaded = true;
          } else {
            _that.otherCars.push(carSet);
          }
        } else if (resourceNode.dataType === 'probeSystem') {
          probeSystemsInWorld = rubeFileLoader.getBodiesByCustomProperty(_that.refWorld, "string", "category", "probeSystem");
          probeSystem = rubeFileLoader.filterElementsByCustomProperty(probeSystemsInWorld, 'int', 'loadingIndex', _that.resourceLoadingIndex)[0];
          iaCarBody = _that.otherCars[_that.otherCars.length - 1].carBody;
          iaBoundDef = new b2.joints.b2DistanceJointDef();
          iaBoundDef.bodyA = probeSystem;
          iaBoundDef.bodyB = iaCarBody;
          iaBoundDef.collideConnected = false;
          iaBoundDef.length = 0;
          iaBoundDef.localAnchorB.SetV(new b2.cMath.b2Vec2(0, 0.25));
          joint = _that.refWorld.CreateJoint(iaBoundDef);
          _that.otherCars[_that.otherCars.length - 1].probeSystem = probeSystem;
        } else if (resourceNode.dataType === "track") {
          _that.trackWalls = rubeFileLoader.getBodies(_that.refWorld);
          _that.trackStartPositions = rubeFileLoader.getBodiesWithNamesStartingWith(_that.refWorld);
          _that.trackIaLine = rubeFileLoader.getBodiesByCustomProperty(_that.refWorld, "string", "category", "iaLine")[0];
        }
        _that.resourceLoadingIndex++;
        if (resourceNode.next != null) {
          _that.loadResource(resourceNode.next);
        } else {
          _that.mainLoaderCallback.apply(null, [_that.trackWalls, _that.playerCar, _that.otherCars]);
        }
      };
    })(this));
  };

  that.preprocessRube = function (parsedJson) {
    var fixture, i, index, j, joint, jsonBody, k, len, len1, len2, ref, ref1, ref2;
    ref = parsedJson.body;
    for (i = 0, len = ref.length; i < len; i++) {
      jsonBody = ref[i];
      if (jsonBody.position !== 0) {
        jsonBody.position.y = jsonBody.position.y * -1;
      }
      if (typeof jsonBody.fixture !== "undefined") {
        ref1 = jsonBody.fixture;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          fixture = ref1[j];
          if (fixture.hasOwnProperty("polygon")) {
            for (index in fixture.polygon.vertices.y) {
              fixture.polygon.vertices.y[index] = -fixture.polygon.vertices.y[index];
            }
            fixture.polygon.vertices.x.reverse();
            fixture.polygon.vertices.y.reverse();
          }
          if (fixture.hasOwnProperty("chain")) {
            for (index in fixture.chain.vertices.y) {
              fixture.chain.vertices.y[index] = -fixture.chain.vertices.y[index];
            }
            fixture.chain.vertices.x.reverse();
            fixture.chain.vertices.y.reverse();
          }
        }
      }
    }
    if (parsedJson.hasOwnProperty("joint")) {
      ref2 = parsedJson.joint;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        joint = ref2[k];
        if (joint.anchorA !== 0) {
          joint.anchorA.y = joint.anchorA.y * -1;
        }
        if (joint.anchorB !== 0) {
          joint.anchorB.y = joint.anchorB.y * -1;
        }
        joint.upperLimit = 0;
        joint.lowerLimit = 0;
      }
    }
    return parsedJson;
  };

  that.loadJSON = function (filePath, callback) {
    var xobj;
    xobj = new XMLHttpRequest();
    xobj.overrideMimeType("application/json");
    xobj.open('GET', filePath, true);
    xobj.onreadystatechange = function () {
      if (xobj.readyState === 4 && xobj.status === 200) {
        callback(xobj.responseText);
      }
    };
    xobj.send(null);
  };

  return that;

};

module.exports = worldSetup;
},{"./libs/rubeFileLoader.js":10,"./utils/b2Helpers.js":13}],17:[function(require,module,exports){
module.exports = require('./vendor/dat.gui')
module.exports.color = require('./vendor/dat.color')
},{"./vendor/dat.color":18,"./vendor/dat.gui":19}],18:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);
},{}],19:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);
},{}]},{},[5])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6XFxfUHJvZ1xcR2l0XFxTdXBlclNwcmludFxcYXBwXFxub2RlX21vZHVsZXNcXGd1bHAtYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJEOi9fUHJvZy9HaXQvU3VwZXJTcHJpbnQvYXBwL2pzL2Nhck1ha2VyLmpzIiwiRDovX1Byb2cvR2l0L1N1cGVyU3ByaW50L2FwcC9qcy9jaGVja3BvaW50TWFuYWdlck1ha2VyLmpzIiwiRDovX1Byb2cvR2l0L1N1cGVyU3ByaW50L2FwcC9qcy9jb25maWdzLmpzIiwiRDovX1Byb2cvR2l0L1N1cGVyU3ByaW50L2FwcC9qcy9jb250YWN0TWFuYWdlck1ha2VyLmpzIiwiRDovX1Byb2cvR2l0L1N1cGVyU3ByaW50L2FwcC9qcy9mYWtlX2I4NzMxNmIuanMiLCJEOi9fUHJvZy9HaXQvU3VwZXJTcHJpbnQvYXBwL2pzL2tleWJvYXJkSGFuZGxlci5qcyIsIkQ6L19Qcm9nL0dpdC9TdXBlclNwcmludC9hcHAvanMvbGlicy9TdGF0cy5qcyIsIkQ6L19Qcm9nL0dpdC9TdXBlclNwcmludC9hcHAvanMvbGlicy9ib3gyZHdlYi9Cb3gyZFdlYi0yLjEuYS4zLmpzIiwiRDovX1Byb2cvR2l0L1N1cGVyU3ByaW50L2FwcC9qcy9saWJzL3BpeGkuanMvcGl4aS5kZXYuanMiLCJEOi9fUHJvZy9HaXQvU3VwZXJTcHJpbnQvYXBwL2pzL2xpYnMvcnViZUZpbGVMb2FkZXIuanMiLCJEOi9fUHJvZy9HaXQvU3VwZXJTcHJpbnQvYXBwL2pzL3BsYXllckNhck1ha2VyLmpzIiwiRDovX1Byb2cvR2l0L1N1cGVyU3ByaW50L2FwcC9qcy91bml2ZXJzZU1ha2VyLmpzIiwiRDovX1Byb2cvR2l0L1N1cGVyU3ByaW50L2FwcC9qcy91dGlscy9iMkhlbHBlcnMuanMiLCJEOi9fUHJvZy9HaXQvU3VwZXJTcHJpbnQvYXBwL2pzL3V0aWxzL2xpbmtlZExpc3QuanMiLCJEOi9fUHJvZy9HaXQvU3VwZXJTcHJpbnQvYXBwL2pzL3V0aWxzL3VybEhlbHBlci5qcyIsIkQ6L19Qcm9nL0dpdC9TdXBlclNwcmludC9hcHAvanMvd29ybGRTZXR1cC5qcyIsIkQ6L19Qcm9nL0dpdC9TdXBlclNwcmludC9hcHAvbm9kZV9tb2R1bGVzL2RhdC1ndWkvaW5kZXguanMiLCJEOi9fUHJvZy9HaXQvU3VwZXJTcHJpbnQvYXBwL25vZGVfbW9kdWxlcy9kYXQtZ3VpL3ZlbmRvci9kYXQuY29sb3IuanMiLCJEOi9fUHJvZy9HaXQvU3VwZXJTcHJpbnQvYXBwL25vZGVfbW9kdWxlcy9kYXQtZ3VpL3ZlbmRvci9kYXQuZ3VpLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1blZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbmZpZ3MgPSByZXF1aXJlKCcuL2NvbmZpZ3MuanMnKTtcbnZhciBiMiA9IHJlcXVpcmUoJy4vdXRpbHMvYjJIZWxwZXJzLmpzJyk7XG52YXIgUElYSSA9IHJlcXVpcmUoJy4vbGlicy9waXhpLmpzL3BpeGkuZGV2LmpzJyk7XG5cbnZhciBjYXJNYWtlciA9IGZ1bmN0aW9uIChjYXJJbmRleCkge1xuICB2YXIgdGhhdCA9IHt9LFxuICAgIGNhckNvbmZpZyA9IGNvbmZpZ3MuY2Fyc1tjYXJJbmRleF0sXG4gIC8vIEIyXG4gICAgZnJvbnRUaXJlcyA9IFtdLFxuICAgIHJlYXJUaXJlcyA9IFtdLFxuICAgIHRpcmVzID0gW10sXG4gICAgdGlyZXNDb3VudCA9IDAsXG5cbiAgICBwcm9iZVN5c3RlbSA9IG51bGwsXG5cbiAgLy8gQ2FyIEJlaGF2aW91cnNcblxuICAgIGxvY2FsTm9ybWFsVmVjdG9yID0gbmV3IGIyLmNNYXRoLmIyVmVjMigxLCAwKSxcbiAgICB2Q3VycmVudFJpZ2h0Tm9ybWFscyA9IFtdLFxuICAgIGxpbmVhclZlbG9jaXRpZXMgPSBbXSxcbiAgICBjdXJyZW50UmlnaHRGb3J3YXJkcyA9IFtdLFxuXG4gIC8vdmFyICBmcm9tIGxvY2sgdG8gbG9jayBpbiAwLjUgc2VjXG4gICAgYWRoZXJlbmNlRmFjdG9yID0gMTtcblxuXG4gIC8vc3RhdGVzXG4gIHRoYXQuYWRoZXJlbmNlID0gdHJ1ZTtcbiAgdGhhdC5kcmlmdGluZyA9IGZhbHNlO1xuICB0aGF0LnB1ZGRsZUVmZmVjdCA9IGZhbHNlO1xuXG4gIC8vZm9yIG5vdyBjaGVja1BvaW50cyBhcmUgcmVsYXRpdmUgdG8gY2FycywgdGhleSBzaG91bGRuJ3QuLi5cbiAgdGhhdC5jaGVja1BvaW50TWFuYWdlciA9IG51bGw7XG5cbiAgdGhhdC5hY2NlbGVyYXRpb25GYWN0b3IgPSBjYXJDb25maWcuYWNjZWxlcmF0aW9uRmFjdG9yO1xuICB0aGF0LmxvY2FsQWNjZWxlcmF0aW9uVmVjdG9yID0gbmV3IGIyLmNNYXRoLmIyVmVjMigwLCAtdGhhdC5hY2NlbGVyYXRpb25GYWN0b3IpO1xuXG4gIHRoYXQudHVyblNwZWVkUGVyU2VjID0gY29uZmlncy5jYXJzW2NhckluZGV4XS5zdGVlcmluZ1doZWVsU3BlZWQgKiBjb25maWdzLmNvbnN0cy5ERUdUT1JBRDtcbiAgdGhhdC50dXJuUGVyVGltZVN0ZXAgPSB0aGF0LnR1cm5TcGVlZFBlclNlYyAvIDYwO1xuXG4gIC8vIFN0ZWVyaW5nIG1nbXRcbiAgdGhhdC5sb2NrQW5nbGVEZWcgPSBjYXJDb25maWcud2hlZWxNYXhBbmdsZTtcbiAgdGhhdC5kcmlmdFRyaWdnZXIgPSBjYXJDb25maWcuZHJpZnRUcmlnZ2VyO1xuICB0aGF0LmRpcmVjdGlvbkpvaW50cyA9IFtdO1xuXG4gIC8vUElYSVxuICB0aGF0LnBpeGlTcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUoUElYSS5UZXh0dXJlLmZyb21GcmFtZShjb25maWdzLmNhcnNbY2FySW5kZXhdLnNwcml0ZVBhdGgpKTtcbiAgdGhhdC5waXhpU3ByaXRlLmFuY2hvci54ID0gMC41O1xuICB0aGF0LnBpeGlTcHJpdGUuYW5jaG9yLnkgPSAwLjU7XG4gIHRoYXQucGl4aVNwcml0ZS5zY2FsZS54ID0gMTtcbiAgdGhhdC5waXhpU3ByaXRlLnNjYWxlLnkgPSAxO1xuXG4gIHRoYXQuc2V0Qm94MmREYXRhID0gZnVuY3Rpb24gKGJveDJkRGF0YSkge1xuICAgIHJlYXJUaXJlcyA9IGJveDJkRGF0YS5yZWFyVGlyZXM7XG4gICAgZnJvbnRUaXJlcyA9IGJveDJkRGF0YS5mcm9udFRpcmVzO1xuICAgIHRpcmVzID0gcmVhclRpcmVzLmNvbmNhdChmcm9udFRpcmVzKTtcbiAgICB0aXJlc0NvdW50ID0gdGlyZXMubGVuZ3RoO1xuICAgIHRoYXQuZGlyZWN0aW9uSm9pbnRzID0gYm94MmREYXRhLmRpcmVjdGlvbkpvaW50cztcbiAgICBpZiAoYm94MmREYXRhLmhhc093blByb3BlcnR5KFwicHJvYmVTeXN0ZW1cIikpIHtcbiAgICAgIHZhciBwcm9iZVN5c3RlbSA9IGJveDJkRGF0YS5wcm9iZVN5c3RlbTtcbiAgICB9XG4gICAgaWYgKHRoYXQuZGlyZWN0aW9uSm9pbnRzWzBdKSB7XG4gICAgICB0aGF0LmRpcmVjdGlvbkpvaW50c1swXS5TZXRMaW1pdHMoMCwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhhdC5kaXJlY3Rpb25Kb2ludHNbMV0uU2V0TGltaXRzKDAsIDApO1xuICAgIH1cbiAgICB0aGF0LmIyQm9keSA9IGJveDJkRGF0YS5jYXJCb2R5O1xuICAgIHJldHVybiB0aGF0LmIyQm9keTtcbiAgfTtcblxuICB0aGF0LnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKGNob3NlblBvc2l0aW9uKSB7XG4gICAgdmFyIHRlbXAgPSBjaG9zZW5Qb3NpdGlvbi5Db3B5KCk7XG4gICAgdGVtcC5BZGQodGhhdC5iMkJvZHkuR2V0UG9zaXRpb24oKSk7XG4gICAgdGhhdC5iMkJvZHkuU2V0UG9zaXRpb24odGVtcCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGVtcCA9IGNob3NlblBvc2l0aW9uLkNvcHkoKTtcbiAgICAgIHRlbXAuQWRkKHRpcmVzW2ldLkdldFBvc2l0aW9uKCkpO1xuICAgICAgdGlyZXNbaV0uU2V0UG9zaXRpb24odGVtcCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvYmVTeXN0ZW0gIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvYmVTeXN0ZW0gIT09IG51bGwpIHtcbiAgICAgIHRlbXAgPSBjaG9zZW5Qb3NpdGlvbi5Db3B5KCk7XG4gICAgICB0ZW1wLkFkZChwcm9iZVN5c3RlbS5HZXRQb3NpdGlvbigpKTtcbiAgICAgIHByb2JlU3lzdGVtLlNldFBvc2l0aW9uKHRlbXApO1xuICAgIH1cbiAgfTtcblxuICB0aGF0LnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoa2V5Ym9hcmREYXRhKSB7XG4gICAgdGhhdC5sb2NhbEFjY2VsZXJhdGlvblZlY3RvciA9IG5ldyBiMi5jTWF0aC5iMlZlYzIoMCwgLXRoYXQuYWNjZWxlcmF0aW9uRmFjdG9yKTtcbiAgICAvL3RpcmVzID0gQHRpcmVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGluZWFyVmVsb2NpdGllc1tpXSA9IHRoYXQuZ2V0TGluZWFyVmVsb2NpdHkoaSlcbiAgICAgIGN1cnJlbnRSaWdodEZvcndhcmRzW2ldID0gdGlyZXNbaV0uR2V0V29ybGRWZWN0b3IobmV3IGIyLmNNYXRoLmIyVmVjMigwLCAxKSk7XG4gICAgICB2Q3VycmVudFJpZ2h0Tm9ybWFsc1tpXSA9IHRoYXQuZ2V0TGF0ZXJhbFZlbG9jaXR5KGkpXG4gICAgfVxuICB9O1xuXG4gIHRoYXQubmVnYXRlVG9ycXVlID0gZnVuY3Rpb24gKHRpcmVJbmRleCkge1xuICAgIHJldHVybiBiMi5tYXRoLkRvdChjdXJyZW50UmlnaHRGb3J3YXJkc1t0aXJlSW5kZXhdLCBsaW5lYXJWZWxvY2l0aWVzW3RpcmVJbmRleF0pIDwgLTAuMDEgPyAtMSA6IDE7XG4gIH07XG5cbiAgdGhhdC5nZXRMYXRlcmFsVmVsb2NpdHkgPSBmdW5jdGlvbiAodGlyZUluZGV4KSB7XG4gICAgdmFyIGN1cnJlbnRSaWdodE5vcm1hbCA9IHRpcmVzW3RpcmVJbmRleF0uR2V0V29ybGRWZWN0b3IobG9jYWxOb3JtYWxWZWN0b3IpO1xuICAgIHZhciB2Q3VycmVudFJpZ2h0Tm9ybWFsID0gYjIubWF0aC5NdWxGVihcbiAgICAgIGIyLm1hdGguRG90KGN1cnJlbnRSaWdodE5vcm1hbCwgbGluZWFyVmVsb2NpdGllc1t0aXJlSW5kZXhdKSxcbiAgICAgIGN1cnJlbnRSaWdodE5vcm1hbFxuICAgICk7XG4gICAgcmV0dXJuIHZDdXJyZW50UmlnaHROb3JtYWw7XG4gIH07XG5cbiAgdGhhdC5nZXRMaW5lYXJWZWxvY2l0eSA9IGZ1bmN0aW9uICh0aXJlSW5kZXgpIHtcbiAgICByZXR1cm4gdGlyZXNbdGlyZUluZGV4XS5HZXRMaW5lYXJWZWxvY2l0eSgpO1xuICB9O1xuXG4gIHRoYXQuZ2V0Rm9yd2FyZFZlbG9jaXR5ID0gZnVuY3Rpb24gKHRpcmVJbmRleCkge1xuICAgIHZhciB2Q3VycmVudFJpZ2h0Rm9yd2FyZCA9IGIyLm1hdGguTXVsRlYoXG4gICAgICBiMi5tYXRoLkRvdChjdXJyZW50UmlnaHRGb3J3YXJkc1t0aXJlSW5kZXhdLCBsaW5lYXJWZWxvY2l0aWVzW3RpcmVJbmRleF0pLFxuICAgICAgY3VycmVudFJpZ2h0Rm9yd2FyZHNbdGlyZUluZGV4XVxuICAgICk7XG4gICAgcmV0dXJuIHZDdXJyZW50UmlnaHRGb3J3YXJkO1xuICB9O1xuXG4gIHRoYXQuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24gKHZlYzIpIHtcbiAgICAvL3RpcmVzID0gQHRpcmVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYjIuYXBwbHlGb3JjZVRvQ2VudGVyKHRpcmVzW2ldLCB2ZWMyKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC51cGRhdGVGcmljdGlvbiA9IGZ1bmN0aW9uICh2ZWMyKSB7XG4gICAgLy90aXJlcyA9IEB0aXJlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlyZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgaWYgKHRoYXQuYWRoZXJlbmNlKSB7XG4gICAgICAgIHZhciB0aXJlVHlwZSA9IGIyLmZpbmRDdXN0b21Qcm9wZXJ0eVZhbHVlKHRpcmVzW2ldLCAnY2F0ZWdvcnknLCAnc3RyaW5nJylcbiAgICAgICAgaWYgKHRpcmVUeXBlID09ICd3aGVlbF9yZWFyJyAmJiB0aGF0LmRyaWZ0aW5nKSB7XG4gICAgICAgICAgYWRoZXJlbmNlRmFjdG9yID0gMC4yXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWRoZXJlbmNlRmFjdG9yID0gMVxuICAgICAgICB9XG4gICAgICAgIHZhciBpbXB1bHNlID0gYjIubWF0aC5NdWxGVigtYWRoZXJlbmNlRmFjdG9yICogdGlyZXNbaV0uR2V0TWFzcygpLCB2Q3VycmVudFJpZ2h0Tm9ybWFsc1tpXSk7XG4gICAgICAgIGlmIChpbXB1bHNlLkxlbmd0aCgpID4gdGhhdC5kcmlmdFRyaWdnZXIpIHtcbiAgICAgICAgICBpbXB1bHNlID0gYjIubWF0aC5NdWxGVih0aGF0LmRyaWZ0VHJpZ2dlciAvIGltcHVsc2UuTGVuZ3RoKCksIGltcHVsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRpcmVzW2ldLkFwcGx5SW1wdWxzZShpbXB1bHNlLCB0aXJlc1tpXS5HZXRXb3JsZENlbnRlcigpKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgaGFzIHNvbWUgZWZmZWN0IG9uIGhvdyB0aGUgY2FyIHR1cm5zXG4gICAgICB2YXIgaW5lcnRpYSA9IHRpcmVzW2ldLkdldEluZXJ0aWEoKVxuICAgICAgdmFyIHZlbCA9IHRpcmVzW2ldLkdldEFuZ3VsYXJWZWxvY2l0eSgpO1xuICAgICAgdGlyZXNbaV0uQXBwbHlBbmd1bGFySW1wdWxzZSgxMCAqIGluZXJ0aWEgKiAtdmVsKTtcblxuICAgICAgLy8gbmF0dXJhbCBmcmljdGlvbiBhZ2FpbnN0IG1vdmVtZW50LiBUaGlzIGlzIGEgRiA9IC1rdiB0eXBlIGZvcmNlLlxuICAgICAgdmFyIGN1cnJlbnRGb3J3YXJkTm9ybWFsID0gdGhhdC5nZXRGb3J3YXJkVmVsb2NpdHkoaSk7XG4gICAgICB2YXIgY3VycmVudEZvcndhcmRTcGVlZCA9IGN1cnJlbnRGb3J3YXJkTm9ybWFsLk5vcm1hbGl6ZSgpO1xuICAgICAgdmFyIGRyYWdGb3JjZU1hZ25pdHVkZSA9IC1jYXJDb25maWcubmF0dXJhbF9kZWNlbGVyYXRpb24gKiBjdXJyZW50Rm9yd2FyZFNwZWVkO1xuICAgICAgdGlyZXNbaV0uQXBwbHlGb3JjZShiMi5tYXRoLk11bEZWKGRyYWdGb3JjZU1hZ25pdHVkZSwgY3VycmVudEZvcndhcmROb3JtYWwpLCB0aXJlc1tpXS5HZXRXb3JsZENlbnRlcigpKTtcblxuICAgICAgLy8gaGVyZSB3ZSB1cGRhdGUgaG93IHRoZSBjYXIgYmVoYXZlIHdoZW4gaXRzIHB1ZGRsZUVmZmVjdCBpcyBvbiAoc2xpZGluZyBvbiBhIHBhZGRsZSkuXG4gICAgICBpZiAodGhhdC5wdWRkbGVFZmZlY3QpIHtcbiAgICAgICAgdGlyZXNbaV0uQXBwbHlUb3JxdWUoKHRoYXQucHVkZGxlRWZmZWN0ID8gMSA6IDApICogY2FyQ29uZmlnLnB1ZGRsZUZhY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGF0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhck1ha2VyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY2hlY2twb2ludE1hbmFnZXJNYWtlciA9IGZ1bmN0aW9uIChuYkNoZWNrUG9pbnRzKSB7XG4gIHZhciB0aGF0ID0ge30sXG4gICAgbmJDaGVja1BvaW50cyA9IG5iQ2hlY2tQb2ludHMsXG4gICAgY3VycmVudENoZWNrUG9pbnRJbmRleCA9IC0xLFxuICAgIHN0YXJ0TGFwID0gbnVsbCxcbiAgICBsYXN0TGFwVGltZSA9IG51bGwsXG4gICAgYmVzdExhcFRpbWUgPSAwLFxuICAgIG5iTGFwcyA9IDA7XG5cbiAgdGhhdC5zdGVwID0gZnVuY3Rpb24gKGNoZWNrcG9pbnRJbmRleCkge1xuICAgIHZhciBsYXBUaW1lLCBub3c7XG4gICAgaWYgKGN1cnJlbnRDaGVja1BvaW50SW5kZXggJSBuYkNoZWNrUG9pbnRzID09PSBjaGVja3BvaW50SW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoZWNrcG9pbnRJbmRleCA9PT0gMCkge1xuICAgICAgaWYgKGN1cnJlbnRDaGVja1BvaW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHN0YXJ0TGFwID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY3VycmVudENoZWNrUG9pbnRJbmRleCA9IDA7XG4gICAgICAgIHRoYXQudXBkYXRlTGFwVGltZSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGxhcFRpbWUgPSBub3cgLSBzdGFydExhcDtcbiAgICAgICAgbGFzdExhcFRpbWUgPSBsYXBUaW1lO1xuICAgICAgICBzdGFydExhcCA9IG5vdztcbiAgICAgICAgaWYgKGJlc3RMYXBUaW1lID09PSAwKSB7XG4gICAgICAgICAgYmVzdExhcFRpbWUgPSBsYXN0TGFwVGltZTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0TGFwVGltZSA8IGJlc3RMYXBUaW1lKSB7XG4gICAgICAgICAgYmVzdExhcFRpbWUgPSBsYXN0TGFwVGltZTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0LnVwZGF0ZUxhcFRpbWUobGFzdExhcFRpbWUpO1xuICAgICAgICB0aGF0LnVwZGF0ZUJlc3RMYXBUaW1lKGJlc3RMYXBUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoZWNrcG9pbnRJbmRleCA9PT0gKGN1cnJlbnRDaGVja1BvaW50SW5kZXggKyAxKSAlIG5iQ2hlY2tQb2ludHMpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Q2hlY2tQb2ludEluZGV4Kys7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQudXBkYXRlTGFwVGltZSA9IGZ1bmN0aW9uICh2YWx1ZUluTXMpIHtcbiAgICB2YXIgc3RyVmFsdWUgPSB0eXBlb2YgdmFsdWVJbk1zICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlSW5NcyAvIDEwMDAgKyBcInNcIiA6IFwiLS0tXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsYXBUaW1lXCIpLmlubmVySFRNTCA9IFwiTGFwIDogXCIgKyBzdHJWYWx1ZTtcbiAgfTtcbiAgdGhhdC51cGRhdGVCZXN0TGFwVGltZSA9IGZ1bmN0aW9uICh2YWx1ZUluTXMpIHtcbiAgICB2YXIgc3RyVmFsdWUgPSB0eXBlb2YgdmFsdWVJbk1zICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlSW5NcyAvIDEwMDAgKyBcInNcIiA6IFwiLS0tXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJiZXN0TGFwVGltZVwiKS5pbm5lckhUTUwgPSBcIkJlc3QgOiBcIiArIHN0clZhbHVlO1xuICB9O1xuXG4gIHRoYXQudXBkYXRlTGFwVGltZSgpO1xuICB0aGF0LnVwZGF0ZUJlc3RMYXBUaW1lKCk7XG5cbiAgcmV0dXJuIHRoYXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrcG9pbnRNYW5hZ2VyTWFrZXI7IiwidmFyIGIyID0gcmVxdWlyZSgnLi91dGlscy9iMkhlbHBlcnMuanMnKTtcclxuXHJcbnZhciBjb25maWdzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB0aGF0ID0ge307XHJcblxyXG4gIHRoYXQuY29uc3RzID0ge1xyXG4gICAgTUVURVI6IDEwMCxcclxuICAgIFNUQUdFX1dJRFRIX1BJWEVMOiAxMDAwLFxyXG4gICAgU1RBR0VfSEVJR0hUX1BJWEVMOiA3NTAsXHJcbiAgICBERUdUT1JBRDogMiAqIE1hdGguUEkgLyAzNjBcclxuICB9O1xyXG4gIHRoYXQuY29uc3RzLlNUQUdFX1dJRFRIX0IyID0gdGhhdC5jb25zdHMuU1RBR0VfV0lEVEhfUElYRUwgLyB0aGF0LmNvbnN0cy5NRVRFUjtcclxuICB0aGF0LmNvbnN0cy5TVEFHRV9IRUlHSFRfQjIgPSB0aGF0LmNvbnN0cy5TVEFHRV9IRUlHSFRfUElYRUwgLyB0aGF0LmNvbnN0cy5NRVRFUjtcclxuICB0aGF0LmNvbnN0cy5TY3JlZW5DZW50ZXJWZWN0b3IgPSBuZXcgYjIuY01hdGguYjJWZWMyKHRoYXQuY29uc3RzLlNUQUdFX1dJRFRIX0IyIC8gMiwgdGhhdC5jb25zdHMuU1RBR0VfSEVJR0hUX0IyIC8gMik7XHJcblxyXG4gIHRoYXQudHJhY2tzID0gW107XHJcbiAgdGhhdC50cmFja3NbMF0gPSB7XHJcbiAgICBpZDogMCxcclxuICAgIG5iQ2hlY2twb2ludHM6IDMsXHJcbiAgICBqc29uUGF0aDogJ2Fzc2V0cy90cmFja3MvdHJhY2swLmpzb24nLFxyXG4gICAgaW1hZ2VQYXRoOiAnYXNzZXRzL3RyYWNrcy9pbWFnZXMvdHJhY2sxLnBuZydcclxuICB9O1xyXG4gIHRoYXQudHJhY2tzWzFdID0ge1xyXG4gICAgaWQ6IDEsXHJcbiAgICBuYkNoZWNrcG9pbnRzOiAzLFxyXG4gICAganNvblBhdGg6ICdhc3NldHMvdHJhY2tzL3RyYWNrMS5qc29uJyxcclxuICAgIGltYWdlUGF0aDogJ2Fzc2V0cy90cmFja3MvaW1hZ2VzL3RyYWNrMS5wbmcnXHJcbiAgfTtcclxuXHJcbiAgdGhhdC5jYXJzID0gW107XHJcbiAgdGhhdC5jYXJzWzBdID0ge1xyXG4gICAgd2lkdGg6IDQwLCAvLyBweCB1bml0XHJcbiAgICBoZWlnaHQ6IDI1LCAvLyBweCB1bml0XHJcbiAgICBzcHJpdGVQYXRoOiAnYXNzZXRzL2NhcnMvaW1hZ2VzL1ZvaXR1cmVfMDMucG5nJyxcclxuICAgIGpzb25QYXRoOiAnYXNzZXRzL2NhcnMvY2FyMC5qc29uJyxcclxuICAgIHByb2Jlc1N5c3RlbVBhdGg6ICdhc3NldHMvY2Fycy9wcm9iZVN5c3RlbTAuanNvbicsXHJcbiAgICAvLyBwaHlzaWNzIHByb3BlcnRpZXNcclxuICAgIGFjY2VsZXJhdGlvbkZhY3RvcjogMC4xLFxyXG4gICAgZHJpZnRUcmlnZ2VyOiAwLjAwMyxcclxuICAgIGRyaWZ0VHJpZ2dlcldpdGhIYW5kYnJha2U6IDAuMDAxLFxyXG4gICAgbmF0dXJhbF9kZWNlbGVyYXRpb246IDAuMDEsXHJcbiAgICBzdGVlcmluZ1doZWVsU3BlZWQ6IDIwMCxcclxuICAgIHdoZWVsTWF4QW5nbGU6IDMwLFxyXG4gICAgLy8gY2FyIGJvZHlcclxuICAgIHJlc3RpdHV0aW9uOiAwLjEsXHJcbiAgICBwdWRkbGVGYWN0b3I6IDAuMDA1XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHRoYXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ3MoKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGIyID0gcmVxdWlyZSgnLi91dGlscy9iMkhlbHBlcnMuanMnKTtcblxudmFyIGNvbnRhY3RNYW5hZ2VyTWFrZXIgPSBmdW5jdGlvbiAod29ybGQsIGNhcnMpIHtcbiAgdmFyIHRoYXQgPSB7fTtcblxuICB2YXIgY29udGFjdExpc3RlbmVyID0gbmV3IGIyLmR5bi5iMkNvbnRhY3RMaXN0ZW5lcigpO1xuXG4gIGNvbnRhY3RMaXN0ZW5lci5CZWdpbkNvbnRhY3QgPSBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgIHRoYXQuSGFuZGxlQ29udGFjdChjb250YWN0LCB0cnVlKTtcbiAgfTtcblxuICBjb250YWN0TGlzdGVuZXIuRW5kQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0KSB7XG4gICAgdGhhdC5IYW5kbGVDb250YWN0KGNvbnRhY3QsIGZhbHNlKTtcbiAgfTtcblxuICB3b3JsZC5TZXRDb250YWN0TGlzdGVuZXIoY29udGFjdExpc3RlbmVyKTtcblxuXG4gIHRoYXQuSGFuZGxlQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0LCBiZWdhbikge1xuICAgIHZhciBjSW5mbyA9IHRoYXQuRXh0cmFjdENvbnRhY3RUeXBlKGNvbnRhY3QpO1xuICAgIGlmIChjSW5mby50eXBlID09PSBcIndhbGxcIilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoYmVnYW4pIHtcbiAgICAgIHN3aXRjaCAoY0luZm8udHlwZSkge1xuICAgICAgICBjYXNlIFwiY3BcIjpcbiAgICAgICAgICBjYXJzWzBdLmNoZWNrUG9pbnRNYW5hZ2VyLlN0ZXAocGFyc2VJbnQoY0luZm8uaWQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInB1ZGRsZVwiOlxuICAgICAgICAgIGNhcnNbMF0uYWRoZXJlbmNlID0gZmFsc2U7XG4gICAgICAgICAgY2Fyc1swXS5wYWRkbGVFZmZlY3QgPSBwdWRkbGVSYW5kb21EaXJlY3Rpb25BcnJheVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJib29zdFwiOlxuICAgICAgICAgIHZhciBib29zdFZlY3RvciA9IG5ldyBiMi5jTWF0aC5iMlZlYzIoY0luZm8uYm9vc3RWZWN0b3IueCwgY0luZm8uYm9vc3RWZWN0b3IueSk7XG4gICAgICAgICAgY2Fyc1swXS5BcHBseUltcHVsc2UoYm9vc3RWZWN0b3IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhcnNbMF0uYWRoZXJlbmNlID0gdHJ1ZTtcbiAgICAgIGNhcnNbMF0ucGFkZGxlRWZmZWN0ID0gMDtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5FeHRyYWN0Q29udGFjdFR5cGUgPSBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgIHZhciBhRGF0YSA9IGNvbnRhY3QuR2V0Rml4dHVyZUEoKTtcbiAgICB2YXIgYkRhdGEgPSBjb250YWN0LkdldEZpeHR1cmVCKCk7XG5cbiAgICBpZiAoYURhdGEubmFtZSA9PT0gJ3dhbGxGaXh0dXJlJyB8fCBiRGF0YS5uYW1lID09PSAnd2FsbEZpeHR1cmUnKVxuICAgICAgcmV0dXJuIHsgJ3R5cGUnOiAnd2FsbCcgfTtcblxuICAgIGlmIChhRGF0YS5uYW1lLmluZGV4T2YoJ2NwJykgPT09IDApXG4gICAgICByZXR1cm4ge1xuICAgICAgICAndHlwZSc6ICdjcCcsXG4gICAgICAgICdpZCc6IGFEYXRhLm5hbWUuc3Vic3RyKDIsIDMpXG4gICAgICB9O1xuICAgIGlmIChiRGF0YS5uYW1lLmluZGV4T2YoJ2NwJykgPT09IDApXG4gICAgICByZXR1cm4ge1xuICAgICAgICAndHlwZSc6ICdjcCcsXG4gICAgICAgICdpZCc6IGJEYXRhLm5hbWUuc3Vic3RyKDIsIDMpXG4gICAgICB9O1xuICAgIGlmIChhRGF0YS5uYW1lLmluZGV4T2YoJ2Jvb3N0JykgPT09IDApXG4gICAgICByZXR1cm4ge1xuICAgICAgICAndHlwZSc6ICdib29zdCcsXG4gICAgICAgICdib29zdFZlY3Rvcic6IGFEYXRhLmN1c3RvbVByb3BlcnRpZXNbMF0udmVjMlxuICAgICAgfTtcbiAgICBpZiAoYkRhdGEubmFtZS5pbmRleE9mKCdib29zdCcpID09PSAwKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3R5cGUnOiAnYm9vc3QnLFxuICAgICAgICAnYm9vc3RWZWN0b3InOiBiRGF0YS5jdXN0b21Qcm9wZXJ0aWVzWzBdLnZlYzJcbiAgICAgIH07XG4gICAgcmV0dXJuIHsgJ3R5cGUnOiAnJyB9O1xuICB9O1xuXG4gIHJldHVybiB0aGF0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWN0TWFuYWdlck1ha2VyOyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHVuaXZlcnNlX21ha2VyID0gcmVxdWlyZSgnLi91bml2ZXJzZU1ha2VyLmpzJyk7XHJcbnZhciBiMiA9IHJlcXVpcmUoJy4vdXRpbHMvYjJIZWxwZXJzLmpzJyk7XHJcbnZhciB1cmxIZWxwZXIgPSByZXF1aXJlKCcuL3V0aWxzL3VybEhlbHBlci5qcycpO1xyXG52YXIgUElYSSA9IHJlcXVpcmUoJy4vbGlicy9waXhpLmpzL3BpeGkuZGV2LmpzJyk7XHJcbnZhciBTdGF0cyA9IHJlcXVpcmUoJy4vbGlicy9TdGF0cy5qcycpO1xyXG52YXIgY29uZmlncyA9ICByZXF1aXJlKCcuL2NvbmZpZ3MuanMnKTtcclxuXHJcbnZhciBzdXBlclNwcmludEdhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHRoYXQgPSB7fTtcclxuXHJcbiAgdGhhdC5zdGF0cyA9IG5ldyBTdGF0cygpO1xyXG4gIHRoYXQucGl4aVN0YWdlID0gbmV3IFBJWEkuU3RhZ2UoMHhEREREREQsIHRydWUpO1xyXG4gIHRoYXQucXVlcnlQYXJhbXMgPSB1cmxIZWxwZXIubG9hZFF1ZXJ5Q29uZmlnKCk7XHJcbiAgdGhhdC51bml2ZXJzZSA9IHVuaXZlcnNlX21ha2VyKHRoYXQucGl4aVN0YWdlLCB0aGF0LnF1ZXJ5UGFyYW1zLnRyYWNrLCB0aGF0LnF1ZXJ5UGFyYW1zLmNhcnMsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGF0LnN0YXRzLnVwZGF0ZSgpO1xyXG4gIH0pO1xyXG5cclxuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xyXG4gIGNhbnZhcy53aWR0aCA9IGNvbmZpZ3MuU1RBR0VfV0lEVEhfUElYRUw7XHJcbiAgY2FudmFzLmhlaWdodCA9IGNvbmZpZ3MuU1RBR0VfSEVJR0hUX1BJWEVMO1xyXG5cclxuICB0aGF0LmluaXRXaW5kb3dBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICAgICAgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgICB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHdpbmRvdy5vbmxvYWQgPSB0aGF0LmluaXRQaXhpO1xyXG4gIH07XHJcblxyXG4gIHRoYXQuaW5pdFBpeGkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmFja2dyb3VuZCwgY29udGFpbmVyLCBwaXhpTG9hZGVyO1xyXG4gICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGF0LnN0YXRzLmRvbUVsZW1lbnQpO1xyXG4gICAgdGhhdC5zdGF0cy5kb21FbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgdGhhdC5waXhpUmVuZGVyZXIgPSBQSVhJLmF1dG9EZXRlY3RSZW5kZXJlcihjb25maWdzLlNUQUdFX1dJRFRIX1BJWEVMLCBjb25maWdzLlNUQUdFX0hFSUdIVF9QSVhFTCwgdm9pZCAwLCBmYWxzZSk7XHJcbiAgICB0aGF0LnVuaXZlcnNlLnNldFBpeGlSZW5kZXJlcih0aGF0LnBpeGlSZW5kZXJlcik7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZUNvbnRhaW5lcicpLmFwcGVuZENoaWxkKHRoYXQucGl4aVJlbmRlcmVyLnZpZXcpO1xyXG4gICAgYmFja2dyb3VuZCA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZSgnYXNzZXRzL3RyYWNrcy9pbWFnZXMvdHJhY2swLnBuZycpO1xyXG4gICAgdGhhdC5waXhpU3RhZ2UuYWRkQ2hpbGQoYmFja2dyb3VuZCk7XHJcbiAgICBwaXhpTG9hZGVyID0gbmV3IFBJWEkuQXNzZXRMb2FkZXIoW2NvbmZpZ3MuY2Fyc1t0aGF0LnF1ZXJ5UGFyYW1zLmNhcnNbMF1dLnNwcml0ZVBhdGhdKTtcclxuICAgIHBpeGlMb2FkZXIub25Db21wbGV0ZSA9IHRoYXQubG9hZFVuaXZlcnNlO1xyXG4gICAgcmV0dXJuIHBpeGlMb2FkZXIubG9hZCgpO1xyXG4gIH07XHJcblxyXG4gIHRoYXQubG9hZFVuaXZlcnNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoYXQudW5pdmVyc2UubG9hZEJveDJkKCk7XHJcbiAgfTtcclxuXHJcbiAgdGhhdC5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZGVidWdEcmF3ZXI7XHJcbiAgICBkZWJ1Z0RyYXdlciA9IG5ldyBiMi5keW4uYjJEZWJ1Z0RyYXcoKTtcclxuICAgIGRlYnVnRHJhd2VyLlNldFNwcml0ZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIikpO1xyXG4gICAgZGVidWdEcmF3ZXIuU2V0RHJhd1NjYWxlKDEwMC4wKTtcclxuICAgIGRlYnVnRHJhd2VyLlNldEZpbGxBbHBoYSgwLjUpO1xyXG4gICAgZGVidWdEcmF3ZXIuU2V0TGluZVRoaWNrbmVzcygxMC4wKTtcclxuICAgIGRlYnVnRHJhd2VyLlNldEZsYWdzKGIyLmR5bi5iMkRlYnVnRHJhdy5lX3NoYXBlQml0IHwgYjIuZHluLmIyRGVidWdEcmF3LmVfam9pbnRCaXQgfCBiMi5keW4uYjJEZWJ1Z0RyYXcuZV9jb250cm9sbGVyQml0IHwgYjIuZHluLmIyRGVidWdEcmF3LmVfcGFpckJpdCk7XHJcbiAgICByZXR1cm4gdGhhdC51bml2ZXJzZS53b3JsZC5TZXREZWJ1Z0RyYXcoZGVidWdEcmF3ZXIpO1xyXG4gIH07XHJcblxyXG4gIHRoYXQuc3RhcnRHYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhhdC5kZWJ1Z0RyYXcoKTtcclxuICAgIHRoYXQuaW5pdFdpbmRvd0FuaW1hdGlvbkZyYW1lKCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHRoYXQ7XHJcbn07XHJcblxyXG52YXIgZ2FtZSA9IHN1cGVyU3ByaW50R2FtZSgpO1xyXG5nYW1lLnN0YXJ0R2FtZSgpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleWJvYXJkSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB7fTtcblxuICB0aGF0LmtleWFycmF5ID0gW107XG4gIHRoYXQua2V5cyA9IHtcbiAgICBhY2NlbGVyYXRlOiBmYWxzZSxcbiAgICBicmFrZTogZmFsc2UsXG4gICAgbGVmdDogZmFsc2UsXG4gICAgcmlnaHQ6IGZhbHNlLFxuICAgIGhhbmRicmFrZTogZmFsc2VcbiAgfTtcbiAgdGhhdC5oYW5kbGVka2V5cyA9IFszNywgMzgsIDM5LCA0MCwgMzJdO1xuXG4gIHRoYXQuaGFuZGxla2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBrZXksIGtub3drZXk7XG4gICAga2V5ID0gZXZlbnQud2hpY2g7XG4gICAgaWYgKGhhbmRsZWRrZXlzLmluZGV4b2Yoa2V5KSA+IC0xKSB7XG4gICAgICBldmVudC5wcmV2ZW50ZGVmYXVsdCgpO1xuICAgIH1cbiAgICBpZiAoa2V5YXJyYXkuaW5kZXhvZihrZXkpID4gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAga25vd2tleSA9IHRydWU7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgMzc6XG4gICAgICAgIGtleXMubGVmdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAga2V5cy5hY2NlbGVyYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBrZXlzLnJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQwOlxuICAgICAgICBrZXlzLmJyYWtlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDMyOlxuICAgICAgICBrZXlzLmhhbmRicmFrZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAga25vd2tleSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoa25vd2tleSkge1xuICAgICAga2V5YXJyYXkucHVzaChrZXkpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0LmhhbmRsZWtleXVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGksIGtleTtcbiAgICBrZXkgPSBldmVudC53aGljaDtcbiAgICBpID0ga2V5YXJyYXkuaW5kZXhvZihrZXkpO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIGtleWFycmF5LnNwbGljZShpLCAxKTtcbiAgICB9XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgMzc6XG4gICAgICAgIGtleXMubGVmdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIGtleXMuYWNjZWxlcmF0ZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGtleXMucmlnaHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQwOlxuICAgICAgICBrZXlzLmJyYWtlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzMjpcbiAgICAgICAga2V5cy5oYW5kYnJha2UgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGF0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlib2FyZEhhbmRsZXIoKTsiLCJ2YXIgU3RhdHM9ZnVuY3Rpb24oKXt2YXIgaCxhLG49MCxvPTAsaT1EYXRlLm5vdygpLHU9aSxwPWksbD0wLHE9MUUzLHI9MCxlLGosZixiPVtbMTYsMTYsNDhdLFswLDI1NSwyNTVdXSxtPTAscz0xRTMsdD0wLGQsayxnLGM9W1sxNiw0OCwxNl0sWzAsMjU1LDBdXTtoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aC5zdHlsZS5jdXJzb3I9XCJwb2ludGVyXCI7aC5zdHlsZS53aWR0aD1cIjgwcHhcIjtoLnN0eWxlLm9wYWNpdHk9XCIwLjlcIjtoLnN0eWxlLnpJbmRleD1cIjEwMDAxXCI7aC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpO249KG4rMSklMjswPT1uPyhlLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLGQuc3R5bGUuZGlzcGxheT1cIm5vbmVcIik6KGUuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixkLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiKX0sITEpO2U9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtlLnN0eWxlLnRleHRBbGlnbj1cblwibGVmdFwiO2Uuc3R5bGUubGluZUhlaWdodD1cIjEuMmVtXCI7ZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCJyZ2IoXCIrTWF0aC5mbG9vcihiWzBdWzBdLzIpK1wiLFwiK01hdGguZmxvb3IoYlswXVsxXS8yKStcIixcIitNYXRoLmZsb29yKGJbMF1bMl0vMikrXCIpXCI7ZS5zdHlsZS5wYWRkaW5nPVwiMCAwIDNweCAzcHhcIjtoLmFwcGVuZENoaWxkKGUpO2o9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtqLnN0eWxlLmZvbnRGYW1pbHk9XCJIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmXCI7ai5zdHlsZS5mb250U2l6ZT1cIjlweFwiO2ouc3R5bGUuY29sb3I9XCJyZ2IoXCIrYlsxXVswXStcIixcIitiWzFdWzFdK1wiLFwiK2JbMV1bMl0rXCIpXCI7ai5zdHlsZS5mb250V2VpZ2h0PVwiYm9sZFwiO2ouaW5uZXJIVE1MPVwiRlBTXCI7ZS5hcHBlbmRDaGlsZChqKTtmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Zi5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCI7Zi5zdHlsZS53aWR0aD1cIjc0cHhcIjtmLnN0eWxlLmhlaWdodD1cblwiMzBweFwiO2Yuc3R5bGUuYmFja2dyb3VuZENvbG9yPVwicmdiKFwiK2JbMV1bMF0rXCIsXCIrYlsxXVsxXStcIixcIitiWzFdWzJdK1wiKVwiO2ZvcihlLmFwcGVuZENoaWxkKGYpOzc0PmYuY2hpbGRyZW4ubGVuZ3RoOylhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLGEuc3R5bGUud2lkdGg9XCIxcHhcIixhLnN0eWxlLmhlaWdodD1cIjMwcHhcIixhLnN0eWxlLmNzc0Zsb2F0PVwibGVmdFwiLGEuc3R5bGUuYmFja2dyb3VuZENvbG9yPVwicmdiKFwiK2JbMF1bMF0rXCIsXCIrYlswXVsxXStcIixcIitiWzBdWzJdK1wiKVwiLGYuYXBwZW5kQ2hpbGQoYSk7ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2Quc3R5bGUudGV4dEFsaWduPVwibGVmdFwiO2Quc3R5bGUubGluZUhlaWdodD1cIjEuMmVtXCI7ZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCJyZ2IoXCIrTWF0aC5mbG9vcihjWzBdWzBdLzIpK1wiLFwiK01hdGguZmxvb3IoY1swXVsxXS8yKStcIixcIitNYXRoLmZsb29yKGNbMF1bMl0vMikrXCIpXCI7ZC5zdHlsZS5wYWRkaW5nPVxuXCIwIDAgM3B4IDNweFwiO2Quc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtoLmFwcGVuZENoaWxkKGQpO2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtrLnN0eWxlLmZvbnRGYW1pbHk9XCJIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmXCI7ay5zdHlsZS5mb250U2l6ZT1cIjlweFwiO2suc3R5bGUuY29sb3I9XCJyZ2IoXCIrY1sxXVswXStcIixcIitjWzFdWzFdK1wiLFwiK2NbMV1bMl0rXCIpXCI7ay5zdHlsZS5mb250V2VpZ2h0PVwiYm9sZFwiO2suaW5uZXJIVE1MPVwiTVNcIjtkLmFwcGVuZENoaWxkKGspO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtnLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIjtnLnN0eWxlLndpZHRoPVwiNzRweFwiO2cuc3R5bGUuaGVpZ2h0PVwiMzBweFwiO2cuc3R5bGUuYmFja2dyb3VuZENvbG9yPVwicmdiKFwiK2NbMV1bMF0rXCIsXCIrY1sxXVsxXStcIixcIitjWzFdWzJdK1wiKVwiO2ZvcihkLmFwcGVuZENoaWxkKGcpOzc0PmcuY2hpbGRyZW4ubGVuZ3RoOylhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLFxuYS5zdHlsZS53aWR0aD1cIjFweFwiLGEuc3R5bGUuaGVpZ2h0PTMwKk1hdGgucmFuZG9tKCkrXCJweFwiLGEuc3R5bGUuY3NzRmxvYXQ9XCJsZWZ0XCIsYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCJyZ2IoXCIrY1swXVswXStcIixcIitjWzBdWzFdK1wiLFwiK2NbMF1bMl0rXCIpXCIsZy5hcHBlbmRDaGlsZChhKTtyZXR1cm57ZG9tRWxlbWVudDpoLHVwZGF0ZTpmdW5jdGlvbigpe2k9RGF0ZS5ub3coKTttPWktdTtzPU1hdGgubWluKHMsbSk7dD1NYXRoLm1heCh0LG0pO2sudGV4dENvbnRlbnQ9bStcIiBNUyAoXCIrcytcIi1cIit0K1wiKVwiO3ZhciBhPU1hdGgubWluKDMwLDMwLTMwKihtLzIwMCkpO2cuYXBwZW5kQ2hpbGQoZy5maXJzdENoaWxkKS5zdHlsZS5oZWlnaHQ9YStcInB4XCI7dT1pO28rKztpZihpPnArMUUzKWw9TWF0aC5yb3VuZCgxRTMqby8oaS1wKSkscT1NYXRoLm1pbihxLGwpLHI9TWF0aC5tYXgocixsKSxqLnRleHRDb250ZW50PWwrXCIgRlBTIChcIitxK1wiLVwiK3IrXCIpXCIsYT1NYXRoLm1pbigzMCwzMC1cbjMwKihsLzEwMCkpLGYuYXBwZW5kQ2hpbGQoZi5maXJzdENoaWxkKS5zdHlsZS5oZWlnaHQ9YStcInB4XCIscD1pLG89MH19fTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0cztcbiIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA3IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb21cbipcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG4qL1xudmFyIEJveDJEID0ge307XG5cbihmdW5jdGlvbiAoYTJqLCB1bmRlZmluZWQpIHtcblxuICAgaWYoIShPYmplY3QucHJvdG90eXBlLmRlZmluZVByb3BlcnR5IGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAmJiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18gaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgJiYgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbihvYmosIHAsIGNmZykge1xuICAgICAgICAgaWYoY2ZnLmdldCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18ocCwgY2ZnLmdldCk7XG4gICAgICAgICBpZihjZmcuc2V0IGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICBvYmouX19kZWZpbmVTZXR0ZXJfXyhwLCBjZmcuc2V0KTtcbiAgICAgIH1cbiAgIH1cbiAgIFxuICAgZnVuY3Rpb24gZW1wdHlGbigpIHt9O1xuICAgYTJqLmluaGVyaXQgPSBmdW5jdGlvbihjbHMsIGJhc2UpIHtcbiAgICAgIHZhciB0bXBDdHIgPSBjbHM7XG4gICAgICBlbXB0eUZuLnByb3RvdHlwZSA9IGJhc2UucHJvdG90eXBlO1xuICAgICAgY2xzLnByb3RvdHlwZSA9IG5ldyBlbXB0eUZuO1xuICAgICAgY2xzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHRtcEN0cjtcbiAgIH07XG4gICBcbiAgIGEyai5nZW5lcmF0ZUNhbGxiYWNrID0gZnVuY3Rpb24gZ2VuZXJhdGVDYWxsYmFjayhjb250ZXh0LCBjYikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIGNiLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgfTtcbiAgIFxuICAgYTJqLk5WZWN0b3IgPSBmdW5jdGlvbiBOVmVjdG9yKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSBsZW5ndGggPSAwO1xuICAgICAgdmFyIHRtcCA9IG5ldyBBcnJheShsZW5ndGggfHwgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKVxuICAgICAgdG1wW2ldID0gMDtcbiAgICAgIHJldHVybiB0bXA7XG4gICB9O1xuICAgXG4gICBhMmouaXMgPSBmdW5jdGlvbiBpcyhvMSwgbzIpIHtcbiAgICAgIGlmIChvMSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKChvMiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiAobzEgaW5zdGFuY2VvZiBvMikpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKChvMS5jb25zdHJ1Y3Rvci5fX2ltcGxlbWVudHMgIT0gdW5kZWZpbmVkKSAmJiAobzEuY29uc3RydWN0b3IuX19pbXBsZW1lbnRzW28yXSkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfTtcbiAgIFxuICAgYTJqLnBhcnNlVUludCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhwYXJzZUludCh2KSk7XG4gICB9XG4gICBcbn0pKEJveDJEKTtcblxuLy8jVE9ETyByZW1vdmUgYXNzaWdubWVudHMgZnJvbSBnbG9iYWwgbmFtZXNwYWNlXG52YXIgVmVjdG9yID0gQXJyYXk7XG52YXIgVmVjdG9yX2Eyal9OdW1iZXIgPSBCb3gyRC5OVmVjdG9yO1xuLy9wYWNrYWdlIHN0cnVjdHVyZVxuaWYgKHR5cGVvZihCb3gyRCkgPT09IFwidW5kZWZpbmVkXCIpIEJveDJEID0ge307XG5pZiAodHlwZW9mKEJveDJELkNvbGxpc2lvbikgPT09IFwidW5kZWZpbmVkXCIpIEJveDJELkNvbGxpc2lvbiA9IHt9O1xuaWYgKHR5cGVvZihCb3gyRC5Db2xsaXNpb24uU2hhcGVzKSA9PT0gXCJ1bmRlZmluZWRcIikgQm94MkQuQ29sbGlzaW9uLlNoYXBlcyA9IHt9O1xuaWYgKHR5cGVvZihCb3gyRC5Db21tb24pID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5Db21tb24gPSB7fTtcbmlmICh0eXBlb2YoQm94MkQuQ29tbW9uLk1hdGgpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5Db21tb24uTWF0aCA9IHt9O1xuaWYgKHR5cGVvZihCb3gyRC5EeW5hbWljcykgPT09IFwidW5kZWZpbmVkXCIpIEJveDJELkR5bmFtaWNzID0ge307XG5pZiAodHlwZW9mKEJveDJELkR5bmFtaWNzLkNvbnRhY3RzKSA9PT0gXCJ1bmRlZmluZWRcIikgQm94MkQuRHluYW1pY3MuQ29udGFjdHMgPSB7fTtcbmlmICh0eXBlb2YoQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycyA9IHt9O1xuaWYgKHR5cGVvZihCb3gyRC5EeW5hbWljcy5Kb2ludHMpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5EeW5hbWljcy5Kb2ludHMgPSB7fTtcbi8vcHJlLWRlZmluaXRpb25zXG4oZnVuY3Rpb24gKCkge1xuICAgQm94MkQuQ29sbGlzaW9uLklCcm9hZFBoYXNlID0gJ0JveDJELkNvbGxpc2lvbi5JQnJvYWRQaGFzZSc7XG5cbiAgIGZ1bmN0aW9uIGIyQUFCQigpIHtcbiAgICAgIGIyQUFCQi5iMkFBQkIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJBQUJCID0gYjJBQUJCO1xuXG4gICBmdW5jdGlvbiBiMkJvdW5kKCkge1xuICAgICAgYjJCb3VuZC5iMkJvdW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyQm91bmQgPSBiMkJvdW5kO1xuXG4gICBmdW5jdGlvbiBiMkJvdW5kVmFsdWVzKCkge1xuICAgICAgYjJCb3VuZFZhbHVlcy5iMkJvdW5kVmFsdWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJCb3VuZFZhbHVlcykgdGhpcy5iMkJvdW5kVmFsdWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyQm91bmRWYWx1ZXMgPSBiMkJvdW5kVmFsdWVzO1xuXG4gICBmdW5jdGlvbiBiMkNvbGxpc2lvbigpIHtcbiAgICAgIGIyQ29sbGlzaW9uLmIyQ29sbGlzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uID0gYjJDb2xsaXNpb247XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdElEKCkge1xuICAgICAgYjJDb250YWN0SUQuYjJDb250YWN0SUQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkNvbnRhY3RJRCkgdGhpcy5iMkNvbnRhY3RJRC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RJRCA9IGIyQ29udGFjdElEO1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RQb2ludCgpIHtcbiAgICAgIGIyQ29udGFjdFBvaW50LmIyQ29udGFjdFBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdFBvaW50ID0gYjJDb250YWN0UG9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyRGlzdGFuY2UoKSB7XG4gICAgICBiMkRpc3RhbmNlLmIyRGlzdGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZSA9IGIyRGlzdGFuY2U7XG5cbiAgIGZ1bmN0aW9uIGIyRGlzdGFuY2VJbnB1dCgpIHtcbiAgICAgIGIyRGlzdGFuY2VJbnB1dC5iMkRpc3RhbmNlSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZUlucHV0ID0gYjJEaXN0YW5jZUlucHV0O1xuXG4gICBmdW5jdGlvbiBiMkRpc3RhbmNlT3V0cHV0KCkge1xuICAgICAgYjJEaXN0YW5jZU91dHB1dC5iMkRpc3RhbmNlT3V0cHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VPdXRwdXQgPSBiMkRpc3RhbmNlT3V0cHV0O1xuXG4gICBmdW5jdGlvbiBiMkRpc3RhbmNlUHJveHkoKSB7XG4gICAgICBiMkRpc3RhbmNlUHJveHkuYjJEaXN0YW5jZVByb3h5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VQcm94eSA9IGIyRGlzdGFuY2VQcm94eTtcblxuICAgZnVuY3Rpb24gYjJEeW5hbWljVHJlZSgpIHtcbiAgICAgIGIyRHluYW1pY1RyZWUuYjJEeW5hbWljVHJlZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRHluYW1pY1RyZWUpIHRoaXMuYjJEeW5hbWljVHJlZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlID0gYjJEeW5hbWljVHJlZTtcblxuICAgZnVuY3Rpb24gYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UoKSB7XG4gICAgICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5iMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSA9IGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlO1xuXG4gICBmdW5jdGlvbiBiMkR5bmFtaWNUcmVlTm9kZSgpIHtcbiAgICAgIGIyRHluYW1pY1RyZWVOb2RlLmIyRHluYW1pY1RyZWVOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVOb2RlID0gYjJEeW5hbWljVHJlZU5vZGU7XG5cbiAgIGZ1bmN0aW9uIGIyRHluYW1pY1RyZWVQYWlyKCkge1xuICAgICAgYjJEeW5hbWljVHJlZVBhaXIuYjJEeW5hbWljVHJlZVBhaXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZVBhaXIgPSBiMkR5bmFtaWNUcmVlUGFpcjtcblxuICAgZnVuY3Rpb24gYjJNYW5pZm9sZCgpIHtcbiAgICAgIGIyTWFuaWZvbGQuYjJNYW5pZm9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTWFuaWZvbGQpIHRoaXMuYjJNYW5pZm9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkID0gYjJNYW5pZm9sZDtcblxuICAgZnVuY3Rpb24gYjJNYW5pZm9sZFBvaW50KCkge1xuICAgICAgYjJNYW5pZm9sZFBvaW50LmIyTWFuaWZvbGRQb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTWFuaWZvbGRQb2ludCkgdGhpcy5iMk1hbmlmb2xkUG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZFBvaW50ID0gYjJNYW5pZm9sZFBvaW50O1xuXG4gICBmdW5jdGlvbiBiMlBvaW50KCkge1xuICAgICAgYjJQb2ludC5iMlBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyUG9pbnQgPSBiMlBvaW50O1xuXG4gICBmdW5jdGlvbiBiMlJheUNhc3RJbnB1dCgpIHtcbiAgICAgIGIyUmF5Q2FzdElucHV0LmIyUmF5Q2FzdElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJSYXlDYXN0SW5wdXQpIHRoaXMuYjJSYXlDYXN0SW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0SW5wdXQgPSBiMlJheUNhc3RJbnB1dDtcblxuICAgZnVuY3Rpb24gYjJSYXlDYXN0T3V0cHV0KCkge1xuICAgICAgYjJSYXlDYXN0T3V0cHV0LmIyUmF5Q2FzdE91dHB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RPdXRwdXQgPSBiMlJheUNhc3RPdXRwdXQ7XG5cbiAgIGZ1bmN0aW9uIGIyU2VnbWVudCgpIHtcbiAgICAgIGIyU2VnbWVudC5iMlNlZ21lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJTZWdtZW50ID0gYjJTZWdtZW50O1xuXG4gICBmdW5jdGlvbiBiMlNlcGFyYXRpb25GdW5jdGlvbigpIHtcbiAgICAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uID0gYjJTZXBhcmF0aW9uRnVuY3Rpb247XG5cbiAgIGZ1bmN0aW9uIGIyU2ltcGxleCgpIHtcbiAgICAgIGIyU2ltcGxleC5iMlNpbXBsZXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlNpbXBsZXgpIHRoaXMuYjJTaW1wbGV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleCA9IGIyU2ltcGxleDtcblxuICAgZnVuY3Rpb24gYjJTaW1wbGV4Q2FjaGUoKSB7XG4gICAgICBiMlNpbXBsZXhDYWNoZS5iMlNpbXBsZXhDYWNoZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhDYWNoZSA9IGIyU2ltcGxleENhY2hlO1xuXG4gICBmdW5jdGlvbiBiMlNpbXBsZXhWZXJ0ZXgoKSB7XG4gICAgICBiMlNpbXBsZXhWZXJ0ZXguYjJTaW1wbGV4VmVydGV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleFZlcnRleCA9IGIyU2ltcGxleFZlcnRleDtcblxuICAgZnVuY3Rpb24gYjJUaW1lT2ZJbXBhY3QoKSB7XG4gICAgICBiMlRpbWVPZkltcGFjdC5iMlRpbWVPZkltcGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdCA9IGIyVGltZU9mSW1wYWN0O1xuXG4gICBmdW5jdGlvbiBiMlRPSUlucHV0KCkge1xuICAgICAgYjJUT0lJbnB1dC5iMlRPSUlucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQgPSBiMlRPSUlucHV0O1xuXG4gICBmdW5jdGlvbiBiMldvcmxkTWFuaWZvbGQoKSB7XG4gICAgICBiMldvcmxkTWFuaWZvbGQuYjJXb3JsZE1hbmlmb2xkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJXb3JsZE1hbmlmb2xkKSB0aGlzLmIyV29ybGRNYW5pZm9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMldvcmxkTWFuaWZvbGQgPSBiMldvcmxkTWFuaWZvbGQ7XG5cbiAgIGZ1bmN0aW9uIENsaXBWZXJ0ZXgoKSB7XG4gICAgICBDbGlwVmVydGV4LkNsaXBWZXJ0ZXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uQ2xpcFZlcnRleCA9IENsaXBWZXJ0ZXg7XG5cbiAgIGZ1bmN0aW9uIEZlYXR1cmVzKCkge1xuICAgICAgRmVhdHVyZXMuRmVhdHVyZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uRmVhdHVyZXMgPSBGZWF0dXJlcztcblxuICAgZnVuY3Rpb24gYjJDaXJjbGVTaGFwZSgpIHtcbiAgICAgIGIyQ2lyY2xlU2hhcGUuYjJDaXJjbGVTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQ2lyY2xlU2hhcGUpIHRoaXMuYjJDaXJjbGVTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJDaXJjbGVTaGFwZSA9IGIyQ2lyY2xlU2hhcGU7XG5cbiAgIGZ1bmN0aW9uIGIyRWRnZUNoYWluRGVmKCkge1xuICAgICAgYjJFZGdlQ2hhaW5EZWYuYjJFZGdlQ2hhaW5EZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkVkZ2VDaGFpbkRlZikgdGhpcy5iMkVkZ2VDaGFpbkRlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlQ2hhaW5EZWYgPSBiMkVkZ2VDaGFpbkRlZjtcblxuICAgZnVuY3Rpb24gYjJFZGdlU2hhcGUoKSB7XG4gICAgICBiMkVkZ2VTaGFwZS5iMkVkZ2VTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRWRnZVNoYXBlKSB0aGlzLmIyRWRnZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VTaGFwZSA9IGIyRWRnZVNoYXBlO1xuXG4gICBmdW5jdGlvbiBiMk1hc3NEYXRhKCkge1xuICAgICAgYjJNYXNzRGF0YS5iMk1hc3NEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMk1hc3NEYXRhID0gYjJNYXNzRGF0YTtcblxuICAgZnVuY3Rpb24gYjJQb2x5Z29uU2hhcGUoKSB7XG4gICAgICBiMlBvbHlnb25TaGFwZS5iMlBvbHlnb25TaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUG9seWdvblNoYXBlKSB0aGlzLmIyUG9seWdvblNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlBvbHlnb25TaGFwZSA9IGIyUG9seWdvblNoYXBlO1xuXG4gICBmdW5jdGlvbiBiMlNoYXBlKCkge1xuICAgICAgYjJTaGFwZS5iMlNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJTaGFwZSkgdGhpcy5iMlNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlID0gYjJTaGFwZTtcbiAgIEJveDJELkNvbW1vbi5iMmludGVybmFsID0gJ0JveDJELkNvbW1vbi5iMmludGVybmFsJztcblxuICAgZnVuY3Rpb24gYjJDb2xvcigpIHtcbiAgICAgIGIyQ29sb3IuYjJDb2xvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQ29sb3IpIHRoaXMuYjJDb2xvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbW1vbi5iMkNvbG9yID0gYjJDb2xvcjtcblxuICAgZnVuY3Rpb24gYjJTZXR0aW5ncygpIHtcbiAgICAgIGIyU2V0dGluZ3MuYjJTZXR0aW5ncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzID0gYjJTZXR0aW5ncztcblxuICAgZnVuY3Rpb24gYjJNYXQyMigpIHtcbiAgICAgIGIyTWF0MjIuYjJNYXQyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTWF0MjIpIHRoaXMuYjJNYXQyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MjIgPSBiMk1hdDIyO1xuXG4gICBmdW5jdGlvbiBiMk1hdDMzKCkge1xuICAgICAgYjJNYXQzMy5iMk1hdDMzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJNYXQzMykgdGhpcy5iMk1hdDMzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyA9IGIyTWF0MzM7XG5cbiAgIGZ1bmN0aW9uIGIyTWF0aCgpIHtcbiAgICAgIGIyTWF0aC5iMk1hdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGggPSBiMk1hdGg7XG5cbiAgIGZ1bmN0aW9uIGIyU3dlZXAoKSB7XG4gICAgICBiMlN3ZWVwLmIyU3dlZXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db21tb24uTWF0aC5iMlN3ZWVwID0gYjJTd2VlcDtcblxuICAgZnVuY3Rpb24gYjJUcmFuc2Zvcm0oKSB7XG4gICAgICBiMlRyYW5zZm9ybS5iMlRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyVHJhbnNmb3JtKSB0aGlzLmIyVHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29tbW9uLk1hdGguYjJUcmFuc2Zvcm0gPSBiMlRyYW5zZm9ybTtcblxuICAgZnVuY3Rpb24gYjJWZWMyKCkge1xuICAgICAgYjJWZWMyLmIyVmVjMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyVmVjMikgdGhpcy5iMlZlYzIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzIgPSBiMlZlYzI7XG5cbiAgIGZ1bmN0aW9uIGIyVmVjMygpIHtcbiAgICAgIGIyVmVjMy5iMlZlYzMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlZlYzMpIHRoaXMuYjJWZWMzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzID0gYjJWZWMzO1xuXG4gICBmdW5jdGlvbiBiMkJvZHkoKSB7XG4gICAgICBiMkJvZHkuYjJCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJCb2R5KSB0aGlzLmIyQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLmIyQm9keSA9IGIyQm9keTtcblxuICAgZnVuY3Rpb24gYjJCb2R5RGVmKCkge1xuICAgICAgYjJCb2R5RGVmLmIyQm9keURlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQm9keURlZikgdGhpcy5iMkJvZHlEZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkJvZHlEZWYgPSBiMkJvZHlEZWY7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdEZpbHRlcigpIHtcbiAgICAgIGIyQ29udGFjdEZpbHRlci5iMkNvbnRhY3RGaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RGaWx0ZXIgPSBiMkNvbnRhY3RGaWx0ZXI7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdEltcHVsc2UoKSB7XG4gICAgICBiMkNvbnRhY3RJbXB1bHNlLmIyQ29udGFjdEltcHVsc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RJbXB1bHNlID0gYjJDb250YWN0SW1wdWxzZTtcblxuICAgZnVuY3Rpb24gYjJDb250YWN0TGlzdGVuZXIoKSB7XG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lci5iMkNvbnRhY3RMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyID0gYjJDb250YWN0TGlzdGVuZXI7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdE1hbmFnZXIoKSB7XG4gICAgICBiMkNvbnRhY3RNYW5hZ2VyLmIyQ29udGFjdE1hbmFnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkNvbnRhY3RNYW5hZ2VyKSB0aGlzLmIyQ29udGFjdE1hbmFnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RNYW5hZ2VyID0gYjJDb250YWN0TWFuYWdlcjtcblxuICAgZnVuY3Rpb24gYjJEZWJ1Z0RyYXcoKSB7XG4gICAgICBiMkRlYnVnRHJhdy5iMkRlYnVnRHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRGVidWdEcmF3KSB0aGlzLmIyRGVidWdEcmF3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcgPSBiMkRlYnVnRHJhdztcblxuICAgZnVuY3Rpb24gYjJEZXN0cnVjdGlvbkxpc3RlbmVyKCkge1xuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcjtcblxuICAgZnVuY3Rpb24gYjJGaWx0ZXJEYXRhKCkge1xuICAgICAgYjJGaWx0ZXJEYXRhLmIyRmlsdGVyRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLmIyRmlsdGVyRGF0YSA9IGIyRmlsdGVyRGF0YTtcblxuICAgZnVuY3Rpb24gYjJGaXh0dXJlKCkge1xuICAgICAgYjJGaXh0dXJlLmIyRml4dHVyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRml4dHVyZSkgdGhpcy5iMkZpeHR1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkZpeHR1cmUgPSBiMkZpeHR1cmU7XG5cbiAgIGZ1bmN0aW9uIGIyRml4dHVyZURlZigpIHtcbiAgICAgIGIyRml4dHVyZURlZi5iMkZpeHR1cmVEZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkZpeHR1cmVEZWYpIHRoaXMuYjJGaXh0dXJlRGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmID0gYjJGaXh0dXJlRGVmO1xuXG4gICBmdW5jdGlvbiBiMklzbGFuZCgpIHtcbiAgICAgIGIySXNsYW5kLmIySXNsYW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJJc2xhbmQpIHRoaXMuYjJJc2xhbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCA9IGIySXNsYW5kO1xuXG4gICBmdW5jdGlvbiBiMlRpbWVTdGVwKCkge1xuICAgICAgYjJUaW1lU3RlcC5iMlRpbWVTdGVwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJUaW1lU3RlcCA9IGIyVGltZVN0ZXA7XG5cbiAgIGZ1bmN0aW9uIGIyV29ybGQoKSB7XG4gICAgICBiMldvcmxkLmIyV29ybGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMldvcmxkKSB0aGlzLmIyV29ybGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMldvcmxkID0gYjJXb3JsZDtcblxuICAgZnVuY3Rpb24gYjJDaXJjbGVDb250YWN0KCkge1xuICAgICAgYjJDaXJjbGVDb250YWN0LmIyQ2lyY2xlQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ2lyY2xlQ29udGFjdCA9IGIyQ2lyY2xlQ29udGFjdDtcblxuICAgZnVuY3Rpb24gYjJDb250YWN0KCkge1xuICAgICAgYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQ29udGFjdCkgdGhpcy5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QgPSBiMkNvbnRhY3Q7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdENvbnN0cmFpbnQoKSB7XG4gICAgICBiMkNvbnRhY3RDb25zdHJhaW50LmIyQ29udGFjdENvbnN0cmFpbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkNvbnRhY3RDb25zdHJhaW50KSB0aGlzLmIyQ29udGFjdENvbnN0cmFpbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RDb25zdHJhaW50ID0gYjJDb250YWN0Q29uc3RyYWludDtcblxuICAgZnVuY3Rpb24gYjJDb250YWN0Q29uc3RyYWludFBvaW50KCkge1xuICAgICAgYjJDb250YWN0Q29uc3RyYWludFBvaW50LmIyQ29udGFjdENvbnN0cmFpbnRQb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdENvbnN0cmFpbnRQb2ludCA9IGIyQ29udGFjdENvbnN0cmFpbnRQb2ludDtcblxuICAgZnVuY3Rpb24gYjJDb250YWN0RWRnZSgpIHtcbiAgICAgIGIyQ29udGFjdEVkZ2UuYjJDb250YWN0RWRnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdEVkZ2UgPSBiMkNvbnRhY3RFZGdlO1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RGYWN0b3J5KCkge1xuICAgICAgYjJDb250YWN0RmFjdG9yeS5iMkNvbnRhY3RGYWN0b3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0RmFjdG9yeSkgdGhpcy5iMkNvbnRhY3RGYWN0b3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0RmFjdG9yeSA9IGIyQ29udGFjdEZhY3Rvcnk7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdFJlZ2lzdGVyKCkge1xuICAgICAgYjJDb250YWN0UmVnaXN0ZXIuYjJDb250YWN0UmVnaXN0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RSZWdpc3RlciA9IGIyQ29udGFjdFJlZ2lzdGVyO1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RSZXN1bHQoKSB7XG4gICAgICBiMkNvbnRhY3RSZXN1bHQuYjJDb250YWN0UmVzdWx0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0UmVzdWx0ID0gYjJDb250YWN0UmVzdWx0O1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RTb2x2ZXIoKSB7XG4gICAgICBiMkNvbnRhY3RTb2x2ZXIuYjJDb250YWN0U29sdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0U29sdmVyKSB0aGlzLmIyQ29udGFjdFNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFNvbHZlciA9IGIyQ29udGFjdFNvbHZlcjtcblxuICAgZnVuY3Rpb24gYjJFZGdlQW5kQ2lyY2xlQ29udGFjdCgpIHtcbiAgICAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QuYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyRWRnZUFuZENpcmNsZUNvbnRhY3QgPSBiMkVkZ2VBbmRDaXJjbGVDb250YWN0O1xuXG4gICBmdW5jdGlvbiBiMk51bGxDb250YWN0KCkge1xuICAgICAgYjJOdWxsQ29udGFjdC5iMk51bGxDb250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJOdWxsQ29udGFjdCkgdGhpcy5iMk51bGxDb250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJOdWxsQ29udGFjdCA9IGIyTnVsbENvbnRhY3Q7XG5cbiAgIGZ1bmN0aW9uIGIyUG9seUFuZENpcmNsZUNvbnRhY3QoKSB7XG4gICAgICBiMlBvbHlBbmRDaXJjbGVDb250YWN0LmIyUG9seUFuZENpcmNsZUNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvbHlBbmRDaXJjbGVDb250YWN0ID0gYjJQb2x5QW5kQ2lyY2xlQ29udGFjdDtcblxuICAgZnVuY3Rpb24gYjJQb2x5QW5kRWRnZUNvbnRhY3QoKSB7XG4gICAgICBiMlBvbHlBbmRFZGdlQ29udGFjdC5iMlBvbHlBbmRFZGdlQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9seUFuZEVkZ2VDb250YWN0ID0gYjJQb2x5QW5kRWRnZUNvbnRhY3Q7XG5cbiAgIGZ1bmN0aW9uIGIyUG9seWdvbkNvbnRhY3QoKSB7XG4gICAgICBiMlBvbHlnb25Db250YWN0LmIyUG9seWdvbkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvbHlnb25Db250YWN0ID0gYjJQb2x5Z29uQ29udGFjdDtcblxuICAgZnVuY3Rpb24gYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkKCkge1xuICAgICAgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCkgdGhpcy5iMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQgPSBiMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQ7XG5cbiAgIGZ1bmN0aW9uIGIyQnVveWFuY3lDb250cm9sbGVyKCkge1xuICAgICAgYjJCdW95YW5jeUNvbnRyb2xsZXIuYjJCdW95YW5jeUNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkJ1b3lhbmN5Q29udHJvbGxlciA9IGIyQnVveWFuY3lDb250cm9sbGVyO1xuXG4gICBmdW5jdGlvbiBiMkNvbnN0YW50QWNjZWxDb250cm9sbGVyKCkge1xuICAgICAgYjJDb25zdGFudEFjY2VsQ29udHJvbGxlci5iMkNvbnN0YW50QWNjZWxDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb25zdGFudEFjY2VsQ29udHJvbGxlciA9IGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXI7XG5cbiAgIGZ1bmN0aW9uIGIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIoKSB7XG4gICAgICBiMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyLmIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyID0gYjJDb25zdGFudEZvcmNlQ29udHJvbGxlcjtcblxuICAgZnVuY3Rpb24gYjJDb250cm9sbGVyKCkge1xuICAgICAgYjJDb250cm9sbGVyLmIyQ29udHJvbGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlciA9IGIyQ29udHJvbGxlcjtcblxuICAgZnVuY3Rpb24gYjJDb250cm9sbGVyRWRnZSgpIHtcbiAgICAgIGIyQ29udHJvbGxlckVkZ2UuYjJDb250cm9sbGVyRWRnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlckVkZ2UgPSBiMkNvbnRyb2xsZXJFZGdlO1xuXG4gICBmdW5jdGlvbiBiMkdyYXZpdHlDb250cm9sbGVyKCkge1xuICAgICAgYjJHcmF2aXR5Q29udHJvbGxlci5iMkdyYXZpdHlDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJHcmF2aXR5Q29udHJvbGxlciA9IGIyR3Jhdml0eUNvbnRyb2xsZXI7XG5cbiAgIGZ1bmN0aW9uIGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIoKSB7XG4gICAgICBiMlRlbnNvckRhbXBpbmdDb250cm9sbGVyLmIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMlRlbnNvckRhbXBpbmdDb250cm9sbGVyID0gYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlcjtcblxuICAgZnVuY3Rpb24gYjJEaXN0YW5jZUpvaW50KCkge1xuICAgICAgYjJEaXN0YW5jZUpvaW50LmIyRGlzdGFuY2VKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRGlzdGFuY2VKb2ludCkgdGhpcy5iMkRpc3RhbmNlSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50ID0gYjJEaXN0YW5jZUpvaW50O1xuXG4gICBmdW5jdGlvbiBiMkRpc3RhbmNlSm9pbnREZWYoKSB7XG4gICAgICBiMkRpc3RhbmNlSm9pbnREZWYuYjJEaXN0YW5jZUpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJEaXN0YW5jZUpvaW50RGVmKSB0aGlzLmIyRGlzdGFuY2VKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkRpc3RhbmNlSm9pbnREZWYgPSBiMkRpc3RhbmNlSm9pbnREZWY7XG5cbiAgIGZ1bmN0aW9uIGIyRnJpY3Rpb25Kb2ludCgpIHtcbiAgICAgIGIyRnJpY3Rpb25Kb2ludC5iMkZyaWN0aW9uSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkZyaWN0aW9uSm9pbnQpIHRoaXMuYjJGcmljdGlvbkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyRnJpY3Rpb25Kb2ludCA9IGIyRnJpY3Rpb25Kb2ludDtcblxuICAgZnVuY3Rpb24gYjJGcmljdGlvbkpvaW50RGVmKCkge1xuICAgICAgYjJGcmljdGlvbkpvaW50RGVmLmIyRnJpY3Rpb25Kb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRnJpY3Rpb25Kb2ludERlZikgdGhpcy5iMkZyaWN0aW9uSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJGcmljdGlvbkpvaW50RGVmID0gYjJGcmljdGlvbkpvaW50RGVmO1xuXG4gICBmdW5jdGlvbiBiMkdlYXJKb2ludCgpIHtcbiAgICAgIGIyR2VhckpvaW50LmIyR2VhckpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJHZWFySm9pbnQpIHRoaXMuYjJHZWFySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJHZWFySm9pbnQgPSBiMkdlYXJKb2ludDtcblxuICAgZnVuY3Rpb24gYjJHZWFySm9pbnREZWYoKSB7XG4gICAgICBiMkdlYXJKb2ludERlZi5iMkdlYXJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyR2VhckpvaW50RGVmKSB0aGlzLmIyR2VhckpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyR2VhckpvaW50RGVmID0gYjJHZWFySm9pbnREZWY7XG5cbiAgIGZ1bmN0aW9uIGIySmFjb2JpYW4oKSB7XG4gICAgICBiMkphY29iaWFuLmIySmFjb2JpYW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKYWNvYmlhbiA9IGIySmFjb2JpYW47XG5cbiAgIGZ1bmN0aW9uIGIySm9pbnQoKSB7XG4gICAgICBiMkpvaW50LmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkpvaW50KSB0aGlzLmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCA9IGIySm9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIySm9pbnREZWYoKSB7XG4gICAgICBiMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkpvaW50RGVmKSB0aGlzLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZiA9IGIySm9pbnREZWY7XG5cbiAgIGZ1bmN0aW9uIGIySm9pbnRFZGdlKCkge1xuICAgICAgYjJKb2ludEVkZ2UuYjJKb2ludEVkZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludEVkZ2UgPSBiMkpvaW50RWRnZTtcblxuICAgZnVuY3Rpb24gYjJMaW5lSm9pbnQoKSB7XG4gICAgICBiMkxpbmVKb2ludC5iMkxpbmVKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTGluZUpvaW50KSB0aGlzLmIyTGluZUpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTGluZUpvaW50ID0gYjJMaW5lSm9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyTGluZUpvaW50RGVmKCkge1xuICAgICAgYjJMaW5lSm9pbnREZWYuYjJMaW5lSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkxpbmVKb2ludERlZikgdGhpcy5iMkxpbmVKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkxpbmVKb2ludERlZiA9IGIyTGluZUpvaW50RGVmO1xuXG4gICBmdW5jdGlvbiBiMk1vdXNlSm9pbnQoKSB7XG4gICAgICBiMk1vdXNlSm9pbnQuYjJNb3VzZUpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJNb3VzZUpvaW50KSB0aGlzLmIyTW91c2VKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMk1vdXNlSm9pbnQgPSBiMk1vdXNlSm9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyTW91c2VKb2ludERlZigpIHtcbiAgICAgIGIyTW91c2VKb2ludERlZi5iMk1vdXNlSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMk1vdXNlSm9pbnREZWYpIHRoaXMuYjJNb3VzZUpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTW91c2VKb2ludERlZiA9IGIyTW91c2VKb2ludERlZjtcblxuICAgZnVuY3Rpb24gYjJQcmlzbWF0aWNKb2ludCgpIHtcbiAgICAgIGIyUHJpc21hdGljSm9pbnQuYjJQcmlzbWF0aWNKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUHJpc21hdGljSm9pbnQpIHRoaXMuYjJQcmlzbWF0aWNKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlByaXNtYXRpY0pvaW50ID0gYjJQcmlzbWF0aWNKb2ludDtcblxuICAgZnVuY3Rpb24gYjJQcmlzbWF0aWNKb2ludERlZigpIHtcbiAgICAgIGIyUHJpc21hdGljSm9pbnREZWYuYjJQcmlzbWF0aWNKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUHJpc21hdGljSm9pbnREZWYpIHRoaXMuYjJQcmlzbWF0aWNKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlByaXNtYXRpY0pvaW50RGVmID0gYjJQcmlzbWF0aWNKb2ludERlZjtcblxuICAgZnVuY3Rpb24gYjJQdWxsZXlKb2ludCgpIHtcbiAgICAgIGIyUHVsbGV5Sm9pbnQuYjJQdWxsZXlKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUHVsbGV5Sm9pbnQpIHRoaXMuYjJQdWxsZXlKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlB1bGxleUpvaW50ID0gYjJQdWxsZXlKb2ludDtcblxuICAgZnVuY3Rpb24gYjJQdWxsZXlKb2ludERlZigpIHtcbiAgICAgIGIyUHVsbGV5Sm9pbnREZWYuYjJQdWxsZXlKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUHVsbGV5Sm9pbnREZWYpIHRoaXMuYjJQdWxsZXlKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlB1bGxleUpvaW50RGVmID0gYjJQdWxsZXlKb2ludERlZjtcblxuICAgZnVuY3Rpb24gYjJSZXZvbHV0ZUpvaW50KCkge1xuICAgICAgYjJSZXZvbHV0ZUpvaW50LmIyUmV2b2x1dGVKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUmV2b2x1dGVKb2ludCkgdGhpcy5iMlJldm9sdXRlSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJSZXZvbHV0ZUpvaW50ID0gYjJSZXZvbHV0ZUpvaW50O1xuXG4gICBmdW5jdGlvbiBiMlJldm9sdXRlSm9pbnREZWYoKSB7XG4gICAgICBiMlJldm9sdXRlSm9pbnREZWYuYjJSZXZvbHV0ZUpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJSZXZvbHV0ZUpvaW50RGVmKSB0aGlzLmIyUmV2b2x1dGVKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlJldm9sdXRlSm9pbnREZWYgPSBiMlJldm9sdXRlSm9pbnREZWY7XG5cbiAgIGZ1bmN0aW9uIGIyV2VsZEpvaW50KCkge1xuICAgICAgYjJXZWxkSm9pbnQuYjJXZWxkSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMldlbGRKb2ludCkgdGhpcy5iMldlbGRKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMldlbGRKb2ludCA9IGIyV2VsZEpvaW50O1xuXG4gICBmdW5jdGlvbiBiMldlbGRKb2ludERlZigpIHtcbiAgICAgIGIyV2VsZEpvaW50RGVmLmIyV2VsZEpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJXZWxkSm9pbnREZWYpIHRoaXMuYjJXZWxkSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJXZWxkSm9pbnREZWYgPSBiMldlbGRKb2ludERlZjtcbn0pKCk7IC8vZGVmaW5pdGlvbnNcbkJveDJELnBvc3REZWZzID0gW107XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyQ2lyY2xlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyQ2lyY2xlU2hhcGUsXG4gICAgICBiMkVkZ2VDaGFpbkRlZiA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlQ2hhaW5EZWYsXG4gICAgICBiMkVkZ2VTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlU2hhcGUsXG4gICAgICBiMk1hc3NEYXRhID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMk1hc3NEYXRhLFxuICAgICAgYjJQb2x5Z29uU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyUG9seWdvblNoYXBlLFxuICAgICAgYjJTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZSxcbiAgICAgIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcbiAgICAgIGIyU2V0dGluZ3MgPSBCb3gyRC5Db21tb24uYjJTZXR0aW5ncyxcbiAgICAgIGIyTWF0MjIgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDIyLFxuICAgICAgYjJNYXQzMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MzMsXG4gICAgICBiMk1hdGggPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGgsXG4gICAgICBiMlN3ZWVwID0gQm94MkQuQ29tbW9uLk1hdGguYjJTd2VlcCxcbiAgICAgIGIyVHJhbnNmb3JtID0gQm94MkQuQ29tbW9uLk1hdGguYjJUcmFuc2Zvcm0sXG4gICAgICBiMlZlYzIgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzIsXG4gICAgICBiMlZlYzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzMsXG4gICAgICBiMkFBQkIgPSBCb3gyRC5Db2xsaXNpb24uYjJBQUJCLFxuICAgICAgYjJCb3VuZCA9IEJveDJELkNvbGxpc2lvbi5iMkJvdW5kLFxuICAgICAgYjJCb3VuZFZhbHVlcyA9IEJveDJELkNvbGxpc2lvbi5iMkJvdW5kVmFsdWVzLFxuICAgICAgYjJDb2xsaXNpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24sXG4gICAgICBiMkNvbnRhY3RJRCA9IEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RJRCxcbiAgICAgIGIyQ29udGFjdFBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdFBvaW50LFxuICAgICAgYjJEaXN0YW5jZSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLFxuICAgICAgYjJEaXN0YW5jZUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VJbnB1dCxcbiAgICAgIGIyRGlzdGFuY2VPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZU91dHB1dCxcbiAgICAgIGIyRGlzdGFuY2VQcm94eSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlUHJveHksXG4gICAgICBiMkR5bmFtaWNUcmVlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWUsXG4gICAgICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSxcbiAgICAgIGIyRHluYW1pY1RyZWVOb2RlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVOb2RlLFxuICAgICAgYjJEeW5hbWljVHJlZVBhaXIgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZVBhaXIsXG4gICAgICBiMk1hbmlmb2xkID0gQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGQsXG4gICAgICBiMk1hbmlmb2xkUG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZFBvaW50LFxuICAgICAgYjJQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMlBvaW50LFxuICAgICAgYjJSYXlDYXN0SW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0SW5wdXQsXG4gICAgICBiMlJheUNhc3RPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0T3V0cHV0LFxuICAgICAgYjJTZWdtZW50ID0gQm94MkQuQ29sbGlzaW9uLmIyU2VnbWVudCxcbiAgICAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uID0gQm94MkQuQ29sbGlzaW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uLFxuICAgICAgYjJTaW1wbGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleCxcbiAgICAgIGIyU2ltcGxleENhY2hlID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleENhY2hlLFxuICAgICAgYjJTaW1wbGV4VmVydGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleFZlcnRleCxcbiAgICAgIGIyVGltZU9mSW1wYWN0ID0gQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LFxuICAgICAgYjJUT0lJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlRPSUlucHV0LFxuICAgICAgYjJXb3JsZE1hbmlmb2xkID0gQm94MkQuQ29sbGlzaW9uLmIyV29ybGRNYW5pZm9sZCxcbiAgICAgIENsaXBWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uQ2xpcFZlcnRleCxcbiAgICAgIEZlYXR1cmVzID0gQm94MkQuQ29sbGlzaW9uLkZlYXR1cmVzLFxuICAgICAgSUJyb2FkUGhhc2UgPSBCb3gyRC5Db2xsaXNpb24uSUJyb2FkUGhhc2U7XG5cbiAgIGIyQUFCQi5iMkFBQkIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxvd2VyQm91bmQgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLnVwcGVyQm91bmQgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJBQUJCLnByb3RvdHlwZS5Jc1ZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRYID0gdGhpcy51cHBlckJvdW5kLnggLSB0aGlzLmxvd2VyQm91bmQueDtcbiAgICAgIHZhciBkWSA9IHRoaXMudXBwZXJCb3VuZC55IC0gdGhpcy5sb3dlckJvdW5kLnk7XG4gICAgICB2YXIgdmFsaWQgPSBkWCA+PSAwLjAgJiYgZFkgPj0gMC4wO1xuICAgICAgdmFsaWQgPSB2YWxpZCAmJiB0aGlzLmxvd2VyQm91bmQuSXNWYWxpZCgpICYmIHRoaXMudXBwZXJCb3VuZC5Jc1ZhbGlkKCk7XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICB9XG4gICBiMkFBQkIucHJvdG90eXBlLkdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgYjJWZWMyKCh0aGlzLmxvd2VyQm91bmQueCArIHRoaXMudXBwZXJCb3VuZC54KSAvIDIsICh0aGlzLmxvd2VyQm91bmQueSArIHRoaXMudXBwZXJCb3VuZC55KSAvIDIpO1xuICAgfVxuICAgYjJBQUJCLnByb3RvdHlwZS5HZXRFeHRlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoKHRoaXMudXBwZXJCb3VuZC54IC0gdGhpcy5sb3dlckJvdW5kLngpIC8gMiwgKHRoaXMudXBwZXJCb3VuZC55IC0gdGhpcy5sb3dlckJvdW5kLnkpIC8gMik7XG4gICB9XG4gICBiMkFBQkIucHJvdG90eXBlLkNvbnRhaW5zID0gZnVuY3Rpb24gKGFhYmIpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHRoaXMubG93ZXJCb3VuZC54IDw9IGFhYmIubG93ZXJCb3VuZC54O1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHRoaXMubG93ZXJCb3VuZC55IDw9IGFhYmIubG93ZXJCb3VuZC55O1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIGFhYmIudXBwZXJCb3VuZC54IDw9IHRoaXMudXBwZXJCb3VuZC54O1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIGFhYmIudXBwZXJCb3VuZC55IDw9IHRoaXMudXBwZXJCb3VuZC55O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgIH1cbiAgIGIyQUFCQi5wcm90b3R5cGUuUmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0KSB7XG4gICAgICB2YXIgdG1pbiA9ICgtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICB2YXIgdG1heCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgcFggPSBpbnB1dC5wMS54O1xuICAgICAgdmFyIHBZID0gaW5wdXQucDEueTtcbiAgICAgIHZhciBkWCA9IGlucHV0LnAyLnggLSBpbnB1dC5wMS54O1xuICAgICAgdmFyIGRZID0gaW5wdXQucDIueSAtIGlucHV0LnAxLnk7XG4gICAgICB2YXIgYWJzRFggPSBNYXRoLmFicyhkWCk7XG4gICAgICB2YXIgYWJzRFkgPSBNYXRoLmFicyhkWSk7XG4gICAgICB2YXIgbm9ybWFsID0gb3V0cHV0Lm5vcm1hbDtcbiAgICAgIHZhciBpbnZfZCA9IDA7XG4gICAgICB2YXIgdDEgPSAwO1xuICAgICAgdmFyIHQyID0gMDtcbiAgICAgIHZhciB0MyA9IDA7XG4gICAgICB2YXIgcyA9IDA7IHtcbiAgICAgICAgIGlmIChhYnNEWCA8IE51bWJlci5NSU5fVkFMVUUpIHtcbiAgICAgICAgICAgIGlmIChwWCA8IHRoaXMubG93ZXJCb3VuZC54IHx8IHRoaXMudXBwZXJCb3VuZC54IDwgcFgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW52X2QgPSAxLjAgLyBkWDtcbiAgICAgICAgICAgIHQxID0gKHRoaXMubG93ZXJCb3VuZC54IC0gcFgpICogaW52X2Q7XG4gICAgICAgICAgICB0MiA9ICh0aGlzLnVwcGVyQm91bmQueCAtIHBYKSAqIGludl9kO1xuICAgICAgICAgICAgcyA9ICgtMS4wKTtcbiAgICAgICAgICAgIGlmICh0MSA+IHQyKSB7XG4gICAgICAgICAgICAgICB0MyA9IHQxO1xuICAgICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgICAgICAgIHQyID0gdDM7XG4gICAgICAgICAgICAgICBzID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQxID4gdG1pbikge1xuICAgICAgICAgICAgICAgbm9ybWFsLnggPSBzO1xuICAgICAgICAgICAgICAgbm9ybWFsLnkgPSAwO1xuICAgICAgICAgICAgICAgdG1pbiA9IHQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIHQyKTtcbiAgICAgICAgICAgIGlmICh0bWluID4gdG1heCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgfVxuICAgICAgfSB7XG4gICAgICAgICBpZiAoYWJzRFkgPCBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICAgICBpZiAocFkgPCB0aGlzLmxvd2VyQm91bmQueSB8fCB0aGlzLnVwcGVyQm91bmQueSA8IHBZKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludl9kID0gMS4wIC8gZFk7XG4gICAgICAgICAgICB0MSA9ICh0aGlzLmxvd2VyQm91bmQueSAtIHBZKSAqIGludl9kO1xuICAgICAgICAgICAgdDIgPSAodGhpcy51cHBlckJvdW5kLnkgLSBwWSkgKiBpbnZfZDtcbiAgICAgICAgICAgIHMgPSAoLTEuMCk7XG4gICAgICAgICAgICBpZiAodDEgPiB0Mikge1xuICAgICAgICAgICAgICAgdDMgPSB0MTtcbiAgICAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgICAgICAgICB0MiA9IHQzO1xuICAgICAgICAgICAgICAgcyA9IDEuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MSA+IHRtaW4pIHtcbiAgICAgICAgICAgICAgIG5vcm1hbC55ID0gcztcbiAgICAgICAgICAgICAgIG5vcm1hbC54ID0gMDtcbiAgICAgICAgICAgICAgIHRtaW4gPSB0MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCB0Mik7XG4gICAgICAgICAgICBpZiAodG1pbiA+IHRtYXgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dHB1dC5mcmFjdGlvbiA9IHRtaW47XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiAgIGIyQUFCQi5wcm90b3R5cGUuVGVzdE92ZXJsYXAgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIHZhciBkMVggPSBvdGhlci5sb3dlckJvdW5kLnggLSB0aGlzLnVwcGVyQm91bmQueDtcbiAgICAgIHZhciBkMVkgPSBvdGhlci5sb3dlckJvdW5kLnkgLSB0aGlzLnVwcGVyQm91bmQueTtcbiAgICAgIHZhciBkMlggPSB0aGlzLmxvd2VyQm91bmQueCAtIG90aGVyLnVwcGVyQm91bmQueDtcbiAgICAgIHZhciBkMlkgPSB0aGlzLmxvd2VyQm91bmQueSAtIG90aGVyLnVwcGVyQm91bmQueTtcbiAgICAgIGlmIChkMVggPiAwLjAgfHwgZDFZID4gMC4wKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZDJYID4gMC4wIHx8IGQyWSA+IDAuMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG4gICBiMkFBQkIuQ29tYmluZSA9IGZ1bmN0aW9uIChhYWJiMSwgYWFiYjIpIHtcbiAgICAgIHZhciBhYWJiID0gbmV3IGIyQUFCQigpO1xuICAgICAgYWFiYi5Db21iaW5lKGFhYmIxLCBhYWJiMik7XG4gICAgICByZXR1cm4gYWFiYjtcbiAgIH1cbiAgIGIyQUFCQi5wcm90b3R5cGUuQ29tYmluZSA9IGZ1bmN0aW9uIChhYWJiMSwgYWFiYjIpIHtcbiAgICAgIHRoaXMubG93ZXJCb3VuZC54ID0gTWF0aC5taW4oYWFiYjEubG93ZXJCb3VuZC54LCBhYWJiMi5sb3dlckJvdW5kLngpO1xuICAgICAgdGhpcy5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbihhYWJiMS5sb3dlckJvdW5kLnksIGFhYmIyLmxvd2VyQm91bmQueSk7XG4gICAgICB0aGlzLnVwcGVyQm91bmQueCA9IE1hdGgubWF4KGFhYmIxLnVwcGVyQm91bmQueCwgYWFiYjIudXBwZXJCb3VuZC54KTtcbiAgICAgIHRoaXMudXBwZXJCb3VuZC55ID0gTWF0aC5tYXgoYWFiYjEudXBwZXJCb3VuZC55LCBhYWJiMi51cHBlckJvdW5kLnkpO1xuICAgfVxuICAgYjJCb3VuZC5iMkJvdW5kID0gZnVuY3Rpb24gKCkge307XG4gICBiMkJvdW5kLnByb3RvdHlwZS5Jc0xvd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT0gMDtcbiAgIH1cbiAgIGIyQm91bmQucHJvdG90eXBlLklzVXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiAxKSA9PSAxO1xuICAgfVxuICAgYjJCb3VuZC5wcm90b3R5cGUuU3dhcCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICB2YXIgdGVtcFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciB0ZW1wUHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgdmFyIHRlbXBTdGFiYmluZ0NvdW50ID0gdGhpcy5zdGFiYmluZ0NvdW50O1xuICAgICAgdGhpcy52YWx1ZSA9IGIudmFsdWU7XG4gICAgICB0aGlzLnByb3h5ID0gYi5wcm94eTtcbiAgICAgIHRoaXMuc3RhYmJpbmdDb3VudCA9IGIuc3RhYmJpbmdDb3VudDtcbiAgICAgIGIudmFsdWUgPSB0ZW1wVmFsdWU7XG4gICAgICBiLnByb3h5ID0gdGVtcFByb3h5O1xuICAgICAgYi5zdGFiYmluZ0NvdW50ID0gdGVtcFN0YWJiaW5nQ291bnQ7XG4gICB9XG4gICBiMkJvdW5kVmFsdWVzLmIyQm91bmRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgIGIyQm91bmRWYWx1ZXMucHJvdG90eXBlLmIyQm91bmRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxvd2VyVmFsdWVzID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKCk7XG4gICAgICB0aGlzLmxvd2VyVmFsdWVzWzBdID0gMC4wO1xuICAgICAgdGhpcy5sb3dlclZhbHVlc1sxXSA9IDAuMDtcbiAgICAgIHRoaXMudXBwZXJWYWx1ZXMgPSBuZXcgVmVjdG9yX2Eyal9OdW1iZXIoKTtcbiAgICAgIHRoaXMudXBwZXJWYWx1ZXNbMF0gPSAwLjA7XG4gICAgICB0aGlzLnVwcGVyVmFsdWVzWzFdID0gMC4wO1xuICAgfVxuICAgYjJDb2xsaXNpb24uYjJDb2xsaXNpb24gPSBmdW5jdGlvbiAoKSB7fTtcbiAgIGIyQ29sbGlzaW9uLkNsaXBTZWdtZW50VG9MaW5lID0gZnVuY3Rpb24gKHZPdXQsIHZJbiwgbm9ybWFsLCBvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBjdjtcbiAgICAgIHZhciBudW1PdXQgPSAwO1xuICAgICAgY3YgPSB2SW5bMF07XG4gICAgICB2YXIgdkluMCA9IGN2LnY7XG4gICAgICBjdiA9IHZJblsxXTtcbiAgICAgIHZhciB2SW4xID0gY3YudjtcbiAgICAgIHZhciBkaXN0YW5jZTAgPSBub3JtYWwueCAqIHZJbjAueCArIG5vcm1hbC55ICogdkluMC55IC0gb2Zmc2V0O1xuICAgICAgdmFyIGRpc3RhbmNlMSA9IG5vcm1hbC54ICogdkluMS54ICsgbm9ybWFsLnkgKiB2SW4xLnkgLSBvZmZzZXQ7XG4gICAgICBpZiAoZGlzdGFuY2UwIDw9IDAuMCkgdk91dFtudW1PdXQrK10uU2V0KHZJblswXSk7XG4gICAgICBpZiAoZGlzdGFuY2UxIDw9IDAuMCkgdk91dFtudW1PdXQrK10uU2V0KHZJblsxXSk7XG4gICAgICBpZiAoZGlzdGFuY2UwICogZGlzdGFuY2UxIDwgMC4wKSB7XG4gICAgICAgICB2YXIgaW50ZXJwID0gZGlzdGFuY2UwIC8gKGRpc3RhbmNlMCAtIGRpc3RhbmNlMSk7XG4gICAgICAgICBjdiA9IHZPdXRbbnVtT3V0XTtcbiAgICAgICAgIHZhciB0VmVjID0gY3YudjtcbiAgICAgICAgIHRWZWMueCA9IHZJbjAueCArIGludGVycCAqICh2SW4xLnggLSB2SW4wLngpO1xuICAgICAgICAgdFZlYy55ID0gdkluMC55ICsgaW50ZXJwICogKHZJbjEueSAtIHZJbjAueSk7XG4gICAgICAgICBjdiA9IHZPdXRbbnVtT3V0XTtcbiAgICAgICAgIHZhciBjdjI7XG4gICAgICAgICBpZiAoZGlzdGFuY2UwID4gMC4wKSB7XG4gICAgICAgICAgICBjdjIgPSB2SW5bMF07XG4gICAgICAgICAgICBjdi5pZCA9IGN2Mi5pZDtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3YyID0gdkluWzFdO1xuICAgICAgICAgICAgY3YuaWQgPSBjdjIuaWQ7XG4gICAgICAgICB9KytudW1PdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtT3V0O1xuICAgfVxuICAgYjJDb2xsaXNpb24uRWRnZVNlcGFyYXRpb24gPSBmdW5jdGlvbiAocG9seTEsIHhmMSwgZWRnZTEsIHBvbHkyLCB4ZjIpIHtcbiAgICAgIGlmIChlZGdlMSA9PT0gdW5kZWZpbmVkKSBlZGdlMSA9IDA7XG4gICAgICB2YXIgY291bnQxID0gcGFyc2VJbnQocG9seTEubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgdmVydGljZXMxID0gcG9seTEubV92ZXJ0aWNlcztcbiAgICAgIHZhciBub3JtYWxzMSA9IHBvbHkxLm1fbm9ybWFscztcbiAgICAgIHZhciBjb3VudDIgPSBwYXJzZUludChwb2x5Mi5tX3ZlcnRleENvdW50KTtcbiAgICAgIHZhciB2ZXJ0aWNlczIgPSBwb2x5Mi5tX3ZlcnRpY2VzO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFZlYztcbiAgICAgIHRNYXQgPSB4ZjEuUjtcbiAgICAgIHRWZWMgPSBub3JtYWxzMVtlZGdlMV07XG4gICAgICB2YXIgbm9ybWFsMVdvcmxkWCA9ICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHZhciBub3JtYWwxV29ybGRZID0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdE1hdCA9IHhmMi5SO1xuICAgICAgdmFyIG5vcm1hbDFYID0gKHRNYXQuY29sMS54ICogbm9ybWFsMVdvcmxkWCArIHRNYXQuY29sMS55ICogbm9ybWFsMVdvcmxkWSk7XG4gICAgICB2YXIgbm9ybWFsMVkgPSAodE1hdC5jb2wyLnggKiBub3JtYWwxV29ybGRYICsgdE1hdC5jb2wyLnkgKiBub3JtYWwxV29ybGRZKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgbWluRG90ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQyOyArK2kpIHtcbiAgICAgICAgIHRWZWMgPSB2ZXJ0aWNlczJbaV07XG4gICAgICAgICB2YXIgZG90ID0gdFZlYy54ICogbm9ybWFsMVggKyB0VmVjLnkgKiBub3JtYWwxWTtcbiAgICAgICAgIGlmIChkb3QgPCBtaW5Eb3QpIHtcbiAgICAgICAgICAgIG1pbkRvdCA9IGRvdDtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRWZWMgPSB2ZXJ0aWNlczFbZWRnZTFdO1xuICAgICAgdE1hdCA9IHhmMS5SO1xuICAgICAgdmFyIHYxWCA9IHhmMS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdmFyIHYxWSA9IHhmMS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdFZlYyA9IHZlcnRpY2VzMltpbmRleF07XG4gICAgICB0TWF0ID0geGYyLlI7XG4gICAgICB2YXIgdjJYID0geGYyLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB2YXIgdjJZID0geGYyLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICB2MlggLT0gdjFYO1xuICAgICAgdjJZIC09IHYxWTtcbiAgICAgIHZhciBzZXBhcmF0aW9uID0gdjJYICogbm9ybWFsMVdvcmxkWCArIHYyWSAqIG5vcm1hbDFXb3JsZFk7XG4gICAgICByZXR1cm4gc2VwYXJhdGlvbjtcbiAgIH1cbiAgIGIyQ29sbGlzaW9uLkZpbmRNYXhTZXBhcmF0aW9uID0gZnVuY3Rpb24gKGVkZ2VJbmRleCwgcG9seTEsIHhmMSwgcG9seTIsIHhmMikge1xuICAgICAgdmFyIGNvdW50MSA9IHBhcnNlSW50KHBvbHkxLm1fdmVydGV4Q291bnQpO1xuICAgICAgdmFyIG5vcm1hbHMxID0gcG9seTEubV9ub3JtYWxzO1xuICAgICAgdmFyIHRWZWM7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHRNYXQgPSB4ZjIuUjtcbiAgICAgIHRWZWMgPSBwb2x5Mi5tX2NlbnRyb2lkO1xuICAgICAgdmFyIGRYID0geGYyLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB2YXIgZFkgPSB4ZjIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHRNYXQgPSB4ZjEuUjtcbiAgICAgIHRWZWMgPSBwb2x5MS5tX2NlbnRyb2lkO1xuICAgICAgZFggLT0geGYxLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICBkWSAtPSB4ZjEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHZhciBkTG9jYWwxWCA9IChkWCAqIHhmMS5SLmNvbDEueCArIGRZICogeGYxLlIuY29sMS55KTtcbiAgICAgIHZhciBkTG9jYWwxWSA9IChkWCAqIHhmMS5SLmNvbDIueCArIGRZICogeGYxLlIuY29sMi55KTtcbiAgICAgIHZhciBlZGdlID0gMDtcbiAgICAgIHZhciBtYXhEb3QgPSAoLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDE7ICsraSkge1xuICAgICAgICAgdFZlYyA9IG5vcm1hbHMxW2ldO1xuICAgICAgICAgdmFyIGRvdCA9ICh0VmVjLnggKiBkTG9jYWwxWCArIHRWZWMueSAqIGRMb2NhbDFZKTtcbiAgICAgICAgIGlmIChkb3QgPiBtYXhEb3QpIHtcbiAgICAgICAgICAgIG1heERvdCA9IGRvdDtcbiAgICAgICAgICAgIGVkZ2UgPSBpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHMgPSBiMkNvbGxpc2lvbi5FZGdlU2VwYXJhdGlvbihwb2x5MSwgeGYxLCBlZGdlLCBwb2x5MiwgeGYyKTtcbiAgICAgIHZhciBwcmV2RWRnZSA9IHBhcnNlSW50KGVkZ2UgLSAxID49IDAgPyBlZGdlIC0gMSA6IGNvdW50MSAtIDEpO1xuICAgICAgdmFyIHNQcmV2ID0gYjJDb2xsaXNpb24uRWRnZVNlcGFyYXRpb24ocG9seTEsIHhmMSwgcHJldkVkZ2UsIHBvbHkyLCB4ZjIpO1xuICAgICAgdmFyIG5leHRFZGdlID0gcGFyc2VJbnQoZWRnZSArIDEgPCBjb3VudDEgPyBlZGdlICsgMSA6IDApO1xuICAgICAgdmFyIHNOZXh0ID0gYjJDb2xsaXNpb24uRWRnZVNlcGFyYXRpb24ocG9seTEsIHhmMSwgbmV4dEVkZ2UsIHBvbHkyLCB4ZjIpO1xuICAgICAgdmFyIGJlc3RFZGdlID0gMDtcbiAgICAgIHZhciBiZXN0U2VwYXJhdGlvbiA9IDA7XG4gICAgICB2YXIgaW5jcmVtZW50ID0gMDtcbiAgICAgIGlmIChzUHJldiA+IHMgJiYgc1ByZXYgPiBzTmV4dCkge1xuICAgICAgICAgaW5jcmVtZW50ID0gKC0xKTtcbiAgICAgICAgIGJlc3RFZGdlID0gcHJldkVkZ2U7XG4gICAgICAgICBiZXN0U2VwYXJhdGlvbiA9IHNQcmV2O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc05leHQgPiBzKSB7XG4gICAgICAgICBpbmNyZW1lbnQgPSAxO1xuICAgICAgICAgYmVzdEVkZ2UgPSBuZXh0RWRnZTtcbiAgICAgICAgIGJlc3RTZXBhcmF0aW9uID0gc05leHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIGVkZ2VJbmRleFswXSA9IGVkZ2U7XG4gICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICBpZiAoaW5jcmVtZW50ID09ICgtMSkpIGVkZ2UgPSBiZXN0RWRnZSAtIDEgPj0gMCA/IGJlc3RFZGdlIC0gMSA6IGNvdW50MSAtIDE7XG4gICAgICAgICBlbHNlIGVkZ2UgPSBiZXN0RWRnZSArIDEgPCBjb3VudDEgPyBiZXN0RWRnZSArIDEgOiAwO3MgPSBiMkNvbGxpc2lvbi5FZGdlU2VwYXJhdGlvbihwb2x5MSwgeGYxLCBlZGdlLCBwb2x5MiwgeGYyKTtcbiAgICAgICAgIGlmIChzID4gYmVzdFNlcGFyYXRpb24pIHtcbiAgICAgICAgICAgIGJlc3RFZGdlID0gZWRnZTtcbiAgICAgICAgICAgIGJlc3RTZXBhcmF0aW9uID0gcztcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBlZGdlSW5kZXhbMF0gPSBiZXN0RWRnZTtcbiAgICAgIHJldHVybiBiZXN0U2VwYXJhdGlvbjtcbiAgIH1cbiAgIGIyQ29sbGlzaW9uLkZpbmRJbmNpZGVudEVkZ2UgPSBmdW5jdGlvbiAoYywgcG9seTEsIHhmMSwgZWRnZTEsIHBvbHkyLCB4ZjIpIHtcbiAgICAgIGlmIChlZGdlMSA9PT0gdW5kZWZpbmVkKSBlZGdlMSA9IDA7XG4gICAgICB2YXIgY291bnQxID0gcGFyc2VJbnQocG9seTEubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgbm9ybWFsczEgPSBwb2x5MS5tX25vcm1hbHM7XG4gICAgICB2YXIgY291bnQyID0gcGFyc2VJbnQocG9seTIubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgdmVydGljZXMyID0gcG9seTIubV92ZXJ0aWNlcztcbiAgICAgIHZhciBub3JtYWxzMiA9IHBvbHkyLm1fbm9ybWFscztcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRWZWM7XG4gICAgICB0TWF0ID0geGYxLlI7XG4gICAgICB0VmVjID0gbm9ybWFsczFbZWRnZTFdO1xuICAgICAgdmFyIG5vcm1hbDFYID0gKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdmFyIG5vcm1hbDFZID0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdE1hdCA9IHhmMi5SO1xuICAgICAgdmFyIHRYID0gKHRNYXQuY29sMS54ICogbm9ybWFsMVggKyB0TWF0LmNvbDEueSAqIG5vcm1hbDFZKTtcbiAgICAgIG5vcm1hbDFZID0gKHRNYXQuY29sMi54ICogbm9ybWFsMVggKyB0TWF0LmNvbDIueSAqIG5vcm1hbDFZKTtcbiAgICAgIG5vcm1hbDFYID0gdFg7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIG1pbkRvdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50MjsgKytpKSB7XG4gICAgICAgICB0VmVjID0gbm9ybWFsczJbaV07XG4gICAgICAgICB2YXIgZG90ID0gKG5vcm1hbDFYICogdFZlYy54ICsgbm9ybWFsMVkgKiB0VmVjLnkpO1xuICAgICAgICAgaWYgKGRvdCA8IG1pbkRvdCkge1xuICAgICAgICAgICAgbWluRG90ID0gZG90O1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRDbGlwO1xuICAgICAgdmFyIGkxID0gcGFyc2VJbnQoaW5kZXgpO1xuICAgICAgdmFyIGkyID0gcGFyc2VJbnQoaTEgKyAxIDwgY291bnQyID8gaTEgKyAxIDogMCk7XG4gICAgICB0Q2xpcCA9IGNbMF07XG4gICAgICB0VmVjID0gdmVydGljZXMyW2kxXTtcbiAgICAgIHRNYXQgPSB4ZjIuUjtcbiAgICAgIHRDbGlwLnYueCA9IHhmMi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdENsaXAudi55ID0geGYyLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICB0Q2xpcC5pZC5mZWF0dXJlcy5yZWZlcmVuY2VFZGdlID0gZWRnZTE7XG4gICAgICB0Q2xpcC5pZC5mZWF0dXJlcy5pbmNpZGVudEVkZ2UgPSBpMTtcbiAgICAgIHRDbGlwLmlkLmZlYXR1cmVzLmluY2lkZW50VmVydGV4ID0gMDtcbiAgICAgIHRDbGlwID0gY1sxXTtcbiAgICAgIHRWZWMgPSB2ZXJ0aWNlczJbaTJdO1xuICAgICAgdE1hdCA9IHhmMi5SO1xuICAgICAgdENsaXAudi54ID0geGYyLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB0Q2xpcC52LnkgPSB4ZjIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHRDbGlwLmlkLmZlYXR1cmVzLnJlZmVyZW5jZUVkZ2UgPSBlZGdlMTtcbiAgICAgIHRDbGlwLmlkLmZlYXR1cmVzLmluY2lkZW50RWRnZSA9IGkyO1xuICAgICAgdENsaXAuaWQuZmVhdHVyZXMuaW5jaWRlbnRWZXJ0ZXggPSAxO1xuICAgfVxuICAgYjJDb2xsaXNpb24uTWFrZUNsaXBQb2ludFZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByID0gbmV3IFZlY3RvcigyKTtcbiAgICAgIHJbMF0gPSBuZXcgQ2xpcFZlcnRleCgpO1xuICAgICAgclsxXSA9IG5ldyBDbGlwVmVydGV4KCk7XG4gICAgICByZXR1cm4gcjtcbiAgIH1cbiAgIGIyQ29sbGlzaW9uLkNvbGxpZGVQb2x5Z29ucyA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgcG9seUEsIHhmQSwgcG9seUIsIHhmQikge1xuICAgICAgdmFyIGN2O1xuICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMDtcbiAgICAgIHZhciB0b3RhbFJhZGl1cyA9IHBvbHlBLm1fcmFkaXVzICsgcG9seUIubV9yYWRpdXM7XG4gICAgICB2YXIgZWRnZUEgPSAwO1xuICAgICAgYjJDb2xsaXNpb24uc19lZGdlQU9bMF0gPSBlZGdlQTtcbiAgICAgIHZhciBzZXBhcmF0aW9uQSA9IGIyQ29sbGlzaW9uLkZpbmRNYXhTZXBhcmF0aW9uKGIyQ29sbGlzaW9uLnNfZWRnZUFPLCBwb2x5QSwgeGZBLCBwb2x5QiwgeGZCKTtcbiAgICAgIGVkZ2VBID0gYjJDb2xsaXNpb24uc19lZGdlQU9bMF07XG4gICAgICBpZiAoc2VwYXJhdGlvbkEgPiB0b3RhbFJhZGl1cykgcmV0dXJuO1xuICAgICAgdmFyIGVkZ2VCID0gMDtcbiAgICAgIGIyQ29sbGlzaW9uLnNfZWRnZUJPWzBdID0gZWRnZUI7XG4gICAgICB2YXIgc2VwYXJhdGlvbkIgPSBiMkNvbGxpc2lvbi5GaW5kTWF4U2VwYXJhdGlvbihiMkNvbGxpc2lvbi5zX2VkZ2VCTywgcG9seUIsIHhmQiwgcG9seUEsIHhmQSk7XG4gICAgICBlZGdlQiA9IGIyQ29sbGlzaW9uLnNfZWRnZUJPWzBdO1xuICAgICAgaWYgKHNlcGFyYXRpb25CID4gdG90YWxSYWRpdXMpIHJldHVybjtcbiAgICAgIHZhciBwb2x5MTtcbiAgICAgIHZhciBwb2x5MjtcbiAgICAgIHZhciB4ZjE7XG4gICAgICB2YXIgeGYyO1xuICAgICAgdmFyIGVkZ2UxID0gMDtcbiAgICAgIHZhciBmbGlwID0gMDtcbiAgICAgIHZhciBrX3JlbGF0aXZlVG9sID0gMC45ODtcbiAgICAgIHZhciBrX2Fic29sdXRlVG9sID0gMC4wMDE7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIGlmIChzZXBhcmF0aW9uQiA+IGtfcmVsYXRpdmVUb2wgKiBzZXBhcmF0aW9uQSArIGtfYWJzb2x1dGVUb2wpIHtcbiAgICAgICAgIHBvbHkxID0gcG9seUI7XG4gICAgICAgICBwb2x5MiA9IHBvbHlBO1xuICAgICAgICAgeGYxID0geGZCO1xuICAgICAgICAgeGYyID0geGZBO1xuICAgICAgICAgZWRnZTEgPSBlZGdlQjtcbiAgICAgICAgIG1hbmlmb2xkLm1fdHlwZSA9IGIyTWFuaWZvbGQuZV9mYWNlQjtcbiAgICAgICAgIGZsaXAgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBwb2x5MSA9IHBvbHlBO1xuICAgICAgICAgcG9seTIgPSBwb2x5QjtcbiAgICAgICAgIHhmMSA9IHhmQTtcbiAgICAgICAgIHhmMiA9IHhmQjtcbiAgICAgICAgIGVkZ2UxID0gZWRnZUE7XG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUE7XG4gICAgICAgICBmbGlwID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmNpZGVudEVkZ2UgPSBiMkNvbGxpc2lvbi5zX2luY2lkZW50RWRnZTtcbiAgICAgIGIyQ29sbGlzaW9uLkZpbmRJbmNpZGVudEVkZ2UoaW5jaWRlbnRFZGdlLCBwb2x5MSwgeGYxLCBlZGdlMSwgcG9seTIsIHhmMik7XG4gICAgICB2YXIgY291bnQxID0gcGFyc2VJbnQocG9seTEubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgdmVydGljZXMxID0gcG9seTEubV92ZXJ0aWNlcztcbiAgICAgIHZhciBsb2NhbF92MTEgPSB2ZXJ0aWNlczFbZWRnZTFdO1xuICAgICAgdmFyIGxvY2FsX3YxMjtcbiAgICAgIGlmIChlZGdlMSArIDEgPCBjb3VudDEpIHtcbiAgICAgICAgIGxvY2FsX3YxMiA9IHZlcnRpY2VzMVtwYXJzZUludChlZGdlMSArIDEpXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgbG9jYWxfdjEyID0gdmVydGljZXMxWzBdO1xuICAgICAgfVxuICAgICAgdmFyIGxvY2FsVGFuZ2VudCA9IGIyQ29sbGlzaW9uLnNfbG9jYWxUYW5nZW50O1xuICAgICAgbG9jYWxUYW5nZW50LlNldChsb2NhbF92MTIueCAtIGxvY2FsX3YxMS54LCBsb2NhbF92MTIueSAtIGxvY2FsX3YxMS55KTtcbiAgICAgIGxvY2FsVGFuZ2VudC5Ob3JtYWxpemUoKTtcbiAgICAgIHZhciBsb2NhbE5vcm1hbCA9IGIyQ29sbGlzaW9uLnNfbG9jYWxOb3JtYWw7XG4gICAgICBsb2NhbE5vcm1hbC54ID0gbG9jYWxUYW5nZW50Lnk7XG4gICAgICBsb2NhbE5vcm1hbC55ID0gKC1sb2NhbFRhbmdlbnQueCk7XG4gICAgICB2YXIgcGxhbmVQb2ludCA9IGIyQ29sbGlzaW9uLnNfcGxhbmVQb2ludDtcbiAgICAgIHBsYW5lUG9pbnQuU2V0KDAuNSAqIChsb2NhbF92MTEueCArIGxvY2FsX3YxMi54KSwgMC41ICogKGxvY2FsX3YxMS55ICsgbG9jYWxfdjEyLnkpKTtcbiAgICAgIHZhciB0YW5nZW50ID0gYjJDb2xsaXNpb24uc190YW5nZW50O1xuICAgICAgdE1hdCA9IHhmMS5SO1xuICAgICAgdGFuZ2VudC54ID0gKHRNYXQuY29sMS54ICogbG9jYWxUYW5nZW50LnggKyB0TWF0LmNvbDIueCAqIGxvY2FsVGFuZ2VudC55KTtcbiAgICAgIHRhbmdlbnQueSA9ICh0TWF0LmNvbDEueSAqIGxvY2FsVGFuZ2VudC54ICsgdE1hdC5jb2wyLnkgKiBsb2NhbFRhbmdlbnQueSk7XG4gICAgICB2YXIgdGFuZ2VudDIgPSBiMkNvbGxpc2lvbi5zX3RhbmdlbnQyO1xuICAgICAgdGFuZ2VudDIueCA9ICgtdGFuZ2VudC54KTtcbiAgICAgIHRhbmdlbnQyLnkgPSAoLXRhbmdlbnQueSk7XG4gICAgICB2YXIgbm9ybWFsID0gYjJDb2xsaXNpb24uc19ub3JtYWw7XG4gICAgICBub3JtYWwueCA9IHRhbmdlbnQueTtcbiAgICAgIG5vcm1hbC55ID0gKC10YW5nZW50LngpO1xuICAgICAgdmFyIHYxMSA9IGIyQ29sbGlzaW9uLnNfdjExO1xuICAgICAgdmFyIHYxMiA9IGIyQ29sbGlzaW9uLnNfdjEyO1xuICAgICAgdjExLnggPSB4ZjEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIGxvY2FsX3YxMS54ICsgdE1hdC5jb2wyLnggKiBsb2NhbF92MTEueSk7XG4gICAgICB2MTEueSA9IHhmMS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogbG9jYWxfdjExLnggKyB0TWF0LmNvbDIueSAqIGxvY2FsX3YxMS55KTtcbiAgICAgIHYxMi54ID0geGYxLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiBsb2NhbF92MTIueCArIHRNYXQuY29sMi54ICogbG9jYWxfdjEyLnkpO1xuICAgICAgdjEyLnkgPSB4ZjEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIGxvY2FsX3YxMi54ICsgdE1hdC5jb2wyLnkgKiBsb2NhbF92MTIueSk7XG4gICAgICB2YXIgZnJvbnRPZmZzZXQgPSBub3JtYWwueCAqIHYxMS54ICsgbm9ybWFsLnkgKiB2MTEueTtcbiAgICAgIHZhciBzaWRlT2Zmc2V0MSA9ICgtdGFuZ2VudC54ICogdjExLngpIC0gdGFuZ2VudC55ICogdjExLnkgKyB0b3RhbFJhZGl1cztcbiAgICAgIHZhciBzaWRlT2Zmc2V0MiA9IHRhbmdlbnQueCAqIHYxMi54ICsgdGFuZ2VudC55ICogdjEyLnkgKyB0b3RhbFJhZGl1cztcbiAgICAgIHZhciBjbGlwUG9pbnRzMSA9IGIyQ29sbGlzaW9uLnNfY2xpcFBvaW50czE7XG4gICAgICB2YXIgY2xpcFBvaW50czIgPSBiMkNvbGxpc2lvbi5zX2NsaXBQb2ludHMyO1xuICAgICAgdmFyIG5wID0gMDtcbiAgICAgIG5wID0gYjJDb2xsaXNpb24uQ2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czEsIGluY2lkZW50RWRnZSwgdGFuZ2VudDIsIHNpZGVPZmZzZXQxKTtcbiAgICAgIGlmIChucCA8IDIpIHJldHVybjtcbiAgICAgIG5wID0gYjJDb2xsaXNpb24uQ2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czIsIGNsaXBQb2ludHMxLCB0YW5nZW50LCBzaWRlT2Zmc2V0Mik7XG4gICAgICBpZiAobnAgPCAyKSByZXR1cm47XG4gICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwuU2V0Vihsb2NhbE5vcm1hbCk7XG4gICAgICBtYW5pZm9sZC5tX2xvY2FsUG9pbnQuU2V0VihwbGFuZVBvaW50KTtcbiAgICAgIHZhciBwb2ludENvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50czsgKytpKSB7XG4gICAgICAgICBjdiA9IGNsaXBQb2ludHMyW2ldO1xuICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBub3JtYWwueCAqIGN2LnYueCArIG5vcm1hbC55ICogY3Yudi55IC0gZnJvbnRPZmZzZXQ7XG4gICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSB0b3RhbFJhZGl1cykge1xuICAgICAgICAgICAgdmFyIGNwID0gbWFuaWZvbGQubV9wb2ludHNbcG9pbnRDb3VudF07XG4gICAgICAgICAgICB0TWF0ID0geGYyLlI7XG4gICAgICAgICAgICB2YXIgdFggPSBjdi52LnggLSB4ZjIucG9zaXRpb24ueDtcbiAgICAgICAgICAgIHZhciB0WSA9IGN2LnYueSAtIHhmMi5wb3NpdGlvbi55O1xuICAgICAgICAgICAgY3AubV9sb2NhbFBvaW50LnggPSAodFggKiB0TWF0LmNvbDEueCArIHRZICogdE1hdC5jb2wxLnkpO1xuICAgICAgICAgICAgY3AubV9sb2NhbFBvaW50LnkgPSAodFggKiB0TWF0LmNvbDIueCArIHRZICogdE1hdC5jb2wyLnkpO1xuICAgICAgICAgICAgY3AubV9pZC5TZXQoY3YuaWQpO1xuICAgICAgICAgICAgY3AubV9pZC5mZWF0dXJlcy5mbGlwID0gZmxpcDtcbiAgICAgICAgICAgICsrcG9pbnRDb3VudDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IHBvaW50Q291bnQ7XG4gICB9XG4gICBiMkNvbGxpc2lvbi5Db2xsaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgY2lyY2xlMSwgeGYxLCBjaXJjbGUyLCB4ZjIpIHtcbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDA7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdE1hdCA9IHhmMS5SO1xuICAgICAgdFZlYyA9IGNpcmNsZTEubV9wO1xuICAgICAgdmFyIHAxWCA9IHhmMS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdmFyIHAxWSA9IHhmMS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdE1hdCA9IHhmMi5SO1xuICAgICAgdFZlYyA9IGNpcmNsZTIubV9wO1xuICAgICAgdmFyIHAyWCA9IHhmMi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdmFyIHAyWSA9IHhmMi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdmFyIGRYID0gcDJYIC0gcDFYO1xuICAgICAgdmFyIGRZID0gcDJZIC0gcDFZO1xuICAgICAgdmFyIGRpc3RTcXIgPSBkWCAqIGRYICsgZFkgKiBkWTtcbiAgICAgIHZhciByYWRpdXMgPSBjaXJjbGUxLm1fcmFkaXVzICsgY2lyY2xlMi5tX3JhZGl1cztcbiAgICAgIGlmIChkaXN0U3FyID4gcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfY2lyY2xlcztcbiAgICAgIG1hbmlmb2xkLm1fbG9jYWxQb2ludC5TZXRWKGNpcmNsZTEubV9wKTtcbiAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5TZXRaZXJvKCk7XG4gICAgICBtYW5pZm9sZC5tX3BvaW50Q291bnQgPSAxO1xuICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9sb2NhbFBvaW50LlNldFYoY2lyY2xlMi5tX3ApO1xuICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9pZC5rZXkgPSAwO1xuICAgfVxuICAgYjJDb2xsaXNpb24uQ29sbGlkZVBvbHlnb25BbmRDaXJjbGUgPSBmdW5jdGlvbiAobWFuaWZvbGQsIHBvbHlnb24sIHhmMSwgY2lyY2xlLCB4ZjIpIHtcbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDA7XG4gICAgICB2YXIgdFBvaW50O1xuICAgICAgdmFyIGRYID0gMDtcbiAgICAgIHZhciBkWSA9IDA7XG4gICAgICB2YXIgcG9zaXRpb25YID0gMDtcbiAgICAgIHZhciBwb3NpdGlvblkgPSAwO1xuICAgICAgdmFyIHRWZWM7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHRNYXQgPSB4ZjIuUjtcbiAgICAgIHRWZWMgPSBjaXJjbGUubV9wO1xuICAgICAgdmFyIGNYID0geGYyLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB2YXIgY1kgPSB4ZjIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIGRYID0gY1ggLSB4ZjEucG9zaXRpb24ueDtcbiAgICAgIGRZID0gY1kgLSB4ZjEucG9zaXRpb24ueTtcbiAgICAgIHRNYXQgPSB4ZjEuUjtcbiAgICAgIHZhciBjTG9jYWxYID0gKGRYICogdE1hdC5jb2wxLnggKyBkWSAqIHRNYXQuY29sMS55KTtcbiAgICAgIHZhciBjTG9jYWxZID0gKGRYICogdE1hdC5jb2wyLnggKyBkWSAqIHRNYXQuY29sMi55KTtcbiAgICAgIHZhciBkaXN0ID0gMDtcbiAgICAgIHZhciBub3JtYWxJbmRleCA9IDA7XG4gICAgICB2YXIgc2VwYXJhdGlvbiA9ICgtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICB2YXIgcmFkaXVzID0gcG9seWdvbi5tX3JhZGl1cyArIGNpcmNsZS5tX3JhZGl1cztcbiAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IHBhcnNlSW50KHBvbHlnb24ubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgdmVydGljZXMgPSBwb2x5Z29uLm1fdmVydGljZXM7XG4gICAgICB2YXIgbm9ybWFscyA9IHBvbHlnb24ubV9ub3JtYWxzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgKytpKSB7XG4gICAgICAgICB0VmVjID0gdmVydGljZXNbaV07XG4gICAgICAgICBkWCA9IGNMb2NhbFggLSB0VmVjLng7XG4gICAgICAgICBkWSA9IGNMb2NhbFkgLSB0VmVjLnk7XG4gICAgICAgICB0VmVjID0gbm9ybWFsc1tpXTtcbiAgICAgICAgIHZhciBzID0gdFZlYy54ICogZFggKyB0VmVjLnkgKiBkWTtcbiAgICAgICAgIGlmIChzID4gcmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG4gICAgICAgICBpZiAocyA+IHNlcGFyYXRpb24pIHtcbiAgICAgICAgICAgIHNlcGFyYXRpb24gPSBzO1xuICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZlcnRJbmRleDEgPSBwYXJzZUludChub3JtYWxJbmRleCk7XG4gICAgICB2YXIgdmVydEluZGV4MiA9IHBhcnNlSW50KHZlcnRJbmRleDEgKyAxIDwgdmVydGV4Q291bnQgPyB2ZXJ0SW5kZXgxICsgMSA6IDApO1xuICAgICAgdmFyIHYxID0gdmVydGljZXNbdmVydEluZGV4MV07XG4gICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1t2ZXJ0SW5kZXgyXTtcbiAgICAgIGlmIChzZXBhcmF0aW9uIDwgTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMTtcbiAgICAgICAgIG1hbmlmb2xkLm1fdHlwZSA9IGIyTWFuaWZvbGQuZV9mYWNlQTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5TZXRWKG5vcm1hbHNbbm9ybWFsSW5kZXhdKTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQb2ludC54ID0gMC41ICogKHYxLnggKyB2Mi54KTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQb2ludC55ID0gMC41ICogKHYxLnkgKyB2Mi55KTtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1fbG9jYWxQb2ludC5TZXRWKGNpcmNsZS5tX3ApO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9pZC5rZXkgPSAwO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHUxID0gKGNMb2NhbFggLSB2MS54KSAqICh2Mi54IC0gdjEueCkgKyAoY0xvY2FsWSAtIHYxLnkpICogKHYyLnkgLSB2MS55KTtcbiAgICAgIHZhciB1MiA9IChjTG9jYWxYIC0gdjIueCkgKiAodjEueCAtIHYyLngpICsgKGNMb2NhbFkgLSB2Mi55KSAqICh2MS55IC0gdjIueSk7XG4gICAgICBpZiAodTEgPD0gMC4wKSB7XG4gICAgICAgICBpZiAoKGNMb2NhbFggLSB2MS54KSAqIChjTG9jYWxYIC0gdjEueCkgKyAoY0xvY2FsWSAtIHYxLnkpICogKGNMb2NhbFkgLSB2MS55KSA+IHJhZGl1cyAqIHJhZGl1cykgcmV0dXJuO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMTtcbiAgICAgICAgIG1hbmlmb2xkLm1fdHlwZSA9IGIyTWFuaWZvbGQuZV9mYWNlQTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC54ID0gY0xvY2FsWCAtIHYxLng7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueSA9IGNMb2NhbFkgLSB2MS55O1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLk5vcm1hbGl6ZSgpO1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBvaW50LlNldFYodjEpO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9sb2NhbFBvaW50LlNldFYoY2lyY2xlLm1fcCk7XG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2lkLmtleSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh1MiA8PSAwKSB7XG4gICAgICAgICBpZiAoKGNMb2NhbFggLSB2Mi54KSAqIChjTG9jYWxYIC0gdjIueCkgKyAoY0xvY2FsWSAtIHYyLnkpICogKGNMb2NhbFkgLSB2Mi55KSA+IHJhZGl1cyAqIHJhZGl1cykgcmV0dXJuO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMTtcbiAgICAgICAgIG1hbmlmb2xkLm1fdHlwZSA9IGIyTWFuaWZvbGQuZV9mYWNlQTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC54ID0gY0xvY2FsWCAtIHYyLng7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueSA9IGNMb2NhbFkgLSB2Mi55O1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLk5vcm1hbGl6ZSgpO1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBvaW50LlNldFYodjIpO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9sb2NhbFBvaW50LlNldFYoY2lyY2xlLm1fcCk7XG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2lkLmtleSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHZhciBmYWNlQ2VudGVyWCA9IDAuNSAqICh2MS54ICsgdjIueCk7XG4gICAgICAgICB2YXIgZmFjZUNlbnRlclkgPSAwLjUgKiAodjEueSArIHYyLnkpO1xuICAgICAgICAgc2VwYXJhdGlvbiA9IChjTG9jYWxYIC0gZmFjZUNlbnRlclgpICogbm9ybWFsc1t2ZXJ0SW5kZXgxXS54ICsgKGNMb2NhbFkgLSBmYWNlQ2VudGVyWSkgKiBub3JtYWxzW3ZlcnRJbmRleDFdLnk7XG4gICAgICAgICBpZiAoc2VwYXJhdGlvbiA+IHJhZGl1cykgcmV0dXJuO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMTtcbiAgICAgICAgIG1hbmlmb2xkLm1fdHlwZSA9IGIyTWFuaWZvbGQuZV9mYWNlQTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC54ID0gbm9ybWFsc1t2ZXJ0SW5kZXgxXS54O1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLnkgPSBub3JtYWxzW3ZlcnRJbmRleDFdLnk7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwuTm9ybWFsaXplKCk7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUG9pbnQuU2V0KGZhY2VDZW50ZXJYLCBmYWNlQ2VudGVyWSk7XG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2xvY2FsUG9pbnQuU2V0VihjaXJjbGUubV9wKTtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1faWQua2V5ID0gMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQ29sbGlzaW9uLlRlc3RPdmVybGFwID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciB0MSA9IGIubG93ZXJCb3VuZDtcbiAgICAgIHZhciB0MiA9IGEudXBwZXJCb3VuZDtcbiAgICAgIHZhciBkMVggPSB0MS54IC0gdDIueDtcbiAgICAgIHZhciBkMVkgPSB0MS55IC0gdDIueTtcbiAgICAgIHQxID0gYS5sb3dlckJvdW5kO1xuICAgICAgdDIgPSBiLnVwcGVyQm91bmQ7XG4gICAgICB2YXIgZDJYID0gdDEueCAtIHQyLng7XG4gICAgICB2YXIgZDJZID0gdDEueSAtIHQyLnk7XG4gICAgICBpZiAoZDFYID4gMC4wIHx8IGQxWSA+IDAuMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGQyWCA+IDAuMCB8fCBkMlkgPiAwLjApIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uc19pbmNpZGVudEVkZ2UgPSBiMkNvbGxpc2lvbi5NYWtlQ2xpcFBvaW50VmVjdG9yKCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uc19jbGlwUG9pbnRzMSA9IGIyQ29sbGlzaW9uLk1ha2VDbGlwUG9pbnRWZWN0b3IoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX2NsaXBQb2ludHMyID0gYjJDb2xsaXNpb24uTWFrZUNsaXBQb2ludFZlY3RvcigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfZWRnZUFPID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKDEpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfZWRnZUJPID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKDEpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfbG9jYWxUYW5nZW50ID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfbG9jYWxOb3JtYWwgPSBuZXcgYjJWZWMyKCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uc19wbGFuZVBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfbm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfdGFuZ2VudCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX3RhbmdlbnQyID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfdjExID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfdjEyID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLmIyQ29sbGlkZVBvbHlUZW1wVmVjID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLmIyX251bGxGZWF0dXJlID0gMHgwMDAwMDBmZjtcbiAgIH0pO1xuICAgYjJDb250YWN0SUQuYjJDb250YWN0SUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzID0gbmV3IEZlYXR1cmVzKCk7XG4gICB9O1xuICAgYjJDb250YWN0SUQucHJvdG90eXBlLmIyQ29udGFjdElEID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5mZWF0dXJlcy5fbV9pZCA9IHRoaXM7XG4gICB9XG4gICBiMkNvbnRhY3RJRC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICB0aGlzLmtleSA9IGlkLl9rZXk7XG4gICB9XG4gICBiMkNvbnRhY3RJRC5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZCA9IG5ldyBiMkNvbnRhY3RJRCgpO1xuICAgICAgaWQua2V5ID0gdGhpcy5rZXk7XG4gICAgICByZXR1cm4gaWQ7XG4gICB9XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYjJDb250YWN0SUQucHJvdG90eXBlLCAna2V5Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9rZXk7XG4gICAgICB9XG4gICB9KTtcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbnRhY3RJRC5wcm90b3R5cGUsICdrZXknLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAwO1xuICAgICAgICAgdGhpcy5fa2V5ID0gdmFsdWU7XG4gICAgICAgICB0aGlzLmZlYXR1cmVzLl9yZWZlcmVuY2VFZGdlID0gdGhpcy5fa2V5ICYgMHgwMDAwMDBmZjtcbiAgICAgICAgIHRoaXMuZmVhdHVyZXMuX2luY2lkZW50RWRnZSA9ICgodGhpcy5fa2V5ICYgMHgwMDAwZmYwMCkgPj4gOCkgJiAweDAwMDAwMGZmO1xuICAgICAgICAgdGhpcy5mZWF0dXJlcy5faW5jaWRlbnRWZXJ0ZXggPSAoKHRoaXMuX2tleSAmIDB4MDBmZjAwMDApID4+IDE2KSAmIDB4MDAwMDAwZmY7XG4gICAgICAgICB0aGlzLmZlYXR1cmVzLl9mbGlwID0gKCh0aGlzLl9rZXkgJiAweGZmMDAwMDAwKSA+PiAyNCkgJiAweDAwMDAwMGZmO1xuICAgICAgfVxuICAgfSk7XG4gICBiMkNvbnRhY3RQb2ludC5iMkNvbnRhY3RQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5ub3JtYWwgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmlkID0gbmV3IGIyQ29udGFjdElEKCk7XG4gICB9O1xuICAgYjJEaXN0YW5jZS5iMkRpc3RhbmNlID0gZnVuY3Rpb24gKCkge307XG4gICBiMkRpc3RhbmNlLkRpc3RhbmNlID0gZnVuY3Rpb24gKG91dHB1dCwgY2FjaGUsIGlucHV0KSB7XG4gICAgICArK2IyRGlzdGFuY2UuYjJfZ2prQ2FsbHM7XG4gICAgICB2YXIgcHJveHlBID0gaW5wdXQucHJveHlBO1xuICAgICAgdmFyIHByb3h5QiA9IGlucHV0LnByb3h5QjtcbiAgICAgIHZhciB0cmFuc2Zvcm1BID0gaW5wdXQudHJhbnNmb3JtQTtcbiAgICAgIHZhciB0cmFuc2Zvcm1CID0gaW5wdXQudHJhbnNmb3JtQjtcbiAgICAgIHZhciBzaW1wbGV4ID0gYjJEaXN0YW5jZS5zX3NpbXBsZXg7XG4gICAgICBzaW1wbGV4LlJlYWRDYWNoZShjYWNoZSwgcHJveHlBLCB0cmFuc2Zvcm1BLCBwcm94eUIsIHRyYW5zZm9ybUIpO1xuICAgICAgdmFyIHZlcnRpY2VzID0gc2ltcGxleC5tX3ZlcnRpY2VzO1xuICAgICAgdmFyIGtfbWF4SXRlcnMgPSAyMDtcbiAgICAgIHZhciBzYXZlQSA9IGIyRGlzdGFuY2Uuc19zYXZlQTtcbiAgICAgIHZhciBzYXZlQiA9IGIyRGlzdGFuY2Uuc19zYXZlQjtcbiAgICAgIHZhciBzYXZlQ291bnQgPSAwO1xuICAgICAgdmFyIGNsb3Nlc3RQb2ludCA9IHNpbXBsZXguR2V0Q2xvc2VzdFBvaW50KCk7XG4gICAgICB2YXIgZGlzdGFuY2VTcXIxID0gY2xvc2VzdFBvaW50Lkxlbmd0aFNxdWFyZWQoKTtcbiAgICAgIHZhciBkaXN0YW5jZVNxcjIgPSBkaXN0YW5jZVNxcjE7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcDtcbiAgICAgIHZhciBpdGVyID0gMDtcbiAgICAgIHdoaWxlIChpdGVyIDwga19tYXhJdGVycykge1xuICAgICAgICAgc2F2ZUNvdW50ID0gc2ltcGxleC5tX2NvdW50O1xuICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgIGkgPCBzYXZlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgc2F2ZUFbaV0gPSB2ZXJ0aWNlc1tpXS5pbmRleEE7XG4gICAgICAgICAgICBzYXZlQltpXSA9IHZlcnRpY2VzW2ldLmluZGV4QjtcbiAgICAgICAgIH1cbiAgICAgICAgIHN3aXRjaCAoc2ltcGxleC5tX2NvdW50KSB7XG4gICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHNpbXBsZXguU29sdmUyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHNpbXBsZXguU29sdmUzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChzaW1wbGV4Lm1fY291bnQgPT0gMykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICAgICBwID0gc2ltcGxleC5HZXRDbG9zZXN0UG9pbnQoKTtcbiAgICAgICAgIGRpc3RhbmNlU3FyMiA9IHAuTGVuZ3RoU3F1YXJlZCgpO1xuICAgICAgICAgaWYgKGRpc3RhbmNlU3FyMiA+IGRpc3RhbmNlU3FyMSkge31cbiAgICAgICAgIGRpc3RhbmNlU3FyMSA9IGRpc3RhbmNlU3FyMjtcbiAgICAgICAgIHZhciBkID0gc2ltcGxleC5HZXRTZWFyY2hEaXJlY3Rpb24oKTtcbiAgICAgICAgIGlmIChkLkxlbmd0aFNxdWFyZWQoKSA8IE51bWJlci5NSU5fVkFMVUUgKiBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1tzaW1wbGV4Lm1fY291bnRdO1xuICAgICAgICAgdmVydGV4LmluZGV4QSA9IHByb3h5QS5HZXRTdXBwb3J0KGIyTWF0aC5NdWxUTVYodHJhbnNmb3JtQS5SLCBkLkdldE5lZ2F0aXZlKCkpKTtcbiAgICAgICAgIHZlcnRleC53QSA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUEsIHByb3h5QS5HZXRWZXJ0ZXgodmVydGV4LmluZGV4QSkpO1xuICAgICAgICAgdmVydGV4LmluZGV4QiA9IHByb3h5Qi5HZXRTdXBwb3J0KGIyTWF0aC5NdWxUTVYodHJhbnNmb3JtQi5SLCBkKSk7XG4gICAgICAgICB2ZXJ0ZXgud0IgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCBwcm94eUIuR2V0VmVydGV4KHZlcnRleC5pbmRleEIpKTtcbiAgICAgICAgIHZlcnRleC53ID0gYjJNYXRoLlN1YnRyYWN0VlYodmVydGV4LndCLCB2ZXJ0ZXgud0EpO1xuICAgICAgICAgKytpdGVyO1xuICAgICAgICAgKytiMkRpc3RhbmNlLmIyX2dqa0l0ZXJzO1xuICAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgIGkgPCBzYXZlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZlcnRleC5pbmRleEEgPT0gc2F2ZUFbaV0gJiYgdmVydGV4LmluZGV4QiA9PSBzYXZlQltpXSkge1xuICAgICAgICAgICAgICAgZHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9KytzaW1wbGV4Lm1fY291bnQ7XG4gICAgICB9XG4gICAgICBiMkRpc3RhbmNlLmIyX2dqa01heEl0ZXJzID0gYjJNYXRoLk1heChiMkRpc3RhbmNlLmIyX2dqa01heEl0ZXJzLCBpdGVyKTtcbiAgICAgIHNpbXBsZXguR2V0V2l0bmVzc1BvaW50cyhvdXRwdXQucG9pbnRBLCBvdXRwdXQucG9pbnRCKTtcbiAgICAgIG91dHB1dC5kaXN0YW5jZSA9IGIyTWF0aC5TdWJ0cmFjdFZWKG91dHB1dC5wb2ludEEsIG91dHB1dC5wb2ludEIpLkxlbmd0aCgpO1xuICAgICAgb3V0cHV0Lml0ZXJhdGlvbnMgPSBpdGVyO1xuICAgICAgc2ltcGxleC5Xcml0ZUNhY2hlKGNhY2hlKTtcbiAgICAgIGlmIChpbnB1dC51c2VSYWRpaSkge1xuICAgICAgICAgdmFyIHJBID0gcHJveHlBLm1fcmFkaXVzO1xuICAgICAgICAgdmFyIHJCID0gcHJveHlCLm1fcmFkaXVzO1xuICAgICAgICAgaWYgKG91dHB1dC5kaXN0YW5jZSA+IHJBICsgckIgJiYgb3V0cHV0LmRpc3RhbmNlID4gTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgICAgb3V0cHV0LmRpc3RhbmNlIC09IHJBICsgckI7XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gYjJNYXRoLlN1YnRyYWN0VlYob3V0cHV0LnBvaW50Qiwgb3V0cHV0LnBvaW50QSk7XG4gICAgICAgICAgICBub3JtYWwuTm9ybWFsaXplKCk7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnRBLnggKz0gckEgKiBub3JtYWwueDtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludEEueSArPSByQSAqIG5vcm1hbC55O1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50Qi54IC09IHJCICogbm9ybWFsLng7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnRCLnkgLT0gckIgKiBub3JtYWwueTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgICAgICAgIHAueCA9IC41ICogKG91dHB1dC5wb2ludEEueCArIG91dHB1dC5wb2ludEIueCk7XG4gICAgICAgICAgICBwLnkgPSAuNSAqIChvdXRwdXQucG9pbnRBLnkgKyBvdXRwdXQucG9pbnRCLnkpO1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50QS54ID0gb3V0cHV0LnBvaW50Qi54ID0gcC54O1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50QS55ID0gb3V0cHV0LnBvaW50Qi55ID0gcC55O1xuICAgICAgICAgICAgb3V0cHV0LmRpc3RhbmNlID0gMC4wO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZS5zX3NpbXBsZXggPSBuZXcgYjJTaW1wbGV4KCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZS5zX3NhdmVBID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKDMpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2Uuc19zYXZlQiA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigzKTtcbiAgIH0pO1xuICAgYjJEaXN0YW5jZUlucHV0LmIyRGlzdGFuY2VJbnB1dCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJEaXN0YW5jZU91dHB1dC5iMkRpc3RhbmNlT3V0cHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb2ludEEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLnBvaW50QiA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkRpc3RhbmNlUHJveHkuYjJEaXN0YW5jZVByb3h5ID0gZnVuY3Rpb24gKCkge307XG4gICBiMkRpc3RhbmNlUHJveHkucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgc3dpdGNoIChzaGFwZS5HZXRUeXBlKCkpIHtcbiAgICAgIGNhc2UgYjJTaGFwZS5lX2NpcmNsZVNoYXBlOlxuICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNpcmNsZSA9IChzaGFwZSBpbnN0YW5jZW9mIGIyQ2lyY2xlU2hhcGUgPyBzaGFwZSA6IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzID0gbmV3IFZlY3RvcigxLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1swXSA9IGNpcmNsZS5tX3A7XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSAxO1xuICAgICAgICAgICAgdGhpcy5tX3JhZGl1cyA9IGNpcmNsZS5tX3JhZGl1cztcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMlNoYXBlLmVfcG9seWdvblNoYXBlOlxuICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBvbHlnb24gPSAoc2hhcGUgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IHNoYXBlIDogbnVsbCk7XG4gICAgICAgICAgICB0aGlzLm1fdmVydGljZXMgPSBwb2x5Z29uLm1fdmVydGljZXM7XG4gICAgICAgICAgICB0aGlzLm1fY291bnQgPSBwb2x5Z29uLm1fdmVydGV4Q291bnQ7XG4gICAgICAgICAgICB0aGlzLm1fcmFkaXVzID0gcG9seWdvbi5tX3JhZGl1cztcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xuICAgICAgfVxuICAgfVxuICAgYjJEaXN0YW5jZVByb3h5LnByb3RvdHlwZS5HZXRTdXBwb3J0ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBiZXN0SW5kZXggPSAwO1xuICAgICAgdmFyIGJlc3RWYWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1swXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzWzBdLnkgKiBkLnk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1fdmVydGljZXNbaV0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1tpXS55ICogZC55O1xuICAgICAgICAgaWYgKHZhbHVlID4gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmVzdEluZGV4O1xuICAgfVxuICAgYjJEaXN0YW5jZVByb3h5LnByb3RvdHlwZS5HZXRTdXBwb3J0VmVydGV4ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBiZXN0SW5kZXggPSAwO1xuICAgICAgdmFyIGJlc3RWYWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1swXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzWzBdLnkgKiBkLnk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1fdmVydGljZXNbaV0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1tpXS55ICogZC55O1xuICAgICAgICAgaWYgKHZhbHVlID4gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tX3ZlcnRpY2VzW2Jlc3RJbmRleF07XG4gICB9XG4gICBiMkRpc3RhbmNlUHJveHkucHJvdG90eXBlLkdldFZlcnRleENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9jb3VudDtcbiAgIH1cbiAgIGIyRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuR2V0VmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgaW5kZXggPSAwO1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydCgwIDw9IGluZGV4ICYmIGluZGV4IDwgdGhpcy5tX2NvdW50KTtcbiAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbaW5kZXhdO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZS5iMkR5bmFtaWNUcmVlID0gZnVuY3Rpb24gKCkge307XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5iMkR5bmFtaWNUcmVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX3Jvb3QgPSBudWxsO1xuICAgICAgdGhpcy5tX2ZyZWVMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9wYXRoID0gMDtcbiAgICAgIHRoaXMubV9pbnNlcnRpb25Db3VudCA9IDA7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5DcmVhdGVQcm94eSA9IGZ1bmN0aW9uIChhYWJiLCB1c2VyRGF0YSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLkFsbG9jYXRlTm9kZSgpO1xuICAgICAgdmFyIGV4dGVuZFggPSBiMlNldHRpbmdzLmIyX2FhYmJFeHRlbnNpb247XG4gICAgICB2YXIgZXh0ZW5kWSA9IGIyU2V0dGluZ3MuYjJfYWFiYkV4dGVuc2lvbjtcbiAgICAgIG5vZGUuYWFiYi5sb3dlckJvdW5kLnggPSBhYWJiLmxvd2VyQm91bmQueCAtIGV4dGVuZFg7XG4gICAgICBub2RlLmFhYmIubG93ZXJCb3VuZC55ID0gYWFiYi5sb3dlckJvdW5kLnkgLSBleHRlbmRZO1xuICAgICAgbm9kZS5hYWJiLnVwcGVyQm91bmQueCA9IGFhYmIudXBwZXJCb3VuZC54ICsgZXh0ZW5kWDtcbiAgICAgIG5vZGUuYWFiYi51cHBlckJvdW5kLnkgPSBhYWJiLnVwcGVyQm91bmQueSArIGV4dGVuZFk7XG4gICAgICBub2RlLnVzZXJEYXRhID0gdXNlckRhdGE7XG4gICAgICB0aGlzLkluc2VydExlYWYobm9kZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLkRlc3Ryb3lQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgICAgdGhpcy5SZW1vdmVMZWFmKHByb3h5KTtcbiAgICAgIHRoaXMuRnJlZU5vZGUocHJveHkpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuTW92ZVByb3h5ID0gZnVuY3Rpb24gKHByb3h5LCBhYWJiLCBkaXNwbGFjZW1lbnQpIHtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQocHJveHkuSXNMZWFmKCkpO1xuICAgICAgaWYgKHByb3h5LmFhYmIuQ29udGFpbnMoYWFiYikpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuUmVtb3ZlTGVhZihwcm94eSk7XG4gICAgICB2YXIgZXh0ZW5kWCA9IGIyU2V0dGluZ3MuYjJfYWFiYkV4dGVuc2lvbiArIGIyU2V0dGluZ3MuYjJfYWFiYk11bHRpcGxpZXIgKiAoZGlzcGxhY2VtZW50LnggPiAwID8gZGlzcGxhY2VtZW50LnggOiAoLWRpc3BsYWNlbWVudC54KSk7XG4gICAgICB2YXIgZXh0ZW5kWSA9IGIyU2V0dGluZ3MuYjJfYWFiYkV4dGVuc2lvbiArIGIyU2V0dGluZ3MuYjJfYWFiYk11bHRpcGxpZXIgKiAoZGlzcGxhY2VtZW50LnkgPiAwID8gZGlzcGxhY2VtZW50LnkgOiAoLWRpc3BsYWNlbWVudC55KSk7XG4gICAgICBwcm94eS5hYWJiLmxvd2VyQm91bmQueCA9IGFhYmIubG93ZXJCb3VuZC54IC0gZXh0ZW5kWDtcbiAgICAgIHByb3h5LmFhYmIubG93ZXJCb3VuZC55ID0gYWFiYi5sb3dlckJvdW5kLnkgLSBleHRlbmRZO1xuICAgICAgcHJveHkuYWFiYi51cHBlckJvdW5kLnggPSBhYWJiLnVwcGVyQm91bmQueCArIGV4dGVuZFg7XG4gICAgICBwcm94eS5hYWJiLnVwcGVyQm91bmQueSA9IGFhYmIudXBwZXJCb3VuZC55ICsgZXh0ZW5kWTtcbiAgICAgIHRoaXMuSW5zZXJ0TGVhZihwcm94eSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLlJlYmFsYW5jZSA9IGZ1bmN0aW9uIChpdGVyYXRpb25zKSB7XG4gICAgICBpZiAoaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkKSBpdGVyYXRpb25zID0gMDtcbiAgICAgIGlmICh0aGlzLm1fcm9vdCA9PSBudWxsKSByZXR1cm47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fcm9vdDtcbiAgICAgICAgIHZhciBiaXQgPSAwO1xuICAgICAgICAgd2hpbGUgKG5vZGUuSXNMZWFmKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUgPSAodGhpcy5tX3BhdGggPj4gYml0KSAmIDEgPyBub2RlLmNoaWxkMiA6IG5vZGUuY2hpbGQxO1xuICAgICAgICAgICAgYml0ID0gKGJpdCArIDEpICYgMzE7XG4gICAgICAgICB9Kyt0aGlzLm1fcGF0aDtcbiAgICAgICAgIHRoaXMuUmVtb3ZlTGVhZihub2RlKTtcbiAgICAgICAgIHRoaXMuSW5zZXJ0TGVhZihub2RlKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLkdldEZhdEFBQkIgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHJldHVybiBwcm94eS5hYWJiO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuR2V0VXNlckRhdGEgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHJldHVybiBwcm94eS51c2VyRGF0YTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLlF1ZXJ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhYWJiKSB7XG4gICAgICBpZiAodGhpcy5tX3Jvb3QgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFZlY3RvcigpO1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHN0YWNrW2NvdW50KytdID0gdGhpcy5tX3Jvb3Q7XG4gICAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgICB2YXIgbm9kZSA9IHN0YWNrWy0tY291bnRdO1xuICAgICAgICAgaWYgKG5vZGUuYWFiYi5UZXN0T3ZlcmxhcChhYWJiKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuSXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgIHZhciBwcm9jZWVkID0gY2FsbGJhY2sobm9kZSk7XG4gICAgICAgICAgICAgICBpZiAoIXByb2NlZWQpIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgc3RhY2tbY291bnQrK10gPSBub2RlLmNoaWxkMTtcbiAgICAgICAgICAgICAgIHN0YWNrW2NvdW50KytdID0gbm9kZS5jaGlsZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5SYXlDYXN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpbnB1dCkge1xuICAgICAgaWYgKHRoaXMubV9yb290ID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBwMSA9IGlucHV0LnAxO1xuICAgICAgdmFyIHAyID0gaW5wdXQucDI7XG4gICAgICB2YXIgciA9IGIyTWF0aC5TdWJ0cmFjdFZWKHAxLCBwMik7XG4gICAgICByLk5vcm1hbGl6ZSgpO1xuICAgICAgdmFyIHYgPSBiMk1hdGguQ3Jvc3NGVigxLjAsIHIpO1xuICAgICAgdmFyIGFic192ID0gYjJNYXRoLkFic1Yodik7XG4gICAgICB2YXIgbWF4RnJhY3Rpb24gPSBpbnB1dC5tYXhGcmFjdGlvbjtcbiAgICAgIHZhciBzZWdtZW50QUFCQiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgdFkgPSAwOyB7XG4gICAgICAgICB0WCA9IHAxLnggKyBtYXhGcmFjdGlvbiAqIChwMi54IC0gcDEueCk7XG4gICAgICAgICB0WSA9IHAxLnkgKyBtYXhGcmFjdGlvbiAqIChwMi55IC0gcDEueSk7XG4gICAgICAgICBzZWdtZW50QUFCQi5sb3dlckJvdW5kLnggPSBNYXRoLm1pbihwMS54LCB0WCk7XG4gICAgICAgICBzZWdtZW50QUFCQi5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbihwMS55LCB0WSk7XG4gICAgICAgICBzZWdtZW50QUFCQi51cHBlckJvdW5kLnggPSBNYXRoLm1heChwMS54LCB0WCk7XG4gICAgICAgICBzZWdtZW50QUFCQi51cHBlckJvdW5kLnkgPSBNYXRoLm1heChwMS55LCB0WSk7XG4gICAgICB9XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgVmVjdG9yKCk7XG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgc3RhY2tbY291bnQrK10gPSB0aGlzLm1fcm9vdDtcbiAgICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgIHZhciBub2RlID0gc3RhY2tbLS1jb3VudF07XG4gICAgICAgICBpZiAobm9kZS5hYWJiLlRlc3RPdmVybGFwKHNlZ21lbnRBQUJCKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICB9XG4gICAgICAgICB2YXIgYyA9IG5vZGUuYWFiYi5HZXRDZW50ZXIoKTtcbiAgICAgICAgIHZhciBoID0gbm9kZS5hYWJiLkdldEV4dGVudHMoKTtcbiAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gTWF0aC5hYnModi54ICogKHAxLnggLSBjLngpICsgdi55ICogKHAxLnkgLSBjLnkpKSAtIGFic192LnggKiBoLnggLSBhYnNfdi55ICogaC55O1xuICAgICAgICAgaWYgKHNlcGFyYXRpb24gPiAwLjApIGNvbnRpbnVlO1xuICAgICAgICAgaWYgKG5vZGUuSXNMZWFmKCkpIHtcbiAgICAgICAgICAgIHZhciBzdWJJbnB1dCA9IG5ldyBiMlJheUNhc3RJbnB1dCgpO1xuICAgICAgICAgICAgc3ViSW5wdXQucDEgPSBpbnB1dC5wMTtcbiAgICAgICAgICAgIHN1YklucHV0LnAyID0gaW5wdXQucDI7XG4gICAgICAgICAgICBzdWJJbnB1dC5tYXhGcmFjdGlvbiA9IGlucHV0Lm1heEZyYWN0aW9uO1xuICAgICAgICAgICAgbWF4RnJhY3Rpb24gPSBjYWxsYmFjayhzdWJJbnB1dCwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobWF4RnJhY3Rpb24gPT0gMC4wKSByZXR1cm47XG4gICAgICAgICAgICBpZiAobWF4RnJhY3Rpb24gPiAwLjApIHtcbiAgICAgICAgICAgICAgIHRYID0gcDEueCArIG1heEZyYWN0aW9uICogKHAyLnggLSBwMS54KTtcbiAgICAgICAgICAgICAgIHRZID0gcDEueSArIG1heEZyYWN0aW9uICogKHAyLnkgLSBwMS55KTtcbiAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLmxvd2VyQm91bmQueCA9IE1hdGgubWluKHAxLngsIHRYKTtcbiAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLmxvd2VyQm91bmQueSA9IE1hdGgubWluKHAxLnksIHRZKTtcbiAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLnVwcGVyQm91bmQueCA9IE1hdGgubWF4KHAxLngsIHRYKTtcbiAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLnVwcGVyQm91bmQueSA9IE1hdGgubWF4KHAxLnksIHRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhY2tbY291bnQrK10gPSBub2RlLmNoaWxkMTtcbiAgICAgICAgICAgIHN0YWNrW2NvdW50KytdID0gbm9kZS5jaGlsZDI7XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5BbGxvY2F0ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5tX2ZyZWVMaXN0KSB7XG4gICAgICAgICB2YXIgbm9kZSA9IHRoaXMubV9mcmVlTGlzdDtcbiAgICAgICAgIHRoaXMubV9mcmVlTGlzdCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgbm9kZS5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgbm9kZS5jaGlsZDEgPSBudWxsO1xuICAgICAgICAgbm9kZS5jaGlsZDIgPSBudWxsO1xuICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGIyRHluYW1pY1RyZWVOb2RlKCk7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5GcmVlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlLnBhcmVudCA9IHRoaXMubV9mcmVlTGlzdDtcbiAgICAgIHRoaXMubV9mcmVlTGlzdCA9IG5vZGU7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5JbnNlcnRMZWFmID0gZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICsrdGhpcy5tX2luc2VydGlvbkNvdW50O1xuICAgICAgaWYgKHRoaXMubV9yb290ID09IG51bGwpIHtcbiAgICAgICAgIHRoaXMubV9yb290ID0gbGVhZjtcbiAgICAgICAgIHRoaXMubV9yb290LnBhcmVudCA9IG51bGw7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY2VudGVyID0gbGVhZi5hYWJiLkdldENlbnRlcigpO1xuICAgICAgdmFyIHNpYmxpbmcgPSB0aGlzLm1fcm9vdDtcbiAgICAgIGlmIChzaWJsaW5nLklzTGVhZigpID09IGZhbHNlKSB7XG4gICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgY2hpbGQxID0gc2libGluZy5jaGlsZDE7XG4gICAgICAgICAgICB2YXIgY2hpbGQyID0gc2libGluZy5jaGlsZDI7XG4gICAgICAgICAgICB2YXIgbm9ybTEgPSBNYXRoLmFicygoY2hpbGQxLmFhYmIubG93ZXJCb3VuZC54ICsgY2hpbGQxLmFhYmIudXBwZXJCb3VuZC54KSAvIDIgLSBjZW50ZXIueCkgKyBNYXRoLmFicygoY2hpbGQxLmFhYmIubG93ZXJCb3VuZC55ICsgY2hpbGQxLmFhYmIudXBwZXJCb3VuZC55KSAvIDIgLSBjZW50ZXIueSk7XG4gICAgICAgICAgICB2YXIgbm9ybTIgPSBNYXRoLmFicygoY2hpbGQyLmFhYmIubG93ZXJCb3VuZC54ICsgY2hpbGQyLmFhYmIudXBwZXJCb3VuZC54KSAvIDIgLSBjZW50ZXIueCkgKyBNYXRoLmFicygoY2hpbGQyLmFhYmIubG93ZXJCb3VuZC55ICsgY2hpbGQyLmFhYmIudXBwZXJCb3VuZC55KSAvIDIgLSBjZW50ZXIueSk7XG4gICAgICAgICAgICBpZiAobm9ybTEgPCBub3JtMikge1xuICAgICAgICAgICAgICAgc2libGluZyA9IGNoaWxkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgc2libGluZyA9IGNoaWxkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIHdoaWxlIChzaWJsaW5nLklzTGVhZigpID09IGZhbHNlKVxuICAgICAgfVxuICAgICAgdmFyIG5vZGUxID0gc2libGluZy5wYXJlbnQ7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLkFsbG9jYXRlTm9kZSgpO1xuICAgICAgbm9kZTIucGFyZW50ID0gbm9kZTE7XG4gICAgICBub2RlMi51c2VyRGF0YSA9IG51bGw7XG4gICAgICBub2RlMi5hYWJiLkNvbWJpbmUobGVhZi5hYWJiLCBzaWJsaW5nLmFhYmIpO1xuICAgICAgaWYgKG5vZGUxKSB7XG4gICAgICAgICBpZiAoc2libGluZy5wYXJlbnQuY2hpbGQxID09IHNpYmxpbmcpIHtcbiAgICAgICAgICAgIG5vZGUxLmNoaWxkMSA9IG5vZGUyO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlMS5jaGlsZDIgPSBub2RlMjtcbiAgICAgICAgIH1cbiAgICAgICAgIG5vZGUyLmNoaWxkMSA9IHNpYmxpbmc7XG4gICAgICAgICBub2RlMi5jaGlsZDIgPSBsZWFmO1xuICAgICAgICAgc2libGluZy5wYXJlbnQgPSBub2RlMjtcbiAgICAgICAgIGxlYWYucGFyZW50ID0gbm9kZTI7XG4gICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAobm9kZTEuYWFiYi5Db250YWlucyhub2RlMi5hYWJiKSkgYnJlYWs7XG4gICAgICAgICAgICBub2RlMS5hYWJiLkNvbWJpbmUobm9kZTEuY2hpbGQxLmFhYmIsIG5vZGUxLmNoaWxkMi5hYWJiKTtcbiAgICAgICAgICAgIG5vZGUyID0gbm9kZTE7XG4gICAgICAgICAgICBub2RlMSA9IG5vZGUxLnBhcmVudDtcbiAgICAgICAgIH1cbiAgICAgICAgIHdoaWxlIChub2RlMSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgbm9kZTIuY2hpbGQxID0gc2libGluZztcbiAgICAgICAgIG5vZGUyLmNoaWxkMiA9IGxlYWY7XG4gICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG5vZGUyO1xuICAgICAgICAgbGVhZi5wYXJlbnQgPSBub2RlMjtcbiAgICAgICAgIHRoaXMubV9yb290ID0gbm9kZTI7XG4gICAgICB9XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5SZW1vdmVMZWFmID0gZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgIGlmIChsZWFmID09IHRoaXMubV9yb290KSB7XG4gICAgICAgICB0aGlzLm1fcm9vdCA9IG51bGw7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbm9kZTIgPSBsZWFmLnBhcmVudDtcbiAgICAgIHZhciBub2RlMSA9IG5vZGUyLnBhcmVudDtcbiAgICAgIHZhciBzaWJsaW5nO1xuICAgICAgaWYgKG5vZGUyLmNoaWxkMSA9PSBsZWFmKSB7XG4gICAgICAgICBzaWJsaW5nID0gbm9kZTIuY2hpbGQyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBzaWJsaW5nID0gbm9kZTIuY2hpbGQxO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUxKSB7XG4gICAgICAgICBpZiAobm9kZTEuY2hpbGQxID09IG5vZGUyKSB7XG4gICAgICAgICAgICBub2RlMS5jaGlsZDEgPSBzaWJsaW5nO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlMS5jaGlsZDIgPSBzaWJsaW5nO1xuICAgICAgICAgfVxuICAgICAgICAgc2libGluZy5wYXJlbnQgPSBub2RlMTtcbiAgICAgICAgIHRoaXMuRnJlZU5vZGUobm9kZTIpO1xuICAgICAgICAgd2hpbGUgKG5vZGUxKSB7XG4gICAgICAgICAgICB2YXIgb2xkQUFCQiA9IG5vZGUxLmFhYmI7XG4gICAgICAgICAgICBub2RlMS5hYWJiID0gYjJBQUJCLkNvbWJpbmUobm9kZTEuY2hpbGQxLmFhYmIsIG5vZGUxLmNoaWxkMi5hYWJiKTtcbiAgICAgICAgICAgIGlmIChvbGRBQUJCLkNvbnRhaW5zKG5vZGUxLmFhYmIpKSBicmVhaztcbiAgICAgICAgICAgIG5vZGUxID0gbm9kZTEucGFyZW50O1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fcm9vdCA9IHNpYmxpbmc7XG4gICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG51bGw7XG4gICAgICAgICB0aGlzLkZyZWVOb2RlKG5vZGUyKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLmIyRHluYW1pY1RyZWVCcm9hZFBoYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX3RyZWUgPSBuZXcgYjJEeW5hbWljVHJlZSgpO1xuICAgICAgdGhpcy5tX21vdmVCdWZmZXIgPSBuZXcgVmVjdG9yKCk7XG4gICAgICB0aGlzLm1fcGFpckJ1ZmZlciA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHRoaXMubV9wYWlyQ291bnQgPSAwO1xuICAgfTtcbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5DcmVhdGVQcm94eSA9IGZ1bmN0aW9uIChhYWJiLCB1c2VyRGF0YSkge1xuICAgICAgdmFyIHByb3h5ID0gdGhpcy5tX3RyZWUuQ3JlYXRlUHJveHkoYWFiYiwgdXNlckRhdGEpO1xuICAgICAgKyt0aGlzLm1fcHJveHlDb3VudDtcbiAgICAgIHRoaXMuQnVmZmVyTW92ZShwcm94eSk7XG4gICAgICByZXR1cm4gcHJveHk7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuRGVzdHJveVByb3h5ID0gZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgICB0aGlzLlVuQnVmZmVyTW92ZShwcm94eSk7XG4gICAgICAtLXRoaXMubV9wcm94eUNvdW50O1xuICAgICAgdGhpcy5tX3RyZWUuRGVzdHJveVByb3h5KHByb3h5KTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5Nb3ZlUHJveHkgPSBmdW5jdGlvbiAocHJveHksIGFhYmIsIGRpc3BsYWNlbWVudCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMubV90cmVlLk1vdmVQcm94eShwcm94eSwgYWFiYiwgZGlzcGxhY2VtZW50KTtcbiAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgIHRoaXMuQnVmZmVyTW92ZShwcm94eSk7XG4gICAgICB9XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuVGVzdE92ZXJsYXAgPSBmdW5jdGlvbiAocHJveHlBLCBwcm94eUIpIHtcbiAgICAgIHZhciBhYWJiQSA9IHRoaXMubV90cmVlLkdldEZhdEFBQkIocHJveHlBKTtcbiAgICAgIHZhciBhYWJiQiA9IHRoaXMubV90cmVlLkdldEZhdEFBQkIocHJveHlCKTtcbiAgICAgIHJldHVybiBhYWJiQS5UZXN0T3ZlcmxhcChhYWJiQik7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuR2V0VXNlckRhdGEgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdHJlZS5HZXRVc2VyRGF0YShwcm94eSk7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuR2V0RmF0QUFCQiA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgICAgcmV0dXJuIHRoaXMubV90cmVlLkdldEZhdEFBQkIocHJveHkpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkdldFByb3h5Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3Byb3h5Q291bnQ7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuVXBkYXRlUGFpcnMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgX190aGlzLm1fcGFpckNvdW50ID0gMDtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgIHF1ZXJ5UHJveHk7XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IF9fdGhpcy5tX21vdmVCdWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgIHF1ZXJ5UHJveHkgPSBfX3RoaXMubV9tb3ZlQnVmZmVyW2ldO1xuXG4gICAgICAgICBmdW5jdGlvbiBRdWVyeUNhbGxiYWNrKHByb3h5KSB7XG4gICAgICAgICAgICBpZiAocHJveHkgPT0gcXVlcnlQcm94eSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoX190aGlzLm1fcGFpckNvdW50ID09IF9fdGhpcy5tX3BhaXJCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICBfX3RoaXMubV9wYWlyQnVmZmVyW19fdGhpcy5tX3BhaXJDb3VudF0gPSBuZXcgYjJEeW5hbWljVHJlZVBhaXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYWlyID0gX190aGlzLm1fcGFpckJ1ZmZlcltfX3RoaXMubV9wYWlyQ291bnRdO1xuICAgICAgICAgICAgcGFpci5wcm94eUEgPSBwcm94eSA8IHF1ZXJ5UHJveHkgPyBwcm94eSA6IHF1ZXJ5UHJveHk7XG4gICAgICAgICAgICBwYWlyLnByb3h5QiA9IHByb3h5ID49IHF1ZXJ5UHJveHkgPyBwcm94eSA6IHF1ZXJ5UHJveHk7KytfX3RoaXMubV9wYWlyQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIH07XG4gICAgICAgICB2YXIgZmF0QUFCQiA9IF9fdGhpcy5tX3RyZWUuR2V0RmF0QUFCQihxdWVyeVByb3h5KTtcbiAgICAgICAgIF9fdGhpcy5tX3RyZWUuUXVlcnkoUXVlcnlDYWxsYmFjaywgZmF0QUFCQik7XG4gICAgICB9XG4gICAgICBfX3RoaXMubV9tb3ZlQnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9fdGhpcy5tX3BhaXJDb3VudDspIHtcbiAgICAgICAgIHZhciBwcmltYXJ5UGFpciA9IF9fdGhpcy5tX3BhaXJCdWZmZXJbaV07XG4gICAgICAgICB2YXIgdXNlckRhdGFBID0gX190aGlzLm1fdHJlZS5HZXRVc2VyRGF0YShwcmltYXJ5UGFpci5wcm94eUEpO1xuICAgICAgICAgdmFyIHVzZXJEYXRhQiA9IF9fdGhpcy5tX3RyZWUuR2V0VXNlckRhdGEocHJpbWFyeVBhaXIucHJveHlCKTtcbiAgICAgICAgIGNhbGxiYWNrKHVzZXJEYXRhQSwgdXNlckRhdGFCKTtcbiAgICAgICAgICsraTtcbiAgICAgICAgIHdoaWxlIChpIDwgX190aGlzLm1fcGFpckNvdW50KSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IF9fdGhpcy5tX3BhaXJCdWZmZXJbaV07XG4gICAgICAgICAgICBpZiAocGFpci5wcm94eUEgIT0gcHJpbWFyeVBhaXIucHJveHlBIHx8IHBhaXIucHJveHlCICE9IHByaW1hcnlQYWlyLnByb3h5Qikge1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9KytpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLlF1ZXJ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhYWJiKSB7XG4gICAgICB0aGlzLm1fdHJlZS5RdWVyeShjYWxsYmFjaywgYWFiYik7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuUmF5Q2FzdCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgaW5wdXQpIHtcbiAgICAgIHRoaXMubV90cmVlLlJheUNhc3QoY2FsbGJhY2ssIGlucHV0KTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5WYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHt9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuUmViYWxhbmNlID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMpIHtcbiAgICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdGhpcy5tX3RyZWUuUmViYWxhbmNlKGl0ZXJhdGlvbnMpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkJ1ZmZlck1vdmUgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHRoaXMubV9tb3ZlQnVmZmVyW3RoaXMubV9tb3ZlQnVmZmVyLmxlbmd0aF0gPSBwcm94eTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5VbkJ1ZmZlck1vdmUgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHZhciBpID0gcGFyc2VJbnQodGhpcy5tX21vdmVCdWZmZXIuaW5kZXhPZihwcm94eSkpO1xuICAgICAgdGhpcy5tX21vdmVCdWZmZXIuc3BsaWNlKGksIDEpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkNvbXBhcmVQYWlycyA9IGZ1bmN0aW9uIChwYWlyMSwgcGFpcjIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UuX19pbXBsZW1lbnRzID0ge307XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5fX2ltcGxlbWVudHNbSUJyb2FkUGhhc2VdID0gdHJ1ZTtcbiAgIGIyRHluYW1pY1RyZWVOb2RlLmIyRHluYW1pY1RyZWVOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5hYWJiID0gbmV3IGIyQUFCQigpO1xuICAgfTtcbiAgIGIyRHluYW1pY1RyZWVOb2RlLnByb3RvdHlwZS5Jc0xlYWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZDEgPT0gbnVsbDtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVQYWlyLmIyRHluYW1pY1RyZWVQYWlyID0gZnVuY3Rpb24gKCkge307XG4gICBiMk1hbmlmb2xkLmIyTWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fcG9pbnRDb3VudCA9IDA7XG4gICB9O1xuICAgYjJNYW5pZm9sZC5wcm90b3R5cGUuYjJNYW5pZm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9wb2ludHMgPSBuZXcgVmVjdG9yKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzOyBpKyspIHtcbiAgICAgICAgIHRoaXMubV9wb2ludHNbaV0gPSBuZXcgYjJNYW5pZm9sZFBvaW50KCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fbG9jYWxQbGFuZU5vcm1hbCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgfVxuICAgYjJNYW5pZm9sZC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xuICAgICAgICAgKCh0aGlzLm1fcG9pbnRzW2ldIGluc3RhbmNlb2YgYjJNYW5pZm9sZFBvaW50ID8gdGhpcy5tX3BvaW50c1tpXSA6IG51bGwpKS5SZXNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2xvY2FsUGxhbmVOb3JtYWwuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX2xvY2FsUG9pbnQuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX3R5cGUgPSAwO1xuICAgICAgdGhpcy5tX3BvaW50Q291bnQgPSAwO1xuICAgfVxuICAgYjJNYW5pZm9sZC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgIHRoaXMubV9wb2ludENvdW50ID0gbS5tX3BvaW50Q291bnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xuICAgICAgICAgKCh0aGlzLm1fcG9pbnRzW2ldIGluc3RhbmNlb2YgYjJNYW5pZm9sZFBvaW50ID8gdGhpcy5tX3BvaW50c1tpXSA6IG51bGwpKS5TZXQobS5tX3BvaW50c1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fbG9jYWxQbGFuZU5vcm1hbC5TZXRWKG0ubV9sb2NhbFBsYW5lTm9ybWFsKTtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50LlNldFYobS5tX2xvY2FsUG9pbnQpO1xuICAgICAgdGhpcy5tX3R5cGUgPSBtLm1fdHlwZTtcbiAgIH1cbiAgIGIyTWFuaWZvbGQucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29weSA9IG5ldyBiMk1hbmlmb2xkKCk7XG4gICAgICBjb3B5LlNldCh0aGlzKTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZC5lX2NpcmNsZXMgPSAweDAwMDE7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZC5lX2ZhY2VBID0gMHgwMDAyO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGQuZV9mYWNlQiA9IDB4MDAwNDtcbiAgIH0pO1xuICAgYjJNYW5pZm9sZFBvaW50LmIyTWFuaWZvbGRQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2lkID0gbmV3IGIyQ29udGFjdElEKCk7XG4gICB9O1xuICAgYjJNYW5pZm9sZFBvaW50LnByb3RvdHlwZS5iMk1hbmlmb2xkUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLlJlc2V0KCk7XG4gICB9XG4gICBiMk1hbmlmb2xkUG9pbnQucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX2xvY2FsUG9pbnQuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX25vcm1hbEltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1fdGFuZ2VudEltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1faWQua2V5ID0gMDtcbiAgIH1cbiAgIGIyTWFuaWZvbGRQb2ludC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50LlNldFYobS5tX2xvY2FsUG9pbnQpO1xuICAgICAgdGhpcy5tX25vcm1hbEltcHVsc2UgPSBtLm1fbm9ybWFsSW1wdWxzZTtcbiAgICAgIHRoaXMubV90YW5nZW50SW1wdWxzZSA9IG0ubV90YW5nZW50SW1wdWxzZTtcbiAgICAgIHRoaXMubV9pZC5TZXQobS5tX2lkKTtcbiAgIH1cbiAgIGIyUG9pbnQuYjJQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucCA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMlBvaW50LnByb3RvdHlwZS5TdXBwb3J0ID0gZnVuY3Rpb24gKHhmLCB2WCwgdlkpIHtcbiAgICAgIGlmICh2WCA9PT0gdW5kZWZpbmVkKSB2WCA9IDA7XG4gICAgICBpZiAodlkgPT09IHVuZGVmaW5lZCkgdlkgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMucDtcbiAgIH1cbiAgIGIyUG9pbnQucHJvdG90eXBlLkdldEZpcnN0VmVydGV4ID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICByZXR1cm4gdGhpcy5wO1xuICAgfVxuICAgYjJSYXlDYXN0SW5wdXQuYjJSYXlDYXN0SW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnAxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5wMiA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMlJheUNhc3RJbnB1dC5wcm90b3R5cGUuYjJSYXlDYXN0SW5wdXQgPSBmdW5jdGlvbiAocDEsIHAyLCBtYXhGcmFjdGlvbikge1xuICAgICAgaWYgKHAxID09PSB1bmRlZmluZWQpIHAxID0gbnVsbDtcbiAgICAgIGlmIChwMiA9PT0gdW5kZWZpbmVkKSBwMiA9IG51bGw7XG4gICAgICBpZiAobWF4RnJhY3Rpb24gPT09IHVuZGVmaW5lZCkgbWF4RnJhY3Rpb24gPSAxO1xuICAgICAgaWYgKHAxKSB0aGlzLnAxLlNldFYocDEpO1xuICAgICAgaWYgKHAyKSB0aGlzLnAyLlNldFYocDIpO1xuICAgICAgdGhpcy5tYXhGcmFjdGlvbiA9IG1heEZyYWN0aW9uO1xuICAgfVxuICAgYjJSYXlDYXN0T3V0cHV0LmIyUmF5Q2FzdE91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyU2VnbWVudC5iMlNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnAxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5wMiA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMlNlZ21lbnQucHJvdG90eXBlLlRlc3RTZWdtZW50ID0gZnVuY3Rpb24gKGxhbWJkYSwgbm9ybWFsLCBzZWdtZW50LCBtYXhMYW1iZGEpIHtcbiAgICAgIGlmIChtYXhMYW1iZGEgPT09IHVuZGVmaW5lZCkgbWF4TGFtYmRhID0gMDtcbiAgICAgIHZhciBzID0gc2VnbWVudC5wMTtcbiAgICAgIHZhciByWCA9IHNlZ21lbnQucDIueCAtIHMueDtcbiAgICAgIHZhciByWSA9IHNlZ21lbnQucDIueSAtIHMueTtcbiAgICAgIHZhciBkWCA9IHRoaXMucDIueCAtIHRoaXMucDEueDtcbiAgICAgIHZhciBkWSA9IHRoaXMucDIueSAtIHRoaXMucDEueTtcbiAgICAgIHZhciBuWCA9IGRZO1xuICAgICAgdmFyIG5ZID0gKC1kWCk7XG4gICAgICB2YXIga19zbG9wID0gMTAwLjAgKiBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgdmFyIGRlbm9tID0gKC0oclggKiBuWCArIHJZICogblkpKTtcbiAgICAgIGlmIChkZW5vbSA+IGtfc2xvcCkge1xuICAgICAgICAgdmFyIGJYID0gcy54IC0gdGhpcy5wMS54O1xuICAgICAgICAgdmFyIGJZID0gcy55IC0gdGhpcy5wMS55O1xuICAgICAgICAgdmFyIGEgPSAoYlggKiBuWCArIGJZICogblkpO1xuICAgICAgICAgaWYgKDAuMCA8PSBhICYmIGEgPD0gbWF4TGFtYmRhICogZGVub20pIHtcbiAgICAgICAgICAgIHZhciBtdTIgPSAoLXJYICogYlkpICsgclkgKiBiWDtcbiAgICAgICAgICAgIGlmICgoLWtfc2xvcCAqIGRlbm9tKSA8PSBtdTIgJiYgbXUyIDw9IGRlbm9tICogKDEuMCArIGtfc2xvcCkpIHtcbiAgICAgICAgICAgICAgIGEgLz0gZGVub207XG4gICAgICAgICAgICAgICB2YXIgbkxlbiA9IE1hdGguc3FydChuWCAqIG5YICsgblkgKiBuWSk7XG4gICAgICAgICAgICAgICBuWCAvPSBuTGVuO1xuICAgICAgICAgICAgICAgblkgLz0gbkxlbjtcbiAgICAgICAgICAgICAgIGxhbWJkYVswXSA9IGE7XG4gICAgICAgICAgICAgICBub3JtYWwuU2V0KG5YLCBuWSk7XG4gICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyU2VnbWVudC5wcm90b3R5cGUuRXh0ZW5kID0gZnVuY3Rpb24gKGFhYmIpIHtcbiAgICAgIHRoaXMuRXh0ZW5kRm9yd2FyZChhYWJiKTtcbiAgICAgIHRoaXMuRXh0ZW5kQmFja3dhcmQoYWFiYik7XG4gICB9XG4gICBiMlNlZ21lbnQucHJvdG90eXBlLkV4dGVuZEZvcndhcmQgPSBmdW5jdGlvbiAoYWFiYikge1xuICAgICAgdmFyIGRYID0gdGhpcy5wMi54IC0gdGhpcy5wMS54O1xuICAgICAgdmFyIGRZID0gdGhpcy5wMi55IC0gdGhpcy5wMS55O1xuICAgICAgdmFyIGxhbWJkYSA9IE1hdGgubWluKGRYID4gMCA/IChhYWJiLnVwcGVyQm91bmQueCAtIHRoaXMucDEueCkgLyBkWCA6IGRYIDwgMCA/IChhYWJiLmxvd2VyQm91bmQueCAtIHRoaXMucDEueCkgLyBkWCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgIGRZID4gMCA/IChhYWJiLnVwcGVyQm91bmQueSAtIHRoaXMucDEueSkgLyBkWSA6IGRZIDwgMCA/IChhYWJiLmxvd2VyQm91bmQueSAtIHRoaXMucDEueSkgLyBkWSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICB0aGlzLnAyLnggPSB0aGlzLnAxLnggKyBkWCAqIGxhbWJkYTtcbiAgICAgIHRoaXMucDIueSA9IHRoaXMucDEueSArIGRZICogbGFtYmRhO1xuICAgfVxuICAgYjJTZWdtZW50LnByb3RvdHlwZS5FeHRlbmRCYWNrd2FyZCA9IGZ1bmN0aW9uIChhYWJiKSB7XG4gICAgICB2YXIgZFggPSAoLXRoaXMucDIueCkgKyB0aGlzLnAxLng7XG4gICAgICB2YXIgZFkgPSAoLXRoaXMucDIueSkgKyB0aGlzLnAxLnk7XG4gICAgICB2YXIgbGFtYmRhID0gTWF0aC5taW4oZFggPiAwID8gKGFhYmIudXBwZXJCb3VuZC54IC0gdGhpcy5wMi54KSAvIGRYIDogZFggPCAwID8gKGFhYmIubG93ZXJCb3VuZC54IC0gdGhpcy5wMi54KSAvIGRYIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgZFkgPiAwID8gKGFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5wMi55KSAvIGRZIDogZFkgPCAwID8gKGFhYmIubG93ZXJCb3VuZC55IC0gdGhpcy5wMi55KSAvIGRZIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgIHRoaXMucDEueCA9IHRoaXMucDIueCArIGRYICogbGFtYmRhO1xuICAgICAgdGhpcy5wMS55ID0gdGhpcy5wMi55ICsgZFkgKiBsYW1iZGE7XG4gICB9XG4gICBiMlNlcGFyYXRpb25GdW5jdGlvbi5iMlNlcGFyYXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2F4aXMgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJTZXBhcmF0aW9uRnVuY3Rpb24ucHJvdG90eXBlLkluaXRpYWxpemUgPSBmdW5jdGlvbiAoY2FjaGUsIHByb3h5QSwgdHJhbnNmb3JtQSwgcHJveHlCLCB0cmFuc2Zvcm1CKSB7XG4gICAgICB0aGlzLm1fcHJveHlBID0gcHJveHlBO1xuICAgICAgdGhpcy5tX3Byb3h5QiA9IHByb3h5QjtcbiAgICAgIHZhciBjb3VudCA9IHBhcnNlSW50KGNhY2hlLmNvdW50KTtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMCA8IGNvdW50ICYmIGNvdW50IDwgMyk7XG4gICAgICB2YXIgbG9jYWxQb2ludEE7XG4gICAgICB2YXIgbG9jYWxQb2ludEExO1xuICAgICAgdmFyIGxvY2FsUG9pbnRBMjtcbiAgICAgIHZhciBsb2NhbFBvaW50QjtcbiAgICAgIHZhciBsb2NhbFBvaW50QjE7XG4gICAgICB2YXIgbG9jYWxQb2ludEIyO1xuICAgICAgdmFyIHBvaW50QVggPSAwO1xuICAgICAgdmFyIHBvaW50QVkgPSAwO1xuICAgICAgdmFyIHBvaW50QlggPSAwO1xuICAgICAgdmFyIHBvaW50QlkgPSAwO1xuICAgICAgdmFyIG5vcm1hbFggPSAwO1xuICAgICAgdmFyIG5vcm1hbFkgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFZlYztcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBzZ24gPSAwO1xuICAgICAgaWYgKGNvdW50ID09IDEpIHtcbiAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9wb2ludHM7XG4gICAgICAgICBsb2NhbFBvaW50QSA9IHRoaXMubV9wcm94eUEuR2V0VmVydGV4KGNhY2hlLmluZGV4QVswXSk7XG4gICAgICAgICBsb2NhbFBvaW50QiA9IHRoaXMubV9wcm94eUIuR2V0VmVydGV4KGNhY2hlLmluZGV4QlswXSk7XG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEE7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQS5SO1xuICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QVkgPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEI7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xuICAgICAgICAgcG9pbnRCWCA9IHRyYW5zZm9ybUIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QlkgPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICB0aGlzLm1fYXhpcy54ID0gcG9pbnRCWCAtIHBvaW50QVg7XG4gICAgICAgICB0aGlzLm1fYXhpcy55ID0gcG9pbnRCWSAtIHBvaW50QVk7XG4gICAgICAgICB0aGlzLm1fYXhpcy5Ob3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhY2hlLmluZGV4QlswXSA9PSBjYWNoZS5pbmRleEJbMV0pIHtcbiAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQTtcbiAgICAgICAgIGxvY2FsUG9pbnRBMSA9IHRoaXMubV9wcm94eUEuR2V0VmVydGV4KGNhY2hlLmluZGV4QVswXSk7XG4gICAgICAgICBsb2NhbFBvaW50QTIgPSB0aGlzLm1fcHJveHlBLkdldFZlcnRleChjYWNoZS5pbmRleEFbMV0pO1xuICAgICAgICAgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLkdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xuICAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQueCA9IDAuNSAqIChsb2NhbFBvaW50QTEueCArIGxvY2FsUG9pbnRBMi54KTtcbiAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50LnkgPSAwLjUgKiAobG9jYWxQb2ludEExLnkgKyBsb2NhbFBvaW50QTIueSk7XG4gICAgICAgICB0aGlzLm1fYXhpcyA9IGIyTWF0aC5Dcm9zc1ZGKGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRBMiwgbG9jYWxQb2ludEExKSwgMS4wKTtcbiAgICAgICAgIHRoaXMubV9heGlzLk5vcm1hbGl6ZSgpO1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9heGlzO1xuICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUEuUjtcbiAgICAgICAgIG5vcm1hbFggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgbm9ybWFsWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX2xvY2FsUG9pbnQ7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQS5SO1xuICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QVkgPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEI7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xuICAgICAgICAgcG9pbnRCWCA9IHRyYW5zZm9ybUIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QlkgPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICBzID0gKHBvaW50QlggLSBwb2ludEFYKSAqIG5vcm1hbFggKyAocG9pbnRCWSAtIHBvaW50QVkpICogbm9ybWFsWTtcbiAgICAgICAgIGlmIChzIDwgMC4wKSB7XG4gICAgICAgICAgICB0aGlzLm1fYXhpcy5OZWdhdGl2ZVNlbGYoKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhY2hlLmluZGV4QVswXSA9PSBjYWNoZS5pbmRleEFbMF0pIHtcbiAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQjtcbiAgICAgICAgIGxvY2FsUG9pbnRCMSA9IHRoaXMubV9wcm94eUIuR2V0VmVydGV4KGNhY2hlLmluZGV4QlswXSk7XG4gICAgICAgICBsb2NhbFBvaW50QjIgPSB0aGlzLm1fcHJveHlCLkdldFZlcnRleChjYWNoZS5pbmRleEJbMV0pO1xuICAgICAgICAgbG9jYWxQb2ludEEgPSB0aGlzLm1fcHJveHlBLkdldFZlcnRleChjYWNoZS5pbmRleEFbMF0pO1xuICAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQueCA9IDAuNSAqIChsb2NhbFBvaW50QjEueCArIGxvY2FsUG9pbnRCMi54KTtcbiAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50LnkgPSAwLjUgKiAobG9jYWxQb2ludEIxLnkgKyBsb2NhbFBvaW50QjIueSk7XG4gICAgICAgICB0aGlzLm1fYXhpcyA9IGIyTWF0aC5Dcm9zc1ZGKGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRCMiwgbG9jYWxQb2ludEIxKSwgMS4wKTtcbiAgICAgICAgIHRoaXMubV9heGlzLk5vcm1hbGl6ZSgpO1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9heGlzO1xuICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUIuUjtcbiAgICAgICAgIG5vcm1hbFggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgbm9ybWFsWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX2xvY2FsUG9pbnQ7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xuICAgICAgICAgcG9pbnRCWCA9IHRyYW5zZm9ybUIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QlkgPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEE7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQS5SO1xuICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QVkgPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICBzID0gKHBvaW50QVggLSBwb2ludEJYKSAqIG5vcm1hbFggKyAocG9pbnRBWSAtIHBvaW50QlkpICogbm9ybWFsWTtcbiAgICAgICAgIGlmIChzIDwgMC4wKSB7XG4gICAgICAgICAgICB0aGlzLm1fYXhpcy5OZWdhdGl2ZVNlbGYoKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgbG9jYWxQb2ludEExID0gdGhpcy5tX3Byb3h5QS5HZXRWZXJ0ZXgoY2FjaGUuaW5kZXhBWzBdKTtcbiAgICAgICAgIGxvY2FsUG9pbnRBMiA9IHRoaXMubV9wcm94eUEuR2V0VmVydGV4KGNhY2hlLmluZGV4QVsxXSk7XG4gICAgICAgICBsb2NhbFBvaW50QjEgPSB0aGlzLm1fcHJveHlCLkdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xuICAgICAgICAgbG9jYWxQb2ludEIyID0gdGhpcy5tX3Byb3h5Qi5HZXRWZXJ0ZXgoY2FjaGUuaW5kZXhCWzFdKTtcbiAgICAgICAgIHZhciBwQSA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUEsIGxvY2FsUG9pbnRBKTtcbiAgICAgICAgIHZhciBkQSA9IGIyTWF0aC5NdWxNVih0cmFuc2Zvcm1BLlIsIGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRBMiwgbG9jYWxQb2ludEExKSk7XG4gICAgICAgICB2YXIgcEIgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCBsb2NhbFBvaW50Qik7XG4gICAgICAgICB2YXIgZEIgPSBiMk1hdGguTXVsTVYodHJhbnNmb3JtQi5SLCBiMk1hdGguU3VidHJhY3RWVihsb2NhbFBvaW50QjIsIGxvY2FsUG9pbnRCMSkpO1xuICAgICAgICAgdmFyIGEgPSBkQS54ICogZEEueCArIGRBLnkgKiBkQS55O1xuICAgICAgICAgdmFyIGUgPSBkQi54ICogZEIueCArIGRCLnkgKiBkQi55O1xuICAgICAgICAgdmFyIHIgPSBiMk1hdGguU3VidHJhY3RWVihkQiwgZEEpO1xuICAgICAgICAgdmFyIGMgPSBkQS54ICogci54ICsgZEEueSAqIHIueTtcbiAgICAgICAgIHZhciBmID0gZEIueCAqIHIueCArIGRCLnkgKiByLnk7XG4gICAgICAgICB2YXIgYiA9IGRBLnggKiBkQi54ICsgZEEueSAqIGRCLnk7XG4gICAgICAgICB2YXIgZGVub20gPSBhICogZSAtIGIgKiBiO1xuICAgICAgICAgcyA9IDAuMDtcbiAgICAgICAgIGlmIChkZW5vbSAhPSAwLjApIHtcbiAgICAgICAgICAgIHMgPSBiMk1hdGguQ2xhbXAoKGIgKiBmIC0gYyAqIGUpIC8gZGVub20sIDAuMCwgMS4wKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciB0ID0gKGIgKiBzICsgZikgLyBlO1xuICAgICAgICAgaWYgKHQgPCAwLjApIHtcbiAgICAgICAgICAgIHQgPSAwLjA7XG4gICAgICAgICAgICBzID0gYjJNYXRoLkNsYW1wKChiIC0gYykgLyBhLCAwLjAsIDEuMCk7XG4gICAgICAgICB9XG4gICAgICAgICBsb2NhbFBvaW50QSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgICAgIGxvY2FsUG9pbnRBLnggPSBsb2NhbFBvaW50QTEueCArIHMgKiAobG9jYWxQb2ludEEyLnggLSBsb2NhbFBvaW50QTEueCk7XG4gICAgICAgICBsb2NhbFBvaW50QS55ID0gbG9jYWxQb2ludEExLnkgKyBzICogKGxvY2FsUG9pbnRBMi55IC0gbG9jYWxQb2ludEExLnkpO1xuICAgICAgICAgbG9jYWxQb2ludEIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICBsb2NhbFBvaW50Qi54ID0gbG9jYWxQb2ludEIxLnggKyBzICogKGxvY2FsUG9pbnRCMi54IC0gbG9jYWxQb2ludEIxLngpO1xuICAgICAgICAgbG9jYWxQb2ludEIueSA9IGxvY2FsUG9pbnRCMS55ICsgcyAqIChsb2NhbFBvaW50QjIueSAtIGxvY2FsUG9pbnRCMS55KTtcbiAgICAgICAgIGlmIChzID09IDAuMCB8fCBzID09IDEuMCkge1xuICAgICAgICAgICAgdGhpcy5tX3R5cGUgPSBiMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VCO1xuICAgICAgICAgICAgdGhpcy5tX2F4aXMgPSBiMk1hdGguQ3Jvc3NWRihiMk1hdGguU3VidHJhY3RWVihsb2NhbFBvaW50QjIsIGxvY2FsUG9pbnRCMSksIDEuMCk7XG4gICAgICAgICAgICB0aGlzLm1fYXhpcy5Ob3JtYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbG9jYWxQb2ludEI7XG4gICAgICAgICAgICB0VmVjID0gdGhpcy5tX2F4aXM7XG4gICAgICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xuICAgICAgICAgICAgbm9ybWFsWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICBub3JtYWxZID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHRWZWMgPSB0aGlzLm1fbG9jYWxQb2ludDtcbiAgICAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1CLlI7XG4gICAgICAgICAgICBwb2ludEJYID0gdHJhbnNmb3JtQi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgcG9pbnRCWSA9IHRyYW5zZm9ybUIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgICAgICAgIHRWZWMgPSBsb2NhbFBvaW50QTtcbiAgICAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1BLlI7XG4gICAgICAgICAgICBwb2ludEFYID0gdHJhbnNmb3JtQS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgcG9pbnRBWSA9IHRyYW5zZm9ybUEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgICAgICAgIHNnbiA9IChwb2ludEFYIC0gcG9pbnRCWCkgKiBub3JtYWxYICsgKHBvaW50QVkgLSBwb2ludEJZKSAqIG5vcm1hbFk7XG4gICAgICAgICAgICBpZiAocyA8IDAuMCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX2F4aXMuTmVnYXRpdmVTZWxmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQTtcbiAgICAgICAgICAgIHRoaXMubV9heGlzID0gYjJNYXRoLkNyb3NzVkYoYjJNYXRoLlN1YnRyYWN0VlYobG9jYWxQb2ludEEyLCBsb2NhbFBvaW50QTEpLCAxLjApO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQgPSBsb2NhbFBvaW50QTtcbiAgICAgICAgICAgIHRWZWMgPSB0aGlzLm1fYXhpcztcbiAgICAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1BLlI7XG4gICAgICAgICAgICBub3JtYWxYID0gdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcbiAgICAgICAgICAgIG5vcm1hbFkgPSB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xuICAgICAgICAgICAgdFZlYyA9IHRoaXMubV9sb2NhbFBvaW50O1xuICAgICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUEuUjtcbiAgICAgICAgICAgIHBvaW50QVggPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICAgICAgICBwb2ludEFZID0gdHJhbnNmb3JtQS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgdFZlYyA9IGxvY2FsUG9pbnRCO1xuICAgICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUIuUjtcbiAgICAgICAgICAgIHBvaW50QlggPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICAgICAgICBwb2ludEJZID0gdHJhbnNmb3JtQi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgc2duID0gKHBvaW50QlggLSBwb2ludEFYKSAqIG5vcm1hbFggKyAocG9pbnRCWSAtIHBvaW50QVkpICogbm9ybWFsWTtcbiAgICAgICAgICAgIGlmIChzIDwgMC4wKSB7XG4gICAgICAgICAgICAgICB0aGlzLm1fYXhpcy5OZWdhdGl2ZVNlbGYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1BLCB0cmFuc2Zvcm1CKSB7XG4gICAgICB2YXIgYXhpc0E7XG4gICAgICB2YXIgYXhpc0I7XG4gICAgICB2YXIgbG9jYWxQb2ludEE7XG4gICAgICB2YXIgbG9jYWxQb2ludEI7XG4gICAgICB2YXIgcG9pbnRBO1xuICAgICAgdmFyIHBvaW50QjtcbiAgICAgIHZhciBzZXBlcmF0aW9uID0gMDtcbiAgICAgIHZhciBub3JtYWw7XG4gICAgICBzd2l0Y2ggKHRoaXMubV90eXBlKSB7XG4gICAgICBjYXNlIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfcG9pbnRzOlxuICAgICAgICAge1xuICAgICAgICAgICAgYXhpc0EgPSBiMk1hdGguTXVsVE1WKHRyYW5zZm9ybUEuUiwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgYXhpc0IgPSBiMk1hdGguTXVsVE1WKHRyYW5zZm9ybUIuUiwgdGhpcy5tX2F4aXMuR2V0TmVnYXRpdmUoKSk7XG4gICAgICAgICAgICBsb2NhbFBvaW50QSA9IHRoaXMubV9wcm94eUEuR2V0U3VwcG9ydFZlcnRleChheGlzQSk7XG4gICAgICAgICAgICBsb2NhbFBvaW50QiA9IHRoaXMubV9wcm94eUIuR2V0U3VwcG9ydFZlcnRleChheGlzQik7XG4gICAgICAgICAgICBwb2ludEEgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCBsb2NhbFBvaW50QSk7XG4gICAgICAgICAgICBwb2ludEIgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCBsb2NhbFBvaW50Qik7XG4gICAgICAgICAgICBzZXBlcmF0aW9uID0gKHBvaW50Qi54IC0gcG9pbnRBLngpICogdGhpcy5tX2F4aXMueCArIChwb2ludEIueSAtIHBvaW50QS55KSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICAgICByZXR1cm4gc2VwZXJhdGlvbjtcbiAgICAgICAgIH1cbiAgICAgIGNhc2UgYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQTpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIG5vcm1hbCA9IGIyTWF0aC5NdWxNVih0cmFuc2Zvcm1BLlIsIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgIHBvaW50QSA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUEsIHRoaXMubV9sb2NhbFBvaW50KTtcbiAgICAgICAgICAgIGF4aXNCID0gYjJNYXRoLk11bFRNVih0cmFuc2Zvcm1CLlIsIG5vcm1hbC5HZXROZWdhdGl2ZSgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9pbnRCID0gdGhpcy5tX3Byb3h5Qi5HZXRTdXBwb3J0VmVydGV4KGF4aXNCKTtcbiAgICAgICAgICAgIHBvaW50QiA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUIsIGxvY2FsUG9pbnRCKTtcbiAgICAgICAgICAgIHNlcGVyYXRpb24gPSAocG9pbnRCLnggLSBwb2ludEEueCkgKiBub3JtYWwueCArIChwb2ludEIueSAtIHBvaW50QS55KSAqIG5vcm1hbC55O1xuICAgICAgICAgICAgcmV0dXJuIHNlcGVyYXRpb247XG4gICAgICAgICB9XG4gICAgICBjYXNlIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfZmFjZUI6XG4gICAgICAgICB7XG4gICAgICAgICAgICBub3JtYWwgPSBiMk1hdGguTXVsTVYodHJhbnNmb3JtQi5SLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICBwb2ludEIgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCB0aGlzLm1fbG9jYWxQb2ludCk7XG4gICAgICAgICAgICBheGlzQSA9IGIyTWF0aC5NdWxUTVYodHJhbnNmb3JtQS5SLCBub3JtYWwuR2V0TmVnYXRpdmUoKSk7XG4gICAgICAgICAgICBsb2NhbFBvaW50QSA9IHRoaXMubV9wcm94eUEuR2V0U3VwcG9ydFZlcnRleChheGlzQSk7XG4gICAgICAgICAgICBwb2ludEEgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCBsb2NhbFBvaW50QSk7XG4gICAgICAgICAgICBzZXBlcmF0aW9uID0gKHBvaW50QS54IC0gcG9pbnRCLngpICogbm9ybWFsLnggKyAocG9pbnRBLnkgLSBwb2ludEIueSkgKiBub3JtYWwueTtcbiAgICAgICAgICAgIHJldHVybiBzZXBlcmF0aW9uO1xuICAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xuICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfcG9pbnRzID0gMHgwMTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VBID0gMHgwMjtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VCID0gMHgwNDtcbiAgIH0pO1xuICAgYjJTaW1wbGV4LmIyU2ltcGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV92MSA9IG5ldyBiMlNpbXBsZXhWZXJ0ZXgoKTtcbiAgICAgIHRoaXMubV92MiA9IG5ldyBiMlNpbXBsZXhWZXJ0ZXgoKTtcbiAgICAgIHRoaXMubV92MyA9IG5ldyBiMlNpbXBsZXhWZXJ0ZXgoKTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlcyA9IG5ldyBWZWN0b3IoMyk7XG4gICB9O1xuICAgYjJTaW1wbGV4LnByb3RvdHlwZS5iMlNpbXBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMF0gPSB0aGlzLm1fdjE7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMV0gPSB0aGlzLm1fdjI7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMl0gPSB0aGlzLm1fdjM7XG4gICB9XG4gICBiMlNpbXBsZXgucHJvdG90eXBlLlJlYWRDYWNoZSA9IGZ1bmN0aW9uIChjYWNoZSwgcHJveHlBLCB0cmFuc2Zvcm1BLCBwcm94eUIsIHRyYW5zZm9ybUIpIHtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMCA8PSBjYWNoZS5jb3VudCAmJiBjYWNoZS5jb3VudCA8PSAzKTtcbiAgICAgIHZhciB3QUxvY2FsO1xuICAgICAgdmFyIHdCTG9jYWw7XG4gICAgICB0aGlzLm1fY291bnQgPSBjYWNoZS5jb3VudDtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMubV92ZXJ0aWNlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyBpKyspIHtcbiAgICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XG4gICAgICAgICB2LmluZGV4QSA9IGNhY2hlLmluZGV4QVtpXTtcbiAgICAgICAgIHYuaW5kZXhCID0gY2FjaGUuaW5kZXhCW2ldO1xuICAgICAgICAgd0FMb2NhbCA9IHByb3h5QS5HZXRWZXJ0ZXgodi5pbmRleEEpO1xuICAgICAgICAgd0JMb2NhbCA9IHByb3h5Qi5HZXRWZXJ0ZXgodi5pbmRleEIpO1xuICAgICAgICAgdi53QSA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUEsIHdBTG9jYWwpO1xuICAgICAgICAgdi53QiA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUIsIHdCTG9jYWwpO1xuICAgICAgICAgdi53ID0gYjJNYXRoLlN1YnRyYWN0VlYodi53Qiwgdi53QSk7XG4gICAgICAgICB2LmEgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9jb3VudCA+IDEpIHtcbiAgICAgICAgIHZhciBtZXRyaWMxID0gY2FjaGUubWV0cmljO1xuICAgICAgICAgdmFyIG1ldHJpYzIgPSB0aGlzLkdldE1ldHJpYygpO1xuICAgICAgICAgaWYgKG1ldHJpYzIgPCAuNSAqIG1ldHJpYzEgfHwgMi4wICogbWV0cmljMSA8IG1ldHJpYzIgfHwgbWV0cmljMiA8IE51bWJlci5NSU5fVkFMVUUpIHtcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDA7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2NvdW50ID09IDApIHtcbiAgICAgICAgIHYgPSB2ZXJ0aWNlc1swXTtcbiAgICAgICAgIHYuaW5kZXhBID0gMDtcbiAgICAgICAgIHYuaW5kZXhCID0gMDtcbiAgICAgICAgIHdBTG9jYWwgPSBwcm94eUEuR2V0VmVydGV4KDApO1xuICAgICAgICAgd0JMb2NhbCA9IHByb3h5Qi5HZXRWZXJ0ZXgoMCk7XG4gICAgICAgICB2LndBID0gYjJNYXRoLk11bFgodHJhbnNmb3JtQSwgd0FMb2NhbCk7XG4gICAgICAgICB2LndCID0gYjJNYXRoLk11bFgodHJhbnNmb3JtQiwgd0JMb2NhbCk7XG4gICAgICAgICB2LncgPSBiMk1hdGguU3VidHJhY3RWVih2LndCLCB2LndBKTtcbiAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICB9XG4gICB9XG4gICBiMlNpbXBsZXgucHJvdG90eXBlLldyaXRlQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlLm1ldHJpYyA9IHRoaXMuR2V0TWV0cmljKCk7XG4gICAgICBjYWNoZS5jb3VudCA9IEJveDJELnBhcnNlVUludCh0aGlzLm1fY291bnQpO1xuICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5tX3ZlcnRpY2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7IGkrKykge1xuICAgICAgICAgY2FjaGUuaW5kZXhBW2ldID0gQm94MkQucGFyc2VVSW50KHZlcnRpY2VzW2ldLmluZGV4QSk7XG4gICAgICAgICBjYWNoZS5pbmRleEJbaV0gPSBCb3gyRC5wYXJzZVVJbnQodmVydGljZXNbaV0uaW5kZXhCKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuR2V0U2VhcmNoRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3dpdGNoICh0aGlzLm1fY291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgIHJldHVybiB0aGlzLm1fdjEudy5HZXROZWdhdGl2ZSgpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGUxMiA9IGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92Mi53LCB0aGlzLm1fdjEudyk7XG4gICAgICAgICAgICB2YXIgc2duID0gYjJNYXRoLkNyb3NzVlYoZTEyLCB0aGlzLm1fdjEudy5HZXROZWdhdGl2ZSgpKTtcbiAgICAgICAgICAgIGlmIChzZ24gPiAwLjApIHtcbiAgICAgICAgICAgICAgIHJldHVybiBiMk1hdGguQ3Jvc3NGVigxLjAsIGUxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIHJldHVybiBiMk1hdGguQ3Jvc3NWRihlMTIsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XG4gICAgICAgICByZXR1cm4gbmV3IGIyVmVjMigpO1xuICAgICAgfVxuICAgfVxuICAgYjJTaW1wbGV4LnByb3RvdHlwZS5HZXRDbG9zZXN0UG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XG4gICAgICAgICByZXR1cm4gbmV3IGIyVmVjMigpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgcmV0dXJuIHRoaXMubV92MS53O1xuICAgICAgY2FzZSAyOlxuICAgICAgICAgcmV0dXJuIG5ldyBiMlZlYzIodGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEudy54ICsgdGhpcy5tX3YyLmEgKiB0aGlzLm1fdjIudy54LCB0aGlzLm1fdjEuYSAqIHRoaXMubV92MS53LnkgKyB0aGlzLm1fdjIuYSAqIHRoaXMubV92Mi53LnkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xuICAgICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuR2V0V2l0bmVzc1BvaW50cyA9IGZ1bmN0aW9uIChwQSwgcEIpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgcEEuU2V0Vih0aGlzLm1fdjEud0EpO1xuICAgICAgICAgcEIuU2V0Vih0aGlzLm1fdjEud0IpO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgICBwQS54ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0EueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndBLng7XG4gICAgICAgICBwQS55ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0EueSArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndBLnk7XG4gICAgICAgICBwQi54ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0IueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndCLng7XG4gICAgICAgICBwQi55ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0IueSArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndCLnk7XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgIHBCLnggPSBwQS54ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0EueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndBLnggKyB0aGlzLm1fdjMuYSAqIHRoaXMubV92My53QS54O1xuICAgICAgICAgcEIueSA9IHBBLnkgPSB0aGlzLm1fdjEuYSAqIHRoaXMubV92MS53QS55ICsgdGhpcy5tX3YyLmEgKiB0aGlzLm1fdjIud0EueSArIHRoaXMubV92My5hICogdGhpcy5tX3YzLndBLnk7XG4gICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgfVxuICAgYjJTaW1wbGV4LnByb3RvdHlwZS5HZXRNZXRyaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XG4gICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgIHJldHVybiBiMk1hdGguU3VidHJhY3RWVih0aGlzLm1fdjEudywgdGhpcy5tX3YyLncpLkxlbmd0aCgpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICAgcmV0dXJuIGIyTWF0aC5Dcm9zc1ZWKGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92Mi53LCB0aGlzLm1fdjEudyksIGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92My53LCB0aGlzLm1fdjEudykpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xuICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuU29sdmUyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHcxID0gdGhpcy5tX3YxLnc7XG4gICAgICB2YXIgdzIgPSB0aGlzLm1fdjIudztcbiAgICAgIHZhciBlMTIgPSBiMk1hdGguU3VidHJhY3RWVih3MiwgdzEpO1xuICAgICAgdmFyIGQxMl8yID0gKC0odzEueCAqIGUxMi54ICsgdzEueSAqIGUxMi55KSk7XG4gICAgICBpZiAoZDEyXzIgPD0gMC4wKSB7XG4gICAgICAgICB0aGlzLm1fdjEuYSA9IDEuMDtcbiAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZDEyXzEgPSAodzIueCAqIGUxMi54ICsgdzIueSAqIGUxMi55KTtcbiAgICAgIGlmIChkMTJfMSA8PSAwLjApIHtcbiAgICAgICAgIHRoaXMubV92Mi5hID0gMS4wO1xuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgIHRoaXMubV92MS5TZXQodGhpcy5tX3YyKTtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbnZfZDEyID0gMS4wIC8gKGQxMl8xICsgZDEyXzIpO1xuICAgICAgdGhpcy5tX3YxLmEgPSBkMTJfMSAqIGludl9kMTI7XG4gICAgICB0aGlzLm1fdjIuYSA9IGQxMl8yICogaW52X2QxMjtcbiAgICAgIHRoaXMubV9jb3VudCA9IDI7XG4gICB9XG4gICBiMlNpbXBsZXgucHJvdG90eXBlLlNvbHZlMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3MSA9IHRoaXMubV92MS53O1xuICAgICAgdmFyIHcyID0gdGhpcy5tX3YyLnc7XG4gICAgICB2YXIgdzMgPSB0aGlzLm1fdjMudztcbiAgICAgIHZhciBlMTIgPSBiMk1hdGguU3VidHJhY3RWVih3MiwgdzEpO1xuICAgICAgdmFyIHcxZTEyID0gYjJNYXRoLkRvdCh3MSwgZTEyKTtcbiAgICAgIHZhciB3MmUxMiA9IGIyTWF0aC5Eb3QodzIsIGUxMik7XG4gICAgICB2YXIgZDEyXzEgPSB3MmUxMjtcbiAgICAgIHZhciBkMTJfMiA9ICgtdzFlMTIpO1xuICAgICAgdmFyIGUxMyA9IGIyTWF0aC5TdWJ0cmFjdFZWKHczLCB3MSk7XG4gICAgICB2YXIgdzFlMTMgPSBiMk1hdGguRG90KHcxLCBlMTMpO1xuICAgICAgdmFyIHczZTEzID0gYjJNYXRoLkRvdCh3MywgZTEzKTtcbiAgICAgIHZhciBkMTNfMSA9IHczZTEzO1xuICAgICAgdmFyIGQxM18yID0gKC13MWUxMyk7XG4gICAgICB2YXIgZTIzID0gYjJNYXRoLlN1YnRyYWN0VlYodzMsIHcyKTtcbiAgICAgIHZhciB3MmUyMyA9IGIyTWF0aC5Eb3QodzIsIGUyMyk7XG4gICAgICB2YXIgdzNlMjMgPSBiMk1hdGguRG90KHczLCBlMjMpO1xuICAgICAgdmFyIGQyM18xID0gdzNlMjM7XG4gICAgICB2YXIgZDIzXzIgPSAoLXcyZTIzKTtcbiAgICAgIHZhciBuMTIzID0gYjJNYXRoLkNyb3NzVlYoZTEyLCBlMTMpO1xuICAgICAgdmFyIGQxMjNfMSA9IG4xMjMgKiBiMk1hdGguQ3Jvc3NWVih3MiwgdzMpO1xuICAgICAgdmFyIGQxMjNfMiA9IG4xMjMgKiBiMk1hdGguQ3Jvc3NWVih3MywgdzEpO1xuICAgICAgdmFyIGQxMjNfMyA9IG4xMjMgKiBiMk1hdGguQ3Jvc3NWVih3MSwgdzIpO1xuICAgICAgaWYgKGQxMl8yIDw9IDAuMCAmJiBkMTNfMiA8PSAwLjApIHtcbiAgICAgICAgIHRoaXMubV92MS5hID0gMS4wO1xuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkMTJfMSA+IDAuMCAmJiBkMTJfMiA+IDAuMCAmJiBkMTIzXzMgPD0gMC4wKSB7XG4gICAgICAgICB2YXIgaW52X2QxMiA9IDEuMCAvIChkMTJfMSArIGQxMl8yKTtcbiAgICAgICAgIHRoaXMubV92MS5hID0gZDEyXzEgKiBpbnZfZDEyO1xuICAgICAgICAgdGhpcy5tX3YyLmEgPSBkMTJfMiAqIGludl9kMTI7XG4gICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGQxM18xID4gMC4wICYmIGQxM18yID4gMC4wICYmIGQxMjNfMiA8PSAwLjApIHtcbiAgICAgICAgIHZhciBpbnZfZDEzID0gMS4wIC8gKGQxM18xICsgZDEzXzIpO1xuICAgICAgICAgdGhpcy5tX3YxLmEgPSBkMTNfMSAqIGludl9kMTM7XG4gICAgICAgICB0aGlzLm1fdjMuYSA9IGQxM18yICogaW52X2QxMztcbiAgICAgICAgIHRoaXMubV9jb3VudCA9IDI7XG4gICAgICAgICB0aGlzLm1fdjIuU2V0KHRoaXMubV92Myk7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZDEyXzEgPD0gMC4wICYmIGQyM18yIDw9IDAuMCkge1xuICAgICAgICAgdGhpcy5tX3YyLmEgPSAxLjA7XG4gICAgICAgICB0aGlzLm1fY291bnQgPSAxO1xuICAgICAgICAgdGhpcy5tX3YxLlNldCh0aGlzLm1fdjIpO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGQxM18xIDw9IDAuMCAmJiBkMjNfMSA8PSAwLjApIHtcbiAgICAgICAgIHRoaXMubV92My5hID0gMS4wO1xuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgIHRoaXMubV92MS5TZXQodGhpcy5tX3YzKTtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkMjNfMSA+IDAuMCAmJiBkMjNfMiA+IDAuMCAmJiBkMTIzXzEgPD0gMC4wKSB7XG4gICAgICAgICB2YXIgaW52X2QyMyA9IDEuMCAvIChkMjNfMSArIGQyM18yKTtcbiAgICAgICAgIHRoaXMubV92Mi5hID0gZDIzXzEgKiBpbnZfZDIzO1xuICAgICAgICAgdGhpcy5tX3YzLmEgPSBkMjNfMiAqIGludl9kMjM7XG4gICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xuICAgICAgICAgdGhpcy5tX3YxLlNldCh0aGlzLm1fdjMpO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGludl9kMTIzID0gMS4wIC8gKGQxMjNfMSArIGQxMjNfMiArIGQxMjNfMyk7XG4gICAgICB0aGlzLm1fdjEuYSA9IGQxMjNfMSAqIGludl9kMTIzO1xuICAgICAgdGhpcy5tX3YyLmEgPSBkMTIzXzIgKiBpbnZfZDEyMztcbiAgICAgIHRoaXMubV92My5hID0gZDEyM18zICogaW52X2QxMjM7XG4gICAgICB0aGlzLm1fY291bnQgPSAzO1xuICAgfVxuICAgYjJTaW1wbGV4Q2FjaGUuYjJTaW1wbGV4Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmluZGV4QSA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigzKTtcbiAgICAgIHRoaXMuaW5kZXhCID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKDMpO1xuICAgfTtcbiAgIGIyU2ltcGxleFZlcnRleC5iMlNpbXBsZXhWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7fTtcbiAgIGIyU2ltcGxleFZlcnRleC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICB0aGlzLndBLlNldFYob3RoZXIud0EpO1xuICAgICAgdGhpcy53Qi5TZXRWKG90aGVyLndCKTtcbiAgICAgIHRoaXMudy5TZXRWKG90aGVyLncpO1xuICAgICAgdGhpcy5hID0gb3RoZXIuYTtcbiAgICAgIHRoaXMuaW5kZXhBID0gb3RoZXIuaW5kZXhBO1xuICAgICAgdGhpcy5pbmRleEIgPSBvdGhlci5pbmRleEI7XG4gICB9XG4gICBiMlRpbWVPZkltcGFjdC5iMlRpbWVPZkltcGFjdCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJUaW1lT2ZJbXBhY3QuVGltZU9mSW1wYWN0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICArK2IyVGltZU9mSW1wYWN0LmIyX3RvaUNhbGxzO1xuICAgICAgdmFyIHByb3h5QSA9IGlucHV0LnByb3h5QTtcbiAgICAgIHZhciBwcm94eUIgPSBpbnB1dC5wcm94eUI7XG4gICAgICB2YXIgc3dlZXBBID0gaW5wdXQuc3dlZXBBO1xuICAgICAgdmFyIHN3ZWVwQiA9IGlucHV0LnN3ZWVwQjtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoc3dlZXBBLnQwID09IHN3ZWVwQi50MCk7XG4gICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KDEuMCAtIHN3ZWVwQS50MCA+IE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgdmFyIHJhZGl1cyA9IHByb3h5QS5tX3JhZGl1cyArIHByb3h5Qi5tX3JhZGl1cztcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBpbnB1dC50b2xlcmFuY2U7XG4gICAgICB2YXIgYWxwaGEgPSAwLjA7XG4gICAgICB2YXIga19tYXhJdGVyYXRpb25zID0gMTAwMDtcbiAgICAgIHZhciBpdGVyID0gMDtcbiAgICAgIHZhciB0YXJnZXQgPSAwLjA7XG4gICAgICBiMlRpbWVPZkltcGFjdC5zX2NhY2hlLmNvdW50ID0gMDtcbiAgICAgIGIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VJbnB1dC51c2VSYWRpaSA9IGZhbHNlO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICAgc3dlZXBBLkdldFRyYW5zZm9ybShiMlRpbWVPZkltcGFjdC5zX3hmQSwgYWxwaGEpO1xuICAgICAgICAgc3dlZXBCLkdldFRyYW5zZm9ybShiMlRpbWVPZkltcGFjdC5zX3hmQiwgYWxwaGEpO1xuICAgICAgICAgYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0LnByb3h5QSA9IHByb3h5QTtcbiAgICAgICAgIGIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VJbnB1dC5wcm94eUIgPSBwcm94eUI7XG4gICAgICAgICBiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlSW5wdXQudHJhbnNmb3JtQSA9IGIyVGltZU9mSW1wYWN0LnNfeGZBO1xuICAgICAgICAgYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0LnRyYW5zZm9ybUIgPSBiMlRpbWVPZkltcGFjdC5zX3hmQjtcbiAgICAgICAgIGIyRGlzdGFuY2UuRGlzdGFuY2UoYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZU91dHB1dCwgYjJUaW1lT2ZJbXBhY3Quc19jYWNoZSwgYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0KTtcbiAgICAgICAgIGlmIChiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlT3V0cHV0LmRpc3RhbmNlIDw9IDAuMCkge1xuICAgICAgICAgICAgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgICAgIGIyVGltZU9mSW1wYWN0LnNfZmNuLkluaXRpYWxpemUoYjJUaW1lT2ZJbXBhY3Quc19jYWNoZSwgcHJveHlBLCBiMlRpbWVPZkltcGFjdC5zX3hmQSwgcHJveHlCLCBiMlRpbWVPZkltcGFjdC5zX3hmQik7XG4gICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IGIyVGltZU9mSW1wYWN0LnNfZmNuLkV2YWx1YXRlKGIyVGltZU9mSW1wYWN0LnNfeGZBLCBiMlRpbWVPZkltcGFjdC5zX3hmQik7XG4gICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSAwLjApIHtcbiAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAoaXRlciA9PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA+IHJhZGl1cykge1xuICAgICAgICAgICAgICAgdGFyZ2V0ID0gYjJNYXRoLk1heChyYWRpdXMgLSB0b2xlcmFuY2UsIDAuNzUgKiByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICB0YXJnZXQgPSBiMk1hdGguTWF4KHNlcGFyYXRpb24gLSB0b2xlcmFuY2UsIDAuMDIgKiByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKHNlcGFyYXRpb24gLSB0YXJnZXQgPCAwLjUgKiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIGlmIChpdGVyID09IDApIHtcbiAgICAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciBuZXdBbHBoYSA9IGFscGhhOyB7XG4gICAgICAgICAgICB2YXIgeDEgPSBhbHBoYTtcbiAgICAgICAgICAgIHZhciB4MiA9IDEuMDtcbiAgICAgICAgICAgIHZhciBmMSA9IHNlcGFyYXRpb247XG4gICAgICAgICAgICBzd2VlcEEuR2V0VHJhbnNmb3JtKGIyVGltZU9mSW1wYWN0LnNfeGZBLCB4Mik7XG4gICAgICAgICAgICBzd2VlcEIuR2V0VHJhbnNmb3JtKGIyVGltZU9mSW1wYWN0LnNfeGZCLCB4Mik7XG4gICAgICAgICAgICB2YXIgZjIgPSBiMlRpbWVPZkltcGFjdC5zX2Zjbi5FdmFsdWF0ZShiMlRpbWVPZkltcGFjdC5zX3hmQSwgYjJUaW1lT2ZJbXBhY3Quc194ZkIpO1xuICAgICAgICAgICAgaWYgKGYyID49IHRhcmdldCkge1xuICAgICAgICAgICAgICAgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb290SXRlckNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgICAgIGlmIChyb290SXRlckNvdW50ICYgMSkge1xuICAgICAgICAgICAgICAgICAgeCA9IHgxICsgKHRhcmdldCAtIGYxKSAqICh4MiAtIHgxKSAvIChmMiAtIGYxKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeCA9IDAuNSAqICh4MSArIHgyKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHN3ZWVwQS5HZXRUcmFuc2Zvcm0oYjJUaW1lT2ZJbXBhY3Quc194ZkEsIHgpO1xuICAgICAgICAgICAgICAgc3dlZXBCLkdldFRyYW5zZm9ybShiMlRpbWVPZkltcGFjdC5zX3hmQiwgeCk7XG4gICAgICAgICAgICAgICB2YXIgZiA9IGIyVGltZU9mSW1wYWN0LnNfZmNuLkV2YWx1YXRlKGIyVGltZU9mSW1wYWN0LnNfeGZBLCBiMlRpbWVPZkltcGFjdC5zX3hmQik7XG4gICAgICAgICAgICAgICBpZiAoYjJNYXRoLkFicyhmIC0gdGFyZ2V0KSA8IDAuMDI1ICogdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IHg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChmID4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICB4MSA9IHg7XG4gICAgICAgICAgICAgICAgICBmMSA9IGY7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHgyID0geDtcbiAgICAgICAgICAgICAgICAgIGYyID0gZjtcbiAgICAgICAgICAgICAgIH0rK3Jvb3RJdGVyQ291bnQ7XG4gICAgICAgICAgICAgICArK2IyVGltZU9mSW1wYWN0LmIyX3RvaVJvb3RJdGVycztcbiAgICAgICAgICAgICAgIGlmIChyb290SXRlckNvdW50ID09IDUwKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIyVGltZU9mSW1wYWN0LmIyX3RvaU1heFJvb3RJdGVycyA9IGIyTWF0aC5NYXgoYjJUaW1lT2ZJbXBhY3QuYjJfdG9pTWF4Um9vdEl0ZXJzLCByb290SXRlckNvdW50KTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChuZXdBbHBoYSA8ICgxLjAgKyAxMDAuMCAqIE51bWJlci5NSU5fVkFMVUUpICogYWxwaGEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgICAgYWxwaGEgPSBuZXdBbHBoYTtcbiAgICAgICAgIGl0ZXIrKztcbiAgICAgICAgICsrYjJUaW1lT2ZJbXBhY3QuYjJfdG9pSXRlcnM7XG4gICAgICAgICBpZiAoaXRlciA9PSBrX21heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgYjJUaW1lT2ZJbXBhY3QuYjJfdG9pTWF4SXRlcnMgPSBiMk1hdGguTWF4KGIyVGltZU9mSW1wYWN0LmIyX3RvaU1heEl0ZXJzLCBpdGVyKTtcbiAgICAgIHJldHVybiBhbHBoYTtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LmIyX3RvaUNhbGxzID0gMDtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdC5iMl90b2lJdGVycyA9IDA7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QuYjJfdG9pTWF4SXRlcnMgPSAwO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LmIyX3RvaVJvb3RJdGVycyA9IDA7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QuYjJfdG9pTWF4Um9vdEl0ZXJzID0gMDtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdC5zX2NhY2hlID0gbmV3IGIyU2ltcGxleENhY2hlKCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0ID0gbmV3IGIyRGlzdGFuY2VJbnB1dCgpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LnNfeGZBID0gbmV3IGIyVHJhbnNmb3JtKCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3Quc194ZkIgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdC5zX2ZjbiA9IG5ldyBiMlNlcGFyYXRpb25GdW5jdGlvbigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VPdXRwdXQgPSBuZXcgYjJEaXN0YW5jZU91dHB1dCgpO1xuICAgfSk7XG4gICBiMlRPSUlucHV0LmIyVE9JSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnByb3h5QSA9IG5ldyBiMkRpc3RhbmNlUHJveHkoKTtcbiAgICAgIHRoaXMucHJveHlCID0gbmV3IGIyRGlzdGFuY2VQcm94eSgpO1xuICAgICAgdGhpcy5zd2VlcEEgPSBuZXcgYjJTd2VlcCgpO1xuICAgICAgdGhpcy5zd2VlcEIgPSBuZXcgYjJTd2VlcCgpO1xuICAgfTtcbiAgIGIyV29ybGRNYW5pZm9sZC5iMldvcmxkTWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fbm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyV29ybGRNYW5pZm9sZC5wcm90b3R5cGUuYjJXb3JsZE1hbmlmb2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX3BvaW50cyA9IG5ldyBWZWN0b3IoYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xuICAgICAgICAgdGhpcy5tX3BvaW50c1tpXSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyV29ybGRNYW5pZm9sZC5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgeGZBLCByYWRpdXNBLCB4ZkIsIHJhZGl1c0IpIHtcbiAgICAgIGlmIChyYWRpdXNBID09PSB1bmRlZmluZWQpIHJhZGl1c0EgPSAwO1xuICAgICAgaWYgKHJhZGl1c0IgPT09IHVuZGVmaW5lZCkgcmFkaXVzQiA9IDA7XG4gICAgICBpZiAobWFuaWZvbGQubV9wb2ludENvdW50ID09IDApIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgbm9ybWFsWCA9IDA7XG4gICAgICB2YXIgbm9ybWFsWSA9IDA7XG4gICAgICB2YXIgcGxhbmVQb2ludFggPSAwO1xuICAgICAgdmFyIHBsYW5lUG9pbnRZID0gMDtcbiAgICAgIHZhciBjbGlwUG9pbnRYID0gMDtcbiAgICAgIHZhciBjbGlwUG9pbnRZID0gMDtcbiAgICAgIHN3aXRjaCAobWFuaWZvbGQubV90eXBlKSB7XG4gICAgICBjYXNlIGIyTWFuaWZvbGQuZV9jaXJjbGVzOlxuICAgICAgICAge1xuICAgICAgICAgICAgdE1hdCA9IHhmQS5SO1xuICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fbG9jYWxQb2ludDtcbiAgICAgICAgICAgIHZhciBwb2ludEFYID0geGZBLnBvc2l0aW9uLnggKyB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgICAgdmFyIHBvaW50QVkgPSB4ZkEucG9zaXRpb24ueSArIHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICAgICB0TWF0ID0geGZCLlI7XG4gICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9wb2ludHNbMF0ubV9sb2NhbFBvaW50O1xuICAgICAgICAgICAgdmFyIHBvaW50QlggPSB4ZkIucG9zaXRpb24ueCArIHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICB2YXIgcG9pbnRCWSA9IHhmQi5wb3NpdGlvbi55ICsgdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHZhciBkWCA9IHBvaW50QlggLSBwb2ludEFYO1xuICAgICAgICAgICAgdmFyIGRZID0gcG9pbnRCWSAtIHBvaW50QVk7XG4gICAgICAgICAgICB2YXIgZDIgPSBkWCAqIGRYICsgZFkgKiBkWTtcbiAgICAgICAgICAgIGlmIChkMiA+IE51bWJlci5NSU5fVkFMVUUgKiBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydChkMik7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggPSBkWCAvIGQ7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSBkWSAvIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueCA9IDE7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNBWCA9IHBvaW50QVggKyByYWRpdXNBICogdGhpcy5tX25vcm1hbC54O1xuICAgICAgICAgICAgdmFyIGNBWSA9IHBvaW50QVkgKyByYWRpdXNBICogdGhpcy5tX25vcm1hbC55O1xuICAgICAgICAgICAgdmFyIGNCWCA9IHBvaW50QlggLSByYWRpdXNCICogdGhpcy5tX25vcm1hbC54O1xuICAgICAgICAgICAgdmFyIGNCWSA9IHBvaW50QlkgLSByYWRpdXNCICogdGhpcy5tX25vcm1hbC55O1xuICAgICAgICAgICAgdGhpcy5tX3BvaW50c1swXS54ID0gMC41ICogKGNBWCArIGNCWCk7XG4gICAgICAgICAgICB0aGlzLm1fcG9pbnRzWzBdLnkgPSAwLjUgKiAoY0FZICsgY0JZKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMk1hbmlmb2xkLmVfZmFjZUE6XG4gICAgICAgICB7XG4gICAgICAgICAgICB0TWF0ID0geGZBLlI7XG4gICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsO1xuICAgICAgICAgICAgbm9ybWFsWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICBub3JtYWxZID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHRNYXQgPSB4ZkEuUjtcbiAgICAgICAgICAgIHRWZWMgPSBtYW5pZm9sZC5tX2xvY2FsUG9pbnQ7XG4gICAgICAgICAgICBwbGFuZVBvaW50WCA9IHhmQS5wb3NpdGlvbi54ICsgdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcbiAgICAgICAgICAgIHBsYW5lUG9pbnRZID0geGZBLnBvc2l0aW9uLnkgKyB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ID0gbm9ybWFsWDtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueSA9IG5vcm1hbFk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwO1xuICAgICAgICAgICAgaSA8IG1hbmlmb2xkLm1fcG9pbnRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICB0TWF0ID0geGZCLlI7XG4gICAgICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9wb2ludHNbaV0ubV9sb2NhbFBvaW50O1xuICAgICAgICAgICAgICAgY2xpcFBvaW50WCA9IHhmQi5wb3NpdGlvbi54ICsgdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFkgPSB4ZkIucG9zaXRpb24ueSArIHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICAgICAgICB0aGlzLm1fcG9pbnRzW2ldLnggPSBjbGlwUG9pbnRYICsgMC41ICogKHJhZGl1c0EgLSAoY2xpcFBvaW50WCAtIHBsYW5lUG9pbnRYKSAqIG5vcm1hbFggLSAoY2xpcFBvaW50WSAtIHBsYW5lUG9pbnRZKSAqIG5vcm1hbFkgLSByYWRpdXNCKSAqIG5vcm1hbFg7XG4gICAgICAgICAgICAgICB0aGlzLm1fcG9pbnRzW2ldLnkgPSBjbGlwUG9pbnRZICsgMC41ICogKHJhZGl1c0EgLSAoY2xpcFBvaW50WCAtIHBsYW5lUG9pbnRYKSAqIG5vcm1hbFggLSAoY2xpcFBvaW50WSAtIHBsYW5lUG9pbnRZKSAqIG5vcm1hbFkgLSByYWRpdXNCKSAqIG5vcm1hbFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJNYW5pZm9sZC5lX2ZhY2VCOlxuICAgICAgICAge1xuICAgICAgICAgICAgdE1hdCA9IHhmQi5SO1xuICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbDtcbiAgICAgICAgICAgIG5vcm1hbFggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgICAgbm9ybWFsWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICAgICB0TWF0ID0geGZCLlI7XG4gICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9sb2NhbFBvaW50O1xuICAgICAgICAgICAgcGxhbmVQb2ludFggPSB4ZkIucG9zaXRpb24ueCArIHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICBwbGFuZVBvaW50WSA9IHhmQi5wb3NpdGlvbi55ICsgdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueCA9ICgtbm9ybWFsWCk7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSAoLW5vcm1hbFkpO1xuICAgICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgICAgIGkgPCBtYW5pZm9sZC5tX3BvaW50Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgdE1hdCA9IHhmQS5SO1xuICAgICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fcG9pbnRzW2ldLm1fbG9jYWxQb2ludDtcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFggPSB4ZkEucG9zaXRpb24ueCArIHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICAgICBjbGlwUG9pbnRZID0geGZBLnBvc2l0aW9uLnkgKyB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xuICAgICAgICAgICAgICAgdGhpcy5tX3BvaW50c1tpXS54ID0gY2xpcFBvaW50WCArIDAuNSAqIChyYWRpdXNCIC0gKGNsaXBQb2ludFggLSBwbGFuZVBvaW50WCkgKiBub3JtYWxYIC0gKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiBub3JtYWxZIC0gcmFkaXVzQSkgKiBub3JtYWxYO1xuICAgICAgICAgICAgICAgdGhpcy5tX3BvaW50c1tpXS55ID0gY2xpcFBvaW50WSArIDAuNSAqIChyYWRpdXNCIC0gKGNsaXBQb2ludFggLSBwbGFuZVBvaW50WCkgKiBub3JtYWxYIC0gKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiBub3JtYWxZIC0gcmFkaXVzQSkgKiBub3JtYWxZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICB9XG4gICBDbGlwVmVydGV4LkNsaXBWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnYgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmlkID0gbmV3IGIyQ29udGFjdElEKCk7XG4gICB9O1xuICAgQ2xpcFZlcnRleC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICB0aGlzLnYuU2V0VihvdGhlci52KTtcbiAgICAgIHRoaXMuaWQuU2V0KG90aGVyLmlkKTtcbiAgIH1cbiAgIEZlYXR1cmVzLkZlYXR1cmVzID0gZnVuY3Rpb24gKCkge307XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVhdHVyZXMucHJvdG90eXBlLCAncmVmZXJlbmNlRWRnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlRWRnZTtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ3JlZmVyZW5jZUVkZ2UnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAwO1xuICAgICAgICAgdGhpcy5fcmVmZXJlbmNlRWRnZSA9IHZhbHVlO1xuICAgICAgICAgdGhpcy5fbV9pZC5fa2V5ID0gKHRoaXMuX21faWQuX2tleSAmIDB4ZmZmZmZmMDApIHwgKHRoaXMuX3JlZmVyZW5jZUVkZ2UgJiAweDAwMDAwMGZmKTtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2luY2lkZW50RWRnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5faW5jaWRlbnRFZGdlO1xuICAgICAgfVxuICAgfSk7XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVhdHVyZXMucHJvdG90eXBlLCAnaW5jaWRlbnRFZGdlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gMDtcbiAgICAgICAgIHRoaXMuX2luY2lkZW50RWRnZSA9IHZhbHVlO1xuICAgICAgICAgdGhpcy5fbV9pZC5fa2V5ID0gKHRoaXMuX21faWQuX2tleSAmIDB4ZmZmZjAwZmYpIHwgKCh0aGlzLl9pbmNpZGVudEVkZ2UgPDwgOCkgJiAweDAwMDBmZjAwKTtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2luY2lkZW50VmVydGV4Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9pbmNpZGVudFZlcnRleDtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2luY2lkZW50VmVydGV4Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gMDtcbiAgICAgICAgIHRoaXMuX2luY2lkZW50VmVydGV4ID0gdmFsdWU7XG4gICAgICAgICB0aGlzLl9tX2lkLl9rZXkgPSAodGhpcy5fbV9pZC5fa2V5ICYgMHhmZjAwZmZmZikgfCAoKHRoaXMuX2luY2lkZW50VmVydGV4IDw8IDE2KSAmIDB4MDBmZjAwMDApO1xuICAgICAgfVxuICAgfSk7XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVhdHVyZXMucHJvdG90eXBlLCAnZmxpcCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZmxpcDtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2ZsaXAnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAwO1xuICAgICAgICAgdGhpcy5fZmxpcCA9IHZhbHVlO1xuICAgICAgICAgdGhpcy5fbV9pZC5fa2V5ID0gKHRoaXMuX21faWQuX2tleSAmIDB4MDBmZmZmZmYpIHwgKCh0aGlzLl9mbGlwIDw8IDI0KSAmIDB4ZmYwMDAwMDApO1xuICAgICAgfVxuICAgfSk7XG59KSgpO1xuKGZ1bmN0aW9uICgpIHtcbiAgIHZhciBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXG4gICAgICBiMmludGVybmFsID0gQm94MkQuQ29tbW9uLmIyaW50ZXJuYWwsXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXG4gICAgICBiMkNpcmNsZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlLFxuICAgICAgYjJFZGdlQ2hhaW5EZWYgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZUNoYWluRGVmLFxuICAgICAgYjJFZGdlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZVNoYXBlLFxuICAgICAgYjJNYXNzRGF0YSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJNYXNzRGF0YSxcbiAgICAgIGIyUG9seWdvblNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlBvbHlnb25TaGFwZSxcbiAgICAgIGIyU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUsXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcbiAgICAgIGIyTWF0MzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDMzLFxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXG4gICAgICBiMlRyYW5zZm9ybSA9IEJveDJELkNvbW1vbi5NYXRoLmIyVHJhbnNmb3JtLFxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxuICAgICAgYjJCb2R5ID0gQm94MkQuRHluYW1pY3MuYjJCb2R5LFxuICAgICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxuICAgICAgYjJDb250YWN0SW1wdWxzZSA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEltcHVsc2UsXG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLFxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXG4gICAgICBiMkRlYnVnRHJhdyA9IEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LFxuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gQm94MkQuRHluYW1pY3MuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLFxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxuICAgICAgYjJGaXh0dXJlID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlLFxuICAgICAgYjJGaXh0dXJlRGVmID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmLFxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcbiAgICAgIGIyVGltZVN0ZXAgPSBCb3gyRC5EeW5hbWljcy5iMlRpbWVTdGVwLFxuICAgICAgYjJXb3JsZCA9IEJveDJELkR5bmFtaWNzLmIyV29ybGQsXG4gICAgICBiMkFBQkIgPSBCb3gyRC5Db2xsaXNpb24uYjJBQUJCLFxuICAgICAgYjJCb3VuZCA9IEJveDJELkNvbGxpc2lvbi5iMkJvdW5kLFxuICAgICAgYjJCb3VuZFZhbHVlcyA9IEJveDJELkNvbGxpc2lvbi5iMkJvdW5kVmFsdWVzLFxuICAgICAgYjJDb2xsaXNpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24sXG4gICAgICBiMkNvbnRhY3RJRCA9IEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RJRCxcbiAgICAgIGIyQ29udGFjdFBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdFBvaW50LFxuICAgICAgYjJEaXN0YW5jZSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLFxuICAgICAgYjJEaXN0YW5jZUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VJbnB1dCxcbiAgICAgIGIyRGlzdGFuY2VPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZU91dHB1dCxcbiAgICAgIGIyRGlzdGFuY2VQcm94eSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlUHJveHksXG4gICAgICBiMkR5bmFtaWNUcmVlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWUsXG4gICAgICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSxcbiAgICAgIGIyRHluYW1pY1RyZWVOb2RlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVOb2RlLFxuICAgICAgYjJEeW5hbWljVHJlZVBhaXIgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZVBhaXIsXG4gICAgICBiMk1hbmlmb2xkID0gQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGQsXG4gICAgICBiMk1hbmlmb2xkUG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZFBvaW50LFxuICAgICAgYjJQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMlBvaW50LFxuICAgICAgYjJSYXlDYXN0SW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0SW5wdXQsXG4gICAgICBiMlJheUNhc3RPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0T3V0cHV0LFxuICAgICAgYjJTZWdtZW50ID0gQm94MkQuQ29sbGlzaW9uLmIyU2VnbWVudCxcbiAgICAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uID0gQm94MkQuQ29sbGlzaW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uLFxuICAgICAgYjJTaW1wbGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleCxcbiAgICAgIGIyU2ltcGxleENhY2hlID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleENhY2hlLFxuICAgICAgYjJTaW1wbGV4VmVydGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleFZlcnRleCxcbiAgICAgIGIyVGltZU9mSW1wYWN0ID0gQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LFxuICAgICAgYjJUT0lJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlRPSUlucHV0LFxuICAgICAgYjJXb3JsZE1hbmlmb2xkID0gQm94MkQuQ29sbGlzaW9uLmIyV29ybGRNYW5pZm9sZCxcbiAgICAgIENsaXBWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uQ2xpcFZlcnRleCxcbiAgICAgIEZlYXR1cmVzID0gQm94MkQuQ29sbGlzaW9uLkZlYXR1cmVzLFxuICAgICAgSUJyb2FkUGhhc2UgPSBCb3gyRC5Db2xsaXNpb24uSUJyb2FkUGhhc2U7XG5cbiAgIEJveDJELmluaGVyaXQoYjJDaXJjbGVTaGFwZSwgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlKTtcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUucHJvdG90eXBlO1xuICAgYjJDaXJjbGVTaGFwZS5iMkNpcmNsZVNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubV9wID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcyA9IG5ldyBiMkNpcmNsZVNoYXBlKCk7XG4gICAgICBzLlNldCh0aGlzKTtcbiAgICAgIHJldHVybiBzO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuU2V0LmNhbGwodGhpcywgb3RoZXIpO1xuICAgICAgaWYgKEJveDJELmlzKG90aGVyLCBiMkNpcmNsZVNoYXBlKSkge1xuICAgICAgICAgdmFyIG90aGVyMiA9IChvdGhlciBpbnN0YW5jZW9mIGIyQ2lyY2xlU2hhcGUgPyBvdGhlciA6IG51bGwpO1xuICAgICAgICAgdGhpcy5tX3AuU2V0VihvdGhlcjIubV9wKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLlRlc3RQb2ludCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIHApIHtcbiAgICAgIHZhciB0TWF0ID0gdHJhbnNmb3JtLlI7XG4gICAgICB2YXIgZFggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9wLnkpO1xuICAgICAgdmFyIGRZID0gdHJhbnNmb3JtLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0aGlzLm1fcC54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fcC55KTtcbiAgICAgIGRYID0gcC54IC0gZFg7XG4gICAgICBkWSA9IHAueSAtIGRZO1xuICAgICAgcmV0dXJuIChkWCAqIGRYICsgZFkgKiBkWSkgPD0gdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XG4gICB9XG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5SYXlDYXN0ID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIHRNYXQgPSB0cmFuc2Zvcm0uUjtcbiAgICAgIHZhciBwb3NpdGlvblggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9wLnkpO1xuICAgICAgdmFyIHBvc2l0aW9uWSA9IHRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX3AueCArIHRNYXQuY29sMi55ICogdGhpcy5tX3AueSk7XG4gICAgICB2YXIgc1ggPSBpbnB1dC5wMS54IC0gcG9zaXRpb25YO1xuICAgICAgdmFyIHNZID0gaW5wdXQucDEueSAtIHBvc2l0aW9uWTtcbiAgICAgIHZhciBiID0gKHNYICogc1ggKyBzWSAqIHNZKSAtIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xuICAgICAgdmFyIHJYID0gaW5wdXQucDIueCAtIGlucHV0LnAxLng7XG4gICAgICB2YXIgclkgPSBpbnB1dC5wMi55IC0gaW5wdXQucDEueTtcbiAgICAgIHZhciBjID0gKHNYICogclggKyBzWSAqIHJZKTtcbiAgICAgIHZhciByciA9IChyWCAqIHJYICsgclkgKiByWSk7XG4gICAgICB2YXIgc2lnbWEgPSBjICogYyAtIHJyICogYjtcbiAgICAgIGlmIChzaWdtYSA8IDAuMCB8fCByciA8IE51bWJlci5NSU5fVkFMVUUpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gKC0oYyArIE1hdGguc3FydChzaWdtYSkpKTtcbiAgICAgIGlmICgwLjAgPD0gYSAmJiBhIDw9IGlucHV0Lm1heEZyYWN0aW9uICogcnIpIHtcbiAgICAgICAgIGEgLz0gcnI7XG4gICAgICAgICBvdXRwdXQuZnJhY3Rpb24gPSBhO1xuICAgICAgICAgb3V0cHV0Lm5vcm1hbC54ID0gc1ggKyBhICogclg7XG4gICAgICAgICBvdXRwdXQubm9ybWFsLnkgPSBzWSArIGEgKiByWTtcbiAgICAgICAgIG91dHB1dC5ub3JtYWwuTm9ybWFsaXplKCk7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIHRNYXQgPSB0cmFuc2Zvcm0uUjtcbiAgICAgIHZhciBwWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3AueCArIHRNYXQuY29sMi54ICogdGhpcy5tX3AueSk7XG4gICAgICB2YXIgcFkgPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubV9wLnkpO1xuICAgICAgYWFiYi5sb3dlckJvdW5kLlNldChwWCAtIHRoaXMubV9yYWRpdXMsIHBZIC0gdGhpcy5tX3JhZGl1cyk7XG4gICAgICBhYWJiLnVwcGVyQm91bmQuU2V0KHBYICsgdGhpcy5tX3JhZGl1cywgcFkgKyB0aGlzLm1fcmFkaXVzKTtcbiAgIH1cbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XG4gICAgICBpZiAoZGVuc2l0eSA9PT0gdW5kZWZpbmVkKSBkZW5zaXR5ID0gMDtcbiAgICAgIG1hc3NEYXRhLm1hc3MgPSBkZW5zaXR5ICogYjJTZXR0aW5ncy5iMl9waSAqIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xuICAgICAgbWFzc0RhdGEuY2VudGVyLlNldFYodGhpcy5tX3ApO1xuICAgICAgbWFzc0RhdGEuSSA9IG1hc3NEYXRhLm1hc3MgKiAoMC41ICogdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXMgKyAodGhpcy5tX3AueCAqIHRoaXMubV9wLnggKyB0aGlzLm1fcC55ICogdGhpcy5tX3AueSkpO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuQ29tcHV0ZVN1Ym1lcmdlZEFyZWEgPSBmdW5jdGlvbiAobm9ybWFsLCBvZmZzZXQsIHhmLCBjKSB7XG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XG4gICAgICB2YXIgcCA9IGIyTWF0aC5NdWxYKHhmLCB0aGlzLm1fcCk7XG4gICAgICB2YXIgbCA9ICgtKGIyTWF0aC5Eb3Qobm9ybWFsLCBwKSAtIG9mZnNldCkpO1xuICAgICAgaWYgKGwgPCAoLXRoaXMubV9yYWRpdXMpICsgTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAobCA+IHRoaXMubV9yYWRpdXMpIHtcbiAgICAgICAgIGMuU2V0VihwKTtcbiAgICAgICAgIHJldHVybiBNYXRoLlBJICogdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XG4gICAgICB9XG4gICAgICB2YXIgcjIgPSB0aGlzLm1fcmFkaXVzICogdGhpcy5tX3JhZGl1cztcbiAgICAgIHZhciBsMiA9IGwgKiBsO1xuICAgICAgdmFyIGFyZWEgPSByMiAqIChNYXRoLmFzaW4obCAvIHRoaXMubV9yYWRpdXMpICsgTWF0aC5QSSAvIDIpICsgbCAqIE1hdGguc3FydChyMiAtIGwyKTtcbiAgICAgIHZhciBjb20gPSAoLTIgLyAzICogTWF0aC5wb3cocjIgLSBsMiwgMS41KSAvIGFyZWEpO1xuICAgICAgYy54ID0gcC54ICsgbm9ybWFsLnggKiBjb207XG4gICAgICBjLnkgPSBwLnkgKyBub3JtYWwueSAqIGNvbTtcbiAgICAgIHJldHVybiBhcmVhO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuR2V0TG9jYWxQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fcDtcbiAgIH1cbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLlNldExvY2FsUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgIHRoaXMubV9wLlNldFYocG9zaXRpb24pO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuR2V0UmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9yYWRpdXM7XG4gICB9XG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5TZXRSYWRpdXMgPSBmdW5jdGlvbiAocmFkaXVzKSB7XG4gICAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHJhZGl1cyA9IDA7XG4gICAgICB0aGlzLm1fcmFkaXVzID0gcmFkaXVzO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuYjJDaXJjbGVTaGFwZSA9IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgICAgIGlmIChyYWRpdXMgPT09IHVuZGVmaW5lZCkgcmFkaXVzID0gMDtcbiAgICAgIHRoaXMuX19zdXBlci5iMlNoYXBlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV9jaXJjbGVTaGFwZTtcbiAgICAgIHRoaXMubV9yYWRpdXMgPSByYWRpdXM7XG4gICB9XG4gICBiMkVkZ2VDaGFpbkRlZi5iMkVkZ2VDaGFpbkRlZiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJFZGdlQ2hhaW5EZWYucHJvdG90eXBlLmIyRWRnZUNoYWluRGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICB0aGlzLmlzQUxvb3AgPSB0cnVlO1xuICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMkVkZ2VTaGFwZSwgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlKTtcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLnByb3RvdHlwZTtcbiAgIGIyRWRnZVNoYXBlLmIyRWRnZVNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuc19zdXBwb3J0VmVjID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3YxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3YyID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2NvcmVWMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9jb3JlVjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2RpcmVjdGlvbiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2Nvcm5lckRpcjIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLlRlc3RQb2ludCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5SYXlDYXN0ID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgclggPSBpbnB1dC5wMi54IC0gaW5wdXQucDEueDtcbiAgICAgIHZhciByWSA9IGlucHV0LnAyLnkgLSBpbnB1dC5wMS55O1xuICAgICAgdE1hdCA9IHRyYW5zZm9ybS5SO1xuICAgICAgdmFyIHYxWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3YxLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV92MS55KTtcbiAgICAgIHZhciB2MVkgPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV92MS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fdjEueSk7XG4gICAgICB2YXIgblggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV92Mi54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fdjIueSkgLSB2MVk7XG4gICAgICB2YXIgblkgPSAoLSh0cmFuc2Zvcm0ucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV92Mi54ICsgdE1hdC5jb2wyLnggKiB0aGlzLm1fdjIueSkgLSB2MVgpKTtcbiAgICAgIHZhciBrX3Nsb3AgPSAxMDAuMCAqIE51bWJlci5NSU5fVkFMVUU7XG4gICAgICB2YXIgZGVub20gPSAoLShyWCAqIG5YICsgclkgKiBuWSkpO1xuICAgICAgaWYgKGRlbm9tID4ga19zbG9wKSB7XG4gICAgICAgICB2YXIgYlggPSBpbnB1dC5wMS54IC0gdjFYO1xuICAgICAgICAgdmFyIGJZID0gaW5wdXQucDEueSAtIHYxWTtcbiAgICAgICAgIHZhciBhID0gKGJYICogblggKyBiWSAqIG5ZKTtcbiAgICAgICAgIGlmICgwLjAgPD0gYSAmJiBhIDw9IGlucHV0Lm1heEZyYWN0aW9uICogZGVub20pIHtcbiAgICAgICAgICAgIHZhciBtdTIgPSAoLXJYICogYlkpICsgclkgKiBiWDtcbiAgICAgICAgICAgIGlmICgoLWtfc2xvcCAqIGRlbm9tKSA8PSBtdTIgJiYgbXUyIDw9IGRlbm9tICogKDEuMCArIGtfc2xvcCkpIHtcbiAgICAgICAgICAgICAgIGEgLz0gZGVub207XG4gICAgICAgICAgICAgICBvdXRwdXQuZnJhY3Rpb24gPSBhO1xuICAgICAgICAgICAgICAgdmFyIG5MZW4gPSBNYXRoLnNxcnQoblggKiBuWCArIG5ZICogblkpO1xuICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbC54ID0gblggLyBuTGVuO1xuICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbC55ID0gblkgLyBuTGVuO1xuICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuQ29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAoYWFiYiwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgdE1hdCA9IHRyYW5zZm9ybS5SO1xuICAgICAgdmFyIHYxWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3YxLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV92MS55KTtcbiAgICAgIHZhciB2MVkgPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV92MS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fdjEueSk7XG4gICAgICB2YXIgdjJYID0gdHJhbnNmb3JtLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0aGlzLm1fdjIueCArIHRNYXQuY29sMi54ICogdGhpcy5tX3YyLnkpO1xuICAgICAgdmFyIHYyWSA9IHRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX3YyLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubV92Mi55KTtcbiAgICAgIGlmICh2MVggPCB2MlgpIHtcbiAgICAgICAgIGFhYmIubG93ZXJCb3VuZC54ID0gdjFYO1xuICAgICAgICAgYWFiYi51cHBlckJvdW5kLnggPSB2Mlg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIGFhYmIubG93ZXJCb3VuZC54ID0gdjJYO1xuICAgICAgICAgYWFiYi51cHBlckJvdW5kLnggPSB2MVg7XG4gICAgICB9XG4gICAgICBpZiAodjFZIDwgdjJZKSB7XG4gICAgICAgICBhYWJiLmxvd2VyQm91bmQueSA9IHYxWTtcbiAgICAgICAgIGFhYmIudXBwZXJCb3VuZC55ID0gdjJZO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBhYWJiLmxvd2VyQm91bmQueSA9IHYyWTtcbiAgICAgICAgIGFhYmIudXBwZXJCb3VuZC55ID0gdjFZO1xuICAgICAgfVxuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XG4gICAgICBpZiAoZGVuc2l0eSA9PT0gdW5kZWZpbmVkKSBkZW5zaXR5ID0gMDtcbiAgICAgIG1hc3NEYXRhLm1hc3MgPSAwO1xuICAgICAgbWFzc0RhdGEuY2VudGVyLlNldFYodGhpcy5tX3YxKTtcbiAgICAgIG1hc3NEYXRhLkkgPSAwO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVTdWJtZXJnZWRBcmVhID0gZnVuY3Rpb24gKG5vcm1hbCwgb2Zmc2V0LCB4ZiwgYykge1xuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xuICAgICAgdmFyIHYwID0gbmV3IGIyVmVjMihub3JtYWwueCAqIG9mZnNldCwgbm9ybWFsLnkgKiBvZmZzZXQpO1xuICAgICAgdmFyIHYxID0gYjJNYXRoLk11bFgoeGYsIHRoaXMubV92MSk7XG4gICAgICB2YXIgdjIgPSBiMk1hdGguTXVsWCh4ZiwgdGhpcy5tX3YyKTtcbiAgICAgIHZhciBkMSA9IGIyTWF0aC5Eb3Qobm9ybWFsLCB2MSkgLSBvZmZzZXQ7XG4gICAgICB2YXIgZDIgPSBiMk1hdGguRG90KG5vcm1hbCwgdjIpIC0gb2Zmc2V0O1xuICAgICAgaWYgKGQxID4gMCkge1xuICAgICAgICAgaWYgKGQyID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYxLnggPSAoLWQyIC8gKGQxIC0gZDIpICogdjEueCkgKyBkMSAvIChkMSAtIGQyKSAqIHYyLng7XG4gICAgICAgICAgICB2MS55ID0gKC1kMiAvIChkMSAtIGQyKSAqIHYxLnkpICsgZDEgLyAoZDEgLSBkMikgKiB2Mi55O1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBpZiAoZDIgPiAwKSB7XG4gICAgICAgICAgICB2Mi54ID0gKC1kMiAvIChkMSAtIGQyKSAqIHYxLngpICsgZDEgLyAoZDEgLSBkMikgKiB2Mi54O1xuICAgICAgICAgICAgdjIueSA9ICgtZDIgLyAoZDEgLSBkMikgKiB2MS55KSArIGQxIC8gKGQxIC0gZDIpICogdjIueTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge31cbiAgICAgIH1cbiAgICAgIGMueCA9ICh2MC54ICsgdjEueCArIHYyLngpIC8gMztcbiAgICAgIGMueSA9ICh2MC55ICsgdjEueSArIHYyLnkpIC8gMztcbiAgICAgIHJldHVybiAwLjUgKiAoKHYxLnggLSB2MC54KSAqICh2Mi55IC0gdjAueSkgLSAodjEueSAtIHYwLnkpICogKHYyLnggLSB2MC54KSk7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGg7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0VmVydGV4MSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdjE7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0VmVydGV4MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdjI7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0Q29yZVZlcnRleDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2NvcmVWMTtcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5HZXRDb3JlVmVydGV4MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY29yZVYyO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldE5vcm1hbFZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbm9ybWFsO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldERpcmVjdGlvblZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZGlyZWN0aW9uO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldENvcm5lcjFWZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2Nvcm5lckRpcjE7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0Q29ybmVyMlZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY29ybmVyRGlyMjtcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5Db3JuZXIxSXNDb252ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2Nvcm5lckNvbnZleDE7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuQ29ybmVyMklzQ29udmV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9jb3JuZXJDb252ZXgyO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldEZpcnN0VmVydGV4ID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICB2YXIgdE1hdCA9IHhmLlI7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMih4Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX2NvcmVWMS54ICsgdE1hdC5jb2wyLnggKiB0aGlzLm1fY29yZVYxLnkpLCB4Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX2NvcmVWMS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fY29yZVYxLnkpKTtcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5HZXROZXh0RWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbmV4dEVkZ2U7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0UHJldkVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3ByZXZFZGdlO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLlN1cHBvcnQgPSBmdW5jdGlvbiAoeGYsIGRYLCBkWSkge1xuICAgICAgaWYgKGRYID09PSB1bmRlZmluZWQpIGRYID0gMDtcbiAgICAgIGlmIChkWSA9PT0gdW5kZWZpbmVkKSBkWSA9IDA7XG4gICAgICB2YXIgdE1hdCA9IHhmLlI7XG4gICAgICB2YXIgdjFYID0geGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9jb3JlVjEueCArIHRNYXQuY29sMi54ICogdGhpcy5tX2NvcmVWMS55KTtcbiAgICAgIHZhciB2MVkgPSB4Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX2NvcmVWMS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fY29yZVYxLnkpO1xuICAgICAgdmFyIHYyWCA9IHhmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0aGlzLm1fY29yZVYyLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9jb3JlVjIueSk7XG4gICAgICB2YXIgdjJZID0geGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV9jb3JlVjIueCArIHRNYXQuY29sMi55ICogdGhpcy5tX2NvcmVWMi55KTtcbiAgICAgIGlmICgodjFYICogZFggKyB2MVkgKiBkWSkgPiAodjJYICogZFggKyB2MlkgKiBkWSkpIHtcbiAgICAgICAgIHRoaXMuc19zdXBwb3J0VmVjLnggPSB2MVg7XG4gICAgICAgICB0aGlzLnNfc3VwcG9ydFZlYy55ID0gdjFZO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLnNfc3VwcG9ydFZlYy54ID0gdjJYO1xuICAgICAgICAgdGhpcy5zX3N1cHBvcnRWZWMueSA9IHYyWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNfc3VwcG9ydFZlYztcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5iMkVkZ2VTaGFwZSA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMlNoYXBlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV9lZGdlU2hhcGU7XG4gICAgICB0aGlzLm1fcHJldkVkZ2UgPSBudWxsO1xuICAgICAgdGhpcy5tX25leHRFZGdlID0gbnVsbDtcbiAgICAgIHRoaXMubV92MSA9IHYxO1xuICAgICAgdGhpcy5tX3YyID0gdjI7XG4gICAgICB0aGlzLm1fZGlyZWN0aW9uLlNldCh0aGlzLm1fdjIueCAtIHRoaXMubV92MS54LCB0aGlzLm1fdjIueSAtIHRoaXMubV92MS55KTtcbiAgICAgIHRoaXMubV9sZW5ndGggPSB0aGlzLm1fZGlyZWN0aW9uLk5vcm1hbGl6ZSgpO1xuICAgICAgdGhpcy5tX25vcm1hbC5TZXQodGhpcy5tX2RpcmVjdGlvbi55LCAoLXRoaXMubV9kaXJlY3Rpb24ueCkpO1xuICAgICAgdGhpcy5tX2NvcmVWMS5TZXQoKC1iMlNldHRpbmdzLmIyX3RvaVNsb3AgKiAodGhpcy5tX25vcm1hbC54IC0gdGhpcy5tX2RpcmVjdGlvbi54KSkgKyB0aGlzLm1fdjEueCwgKC1iMlNldHRpbmdzLmIyX3RvaVNsb3AgKiAodGhpcy5tX25vcm1hbC55IC0gdGhpcy5tX2RpcmVjdGlvbi55KSkgKyB0aGlzLm1fdjEueSk7XG4gICAgICB0aGlzLm1fY29yZVYyLlNldCgoLWIyU2V0dGluZ3MuYjJfdG9pU2xvcCAqICh0aGlzLm1fbm9ybWFsLnggKyB0aGlzLm1fZGlyZWN0aW9uLngpKSArIHRoaXMubV92Mi54LCAoLWIyU2V0dGluZ3MuYjJfdG9pU2xvcCAqICh0aGlzLm1fbm9ybWFsLnkgKyB0aGlzLm1fZGlyZWN0aW9uLnkpKSArIHRoaXMubV92Mi55KTtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIxID0gdGhpcy5tX25vcm1hbDtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIyLlNldCgoLXRoaXMubV9ub3JtYWwueCksICgtdGhpcy5tX25vcm1hbC55KSk7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuU2V0UHJldkVkZ2UgPSBmdW5jdGlvbiAoZWRnZSwgY29yZSwgY29ybmVyRGlyLCBjb252ZXgpIHtcbiAgICAgIHRoaXMubV9wcmV2RWRnZSA9IGVkZ2U7XG4gICAgICB0aGlzLm1fY29yZVYxID0gY29yZTtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIxID0gY29ybmVyRGlyO1xuICAgICAgdGhpcy5tX2Nvcm5lckNvbnZleDEgPSBjb252ZXg7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuU2V0TmV4dEVkZ2UgPSBmdW5jdGlvbiAoZWRnZSwgY29yZSwgY29ybmVyRGlyLCBjb252ZXgpIHtcbiAgICAgIHRoaXMubV9uZXh0RWRnZSA9IGVkZ2U7XG4gICAgICB0aGlzLm1fY29yZVYyID0gY29yZTtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIyID0gY29ybmVyRGlyO1xuICAgICAgdGhpcy5tX2Nvcm5lckNvbnZleDIgPSBjb252ZXg7XG4gICB9XG4gICBiMk1hc3NEYXRhLmIyTWFzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1hc3MgPSAwLjA7XG4gICAgICB0aGlzLmNlbnRlciA9IG5ldyBiMlZlYzIoMCwgMCk7XG4gICAgICB0aGlzLkkgPSAwLjA7XG4gICB9O1xuICAgQm94MkQuaW5oZXJpdChiMlBvbHlnb25TaGFwZSwgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlKTtcbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLnByb3RvdHlwZTtcbiAgIGIyUG9seWdvblNoYXBlLmIyUG9seWdvblNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICBzLlNldCh0aGlzKTtcbiAgICAgIHJldHVybiBzO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgdGhpcy5fX3N1cGVyLlNldC5jYWxsKHRoaXMsIG90aGVyKTtcbiAgICAgIGlmIChCb3gyRC5pcyhvdGhlciwgYjJQb2x5Z29uU2hhcGUpKSB7XG4gICAgICAgICB2YXIgb3RoZXIyID0gKG90aGVyIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyBvdGhlciA6IG51bGwpO1xuICAgICAgICAgdGhpcy5tX2NlbnRyb2lkLlNldFYob3RoZXIyLm1fY2VudHJvaWQpO1xuICAgICAgICAgdGhpcy5tX3ZlcnRleENvdW50ID0gb3RoZXIyLm1fdmVydGV4Q291bnQ7XG4gICAgICAgICB0aGlzLlJlc2VydmUodGhpcy5tX3ZlcnRleENvdW50KTtcbiAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1tpXS5TZXRWKG90aGVyMi5tX3ZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWxzW2ldLlNldFYob3RoZXIyLm1fbm9ybWFsc1tpXSk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNBcnJheSA9IGZ1bmN0aW9uICh2ZXJ0aWNlcywgdmVydGV4Q291bnQpIHtcbiAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PT0gdW5kZWZpbmVkKSB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICB2YXIgdiA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgIHRWZWM7XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICB0VmVjID0gdmVydGljZXNbaV07XG4gICAgICAgICB2LnB1c2godFZlYyk7XG4gICAgICB9XG4gICAgICB0aGlzLlNldEFzVmVjdG9yKHYsIHZlcnRleENvdW50KTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLkFzQXJyYXkgPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50KSB7XG4gICAgICBpZiAodmVydGV4Q291bnQgPT09IHVuZGVmaW5lZCkgdmVydGV4Q291bnQgPSAwO1xuICAgICAgdmFyIHBvbHlnb25TaGFwZSA9IG5ldyBiMlBvbHlnb25TaGFwZSgpO1xuICAgICAgcG9seWdvblNoYXBlLlNldEFzQXJyYXkodmVydGljZXMsIHZlcnRleENvdW50KTtcbiAgICAgIHJldHVybiBwb2x5Z29uU2hhcGU7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNWZWN0b3IgPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50KSB7XG4gICAgICBpZiAodmVydGV4Q291bnQgPT09IHVuZGVmaW5lZCkgdmVydGV4Q291bnQgPSAwO1xuICAgICAgaWYgKHZlcnRleENvdW50ID09IDApIHZlcnRleENvdW50ID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydCgyIDw9IHZlcnRleENvdW50KTtcbiAgICAgIHRoaXMubV92ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xuICAgICAgdGhpcy5SZXNlcnZlKHZlcnRleENvdW50KTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyBpKyspIHtcbiAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1tpXS5TZXRWKHZlcnRpY2VzW2ldKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgIHZhciBpMSA9IHBhcnNlSW50KGkpO1xuICAgICAgICAgdmFyIGkyID0gcGFyc2VJbnQoaSArIDEgPCB0aGlzLm1fdmVydGV4Q291bnQgPyBpICsgMSA6IDApO1xuICAgICAgICAgdmFyIGVkZ2UgPSBiMk1hdGguU3VidHJhY3RWVih0aGlzLm1fdmVydGljZXNbaTJdLCB0aGlzLm1fdmVydGljZXNbaTFdKTtcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZWRnZS5MZW5ndGhTcXVhcmVkKCkgPiBOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgICAgIHRoaXMubV9ub3JtYWxzW2ldLlNldFYoYjJNYXRoLkNyb3NzVkYoZWRnZSwgMS4wKSk7XG4gICAgICAgICB0aGlzLm1fbm9ybWFsc1tpXS5Ob3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9jZW50cm9pZCA9IGIyUG9seWdvblNoYXBlLkNvbXB1dGVDZW50cm9pZCh0aGlzLm1fdmVydGljZXMsIHRoaXMubV92ZXJ0ZXhDb3VudCk7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5Bc1ZlY3RvciA9IGZ1bmN0aW9uICh2ZXJ0aWNlcywgdmVydGV4Q291bnQpIHtcbiAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PT0gdW5kZWZpbmVkKSB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICBwb2x5Z29uU2hhcGUuU2V0QXNWZWN0b3IodmVydGljZXMsIHZlcnRleENvdW50KTtcbiAgICAgIHJldHVybiBwb2x5Z29uU2hhcGU7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNCb3ggPSBmdW5jdGlvbiAoaHgsIGh5KSB7XG4gICAgICBpZiAoaHggPT09IHVuZGVmaW5lZCkgaHggPSAwO1xuICAgICAgaWYgKGh5ID09PSB1bmRlZmluZWQpIGh5ID0gMDtcbiAgICAgIHRoaXMubV92ZXJ0ZXhDb3VudCA9IDQ7XG4gICAgICB0aGlzLlJlc2VydmUoNCk7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMF0uU2V0KCgtaHgpLCAoLWh5KSk7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMV0uU2V0KGh4LCAoLWh5KSk7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMl0uU2V0KGh4LCBoeSk7XG4gICAgICB0aGlzLm1fdmVydGljZXNbM10uU2V0KCgtaHgpLCBoeSk7XG4gICAgICB0aGlzLm1fbm9ybWFsc1swXS5TZXQoMC4wLCAoLTEuMCkpO1xuICAgICAgdGhpcy5tX25vcm1hbHNbMV0uU2V0KDEuMCwgMC4wKTtcbiAgICAgIHRoaXMubV9ub3JtYWxzWzJdLlNldCgwLjAsIDEuMCk7XG4gICAgICB0aGlzLm1fbm9ybWFsc1szXS5TZXQoKC0xLjApLCAwLjApO1xuICAgICAgdGhpcy5tX2NlbnRyb2lkLlNldFplcm8oKTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLkFzQm94ID0gZnVuY3Rpb24gKGh4LCBoeSkge1xuICAgICAgaWYgKGh4ID09PSB1bmRlZmluZWQpIGh4ID0gMDtcbiAgICAgIGlmIChoeSA9PT0gdW5kZWZpbmVkKSBoeSA9IDA7XG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICBwb2x5Z29uU2hhcGUuU2V0QXNCb3goaHgsIGh5KTtcbiAgICAgIHJldHVybiBwb2x5Z29uU2hhcGU7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNPcmllbnRlZEJveCA9IGZ1bmN0aW9uIChoeCwgaHksIGNlbnRlciwgYW5nbGUpIHtcbiAgICAgIGlmIChoeCA9PT0gdW5kZWZpbmVkKSBoeCA9IDA7XG4gICAgICBpZiAoaHkgPT09IHVuZGVmaW5lZCkgaHkgPSAwO1xuICAgICAgaWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSBjZW50ZXIgPSBudWxsO1xuICAgICAgaWYgKGFuZ2xlID09PSB1bmRlZmluZWQpIGFuZ2xlID0gMC4wO1xuICAgICAgdGhpcy5tX3ZlcnRleENvdW50ID0gNDtcbiAgICAgIHRoaXMuUmVzZXJ2ZSg0KTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1swXS5TZXQoKC1oeCksICgtaHkpKTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1sxXS5TZXQoaHgsICgtaHkpKTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1syXS5TZXQoaHgsIGh5KTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1szXS5TZXQoKC1oeCksIGh5KTtcbiAgICAgIHRoaXMubV9ub3JtYWxzWzBdLlNldCgwLjAsICgtMS4wKSk7XG4gICAgICB0aGlzLm1fbm9ybWFsc1sxXS5TZXQoMS4wLCAwLjApO1xuICAgICAgdGhpcy5tX25vcm1hbHNbMl0uU2V0KDAuMCwgMS4wKTtcbiAgICAgIHRoaXMubV9ub3JtYWxzWzNdLlNldCgoLTEuMCksIDAuMCk7XG4gICAgICB0aGlzLm1fY2VudHJvaWQgPSBjZW50ZXI7XG4gICAgICB2YXIgeGYgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcbiAgICAgIHhmLnBvc2l0aW9uID0gY2VudGVyO1xuICAgICAgeGYuUi5TZXQoYW5nbGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW2ldID0gYjJNYXRoLk11bFgoeGYsIHRoaXMubV92ZXJ0aWNlc1tpXSk7XG4gICAgICAgICB0aGlzLm1fbm9ybWFsc1tpXSA9IGIyTWF0aC5NdWxNVih4Zi5SLCB0aGlzLm1fbm9ybWFsc1tpXSk7XG4gICAgICB9XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5Bc09yaWVudGVkQm94ID0gZnVuY3Rpb24gKGh4LCBoeSwgY2VudGVyLCBhbmdsZSkge1xuICAgICAgaWYgKGh4ID09PSB1bmRlZmluZWQpIGh4ID0gMDtcbiAgICAgIGlmIChoeSA9PT0gdW5kZWZpbmVkKSBoeSA9IDA7XG4gICAgICBpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIGNlbnRlciA9IG51bGw7XG4gICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkgYW5nbGUgPSAwLjA7XG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICBwb2x5Z29uU2hhcGUuU2V0QXNPcmllbnRlZEJveChoeCwgaHksIGNlbnRlciwgYW5nbGUpO1xuICAgICAgcmV0dXJuIHBvbHlnb25TaGFwZTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5TZXRBc0VkZ2UgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICB0aGlzLm1fdmVydGV4Q291bnQgPSAyO1xuICAgICAgdGhpcy5SZXNlcnZlKDIpO1xuICAgICAgdGhpcy5tX3ZlcnRpY2VzWzBdLlNldFYodjEpO1xuICAgICAgdGhpcy5tX3ZlcnRpY2VzWzFdLlNldFYodjIpO1xuICAgICAgdGhpcy5tX2NlbnRyb2lkLnggPSAwLjUgKiAodjEueCArIHYyLngpO1xuICAgICAgdGhpcy5tX2NlbnRyb2lkLnkgPSAwLjUgKiAodjEueSArIHYyLnkpO1xuICAgICAgdGhpcy5tX25vcm1hbHNbMF0gPSBiMk1hdGguQ3Jvc3NWRihiMk1hdGguU3VidHJhY3RWVih2MiwgdjEpLCAxLjApO1xuICAgICAgdGhpcy5tX25vcm1hbHNbMF0uTm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm1fbm9ybWFsc1sxXS54ID0gKC10aGlzLm1fbm9ybWFsc1swXS54KTtcbiAgICAgIHRoaXMubV9ub3JtYWxzWzFdLnkgPSAoLXRoaXMubV9ub3JtYWxzWzBdLnkpO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUuQXNFZGdlID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgdmFyIHBvbHlnb25TaGFwZSA9IG5ldyBiMlBvbHlnb25TaGFwZSgpO1xuICAgICAgcG9seWdvblNoYXBlLlNldEFzRWRnZSh2MSwgdjIpO1xuICAgICAgcmV0dXJuIHBvbHlnb25TaGFwZTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5UZXN0UG9pbnQgPSBmdW5jdGlvbiAoeGYsIHApIHtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdmFyIHRNYXQgPSB4Zi5SO1xuICAgICAgdmFyIHRYID0gcC54IC0geGYucG9zaXRpb24ueDtcbiAgICAgIHZhciB0WSA9IHAueSAtIHhmLnBvc2l0aW9uLnk7XG4gICAgICB2YXIgcExvY2FsWCA9ICh0WCAqIHRNYXQuY29sMS54ICsgdFkgKiB0TWF0LmNvbDEueSk7XG4gICAgICB2YXIgcExvY2FsWSA9ICh0WCAqIHRNYXQuY29sMi54ICsgdFkgKiB0TWF0LmNvbDIueSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV92ZXJ0ZXhDb3VudDsgKytpKSB7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX3ZlcnRpY2VzW2ldO1xuICAgICAgICAgdFggPSBwTG9jYWxYIC0gdFZlYy54O1xuICAgICAgICAgdFkgPSBwTG9jYWxZIC0gdFZlYy55O1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9ub3JtYWxzW2ldO1xuICAgICAgICAgdmFyIGRvdCA9ICh0VmVjLnggKiB0WCArIHRWZWMueSAqIHRZKTtcbiAgICAgICAgIGlmIChkb3QgPiAwLjApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgbG93ZXIgPSAwLjA7XG4gICAgICB2YXIgdXBwZXIgPSBpbnB1dC5tYXhGcmFjdGlvbjtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgdFkgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFZlYztcbiAgICAgIHRYID0gaW5wdXQucDEueCAtIHRyYW5zZm9ybS5wb3NpdGlvbi54O1xuICAgICAgdFkgPSBpbnB1dC5wMS55IC0gdHJhbnNmb3JtLnBvc2l0aW9uLnk7XG4gICAgICB0TWF0ID0gdHJhbnNmb3JtLlI7XG4gICAgICB2YXIgcDFYID0gKHRYICogdE1hdC5jb2wxLnggKyB0WSAqIHRNYXQuY29sMS55KTtcbiAgICAgIHZhciBwMVkgPSAodFggKiB0TWF0LmNvbDIueCArIHRZICogdE1hdC5jb2wyLnkpO1xuICAgICAgdFggPSBpbnB1dC5wMi54IC0gdHJhbnNmb3JtLnBvc2l0aW9uLng7XG4gICAgICB0WSA9IGlucHV0LnAyLnkgLSB0cmFuc2Zvcm0ucG9zaXRpb24ueTtcbiAgICAgIHRNYXQgPSB0cmFuc2Zvcm0uUjtcbiAgICAgIHZhciBwMlggPSAodFggKiB0TWF0LmNvbDEueCArIHRZICogdE1hdC5jb2wxLnkpO1xuICAgICAgdmFyIHAyWSA9ICh0WCAqIHRNYXQuY29sMi54ICsgdFkgKiB0TWF0LmNvbDIueSk7XG4gICAgICB2YXIgZFggPSBwMlggLSBwMVg7XG4gICAgICB2YXIgZFkgPSBwMlkgLSBwMVk7XG4gICAgICB2YXIgaW5kZXggPSBwYXJzZUludCgoLTEpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgIHRWZWMgPSB0aGlzLm1fdmVydGljZXNbaV07XG4gICAgICAgICB0WCA9IHRWZWMueCAtIHAxWDtcbiAgICAgICAgIHRZID0gdFZlYy55IC0gcDFZO1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9ub3JtYWxzW2ldO1xuICAgICAgICAgdmFyIG51bWVyYXRvciA9ICh0VmVjLnggKiB0WCArIHRWZWMueSAqIHRZKTtcbiAgICAgICAgIHZhciBkZW5vbWluYXRvciA9ICh0VmVjLnggKiBkWCArIHRWZWMueSAqIGRZKTtcbiAgICAgICAgIGlmIChkZW5vbWluYXRvciA9PSAwLjApIHtcbiAgICAgICAgICAgIGlmIChudW1lcmF0b3IgPCAwLjApIHtcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRlbm9taW5hdG9yIDwgMC4wICYmIG51bWVyYXRvciA8IGxvd2VyICogZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgIGxvd2VyID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZW5vbWluYXRvciA+IDAuMCAmJiBudW1lcmF0b3IgPCB1cHBlciAqIGRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICAgICB1cHBlciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKHVwcGVyIDwgbG93ZXIgLSBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgb3V0cHV0LmZyYWN0aW9uID0gbG93ZXI7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtLlI7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX25vcm1hbHNbaW5kZXhdO1xuICAgICAgICAgb3V0cHV0Lm5vcm1hbC54ID0gKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgb3V0cHV0Lm5vcm1hbC55ID0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuQ29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAoYWFiYiwgeGYpIHtcbiAgICAgIHZhciB0TWF0ID0geGYuUjtcbiAgICAgIHZhciB0VmVjID0gdGhpcy5tX3ZlcnRpY2VzWzBdO1xuICAgICAgdmFyIGxvd2VyWCA9IHhmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB2YXIgbG93ZXJZID0geGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHZhciB1cHBlclggPSBsb3dlclg7XG4gICAgICB2YXIgdXBwZXJZID0gbG93ZXJZO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgdFZlYyA9IHRoaXMubV92ZXJ0aWNlc1tpXTtcbiAgICAgICAgIHZhciB2WCA9IHhmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICAgICB2YXIgdlkgPSB4Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgbG93ZXJYID0gbG93ZXJYIDwgdlggPyBsb3dlclggOiB2WDtcbiAgICAgICAgIGxvd2VyWSA9IGxvd2VyWSA8IHZZID8gbG93ZXJZIDogdlk7XG4gICAgICAgICB1cHBlclggPSB1cHBlclggPiB2WCA/IHVwcGVyWCA6IHZYO1xuICAgICAgICAgdXBwZXJZID0gdXBwZXJZID4gdlkgPyB1cHBlclkgOiB2WTtcbiAgICAgIH1cbiAgICAgIGFhYmIubG93ZXJCb3VuZC54ID0gbG93ZXJYIC0gdGhpcy5tX3JhZGl1cztcbiAgICAgIGFhYmIubG93ZXJCb3VuZC55ID0gbG93ZXJZIC0gdGhpcy5tX3JhZGl1cztcbiAgICAgIGFhYmIudXBwZXJCb3VuZC54ID0gdXBwZXJYICsgdGhpcy5tX3JhZGl1cztcbiAgICAgIGFhYmIudXBwZXJCb3VuZC55ID0gdXBwZXJZICsgdGhpcy5tX3JhZGl1cztcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5Db21wdXRlTWFzcyA9IGZ1bmN0aW9uIChtYXNzRGF0YSwgZGVuc2l0eSkge1xuICAgICAgaWYgKGRlbnNpdHkgPT09IHVuZGVmaW5lZCkgZGVuc2l0eSA9IDA7XG4gICAgICBpZiAodGhpcy5tX3ZlcnRleENvdW50ID09IDIpIHtcbiAgICAgICAgIG1hc3NEYXRhLmNlbnRlci54ID0gMC41ICogKHRoaXMubV92ZXJ0aWNlc1swXS54ICsgdGhpcy5tX3ZlcnRpY2VzWzFdLngpO1xuICAgICAgICAgbWFzc0RhdGEuY2VudGVyLnkgPSAwLjUgKiAodGhpcy5tX3ZlcnRpY2VzWzBdLnkgKyB0aGlzLm1fdmVydGljZXNbMV0ueSk7XG4gICAgICAgICBtYXNzRGF0YS5tYXNzID0gMC4wO1xuICAgICAgICAgbWFzc0RhdGEuSSA9IDAuMDtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjZW50ZXJYID0gMC4wO1xuICAgICAgdmFyIGNlbnRlclkgPSAwLjA7XG4gICAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICAgIHZhciBJID0gMC4wO1xuICAgICAgdmFyIHAxWCA9IDAuMDtcbiAgICAgIHZhciBwMVkgPSAwLjA7XG4gICAgICB2YXIga19pbnYzID0gMS4wIC8gMy4wO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgdmFyIHAyID0gdGhpcy5tX3ZlcnRpY2VzW2ldO1xuICAgICAgICAgdmFyIHAzID0gaSArIDEgPCB0aGlzLm1fdmVydGV4Q291bnQgPyB0aGlzLm1fdmVydGljZXNbcGFyc2VJbnQoaSArIDEpXSA6IHRoaXMubV92ZXJ0aWNlc1swXTtcbiAgICAgICAgIHZhciBlMVggPSBwMi54IC0gcDFYO1xuICAgICAgICAgdmFyIGUxWSA9IHAyLnkgLSBwMVk7XG4gICAgICAgICB2YXIgZTJYID0gcDMueCAtIHAxWDtcbiAgICAgICAgIHZhciBlMlkgPSBwMy55IC0gcDFZO1xuICAgICAgICAgdmFyIEQgPSBlMVggKiBlMlkgLSBlMVkgKiBlMlg7XG4gICAgICAgICB2YXIgdHJpYW5nbGVBcmVhID0gMC41ICogRDthcmVhICs9IHRyaWFuZ2xlQXJlYTtcbiAgICAgICAgIGNlbnRlclggKz0gdHJpYW5nbGVBcmVhICoga19pbnYzICogKHAxWCArIHAyLnggKyBwMy54KTtcbiAgICAgICAgIGNlbnRlclkgKz0gdHJpYW5nbGVBcmVhICoga19pbnYzICogKHAxWSArIHAyLnkgKyBwMy55KTtcbiAgICAgICAgIHZhciBweCA9IHAxWDtcbiAgICAgICAgIHZhciBweSA9IHAxWTtcbiAgICAgICAgIHZhciBleDEgPSBlMVg7XG4gICAgICAgICB2YXIgZXkxID0gZTFZO1xuICAgICAgICAgdmFyIGV4MiA9IGUyWDtcbiAgICAgICAgIHZhciBleTIgPSBlMlk7XG4gICAgICAgICB2YXIgaW50eDIgPSBrX2ludjMgKiAoMC4yNSAqIChleDEgKiBleDEgKyBleDIgKiBleDEgKyBleDIgKiBleDIpICsgKHB4ICogZXgxICsgcHggKiBleDIpKSArIDAuNSAqIHB4ICogcHg7XG4gICAgICAgICB2YXIgaW50eTIgPSBrX2ludjMgKiAoMC4yNSAqIChleTEgKiBleTEgKyBleTIgKiBleTEgKyBleTIgKiBleTIpICsgKHB5ICogZXkxICsgcHkgKiBleTIpKSArIDAuNSAqIHB5ICogcHk7SSArPSBEICogKGludHgyICsgaW50eTIpO1xuICAgICAgfVxuICAgICAgbWFzc0RhdGEubWFzcyA9IGRlbnNpdHkgKiBhcmVhO1xuICAgICAgY2VudGVyWCAqPSAxLjAgLyBhcmVhO1xuICAgICAgY2VudGVyWSAqPSAxLjAgLyBhcmVhO1xuICAgICAgbWFzc0RhdGEuY2VudGVyLlNldChjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIG1hc3NEYXRhLkkgPSBkZW5zaXR5ICogSTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5Db21wdXRlU3VibWVyZ2VkQXJlYSA9IGZ1bmN0aW9uIChub3JtYWwsIG9mZnNldCwgeGYsIGMpIHtcbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBub3JtYWxMID0gYjJNYXRoLk11bFRNVih4Zi5SLCBub3JtYWwpO1xuICAgICAgdmFyIG9mZnNldEwgPSBvZmZzZXQgLSBiMk1hdGguRG90KG5vcm1hbCwgeGYucG9zaXRpb24pO1xuICAgICAgdmFyIGRlcHRocyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigpO1xuICAgICAgdmFyIGRpdmVDb3VudCA9IDA7XG4gICAgICB2YXIgaW50b0luZGV4ID0gcGFyc2VJbnQoKC0xKSk7XG4gICAgICB2YXIgb3V0b0luZGV4ID0gcGFyc2VJbnQoKC0xKSk7XG4gICAgICB2YXIgbGFzdFN1Ym1lcmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yIChpID0gMDtcbiAgICAgIGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgZGVwdGhzW2ldID0gYjJNYXRoLkRvdChub3JtYWxMLCB0aGlzLm1fdmVydGljZXNbaV0pIC0gb2Zmc2V0TDtcbiAgICAgICAgIHZhciBpc1N1Ym1lcmdlZCA9IGRlcHRoc1tpXSA8ICgtTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChpc1N1Ym1lcmdlZCkge1xuICAgICAgICAgICAgICAgaWYgKCFsYXN0U3VibWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgICBpbnRvSW5kZXggPSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgIGRpdmVDb3VudCsrO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICBpZiAobGFzdFN1Ym1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgb3V0b0luZGV4ID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICBkaXZlQ291bnQrKztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGxhc3RTdWJtZXJnZWQgPSBpc1N1Ym1lcmdlZDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGl2ZUNvdW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgICBpZiAobGFzdFN1Ym1lcmdlZCkge1xuICAgICAgICAgICAgdmFyIG1kID0gbmV3IGIyTWFzc0RhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuQ29tcHV0ZU1hc3MobWQsIDEpO1xuICAgICAgICAgICAgYy5TZXRWKGIyTWF0aC5NdWxYKHhmLCBtZC5jZW50ZXIpKTtcbiAgICAgICAgICAgIHJldHVybiBtZC5tYXNzO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgaWYgKGludG9JbmRleCA9PSAoLTEpKSB7XG4gICAgICAgICAgICBpbnRvSW5kZXggPSB0aGlzLm1fdmVydGV4Q291bnQgLSAxO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRvSW5kZXggPSB0aGlzLm1fdmVydGV4Q291bnQgLSAxO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgaW50b0luZGV4MiA9IHBhcnNlSW50KChpbnRvSW5kZXggKyAxKSAlIHRoaXMubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgb3V0b0luZGV4MiA9IHBhcnNlSW50KChvdXRvSW5kZXggKyAxKSAlIHRoaXMubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgaW50b0xhbWRkYSA9ICgwIC0gZGVwdGhzW2ludG9JbmRleF0pIC8gKGRlcHRoc1tpbnRvSW5kZXgyXSAtIGRlcHRoc1tpbnRvSW5kZXhdKTtcbiAgICAgIHZhciBvdXRvTGFtZGRhID0gKDAgLSBkZXB0aHNbb3V0b0luZGV4XSkgLyAoZGVwdGhzW291dG9JbmRleDJdIC0gZGVwdGhzW291dG9JbmRleF0pO1xuICAgICAgdmFyIGludG9WZWMgPSBuZXcgYjJWZWMyKHRoaXMubV92ZXJ0aWNlc1tpbnRvSW5kZXhdLnggKiAoMSAtIGludG9MYW1kZGEpICsgdGhpcy5tX3ZlcnRpY2VzW2ludG9JbmRleDJdLnggKiBpbnRvTGFtZGRhLCB0aGlzLm1fdmVydGljZXNbaW50b0luZGV4XS55ICogKDEgLSBpbnRvTGFtZGRhKSArIHRoaXMubV92ZXJ0aWNlc1tpbnRvSW5kZXgyXS55ICogaW50b0xhbWRkYSk7XG4gICAgICB2YXIgb3V0b1ZlYyA9IG5ldyBiMlZlYzIodGhpcy5tX3ZlcnRpY2VzW291dG9JbmRleF0ueCAqICgxIC0gb3V0b0xhbWRkYSkgKyB0aGlzLm1fdmVydGljZXNbb3V0b0luZGV4Ml0ueCAqIG91dG9MYW1kZGEsIHRoaXMubV92ZXJ0aWNlc1tvdXRvSW5kZXhdLnkgKiAoMSAtIG91dG9MYW1kZGEpICsgdGhpcy5tX3ZlcnRpY2VzW291dG9JbmRleDJdLnkgKiBvdXRvTGFtZGRhKTtcbiAgICAgIHZhciBhcmVhID0gMDtcbiAgICAgIHZhciBjZW50ZXIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB2YXIgcDIgPSB0aGlzLm1fdmVydGljZXNbaW50b0luZGV4Ml07XG4gICAgICB2YXIgcDM7XG4gICAgICBpID0gaW50b0luZGV4MjtcbiAgICAgIHdoaWxlIChpICE9IG91dG9JbmRleDIpIHtcbiAgICAgICAgIGkgPSAoaSArIDEpICUgdGhpcy5tX3ZlcnRleENvdW50O1xuICAgICAgICAgaWYgKGkgPT0gb3V0b0luZGV4MikgcDMgPSBvdXRvVmVjO1xuICAgICAgICAgZWxzZSBwMyA9IHRoaXMubV92ZXJ0aWNlc1tpXTtcbiAgICAgICAgIHZhciB0cmlhbmdsZUFyZWEgPSAwLjUgKiAoKHAyLnggLSBpbnRvVmVjLngpICogKHAzLnkgLSBpbnRvVmVjLnkpIC0gKHAyLnkgLSBpbnRvVmVjLnkpICogKHAzLnggLSBpbnRvVmVjLngpKTtcbiAgICAgICAgIGFyZWEgKz0gdHJpYW5nbGVBcmVhO1xuICAgICAgICAgY2VudGVyLnggKz0gdHJpYW5nbGVBcmVhICogKGludG9WZWMueCArIHAyLnggKyBwMy54KSAvIDM7XG4gICAgICAgICBjZW50ZXIueSArPSB0cmlhbmdsZUFyZWEgKiAoaW50b1ZlYy55ICsgcDIueSArIHAzLnkpIC8gMztcbiAgICAgICAgIHAyID0gcDM7XG4gICAgICB9XG4gICAgICBjZW50ZXIuTXVsdGlwbHkoMSAvIGFyZWEpO1xuICAgICAgYy5TZXRWKGIyTWF0aC5NdWxYKHhmLCBjZW50ZXIpKTtcbiAgICAgIHJldHVybiBhcmVhO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLkdldFZlcnRleENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0ZXhDb3VudDtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5HZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXM7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuR2V0Tm9ybWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbm9ybWFscztcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5HZXRTdXBwb3J0ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBiZXN0SW5kZXggPSAwO1xuICAgICAgdmFyIGJlc3RWYWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1swXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzWzBdLnkgKiBkLnk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubV92ZXJ0ZXhDb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1fdmVydGljZXNbaV0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1tpXS55ICogZC55O1xuICAgICAgICAgaWYgKHZhbHVlID4gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmVzdEluZGV4O1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLkdldFN1cHBvcnRWZXJ0ZXggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGJlc3RJbmRleCA9IDA7XG4gICAgICB2YXIgYmVzdFZhbHVlID0gdGhpcy5tX3ZlcnRpY2VzWzBdLnggKiBkLnggKyB0aGlzLm1fdmVydGljZXNbMF0ueSAqIGQueTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1tpXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzW2ldLnkgKiBkLnk7XG4gICAgICAgICBpZiAodmFsdWUgPiBiZXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGk7XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbYmVzdEluZGV4XTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5WYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5iMlBvbHlnb25TaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMlNoYXBlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV9wb2x5Z29uU2hhcGU7XG4gICAgICB0aGlzLm1fY2VudHJvaWQgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fdmVydGljZXMgPSBuZXcgVmVjdG9yKCk7XG4gICAgICB0aGlzLm1fbm9ybWFscyA9IG5ldyBWZWN0b3IoKTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5SZXNlcnZlID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgY291bnQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IHBhcnNlSW50KHRoaXMubV92ZXJ0aWNlcy5sZW5ndGgpOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW2ldID0gbmV3IGIyVmVjMigpO1xuICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0gPSBuZXcgYjJWZWMyKCk7XG4gICAgICB9XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5Db21wdXRlQ2VudHJvaWQgPSBmdW5jdGlvbiAodnMsIGNvdW50KSB7XG4gICAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgY291bnQgPSAwO1xuICAgICAgdmFyIGMgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICAgIHZhciBwMVggPSAwLjA7XG4gICAgICB2YXIgcDFZID0gMC4wO1xuICAgICAgdmFyIGludjMgPSAxLjAgLyAzLjA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgIHZhciBwMiA9IHZzW2ldO1xuICAgICAgICAgdmFyIHAzID0gaSArIDEgPCBjb3VudCA/IHZzW3BhcnNlSW50KGkgKyAxKV0gOiB2c1swXTtcbiAgICAgICAgIHZhciBlMVggPSBwMi54IC0gcDFYO1xuICAgICAgICAgdmFyIGUxWSA9IHAyLnkgLSBwMVk7XG4gICAgICAgICB2YXIgZTJYID0gcDMueCAtIHAxWDtcbiAgICAgICAgIHZhciBlMlkgPSBwMy55IC0gcDFZO1xuICAgICAgICAgdmFyIEQgPSAoZTFYICogZTJZIC0gZTFZICogZTJYKTtcbiAgICAgICAgIHZhciB0cmlhbmdsZUFyZWEgPSAwLjUgKiBEO2FyZWEgKz0gdHJpYW5nbGVBcmVhO1xuICAgICAgICAgYy54ICs9IHRyaWFuZ2xlQXJlYSAqIGludjMgKiAocDFYICsgcDIueCArIHAzLngpO1xuICAgICAgICAgYy55ICs9IHRyaWFuZ2xlQXJlYSAqIGludjMgKiAocDFZICsgcDIueSArIHAzLnkpO1xuICAgICAgfVxuICAgICAgYy54ICo9IDEuMCAvIGFyZWE7XG4gICAgICBjLnkgKj0gMS4wIC8gYXJlYTtcbiAgICAgIHJldHVybiBjO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUuQ29tcHV0ZU9CQiA9IGZ1bmN0aW9uIChvYmIsIHZzLCBjb3VudCkge1xuICAgICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIGNvdW50ID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBwID0gbmV3IFZlY3Rvcihjb3VudCArIDEpO1xuICAgICAgZm9yIChpID0gMDtcbiAgICAgIGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICBwW2ldID0gdnNbaV07XG4gICAgICB9XG4gICAgICBwW2NvdW50XSA9IHBbMF07XG4gICAgICB2YXIgbWluQXJlYSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBmb3IgKGkgPSAxO1xuICAgICAgaSA8PSBjb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgcm9vdCA9IHBbcGFyc2VJbnQoaSAtIDEpXTtcbiAgICAgICAgIHZhciB1eFggPSBwW2ldLnggLSByb290Lng7XG4gICAgICAgICB2YXIgdXhZID0gcFtpXS55IC0gcm9vdC55O1xuICAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydCh1eFggKiB1eFggKyB1eFkgKiB1eFkpO1xuICAgICAgICAgdXhYIC89IGxlbmd0aDtcbiAgICAgICAgIHV4WSAvPSBsZW5ndGg7XG4gICAgICAgICB2YXIgdXlYID0gKC11eFkpO1xuICAgICAgICAgdmFyIHV5WSA9IHV4WDtcbiAgICAgICAgIHZhciBsb3dlclggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgdmFyIGxvd2VyWSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICB2YXIgdXBwZXJYID0gKC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgIHZhciB1cHBlclkgPSAoLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgZFggPSBwW2pdLnggLSByb290Lng7XG4gICAgICAgICAgICB2YXIgZFkgPSBwW2pdLnkgLSByb290Lnk7XG4gICAgICAgICAgICB2YXIgclggPSAodXhYICogZFggKyB1eFkgKiBkWSk7XG4gICAgICAgICAgICB2YXIgclkgPSAodXlYICogZFggKyB1eVkgKiBkWSk7XG4gICAgICAgICAgICBpZiAoclggPCBsb3dlclgpIGxvd2VyWCA9IHJYO1xuICAgICAgICAgICAgaWYgKHJZIDwgbG93ZXJZKSBsb3dlclkgPSByWTtcbiAgICAgICAgICAgIGlmIChyWCA+IHVwcGVyWCkgdXBwZXJYID0gclg7XG4gICAgICAgICAgICBpZiAoclkgPiB1cHBlclkpIHVwcGVyWSA9IHJZO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGFyZWEgPSAodXBwZXJYIC0gbG93ZXJYKSAqICh1cHBlclkgLSBsb3dlclkpO1xuICAgICAgICAgaWYgKGFyZWEgPCAwLjk1ICogbWluQXJlYSkge1xuICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICBvYmIuUi5jb2wxLnggPSB1eFg7XG4gICAgICAgICAgICBvYmIuUi5jb2wxLnkgPSB1eFk7XG4gICAgICAgICAgICBvYmIuUi5jb2wyLnggPSB1eVg7XG4gICAgICAgICAgICBvYmIuUi5jb2wyLnkgPSB1eVk7XG4gICAgICAgICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIChsb3dlclggKyB1cHBlclgpO1xuICAgICAgICAgICAgdmFyIGNlbnRlclkgPSAwLjUgKiAobG93ZXJZICsgdXBwZXJZKTtcbiAgICAgICAgICAgIHZhciB0TWF0ID0gb2JiLlI7XG4gICAgICAgICAgICBvYmIuY2VudGVyLnggPSByb290LnggKyAodE1hdC5jb2wxLnggKiBjZW50ZXJYICsgdE1hdC5jb2wyLnggKiBjZW50ZXJZKTtcbiAgICAgICAgICAgIG9iYi5jZW50ZXIueSA9IHJvb3QueSArICh0TWF0LmNvbDEueSAqIGNlbnRlclggKyB0TWF0LmNvbDIueSAqIGNlbnRlclkpO1xuICAgICAgICAgICAgb2JiLmV4dGVudHMueCA9IDAuNSAqICh1cHBlclggLSBsb3dlclgpO1xuICAgICAgICAgICAgb2JiLmV4dGVudHMueSA9IDAuNSAqICh1cHBlclkgLSBsb3dlclkpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyUG9seWdvblNoYXBlLnNfbWF0ID0gbmV3IGIyTWF0MjIoKTtcbiAgIH0pO1xuICAgYjJTaGFwZS5iMlNoYXBlID0gZnVuY3Rpb24gKCkge307XG4gICBiMlNoYXBlLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICB9XG4gICBiMlNoYXBlLnByb3RvdHlwZS5TZXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIHRoaXMubV9yYWRpdXMgPSBvdGhlci5tX3JhZGl1cztcbiAgIH1cbiAgIGIyU2hhcGUucHJvdG90eXBlLkdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3R5cGU7XG4gICB9XG4gICBiMlNoYXBlLnByb3RvdHlwZS5UZXN0UG9pbnQgPSBmdW5jdGlvbiAoeGYsIHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyU2hhcGUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCwgdHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBiMlNoYXBlLnByb3RvdHlwZS5Db21wdXRlQUFCQiA9IGZ1bmN0aW9uIChhYWJiLCB4Zikge31cbiAgIGIyU2hhcGUucHJvdG90eXBlLkNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XG4gICAgICBpZiAoZGVuc2l0eSA9PT0gdW5kZWZpbmVkKSBkZW5zaXR5ID0gMDtcbiAgIH1cbiAgIGIyU2hhcGUucHJvdG90eXBlLkNvbXB1dGVTdWJtZXJnZWRBcmVhID0gZnVuY3Rpb24gKG5vcm1hbCwgb2Zmc2V0LCB4ZiwgYykge1xuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xuICAgICAgcmV0dXJuIDA7XG4gICB9XG4gICBiMlNoYXBlLlRlc3RPdmVybGFwID0gZnVuY3Rpb24gKHNoYXBlMSwgdHJhbnNmb3JtMSwgc2hhcGUyLCB0cmFuc2Zvcm0yKSB7XG4gICAgICB2YXIgaW5wdXQgPSBuZXcgYjJEaXN0YW5jZUlucHV0KCk7XG4gICAgICBpbnB1dC5wcm94eUEgPSBuZXcgYjJEaXN0YW5jZVByb3h5KCk7XG4gICAgICBpbnB1dC5wcm94eUEuU2V0KHNoYXBlMSk7XG4gICAgICBpbnB1dC5wcm94eUIgPSBuZXcgYjJEaXN0YW5jZVByb3h5KCk7XG4gICAgICBpbnB1dC5wcm94eUIuU2V0KHNoYXBlMik7XG4gICAgICBpbnB1dC50cmFuc2Zvcm1BID0gdHJhbnNmb3JtMTtcbiAgICAgIGlucHV0LnRyYW5zZm9ybUIgPSB0cmFuc2Zvcm0yO1xuICAgICAgaW5wdXQudXNlUmFkaWkgPSB0cnVlO1xuICAgICAgdmFyIHNpbXBsZXhDYWNoZSA9IG5ldyBiMlNpbXBsZXhDYWNoZSgpO1xuICAgICAgc2ltcGxleENhY2hlLmNvdW50ID0gMDtcbiAgICAgIHZhciBvdXRwdXQgPSBuZXcgYjJEaXN0YW5jZU91dHB1dCgpO1xuICAgICAgYjJEaXN0YW5jZS5EaXN0YW5jZShvdXRwdXQsIHNpbXBsZXhDYWNoZSwgaW5wdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dC5kaXN0YW5jZSA8IDEwLjAgKiBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgfVxuICAgYjJTaGFwZS5wcm90b3R5cGUuYjJTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV90eXBlID0gYjJTaGFwZS5lX3Vua25vd25TaGFwZTtcbiAgICAgIHRoaXMubV9yYWRpdXMgPSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX3Vua25vd25TaGFwZSA9IHBhcnNlSW50KCgtMSkpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmVfY2lyY2xlU2hhcGUgPSAwO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmVfcG9seWdvblNoYXBlID0gMTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX2VkZ2VTaGFwZSA9IDI7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUuZV9zaGFwZVR5cGVDb3VudCA9IDM7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUuZV9oaXRDb2xsaWRlID0gMTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX21pc3NDb2xsaWRlID0gMDtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX3N0YXJ0c0luc2lkZUNvbGxpZGUgPSBwYXJzZUludCgoLTEpKTtcbiAgIH0pO1xufSkoKTtcbihmdW5jdGlvbiAoKSB7XG4gICB2YXIgYjJDb2xvciA9IEJveDJELkNvbW1vbi5iMkNvbG9yLFxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxuICAgICAgYjJNYXQyMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MjIsXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcbiAgICAgIGIyU3dlZXAgPSBCb3gyRC5Db21tb24uTWF0aC5iMlN3ZWVwLFxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcbiAgICAgIGIyVmVjMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMztcblxuICAgYjJDb2xvci5iMkNvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fciA9IDA7XG4gICAgICB0aGlzLl9nID0gMDtcbiAgICAgIHRoaXMuX2IgPSAwO1xuICAgfTtcbiAgIGIyQ29sb3IucHJvdG90eXBlLmIyQ29sb3IgPSBmdW5jdGlvbiAocnIsIGdnLCBiYikge1xuICAgICAgaWYgKHJyID09PSB1bmRlZmluZWQpIHJyID0gMDtcbiAgICAgIGlmIChnZyA9PT0gdW5kZWZpbmVkKSBnZyA9IDA7XG4gICAgICBpZiAoYmIgPT09IHVuZGVmaW5lZCkgYmIgPSAwO1xuICAgICAgdGhpcy5fciA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAocnIsIDAuMCwgMS4wKSk7XG4gICAgICB0aGlzLl9nID0gQm94MkQucGFyc2VVSW50KDI1NSAqIGIyTWF0aC5DbGFtcChnZywgMC4wLCAxLjApKTtcbiAgICAgIHRoaXMuX2IgPSBCb3gyRC5wYXJzZVVJbnQoMjU1ICogYjJNYXRoLkNsYW1wKGJiLCAwLjAsIDEuMCkpO1xuICAgfVxuICAgYjJDb2xvci5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHJyLCBnZywgYmIpIHtcbiAgICAgIGlmIChyciA9PT0gdW5kZWZpbmVkKSByciA9IDA7XG4gICAgICBpZiAoZ2cgPT09IHVuZGVmaW5lZCkgZ2cgPSAwO1xuICAgICAgaWYgKGJiID09PSB1bmRlZmluZWQpIGJiID0gMDtcbiAgICAgIHRoaXMuX3IgPSBCb3gyRC5wYXJzZVVJbnQoMjU1ICogYjJNYXRoLkNsYW1wKHJyLCAwLjAsIDEuMCkpO1xuICAgICAgdGhpcy5fZyA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAoZ2csIDAuMCwgMS4wKSk7XG4gICAgICB0aGlzLl9iID0gQm94MkQucGFyc2VVSW50KDI1NSAqIGIyTWF0aC5DbGFtcChiYiwgMC4wLCAxLjApKTtcbiAgIH1cbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ3InLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHJyKSB7XG4gICAgICAgICBpZiAocnIgPT09IHVuZGVmaW5lZCkgcnIgPSAwO1xuICAgICAgICAgdGhpcy5fciA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAocnIsIDAuMCwgMS4wKSk7XG4gICAgICB9XG4gICB9KTtcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ2cnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGdnKSB7XG4gICAgICAgICBpZiAoZ2cgPT09IHVuZGVmaW5lZCkgZ2cgPSAwO1xuICAgICAgICAgdGhpcy5fZyA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAoZ2csIDAuMCwgMS4wKSk7XG4gICAgICB9XG4gICB9KTtcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ2InLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGJiKSB7XG4gICAgICAgICBpZiAoYmIgPT09IHVuZGVmaW5lZCkgYmIgPSAwO1xuICAgICAgICAgdGhpcy5fYiA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAoYmIsIDAuMCwgMS4wKSk7XG4gICAgICB9XG4gICB9KTtcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ2NvbG9yJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHJldHVybiAodGhpcy5fciA8PCAxNikgfCAodGhpcy5fZyA8PCA4KSB8ICh0aGlzLl9iKTtcbiAgICAgIH1cbiAgIH0pO1xuICAgYjJTZXR0aW5ncy5iMlNldHRpbmdzID0gZnVuY3Rpb24gKCkge307XG4gICBiMlNldHRpbmdzLmIyTWl4RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24xLCBmcmljdGlvbjIpIHtcbiAgICAgIGlmIChmcmljdGlvbjEgPT09IHVuZGVmaW5lZCkgZnJpY3Rpb24xID0gMDtcbiAgICAgIGlmIChmcmljdGlvbjIgPT09IHVuZGVmaW5lZCkgZnJpY3Rpb24yID0gMDtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZnJpY3Rpb24xICogZnJpY3Rpb24yKTtcbiAgIH1cbiAgIGIyU2V0dGluZ3MuYjJNaXhSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uIChyZXN0aXR1dGlvbjEsIHJlc3RpdHV0aW9uMikge1xuICAgICAgaWYgKHJlc3RpdHV0aW9uMSA9PT0gdW5kZWZpbmVkKSByZXN0aXR1dGlvbjEgPSAwO1xuICAgICAgaWYgKHJlc3RpdHV0aW9uMiA9PT0gdW5kZWZpbmVkKSByZXN0aXR1dGlvbjIgPSAwO1xuICAgICAgcmV0dXJuIHJlc3RpdHV0aW9uMSA+IHJlc3RpdHV0aW9uMiA/IHJlc3RpdHV0aW9uMSA6IHJlc3RpdHV0aW9uMjtcbiAgIH1cbiAgIGIyU2V0dGluZ3MuYjJBc3NlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgaWYgKCFhKSB7XG4gICAgICAgICB0aHJvdyBcIkFzc2VydGlvbiBGYWlsZWRcIjtcbiAgICAgIH1cbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuVkVSU0lPTiA9IFwiMi4xYWxwaGFcIjtcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLlVTSFJUX01BWCA9IDB4MDAwMGZmZmY7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9waSA9IE1hdGguUEk7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50cyA9IDI7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9hYWJiRXh0ZW5zaW9uID0gMC4xO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfYWFiYk11bHRpcGxpZXIgPSAyLjA7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9wb2x5Z29uUmFkaXVzID0gMi4wICogYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCA9IDAuMDA1O1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3AgPSAyLjAgLyAxODAuMCAqIGIyU2V0dGluZ3MuYjJfcGk7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl90b2lTbG9wID0gOC4wICogYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4VE9JQ29udGFjdHNQZXJJc2xhbmQgPSAzMjtcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX21heFRPSUpvaW50c1BlcklzbGFuZCA9IDMyO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfdmVsb2NpdHlUaHJlc2hvbGQgPSAxLjA7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uID0gMC4yO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4QW5ndWxhckNvcnJlY3Rpb24gPSA4LjAgLyAxODAuMCAqIGIyU2V0dGluZ3MuYjJfcGk7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvbiA9IDIuMDtcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX21heFRyYW5zbGF0aW9uU3F1YXJlZCA9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBiMlNldHRpbmdzLmIyX21heFRyYW5zbGF0aW9uO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb24gPSAwLjUgKiBiMlNldHRpbmdzLmIyX3BpO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb25TcXVhcmVkID0gYjJTZXR0aW5ncy5iMl9tYXhSb3RhdGlvbiAqIGIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb247XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9jb250YWN0QmF1bWdhcnRlID0gMC4yO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfdGltZVRvU2xlZXAgPSAwLjU7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9saW5lYXJTbGVlcFRvbGVyYW5jZSA9IDAuMDE7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xlZXBUb2xlcmFuY2UgPSAyLjAgLyAxODAuMCAqIGIyU2V0dGluZ3MuYjJfcGk7XG4gICB9KTtcbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyQUFCQiA9IEJveDJELkNvbGxpc2lvbi5iMkFBQkIsXG4gICAgICBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXG4gICAgICBiMmludGVybmFsID0gQm94MkQuQ29tbW9uLmIyaW50ZXJuYWwsXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcbiAgICAgIGIyTWF0MzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDMzLFxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXG4gICAgICBiMlRyYW5zZm9ybSA9IEJveDJELkNvbW1vbi5NYXRoLmIyVHJhbnNmb3JtLFxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzO1xuXG4gICBiMk1hdDIyLmIyTWF0MjIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbDEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmNvbDIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJNYXQyMi5wcm90b3R5cGUuYjJNYXQyMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuU2V0SWRlbnRpdHkoKTtcbiAgIH1cbiAgIGIyTWF0MjIuRnJvbUFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkgYW5nbGUgPSAwO1xuICAgICAgdmFyIG1hdCA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICBtYXQuU2V0KGFuZ2xlKTtcbiAgICAgIHJldHVybiBtYXQ7XG4gICB9XG4gICBiMk1hdDIyLkZyb21WViA9IGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICAgIHZhciBtYXQgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgbWF0LlNldFZWKGMxLCBjMik7XG4gICAgICByZXR1cm4gbWF0O1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkgYW5nbGUgPSAwO1xuICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHRoaXMuY29sMS54ID0gYztcbiAgICAgIHRoaXMuY29sMi54ID0gKC1zKTtcbiAgICAgIHRoaXMuY29sMS55ID0gcztcbiAgICAgIHRoaXMuY29sMi55ID0gYztcbiAgIH1cbiAgIGIyTWF0MjIucHJvdG90eXBlLlNldFZWID0gZnVuY3Rpb24gKGMxLCBjMikge1xuICAgICAgdGhpcy5jb2wxLlNldFYoYzEpO1xuICAgICAgdGhpcy5jb2wyLlNldFYoYzIpO1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXQgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgbWF0LlNldE0odGhpcyk7XG4gICAgICByZXR1cm4gbWF0O1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuU2V0TSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICB0aGlzLmNvbDEuU2V0VihtLmNvbDEpO1xuICAgICAgdGhpcy5jb2wyLlNldFYobS5jb2wyKTtcbiAgIH1cbiAgIGIyTWF0MjIucHJvdG90eXBlLkFkZE0gPSBmdW5jdGlvbiAobSkge1xuICAgICAgdGhpcy5jb2wxLnggKz0gbS5jb2wxLng7XG4gICAgICB0aGlzLmNvbDEueSArPSBtLmNvbDEueTtcbiAgICAgIHRoaXMuY29sMi54ICs9IG0uY29sMi54O1xuICAgICAgdGhpcy5jb2wyLnkgKz0gbS5jb2wyLnk7XG4gICB9XG4gICBiMk1hdDIyLnByb3RvdHlwZS5TZXRJZGVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29sMS54ID0gMS4wO1xuICAgICAgdGhpcy5jb2wyLnggPSAwLjA7XG4gICAgICB0aGlzLmNvbDEueSA9IDAuMDtcbiAgICAgIHRoaXMuY29sMi55ID0gMS4wO1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuU2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29sMS54ID0gMC4wO1xuICAgICAgdGhpcy5jb2wyLnggPSAwLjA7XG4gICAgICB0aGlzLmNvbDEueSA9IDAuMDtcbiAgICAgIHRoaXMuY29sMi55ID0gMC4wO1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuR2V0QW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLmNvbDEueSwgdGhpcy5jb2wxLngpO1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuR2V0SW52ZXJzZSA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgIHZhciBhID0gdGhpcy5jb2wxLng7XG4gICAgICB2YXIgYiA9IHRoaXMuY29sMi54O1xuICAgICAgdmFyIGMgPSB0aGlzLmNvbDEueTtcbiAgICAgIHZhciBkID0gdGhpcy5jb2wyLnk7XG4gICAgICB2YXIgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgICAgIGlmIChkZXQgIT0gMC4wKSB7XG4gICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICB9XG4gICAgICBvdXQuY29sMS54ID0gZGV0ICogZDtcbiAgICAgIG91dC5jb2wyLnggPSAoLWRldCAqIGIpO1xuICAgICAgb3V0LmNvbDEueSA9ICgtZGV0ICogYyk7XG4gICAgICBvdXQuY29sMi55ID0gZGV0ICogYTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICB9XG4gICBiMk1hdDIyLnByb3RvdHlwZS5Tb2x2ZSA9IGZ1bmN0aW9uIChvdXQsIGJYLCBiWSkge1xuICAgICAgaWYgKGJYID09PSB1bmRlZmluZWQpIGJYID0gMDtcbiAgICAgIGlmIChiWSA9PT0gdW5kZWZpbmVkKSBiWSA9IDA7XG4gICAgICB2YXIgYTExID0gdGhpcy5jb2wxLng7XG4gICAgICB2YXIgYTEyID0gdGhpcy5jb2wyLng7XG4gICAgICB2YXIgYTIxID0gdGhpcy5jb2wxLnk7XG4gICAgICB2YXIgYTIyID0gdGhpcy5jb2wyLnk7XG4gICAgICB2YXIgZGV0ID0gYTExICogYTIyIC0gYTEyICogYTIxO1xuICAgICAgaWYgKGRldCAhPSAwLjApIHtcbiAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICAgIH1cbiAgICAgIG91dC54ID0gZGV0ICogKGEyMiAqIGJYIC0gYTEyICogYlkpO1xuICAgICAgb3V0LnkgPSBkZXQgKiAoYTExICogYlkgLSBhMjEgKiBiWCk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuQWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb2wxLkFicygpO1xuICAgICAgdGhpcy5jb2wyLkFicygpO1xuICAgfVxuICAgYjJNYXQzMy5iMk1hdDMzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb2wxID0gbmV3IGIyVmVjMygpO1xuICAgICAgdGhpcy5jb2wyID0gbmV3IGIyVmVjMygpO1xuICAgICAgdGhpcy5jb2wzID0gbmV3IGIyVmVjMygpO1xuICAgfTtcbiAgIGIyTWF0MzMucHJvdG90eXBlLmIyTWF0MzMgPSBmdW5jdGlvbiAoYzEsIGMyLCBjMykge1xuICAgICAgaWYgKGMxID09PSB1bmRlZmluZWQpIGMxID0gbnVsbDtcbiAgICAgIGlmIChjMiA9PT0gdW5kZWZpbmVkKSBjMiA9IG51bGw7XG4gICAgICBpZiAoYzMgPT09IHVuZGVmaW5lZCkgYzMgPSBudWxsO1xuICAgICAgaWYgKCFjMSAmJiAhYzIgJiYgIWMzKSB7XG4gICAgICAgICB0aGlzLmNvbDEuU2V0WmVybygpO1xuICAgICAgICAgdGhpcy5jb2wyLlNldFplcm8oKTtcbiAgICAgICAgIHRoaXMuY29sMy5TZXRaZXJvKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMuY29sMS5TZXRWKGMxKTtcbiAgICAgICAgIHRoaXMuY29sMi5TZXRWKGMyKTtcbiAgICAgICAgIHRoaXMuY29sMy5TZXRWKGMzKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyTWF0MzMucHJvdG90eXBlLlNldFZWViA9IGZ1bmN0aW9uIChjMSwgYzIsIGMzKSB7XG4gICAgICB0aGlzLmNvbDEuU2V0VihjMSk7XG4gICAgICB0aGlzLmNvbDIuU2V0VihjMik7XG4gICAgICB0aGlzLmNvbDMuU2V0VihjMyk7XG4gICB9XG4gICBiMk1hdDMzLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBiMk1hdDMzKHRoaXMuY29sMSwgdGhpcy5jb2wyLCB0aGlzLmNvbDMpO1xuICAgfVxuICAgYjJNYXQzMy5wcm90b3R5cGUuU2V0TSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICB0aGlzLmNvbDEuU2V0VihtLmNvbDEpO1xuICAgICAgdGhpcy5jb2wyLlNldFYobS5jb2wyKTtcbiAgICAgIHRoaXMuY29sMy5TZXRWKG0uY29sMyk7XG4gICB9XG4gICBiMk1hdDMzLnByb3RvdHlwZS5BZGRNID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgIHRoaXMuY29sMS54ICs9IG0uY29sMS54O1xuICAgICAgdGhpcy5jb2wxLnkgKz0gbS5jb2wxLnk7XG4gICAgICB0aGlzLmNvbDEueiArPSBtLmNvbDEuejtcbiAgICAgIHRoaXMuY29sMi54ICs9IG0uY29sMi54O1xuICAgICAgdGhpcy5jb2wyLnkgKz0gbS5jb2wyLnk7XG4gICAgICB0aGlzLmNvbDIueiArPSBtLmNvbDIuejtcbiAgICAgIHRoaXMuY29sMy54ICs9IG0uY29sMy54O1xuICAgICAgdGhpcy5jb2wzLnkgKz0gbS5jb2wzLnk7XG4gICAgICB0aGlzLmNvbDMueiArPSBtLmNvbDMuejtcbiAgIH1cbiAgIGIyTWF0MzMucHJvdG90eXBlLlNldElkZW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb2wxLnggPSAxLjA7XG4gICAgICB0aGlzLmNvbDIueCA9IDAuMDtcbiAgICAgIHRoaXMuY29sMy54ID0gMC4wO1xuICAgICAgdGhpcy5jb2wxLnkgPSAwLjA7XG4gICAgICB0aGlzLmNvbDIueSA9IDEuMDtcbiAgICAgIHRoaXMuY29sMy55ID0gMC4wO1xuICAgICAgdGhpcy5jb2wxLnogPSAwLjA7XG4gICAgICB0aGlzLmNvbDIueiA9IDAuMDtcbiAgICAgIHRoaXMuY29sMy56ID0gMS4wO1xuICAgfVxuICAgYjJNYXQzMy5wcm90b3R5cGUuU2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29sMS54ID0gMC4wO1xuICAgICAgdGhpcy5jb2wyLnggPSAwLjA7XG4gICAgICB0aGlzLmNvbDMueCA9IDAuMDtcbiAgICAgIHRoaXMuY29sMS55ID0gMC4wO1xuICAgICAgdGhpcy5jb2wyLnkgPSAwLjA7XG4gICAgICB0aGlzLmNvbDMueSA9IDAuMDtcbiAgICAgIHRoaXMuY29sMS56ID0gMC4wO1xuICAgICAgdGhpcy5jb2wyLnogPSAwLjA7XG4gICAgICB0aGlzLmNvbDMueiA9IDAuMDtcbiAgIH1cbiAgIGIyTWF0MzMucHJvdG90eXBlLlNvbHZlMjIgPSBmdW5jdGlvbiAob3V0LCBiWCwgYlkpIHtcbiAgICAgIGlmIChiWCA9PT0gdW5kZWZpbmVkKSBiWCA9IDA7XG4gICAgICBpZiAoYlkgPT09IHVuZGVmaW5lZCkgYlkgPSAwO1xuICAgICAgdmFyIGExMSA9IHRoaXMuY29sMS54O1xuICAgICAgdmFyIGExMiA9IHRoaXMuY29sMi54O1xuICAgICAgdmFyIGEyMSA9IHRoaXMuY29sMS55O1xuICAgICAgdmFyIGEyMiA9IHRoaXMuY29sMi55O1xuICAgICAgdmFyIGRldCA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgICAgIGlmIChkZXQgIT0gMC4wKSB7XG4gICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICB9XG4gICAgICBvdXQueCA9IGRldCAqIChhMjIgKiBiWCAtIGExMiAqIGJZKTtcbiAgICAgIG91dC55ID0gZGV0ICogKGExMSAqIGJZIC0gYTIxICogYlgpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgIH1cbiAgIGIyTWF0MzMucHJvdG90eXBlLlNvbHZlMzMgPSBmdW5jdGlvbiAob3V0LCBiWCwgYlksIGJaKSB7XG4gICAgICBpZiAoYlggPT09IHVuZGVmaW5lZCkgYlggPSAwO1xuICAgICAgaWYgKGJZID09PSB1bmRlZmluZWQpIGJZID0gMDtcbiAgICAgIGlmIChiWiA9PT0gdW5kZWZpbmVkKSBiWiA9IDA7XG4gICAgICB2YXIgYTExID0gdGhpcy5jb2wxLng7XG4gICAgICB2YXIgYTIxID0gdGhpcy5jb2wxLnk7XG4gICAgICB2YXIgYTMxID0gdGhpcy5jb2wxLno7XG4gICAgICB2YXIgYTEyID0gdGhpcy5jb2wyLng7XG4gICAgICB2YXIgYTIyID0gdGhpcy5jb2wyLnk7XG4gICAgICB2YXIgYTMyID0gdGhpcy5jb2wyLno7XG4gICAgICB2YXIgYTEzID0gdGhpcy5jb2wzLng7XG4gICAgICB2YXIgYTIzID0gdGhpcy5jb2wzLnk7XG4gICAgICB2YXIgYTMzID0gdGhpcy5jb2wzLno7XG4gICAgICB2YXIgZGV0ID0gYTExICogKGEyMiAqIGEzMyAtIGEzMiAqIGEyMykgKyBhMjEgKiAoYTMyICogYTEzIC0gYTEyICogYTMzKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMjIgKiBhMTMpO1xuICAgICAgaWYgKGRldCAhPSAwLjApIHtcbiAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICAgIH1cbiAgICAgIG91dC54ID0gZGV0ICogKGJYICogKGEyMiAqIGEzMyAtIGEzMiAqIGEyMykgKyBiWSAqIChhMzIgKiBhMTMgLSBhMTIgKiBhMzMpICsgYlogKiAoYTEyICogYTIzIC0gYTIyICogYTEzKSk7XG4gICAgICBvdXQueSA9IGRldCAqIChhMTEgKiAoYlkgKiBhMzMgLSBiWiAqIGEyMykgKyBhMjEgKiAoYlogKiBhMTMgLSBiWCAqIGEzMykgKyBhMzEgKiAoYlggKiBhMjMgLSBiWSAqIGExMykpO1xuICAgICAgb3V0LnogPSBkZXQgKiAoYTExICogKGEyMiAqIGJaIC0gYTMyICogYlkpICsgYTIxICogKGEzMiAqIGJYIC0gYTEyICogYlopICsgYTMxICogKGExMiAqIGJZIC0gYTIyICogYlgpKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICB9XG4gICBiMk1hdGguYjJNYXRoID0gZnVuY3Rpb24gKCkge307XG4gICBiMk1hdGguSXNWYWxpZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB4ID0gMDtcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh4KTtcbiAgIH1cbiAgIGIyTWF0aC5Eb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEueCAqIGIueCArIGEueSAqIGIueTtcbiAgIH1cbiAgIGIyTWF0aC5Dcm9zc1ZWID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG4gICB9XG4gICBiMk1hdGguQ3Jvc3NWRiA9IGZ1bmN0aW9uIChhLCBzKSB7XG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMDtcbiAgICAgIHZhciB2ID0gbmV3IGIyVmVjMihzICogYS55LCAoLXMgKiBhLngpKTtcbiAgICAgIHJldHVybiB2O1xuICAgfVxuICAgYjJNYXRoLkNyb3NzRlYgPSBmdW5jdGlvbiAocywgYSkge1xuICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDA7XG4gICAgICB2YXIgdiA9IG5ldyBiMlZlYzIoKC1zICogYS55KSwgcyAqIGEueCk7XG4gICAgICByZXR1cm4gdjtcbiAgIH1cbiAgIGIyTWF0aC5NdWxNViA9IGZ1bmN0aW9uIChBLCB2KSB7XG4gICAgICB2YXIgdSA9IG5ldyBiMlZlYzIoQS5jb2wxLnggKiB2LnggKyBBLmNvbDIueCAqIHYueSwgQS5jb2wxLnkgKiB2LnggKyBBLmNvbDIueSAqIHYueSk7XG4gICAgICByZXR1cm4gdTtcbiAgIH1cbiAgIGIyTWF0aC5NdWxUTVYgPSBmdW5jdGlvbiAoQSwgdikge1xuICAgICAgdmFyIHUgPSBuZXcgYjJWZWMyKGIyTWF0aC5Eb3QodiwgQS5jb2wxKSwgYjJNYXRoLkRvdCh2LCBBLmNvbDIpKTtcbiAgICAgIHJldHVybiB1O1xuICAgfVxuICAgYjJNYXRoLk11bFggPSBmdW5jdGlvbiAoVCwgdikge1xuICAgICAgdmFyIGEgPSBiMk1hdGguTXVsTVYoVC5SLCB2KTtcbiAgICAgIGEueCArPSBULnBvc2l0aW9uLng7XG4gICAgICBhLnkgKz0gVC5wb3NpdGlvbi55O1xuICAgICAgcmV0dXJuIGE7XG4gICB9XG4gICBiMk1hdGguTXVsWFQgPSBmdW5jdGlvbiAoVCwgdikge1xuICAgICAgdmFyIGEgPSBiMk1hdGguU3VidHJhY3RWVih2LCBULnBvc2l0aW9uKTtcbiAgICAgIHZhciB0WCA9IChhLnggKiBULlIuY29sMS54ICsgYS55ICogVC5SLmNvbDEueSk7XG4gICAgICBhLnkgPSAoYS54ICogVC5SLmNvbDIueCArIGEueSAqIFQuUi5jb2wyLnkpO1xuICAgICAgYS54ID0gdFg7XG4gICAgICByZXR1cm4gYTtcbiAgIH1cbiAgIGIyTWF0aC5BZGRWViA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgdiA9IG5ldyBiMlZlYzIoYS54ICsgYi54LCBhLnkgKyBiLnkpO1xuICAgICAgcmV0dXJuIHY7XG4gICB9XG4gICBiMk1hdGguU3VidHJhY3RWViA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgdiA9IG5ldyBiMlZlYzIoYS54IC0gYi54LCBhLnkgLSBiLnkpO1xuICAgICAgcmV0dXJuIHY7XG4gICB9XG4gICBiMk1hdGguRGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGNYID0gYS54IC0gYi54O1xuICAgICAgdmFyIGNZID0gYS55IC0gYi55O1xuICAgICAgcmV0dXJuIE1hdGguc3FydChjWCAqIGNYICsgY1kgKiBjWSk7XG4gICB9XG4gICBiMk1hdGguRGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBjWCA9IGEueCAtIGIueDtcbiAgICAgIHZhciBjWSA9IGEueSAtIGIueTtcbiAgICAgIHJldHVybiAoY1ggKiBjWCArIGNZICogY1kpO1xuICAgfVxuICAgYjJNYXRoLk11bEZWID0gZnVuY3Rpb24gKHMsIGEpIHtcbiAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAwO1xuICAgICAgdmFyIHYgPSBuZXcgYjJWZWMyKHMgKiBhLngsIHMgKiBhLnkpO1xuICAgICAgcmV0dXJuIHY7XG4gICB9XG4gICBiMk1hdGguQWRkTU0gPSBmdW5jdGlvbiAoQSwgQikge1xuICAgICAgdmFyIEMgPSBiMk1hdDIyLkZyb21WVihiMk1hdGguQWRkVlYoQS5jb2wxLCBCLmNvbDEpLCBiMk1hdGguQWRkVlYoQS5jb2wyLCBCLmNvbDIpKTtcbiAgICAgIHJldHVybiBDO1xuICAgfVxuICAgYjJNYXRoLk11bE1NID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgICAgIHZhciBDID0gYjJNYXQyMi5Gcm9tVlYoYjJNYXRoLk11bE1WKEEsIEIuY29sMSksIGIyTWF0aC5NdWxNVihBLCBCLmNvbDIpKTtcbiAgICAgIHJldHVybiBDO1xuICAgfVxuICAgYjJNYXRoLk11bFRNTSA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gICAgICB2YXIgYzEgPSBuZXcgYjJWZWMyKGIyTWF0aC5Eb3QoQS5jb2wxLCBCLmNvbDEpLCBiMk1hdGguRG90KEEuY29sMiwgQi5jb2wxKSk7XG4gICAgICB2YXIgYzIgPSBuZXcgYjJWZWMyKGIyTWF0aC5Eb3QoQS5jb2wxLCBCLmNvbDIpLCBiMk1hdGguRG90KEEuY29sMiwgQi5jb2wyKSk7XG4gICAgICB2YXIgQyA9IGIyTWF0MjIuRnJvbVZWKGMxLCBjMik7XG4gICAgICByZXR1cm4gQztcbiAgIH1cbiAgIGIyTWF0aC5BYnMgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgYSA9IDA7XG4gICAgICByZXR1cm4gYSA+IDAuMCA/IGEgOiAoLWEpO1xuICAgfVxuICAgYjJNYXRoLkFic1YgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgdmFyIGIgPSBuZXcgYjJWZWMyKGIyTWF0aC5BYnMoYS54KSwgYjJNYXRoLkFicyhhLnkpKTtcbiAgICAgIHJldHVybiBiO1xuICAgfVxuICAgYjJNYXRoLkFic00gPSBmdW5jdGlvbiAoQSkge1xuICAgICAgdmFyIEIgPSBiMk1hdDIyLkZyb21WVihiMk1hdGguQWJzVihBLmNvbDEpLCBiMk1hdGguQWJzVihBLmNvbDIpKTtcbiAgICAgIHJldHVybiBCO1xuICAgfVxuICAgYjJNYXRoLk1pbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIGIgPSAwO1xuICAgICAgcmV0dXJuIGEgPCBiID8gYSA6IGI7XG4gICB9XG4gICBiMk1hdGguTWluViA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYyA9IG5ldyBiMlZlYzIoYjJNYXRoLk1pbihhLngsIGIueCksIGIyTWF0aC5NaW4oYS55LCBiLnkpKTtcbiAgICAgIHJldHVybiBjO1xuICAgfVxuICAgYjJNYXRoLk1heCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIGIgPSAwO1xuICAgICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7XG4gICB9XG4gICBiMk1hdGguTWF4ViA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYyA9IG5ldyBiMlZlYzIoYjJNYXRoLk1heChhLngsIGIueCksIGIyTWF0aC5NYXgoYS55LCBiLnkpKTtcbiAgICAgIHJldHVybiBjO1xuICAgfVxuICAgYjJNYXRoLkNsYW1wID0gZnVuY3Rpb24gKGEsIGxvdywgaGlnaCkge1xuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgYSA9IDA7XG4gICAgICBpZiAobG93ID09PSB1bmRlZmluZWQpIGxvdyA9IDA7XG4gICAgICBpZiAoaGlnaCA9PT0gdW5kZWZpbmVkKSBoaWdoID0gMDtcbiAgICAgIHJldHVybiBhIDwgbG93ID8gbG93IDogYSA+IGhpZ2ggPyBoaWdoIDogYTtcbiAgIH1cbiAgIGIyTWF0aC5DbGFtcFYgPSBmdW5jdGlvbiAoYSwgbG93LCBoaWdoKSB7XG4gICAgICByZXR1cm4gYjJNYXRoLk1heFYobG93LCBiMk1hdGguTWluVihhLCBoaWdoKSk7XG4gICB9XG4gICBiMk1hdGguU3dhcCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgdG1wID0gYVswXTtcbiAgICAgIGFbMF0gPSBiWzBdO1xuICAgICAgYlswXSA9IHRtcDtcbiAgIH1cbiAgIGIyTWF0aC5SYW5kb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgfVxuICAgYjJNYXRoLlJhbmRvbVJhbmdlID0gZnVuY3Rpb24gKGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09PSB1bmRlZmluZWQpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PT0gdW5kZWZpbmVkKSBoaSA9IDA7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCk7XG4gICAgICByID0gKGhpIC0gbG8pICogciArIGxvO1xuICAgICAgcmV0dXJuIHI7XG4gICB9XG4gICBiMk1hdGguTmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeCA9IDA7XG4gICAgICB4IHw9ICh4ID4+IDEpICYgMHg3RkZGRkZGRjtcbiAgICAgIHggfD0gKHggPj4gMikgJiAweDNGRkZGRkZGO1xuICAgICAgeCB8PSAoeCA+PiA0KSAmIDB4MEZGRkZGRkY7XG4gICAgICB4IHw9ICh4ID4+IDgpICYgMHgwMEZGRkZGRjtcbiAgICAgIHggfD0gKHggPj4gMTYpICYgMHgwMDAwRkZGRjtcbiAgICAgIHJldHVybiB4ICsgMTtcbiAgIH1cbiAgIGIyTWF0aC5Jc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeCA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0geCA+IDAgJiYgKHggJiAoeCAtIDEpKSA9PSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLmIyVmVjMl96ZXJvID0gbmV3IGIyVmVjMigwLjAsIDAuMCk7XG4gICAgICBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGguYjJNYXQyMl9pZGVudGl0eSA9IGIyTWF0MjIuRnJvbVZWKG5ldyBiMlZlYzIoMS4wLCAwLjApLCBuZXcgYjJWZWMyKDAuMCwgMS4wKSk7XG4gICAgICBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGguYjJUcmFuc2Zvcm1faWRlbnRpdHkgPSBuZXcgYjJUcmFuc2Zvcm0oYjJNYXRoLmIyVmVjMl96ZXJvLCBiMk1hdGguYjJNYXQyMl9pZGVudGl0eSk7XG4gICB9KTtcbiAgIGIyU3dlZXAuYjJTd2VlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubG9jYWxDZW50ZXIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmMwID0gbmV3IGIyVmVjMjtcbiAgICAgIHRoaXMuYyA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMlN3ZWVwLnByb3RvdHlwZS5TZXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIHRoaXMubG9jYWxDZW50ZXIuU2V0VihvdGhlci5sb2NhbENlbnRlcik7XG4gICAgICB0aGlzLmMwLlNldFYob3RoZXIuYzApO1xuICAgICAgdGhpcy5jLlNldFYob3RoZXIuYyk7XG4gICAgICB0aGlzLmEwID0gb3RoZXIuYTA7XG4gICAgICB0aGlzLmEgPSBvdGhlci5hO1xuICAgICAgdGhpcy50MCA9IG90aGVyLnQwO1xuICAgfVxuICAgYjJTd2VlcC5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb3B5ID0gbmV3IGIyU3dlZXAoKTtcbiAgICAgIGNvcHkubG9jYWxDZW50ZXIuU2V0Vih0aGlzLmxvY2FsQ2VudGVyKTtcbiAgICAgIGNvcHkuYzAuU2V0Vih0aGlzLmMwKTtcbiAgICAgIGNvcHkuYy5TZXRWKHRoaXMuYyk7XG4gICAgICBjb3B5LmEwID0gdGhpcy5hMDtcbiAgICAgIGNvcHkuYSA9IHRoaXMuYTtcbiAgICAgIGNvcHkudDAgPSB0aGlzLnQwO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICB9XG4gICBiMlN3ZWVwLnByb3RvdHlwZS5HZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoeGYsIGFscGhhKSB7XG4gICAgICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkgYWxwaGEgPSAwO1xuICAgICAgeGYucG9zaXRpb24ueCA9ICgxLjAgLSBhbHBoYSkgKiB0aGlzLmMwLnggKyBhbHBoYSAqIHRoaXMuYy54O1xuICAgICAgeGYucG9zaXRpb24ueSA9ICgxLjAgLSBhbHBoYSkgKiB0aGlzLmMwLnkgKyBhbHBoYSAqIHRoaXMuYy55O1xuICAgICAgdmFyIGFuZ2xlID0gKDEuMCAtIGFscGhhKSAqIHRoaXMuYTAgKyBhbHBoYSAqIHRoaXMuYTtcbiAgICAgIHhmLlIuU2V0KGFuZ2xlKTtcbiAgICAgIHZhciB0TWF0ID0geGYuUjtcbiAgICAgIHhmLnBvc2l0aW9uLnggLT0gKHRNYXQuY29sMS54ICogdGhpcy5sb2NhbENlbnRlci54ICsgdE1hdC5jb2wyLnggKiB0aGlzLmxvY2FsQ2VudGVyLnkpO1xuICAgICAgeGYucG9zaXRpb24ueSAtPSAodE1hdC5jb2wxLnkgKiB0aGlzLmxvY2FsQ2VudGVyLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubG9jYWxDZW50ZXIueSk7XG4gICB9XG4gICBiMlN3ZWVwLnByb3RvdHlwZS5BZHZhbmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHQgPSAwO1xuICAgICAgaWYgKHRoaXMudDAgPCB0ICYmIDEuMCAtIHRoaXMudDAgPiBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICB2YXIgYWxwaGEgPSAodCAtIHRoaXMudDApIC8gKDEuMCAtIHRoaXMudDApO1xuICAgICAgICAgdGhpcy5jMC54ID0gKDEuMCAtIGFscGhhKSAqIHRoaXMuYzAueCArIGFscGhhICogdGhpcy5jLng7XG4gICAgICAgICB0aGlzLmMwLnkgPSAoMS4wIC0gYWxwaGEpICogdGhpcy5jMC55ICsgYWxwaGEgKiB0aGlzLmMueTtcbiAgICAgICAgIHRoaXMuYTAgPSAoMS4wIC0gYWxwaGEpICogdGhpcy5hMCArIGFscGhhICogdGhpcy5hO1xuICAgICAgICAgdGhpcy50MCA9IHQ7XG4gICAgICB9XG4gICB9XG4gICBiMlRyYW5zZm9ybS5iMlRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgYjJWZWMyO1xuICAgICAgdGhpcy5SID0gbmV3IGIyTWF0MjIoKTtcbiAgIH07XG4gICBiMlRyYW5zZm9ybS5wcm90b3R5cGUuYjJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocG9zLCByKSB7XG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHBvcyA9IG51bGw7XG4gICAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByID0gbnVsbDtcbiAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgIHRoaXMucG9zaXRpb24uU2V0Vihwb3MpO1xuICAgICAgICAgdGhpcy5SLlNldE0ocik7XG4gICAgICB9XG4gICB9XG4gICBiMlRyYW5zZm9ybS5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChwb3MsIHIpIHtcbiAgICAgIHRoaXMucG9zaXRpb24uU2V0Vihwb3MpO1xuICAgICAgdGhpcy5SLlNldE0ocik7XG4gICB9XG4gICBiMlRyYW5zZm9ybS5wcm90b3R5cGUuU2V0SWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uLlNldFplcm8oKTtcbiAgICAgIHRoaXMuUi5TZXRJZGVudGl0eSgpO1xuICAgfVxuICAgYjJUcmFuc2Zvcm0ucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnBvc2l0aW9uLlNldFYoeC5wb3NpdGlvbik7XG4gICAgICB0aGlzLlIuU2V0TSh4LlIpO1xuICAgfVxuICAgYjJUcmFuc2Zvcm0ucHJvdG90eXBlLkdldEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5SLmNvbDEueSwgdGhpcy5SLmNvbDEueCk7XG4gICB9XG4gICBiMlZlYzIuYjJWZWMyID0gZnVuY3Rpb24gKCkge307XG4gICBiMlZlYzIucHJvdG90eXBlLmIyVmVjMiA9IGZ1bmN0aW9uICh4XywgeV8pIHtcbiAgICAgIGlmICh4XyA9PT0gdW5kZWZpbmVkKSB4XyA9IDA7XG4gICAgICBpZiAoeV8gPT09IHVuZGVmaW5lZCkgeV8gPSAwO1xuICAgICAgdGhpcy54ID0geF87XG4gICAgICB0aGlzLnkgPSB5XztcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuU2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMueCA9IDAuMDtcbiAgICAgIHRoaXMueSA9IDAuMDtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHhfLCB5Xykge1xuICAgICAgaWYgKHhfID09PSB1bmRlZmluZWQpIHhfID0gMDtcbiAgICAgIGlmICh5XyA9PT0gdW5kZWZpbmVkKSB5XyA9IDA7XG4gICAgICB0aGlzLnggPSB4XztcbiAgICAgIHRoaXMueSA9IHlfO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5TZXRWID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgIHRoaXMueSA9IHYueTtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuR2V0TmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMigoLXRoaXMueCksICgtdGhpcy55KSk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLk5lZ2F0aXZlU2VsZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMueCA9ICgtdGhpcy54KTtcbiAgICAgIHRoaXMueSA9ICgtdGhpcy55KTtcbiAgIH1cbiAgIGIyVmVjMi5NYWtlID0gZnVuY3Rpb24gKHhfLCB5Xykge1xuICAgICAgaWYgKHhfID09PSB1bmRlZmluZWQpIHhfID0gMDtcbiAgICAgIGlmICh5XyA9PT0gdW5kZWZpbmVkKSB5XyA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMih4XywgeV8pO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIodGhpcy54LCB0aGlzLnkpO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5BZGQgPSBmdW5jdGlvbiAodikge1xuICAgICAgdGhpcy54ICs9IHYueDtcbiAgICAgIHRoaXMueSArPSB2Lnk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLlN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHRoaXMueCAtPSB2Lng7XG4gICAgICB0aGlzLnkgLT0gdi55O1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5NdWx0aXBseSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgIHRoaXMueCAqPSBhO1xuICAgICAgdGhpcy55ICo9IGE7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLk11bE0gPSBmdW5jdGlvbiAoQSkge1xuICAgICAgdmFyIHRYID0gdGhpcy54O1xuICAgICAgdGhpcy54ID0gQS5jb2wxLnggKiB0WCArIEEuY29sMi54ICogdGhpcy55O1xuICAgICAgdGhpcy55ID0gQS5jb2wxLnkgKiB0WCArIEEuY29sMi55ICogdGhpcy55O1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5NdWxUTSA9IGZ1bmN0aW9uIChBKSB7XG4gICAgICB2YXIgdFggPSBiMk1hdGguRG90KHRoaXMsIEEuY29sMSk7XG4gICAgICB0aGlzLnkgPSBiMk1hdGguRG90KHRoaXMsIEEuY29sMik7XG4gICAgICB0aGlzLnggPSB0WDtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuQ3Jvc3NWRiA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMDtcbiAgICAgIHZhciB0WCA9IHRoaXMueDtcbiAgICAgIHRoaXMueCA9IHMgKiB0aGlzLnk7XG4gICAgICB0aGlzLnkgPSAoLXMgKiB0WCk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLkNyb3NzRlYgPSBmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDA7XG4gICAgICB2YXIgdFggPSB0aGlzLng7XG4gICAgICB0aGlzLnggPSAoLXMgKiB0aGlzLnkpO1xuICAgICAgdGhpcy55ID0gcyAqIHRYO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5NaW5WID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHRoaXMueCA9IHRoaXMueCA8IGIueCA/IHRoaXMueCA6IGIueDtcbiAgICAgIHRoaXMueSA9IHRoaXMueSA8IGIueSA/IHRoaXMueSA6IGIueTtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuTWF4ViA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICB0aGlzLnggPSB0aGlzLnggPiBiLnggPyB0aGlzLnggOiBiLng7XG4gICAgICB0aGlzLnkgPSB0aGlzLnkgPiBiLnkgPyB0aGlzLnkgOiBiLnk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLkFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnggPCAwKSB0aGlzLnggPSAoLXRoaXMueCk7XG4gICAgICBpZiAodGhpcy55IDwgMCkgdGhpcy55ID0gKC10aGlzLnkpO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5MZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLkxlbmd0aFNxdWFyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLk5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICAgIGlmIChsZW5ndGggPCBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgfVxuICAgICAgdmFyIGludkxlbmd0aCA9IDEuMCAvIGxlbmd0aDtcbiAgICAgIHRoaXMueCAqPSBpbnZMZW5ndGg7XG4gICAgICB0aGlzLnkgKj0gaW52TGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuSXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiMk1hdGguSXNWYWxpZCh0aGlzLngpICYmIGIyTWF0aC5Jc1ZhbGlkKHRoaXMueSk7XG4gICB9XG4gICBiMlZlYzMuYjJWZWMzID0gZnVuY3Rpb24gKCkge307XG4gICBiMlZlYzMucHJvdG90eXBlLmIyVmVjMyA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB4ID0gMDtcbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHkgPSAwO1xuICAgICAgaWYgKHogPT09IHVuZGVmaW5lZCkgeiA9IDA7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMueiA9IHo7XG4gICB9XG4gICBiMlZlYzMucHJvdG90eXBlLlNldFplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLnogPSAwLjA7XG4gICB9XG4gICBiMlZlYzMucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB4ID0gMDtcbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHkgPSAwO1xuICAgICAgaWYgKHogPT09IHVuZGVmaW5lZCkgeiA9IDA7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMueiA9IHo7XG4gICB9XG4gICBiMlZlYzMucHJvdG90eXBlLlNldFYgPSBmdW5jdGlvbiAodikge1xuICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgdGhpcy56ID0gdi56O1xuICAgfVxuICAgYjJWZWMzLnByb3RvdHlwZS5HZXROZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgYjJWZWMzKCgtdGhpcy54KSwgKC10aGlzLnkpLCAoLXRoaXMueikpO1xuICAgfVxuICAgYjJWZWMzLnByb3RvdHlwZS5OZWdhdGl2ZVNlbGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnggPSAoLXRoaXMueCk7XG4gICAgICB0aGlzLnkgPSAoLXRoaXMueSk7XG4gICAgICB0aGlzLnogPSAoLXRoaXMueik7XG4gICB9XG4gICBiMlZlYzMucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcbiAgIH1cbiAgIGIyVmVjMy5wcm90b3R5cGUuQWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgdGhpcy56ICs9IHYuejtcbiAgIH1cbiAgIGIyVmVjMy5wcm90b3R5cGUuU3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xuICAgICAgdGhpcy54IC09IHYueDtcbiAgICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgICB0aGlzLnogLT0gdi56O1xuICAgfVxuICAgYjJWZWMzLnByb3RvdHlwZS5NdWx0aXBseSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgIHRoaXMueCAqPSBhO1xuICAgICAgdGhpcy55ICo9IGE7XG4gICAgICB0aGlzLnogKj0gYTtcbiAgIH1cbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyQ29udHJvbGxlckVkZ2UgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXJFZGdlLFxuICAgICAgYjJNYXQyMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MjIsXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcbiAgICAgIGIyU3dlZXAgPSBCb3gyRC5Db21tb24uTWF0aC5iMlN3ZWVwLFxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcbiAgICAgIGIyVmVjMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMyxcbiAgICAgIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcbiAgICAgIGIyU2V0dGluZ3MgPSBCb3gyRC5Db21tb24uYjJTZXR0aW5ncyxcbiAgICAgIGIyQUFCQiA9IEJveDJELkNvbGxpc2lvbi5iMkFBQkIsXG4gICAgICBiMkJvdW5kID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmQsXG4gICAgICBiMkJvdW5kVmFsdWVzID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmRWYWx1ZXMsXG4gICAgICBiMkNvbGxpc2lvbiA9IEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbixcbiAgICAgIGIyQ29udGFjdElEID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdElELFxuICAgICAgYjJDb250YWN0UG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJDb250YWN0UG9pbnQsXG4gICAgICBiMkRpc3RhbmNlID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2UsXG4gICAgICBiMkRpc3RhbmNlSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZUlucHV0LFxuICAgICAgYjJEaXN0YW5jZU91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlT3V0cHV0LFxuICAgICAgYjJEaXN0YW5jZVByb3h5ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VQcm94eSxcbiAgICAgIGIyRHluYW1pY1RyZWUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSxcbiAgICAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLFxuICAgICAgYjJEeW5hbWljVHJlZU5vZGUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZU5vZGUsXG4gICAgICBiMkR5bmFtaWNUcmVlUGFpciA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlUGFpcixcbiAgICAgIGIyTWFuaWZvbGQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZCxcbiAgICAgIGIyTWFuaWZvbGRQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkUG9pbnQsXG4gICAgICBiMlBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyUG9pbnQsXG4gICAgICBiMlJheUNhc3RJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RJbnB1dCxcbiAgICAgIGIyUmF5Q2FzdE91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RPdXRwdXQsXG4gICAgICBiMlNlZ21lbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJTZWdtZW50LFxuICAgICAgYjJTZXBhcmF0aW9uRnVuY3Rpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJTZXBhcmF0aW9uRnVuY3Rpb24sXG4gICAgICBiMlNpbXBsZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4LFxuICAgICAgYjJTaW1wbGV4Q2FjaGUgPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4Q2FjaGUsXG4gICAgICBiMlNpbXBsZXhWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4VmVydGV4LFxuICAgICAgYjJUaW1lT2ZJbXBhY3QgPSBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QsXG4gICAgICBiMlRPSUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQsXG4gICAgICBiMldvcmxkTWFuaWZvbGQgPSBCb3gyRC5Db2xsaXNpb24uYjJXb3JsZE1hbmlmb2xkLFxuICAgICAgQ2xpcFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5DbGlwVmVydGV4LFxuICAgICAgRmVhdHVyZXMgPSBCb3gyRC5Db2xsaXNpb24uRmVhdHVyZXMsXG4gICAgICBJQnJvYWRQaGFzZSA9IEJveDJELkNvbGxpc2lvbi5JQnJvYWRQaGFzZSxcbiAgICAgIGIyQ2lyY2xlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyQ2lyY2xlU2hhcGUsXG4gICAgICBiMkVkZ2VDaGFpbkRlZiA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlQ2hhaW5EZWYsXG4gICAgICBiMkVkZ2VTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlU2hhcGUsXG4gICAgICBiMk1hc3NEYXRhID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMk1hc3NEYXRhLFxuICAgICAgYjJQb2x5Z29uU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyUG9seWdvblNoYXBlLFxuICAgICAgYjJTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZSxcbiAgICAgIGIyQm9keSA9IEJveDJELkR5bmFtaWNzLmIyQm9keSxcbiAgICAgIGIyQm9keURlZiA9IEJveDJELkR5bmFtaWNzLmIyQm9keURlZixcbiAgICAgIGIyQ29udGFjdEZpbHRlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEZpbHRlcixcbiAgICAgIGIyQ29udGFjdEltcHVsc2UgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RJbXB1bHNlLFxuICAgICAgYjJDb250YWN0TGlzdGVuZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lcixcbiAgICAgIGIyQ29udGFjdE1hbmFnZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RNYW5hZ2VyLFxuICAgICAgYjJEZWJ1Z0RyYXcgPSBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdyxcbiAgICAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcixcbiAgICAgIGIyRmlsdGVyRGF0YSA9IEJveDJELkR5bmFtaWNzLmIyRmlsdGVyRGF0YSxcbiAgICAgIGIyRml4dHVyZSA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZSxcbiAgICAgIGIyRml4dHVyZURlZiA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcbiAgICAgIGIySXNsYW5kID0gQm94MkQuRHluYW1pY3MuYjJJc2xhbmQsXG4gICAgICBiMlRpbWVTdGVwID0gQm94MkQuRHluYW1pY3MuYjJUaW1lU3RlcCxcbiAgICAgIGIyV29ybGQgPSBCb3gyRC5EeW5hbWljcy5iMldvcmxkLFxuICAgICAgYjJDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDaXJjbGVDb250YWN0LFxuICAgICAgYjJDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LFxuICAgICAgYjJDb250YWN0Q29uc3RyYWludCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdENvbnN0cmFpbnQsXG4gICAgICBiMkNvbnRhY3RDb25zdHJhaW50UG9pbnQgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RDb25zdHJhaW50UG9pbnQsXG4gICAgICBiMkNvbnRhY3RFZGdlID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0RWRnZSxcbiAgICAgIGIyQ29udGFjdEZhY3RvcnkgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RGYWN0b3J5LFxuICAgICAgYjJDb250YWN0UmVnaXN0ZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RSZWdpc3RlcixcbiAgICAgIGIyQ29udGFjdFJlc3VsdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFJlc3VsdCxcbiAgICAgIGIyQ29udGFjdFNvbHZlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFNvbHZlcixcbiAgICAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkVkZ2VBbmRDaXJjbGVDb250YWN0LFxuICAgICAgYjJOdWxsQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyTnVsbENvbnRhY3QsXG4gICAgICBiMlBvbHlBbmRDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCxcbiAgICAgIGIyUG9seUFuZEVkZ2VDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kRWRnZUNvbnRhY3QsXG4gICAgICBiMlBvbHlnb25Db250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5Z29uQ29udGFjdCxcbiAgICAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCxcbiAgICAgIGIyQ29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcixcbiAgICAgIGIyRGlzdGFuY2VKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkRpc3RhbmNlSm9pbnQsXG4gICAgICBiMkRpc3RhbmNlSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50RGVmLFxuICAgICAgYjJGcmljdGlvbkpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyRnJpY3Rpb25Kb2ludCxcbiAgICAgIGIyRnJpY3Rpb25Kb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkZyaWN0aW9uSm9pbnREZWYsXG4gICAgICBiMkdlYXJKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkdlYXJKb2ludCxcbiAgICAgIGIyR2VhckpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyR2VhckpvaW50RGVmLFxuICAgICAgYjJKYWNvYmlhbiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkphY29iaWFuLFxuICAgICAgYjJKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LFxuICAgICAgYjJKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLFxuICAgICAgYjJKb2ludEVkZ2UgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludEVkZ2UsXG4gICAgICBiMkxpbmVKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkxpbmVKb2ludCxcbiAgICAgIGIyTGluZUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTGluZUpvaW50RGVmLFxuICAgICAgYjJNb3VzZUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTW91c2VKb2ludCxcbiAgICAgIGIyTW91c2VKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMk1vdXNlSm9pbnREZWYsXG4gICAgICBiMlByaXNtYXRpY0pvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHJpc21hdGljSm9pbnQsXG4gICAgICBiMlByaXNtYXRpY0pvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHJpc21hdGljSm9pbnREZWYsXG4gICAgICBiMlB1bGxleUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnQsXG4gICAgICBiMlB1bGxleUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnREZWYsXG4gICAgICBiMlJldm9sdXRlSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJSZXZvbHV0ZUpvaW50LFxuICAgICAgYjJSZXZvbHV0ZUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludERlZixcbiAgICAgIGIyV2VsZEpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyV2VsZEpvaW50LFxuICAgICAgYjJXZWxkSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJXZWxkSm9pbnREZWY7XG5cbiAgIGIyQm9keS5iMkJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1feGYgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMubV9zd2VlcCA9IG5ldyBiMlN3ZWVwKCk7XG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fZm9yY2UgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJCb2R5LnByb3RvdHlwZS5jb25uZWN0RWRnZXMgPSBmdW5jdGlvbiAoczEsIHMyLCBhbmdsZTEpIHtcbiAgICAgIGlmIChhbmdsZTEgPT09IHVuZGVmaW5lZCkgYW5nbGUxID0gMDtcbiAgICAgIHZhciBhbmdsZTIgPSBNYXRoLmF0YW4yKHMyLkdldERpcmVjdGlvblZlY3RvcigpLnksIHMyLkdldERpcmVjdGlvblZlY3RvcigpLngpO1xuICAgICAgdmFyIGNvcmVPZmZzZXQgPSBNYXRoLnRhbigoYW5nbGUyIC0gYW5nbGUxKSAqIDAuNSk7XG4gICAgICB2YXIgY29yZSA9IGIyTWF0aC5NdWxGVihjb3JlT2Zmc2V0LCBzMi5HZXREaXJlY3Rpb25WZWN0b3IoKSk7XG4gICAgICBjb3JlID0gYjJNYXRoLlN1YnRyYWN0VlYoY29yZSwgczIuR2V0Tm9ybWFsVmVjdG9yKCkpO1xuICAgICAgY29yZSA9IGIyTWF0aC5NdWxGVihiMlNldHRpbmdzLmIyX3RvaVNsb3AsIGNvcmUpO1xuICAgICAgY29yZSA9IGIyTWF0aC5BZGRWVihjb3JlLCBzMi5HZXRWZXJ0ZXgxKCkpO1xuICAgICAgdmFyIGNvcm5lckRpciA9IGIyTWF0aC5BZGRWVihzMS5HZXREaXJlY3Rpb25WZWN0b3IoKSwgczIuR2V0RGlyZWN0aW9uVmVjdG9yKCkpO1xuICAgICAgY29ybmVyRGlyLk5vcm1hbGl6ZSgpO1xuICAgICAgdmFyIGNvbnZleCA9IGIyTWF0aC5Eb3QoczEuR2V0RGlyZWN0aW9uVmVjdG9yKCksIHMyLkdldE5vcm1hbFZlY3RvcigpKSA+IDAuMDtcbiAgICAgIHMxLlNldE5leHRFZGdlKHMyLCBjb3JlLCBjb3JuZXJEaXIsIGNvbnZleCk7XG4gICAgICBzMi5TZXRQcmV2RWRnZShzMSwgY29yZSwgY29ybmVyRGlyLCBjb252ZXgpO1xuICAgICAgcmV0dXJuIGFuZ2xlMjtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuQ3JlYXRlRml4dHVyZSA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIGlmICh0aGlzLm1fd29ybGQuSXNMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBmaXh0dXJlID0gbmV3IGIyRml4dHVyZSgpO1xuICAgICAgZml4dHVyZS5DcmVhdGUodGhpcywgdGhpcy5tX3hmLCBkZWYpO1xuICAgICAgaWYgKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2FjdGl2ZUZsYWcpIHtcbiAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlO1xuICAgICAgICAgZml4dHVyZS5DcmVhdGVQcm94eShicm9hZFBoYXNlLCB0aGlzLm1feGYpO1xuICAgICAgfVxuICAgICAgZml4dHVyZS5tX25leHQgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICB0aGlzLm1fZml4dHVyZUxpc3QgPSBmaXh0dXJlO1xuICAgICAgKyt0aGlzLm1fZml4dHVyZUNvdW50O1xuICAgICAgZml4dHVyZS5tX2JvZHkgPSB0aGlzO1xuICAgICAgaWYgKGZpeHR1cmUubV9kZW5zaXR5ID4gMC4wKSB7XG4gICAgICAgICB0aGlzLlJlc2V0TWFzc0RhdGEoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV93b3JsZC5tX2ZsYWdzIHw9IGIyV29ybGQuZV9uZXdGaXh0dXJlO1xuICAgICAgcmV0dXJuIGZpeHR1cmU7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkNyZWF0ZUZpeHR1cmUyID0gZnVuY3Rpb24gKHNoYXBlLCBkZW5zaXR5KSB7XG4gICAgICBpZiAoZGVuc2l0eSA9PT0gdW5kZWZpbmVkKSBkZW5zaXR5ID0gMC4wO1xuICAgICAgdmFyIGRlZiA9IG5ldyBiMkZpeHR1cmVEZWYoKTtcbiAgICAgIGRlZi5zaGFwZSA9IHNoYXBlO1xuICAgICAgZGVmLmRlbnNpdHkgPSBkZW5zaXR5O1xuICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlRml4dHVyZShkZWYpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5EZXN0cm95Rml4dHVyZSA9IGZ1bmN0aW9uIChmaXh0dXJlKSB7XG4gICAgICBpZiAodGhpcy5tX3dvcmxkLklzTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICB2YXIgcHBGID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgaWYgKG5vZGUgPT0gZml4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHBwRikgcHBGLm1fbmV4dCA9IGZpeHR1cmUubV9uZXh0O1xuICAgICAgICAgICAgZWxzZSB0aGlzLm1fZml4dHVyZUxpc3QgPSBmaXh0dXJlLm1fbmV4dDtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgICAgcHBGID0gbm9kZTtcbiAgICAgICAgIG5vZGUgPSBub2RlLm1fbmV4dDtcbiAgICAgIH1cbiAgICAgIHZhciBlZGdlID0gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgIHZhciBjID0gZWRnZS5jb250YWN0O1xuICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgIHZhciBmaXh0dXJlQSA9IGMuR2V0Rml4dHVyZUEoKTtcbiAgICAgICAgIHZhciBmaXh0dXJlQiA9IGMuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgIGlmIChmaXh0dXJlID09IGZpeHR1cmVBIHx8IGZpeHR1cmUgPT0gZml4dHVyZUIpIHtcbiAgICAgICAgICAgIHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLkRlc3Ryb3koYyk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfYWN0aXZlRmxhZykge1xuICAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICBmaXh0dXJlLkRlc3Ryb3lQcm94eShicm9hZFBoYXNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge31cbiAgICAgIGZpeHR1cmUuRGVzdHJveSgpO1xuICAgICAgZml4dHVyZS5tX2JvZHkgPSBudWxsO1xuICAgICAgZml4dHVyZS5tX25leHQgPSBudWxsO1xuICAgICAgLS10aGlzLm1fZml4dHVyZUNvdW50O1xuICAgICAgdGhpcy5SZXNldE1hc3NEYXRhKCk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldFBvc2l0aW9uQW5kQW5nbGUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkgYW5nbGUgPSAwO1xuICAgICAgdmFyIGY7XG4gICAgICBpZiAodGhpcy5tX3dvcmxkLklzTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tX3hmLlIuU2V0KGFuZ2xlKTtcbiAgICAgIHRoaXMubV94Zi5wb3NpdGlvbi5TZXRWKHBvc2l0aW9uKTtcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX3hmLlI7XG4gICAgICB2YXIgdFZlYyA9IHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgIHRoaXMubV9zd2VlcC5jLnggPSAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB0aGlzLm1fc3dlZXAuYy55ID0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdGhpcy5tX3N3ZWVwLmMueCArPSB0aGlzLm1feGYucG9zaXRpb24ueDtcbiAgICAgIHRoaXMubV9zd2VlcC5jLnkgKz0gdGhpcy5tX3hmLnBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1fc3dlZXAuYzAuU2V0Vih0aGlzLm1fc3dlZXAuYyk7XG4gICAgICB0aGlzLm1fc3dlZXAuYTAgPSB0aGlzLm1fc3dlZXAuYSA9IGFuZ2xlO1xuICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICBmb3IgKGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgIGYuU3luY2hyb25pemUoYnJvYWRQaGFzZSwgdGhpcy5tX3hmLCB0aGlzLm1feGYpO1xuICAgICAgfVxuICAgICAgdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIuRmluZE5ld0NvbnRhY3RzKCk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4Zikge1xuICAgICAgdGhpcy5TZXRQb3NpdGlvbkFuZEFuZ2xlKHhmLnBvc2l0aW9uLCB4Zi5HZXRBbmdsZSgpKTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV94ZjtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3hmLnBvc2l0aW9uO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgdGhpcy5TZXRQb3NpdGlvbkFuZEFuZ2xlKHBvc2l0aW9uLCB0aGlzLkdldEFuZ2xlKCkpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fc3dlZXAuYTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gdW5kZWZpbmVkKSBhbmdsZSA9IDA7XG4gICAgICB0aGlzLlNldFBvc2l0aW9uQW5kQW5nbGUodGhpcy5HZXRQb3NpdGlvbigpLCBhbmdsZSk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldFdvcmxkQ2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9zd2VlcC5jO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRMb2NhbENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmICh0aGlzLm1fdHlwZSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LlNldFYodik7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9saW5lYXJWZWxvY2l0eTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24gKG9tZWdhKSB7XG4gICAgICBpZiAob21lZ2EgPT09IHVuZGVmaW5lZCkgb21lZ2EgPSAwO1xuICAgICAgaWYgKHRoaXMubV90eXBlID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gb21lZ2E7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldEFuZ3VsYXJWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXREZWZpbml0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJkID0gbmV3IGIyQm9keURlZigpO1xuICAgICAgYmQudHlwZSA9IHRoaXMuR2V0VHlwZSgpO1xuICAgICAgYmQuYWxsb3dTbGVlcCA9ICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZykgPT0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICAgICBiZC5hbmdsZSA9IHRoaXMuR2V0QW5nbGUoKTtcbiAgICAgIGJkLmFuZ3VsYXJEYW1waW5nID0gdGhpcy5tX2FuZ3VsYXJEYW1waW5nO1xuICAgICAgYmQuYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIGJkLmZpeGVkUm90YXRpb24gPSAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfZml4ZWRSb3RhdGlvbkZsYWcpID09IGIyQm9keS5lX2ZpeGVkUm90YXRpb25GbGFnO1xuICAgICAgYmQuYnVsbGV0ID0gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2J1bGxldEZsYWcpID09IGIyQm9keS5lX2J1bGxldEZsYWc7XG4gICAgICBiZC5hd2FrZSA9ICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9hd2FrZUZsYWcpID09IGIyQm9keS5lX2F3YWtlRmxhZztcbiAgICAgIGJkLmxpbmVhckRhbXBpbmcgPSB0aGlzLm1fbGluZWFyRGFtcGluZztcbiAgICAgIGJkLmxpbmVhclZlbG9jaXR5LlNldFYodGhpcy5HZXRMaW5lYXJWZWxvY2l0eSgpKTtcbiAgICAgIGJkLnBvc2l0aW9uID0gdGhpcy5HZXRQb3NpdGlvbigpO1xuICAgICAgYmQudXNlckRhdGEgPSB0aGlzLkdldFVzZXJEYXRhKCk7XG4gICAgICByZXR1cm4gYmQ7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UsIHBvaW50KSB7XG4gICAgICBpZiAodGhpcy5tX3R5cGUgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5Jc0F3YWtlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgIHRoaXMuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fZm9yY2UueCArPSBmb3JjZS54O1xuICAgICAgdGhpcy5tX2ZvcmNlLnkgKz0gZm9yY2UueTtcbiAgICAgIHRoaXMubV90b3JxdWUgKz0gKChwb2ludC54IC0gdGhpcy5tX3N3ZWVwLmMueCkgKiBmb3JjZS55IC0gKHBvaW50LnkgLSB0aGlzLm1fc3dlZXAuYy55KSAqIGZvcmNlLngpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5BcHBseVRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcbiAgICAgIGlmICh0b3JxdWUgPT09IHVuZGVmaW5lZCkgdG9ycXVlID0gMDtcbiAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV90b3JxdWUgKz0gdG9ycXVlO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5BcHBseUltcHVsc2UgPSBmdW5jdGlvbiAoaW1wdWxzZSwgcG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS54ICs9IHRoaXMubV9pbnZNYXNzICogaW1wdWxzZS54O1xuICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LnkgKz0gdGhpcy5tX2ludk1hc3MgKiBpbXB1bHNlLnk7XG4gICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMubV9pbnZJICogKChwb2ludC54IC0gdGhpcy5tX3N3ZWVwLmMueCkgKiBpbXB1bHNlLnkgLSAocG9pbnQueSAtIHRoaXMubV9zd2VlcC5jLnkpICogaW1wdWxzZS54KTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuQXBwbHlBbmd1bGFySW1wdWxzZSA9IGZ1bmN0aW9uIChpbXB1bHNlKVxuICAge1xuICAgXHRpZiAodGhpcy5Jc0F3YWtlKCkgPT0gZmFsc2UpXG4gICBcdHtcbiAgIFx0XHR0aGlzLlNldEF3YWtlKHRydWUpO1xuICAgXHR9XG4gICBcdHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5tX2ludkkgKiBpbXB1bHNlO1xuICAgfTtcbiAgIGIyQm9keS5wcm90b3R5cGUuU3BsaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaW5lYXJWZWxvY2l0eSA9IHRoaXMuR2V0TGluZWFyVmVsb2NpdHkoKS5Db3B5KCk7XG4gICAgICB2YXIgYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5HZXRBbmd1bGFyVmVsb2NpdHkoKTtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLkdldFdvcmxkQ2VudGVyKCk7XG4gICAgICB2YXIgYm9keTEgPSB0aGlzO1xuICAgICAgdmFyIGJvZHkyID0gdGhpcy5tX3dvcmxkLkNyZWF0ZUJvZHkodGhpcy5HZXREZWZpbml0aW9uKCkpO1xuICAgICAgdmFyIHByZXY7XG4gICAgICBmb3IgKHZhciBmID0gYm9keTEubV9maXh0dXJlTGlzdDsgZjspIHtcbiAgICAgICAgIGlmIChjYWxsYmFjayhmKSkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBmLm1fbmV4dDtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICBwcmV2Lm1fbmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIGJvZHkxLm1fZml4dHVyZUxpc3QgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keTEubV9maXh0dXJlQ291bnQtLTtcbiAgICAgICAgICAgIGYubV9uZXh0ID0gYm9keTIubV9maXh0dXJlTGlzdDtcbiAgICAgICAgICAgIGJvZHkyLm1fZml4dHVyZUxpc3QgPSBmO1xuICAgICAgICAgICAgYm9keTIubV9maXh0dXJlQ291bnQrKztcbiAgICAgICAgICAgIGYubV9ib2R5ID0gYm9keTI7XG4gICAgICAgICAgICBmID0gbmV4dDtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldiA9IGY7XG4gICAgICAgICAgICBmID0gZi5tX25leHQ7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBib2R5MS5SZXNldE1hc3NEYXRhKCk7XG4gICAgICBib2R5Mi5SZXNldE1hc3NEYXRhKCk7XG4gICAgICB2YXIgY2VudGVyMSA9IGJvZHkxLkdldFdvcmxkQ2VudGVyKCk7XG4gICAgICB2YXIgY2VudGVyMiA9IGJvZHkyLkdldFdvcmxkQ2VudGVyKCk7XG4gICAgICB2YXIgdmVsb2NpdHkxID0gYjJNYXRoLkFkZFZWKGxpbmVhclZlbG9jaXR5LCBiMk1hdGguQ3Jvc3NGVihhbmd1bGFyVmVsb2NpdHksIGIyTWF0aC5TdWJ0cmFjdFZWKGNlbnRlcjEsIGNlbnRlcikpKTtcbiAgICAgIHZhciB2ZWxvY2l0eTIgPSBiMk1hdGguQWRkVlYobGluZWFyVmVsb2NpdHksIGIyTWF0aC5Dcm9zc0ZWKGFuZ3VsYXJWZWxvY2l0eSwgYjJNYXRoLlN1YnRyYWN0VlYoY2VudGVyMiwgY2VudGVyKSkpO1xuICAgICAgYm9keTEuU2V0TGluZWFyVmVsb2NpdHkodmVsb2NpdHkxKTtcbiAgICAgIGJvZHkyLlNldExpbmVhclZlbG9jaXR5KHZlbG9jaXR5Mik7XG4gICAgICBib2R5MS5TZXRBbmd1bGFyVmVsb2NpdHkoYW5ndWxhclZlbG9jaXR5KTtcbiAgICAgIGJvZHkyLlNldEFuZ3VsYXJWZWxvY2l0eShhbmd1bGFyVmVsb2NpdHkpO1xuICAgICAgYm9keTEuU3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgYm9keTIuU3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgcmV0dXJuIGJvZHkyO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5NZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgdmFyIGY7XG4gICAgICBmb3IgKGYgPSBvdGhlci5tX2ZpeHR1cmVMaXN0O1xuICAgICAgZjspIHtcbiAgICAgICAgIHZhciBuZXh0ID0gZi5tX25leHQ7XG4gICAgICAgICBvdGhlci5tX2ZpeHR1cmVDb3VudC0tO1xuICAgICAgICAgZi5tX25leHQgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICAgICB0aGlzLm1fZml4dHVyZUxpc3QgPSBmO1xuICAgICAgICAgdGhpcy5tX2ZpeHR1cmVDb3VudCsrO1xuICAgICAgICAgZi5tX2JvZHkgPSBib2R5MjtcbiAgICAgICAgIGYgPSBuZXh0O1xuICAgICAgfVxuICAgICAgYm9keTEubV9maXh0dXJlQ291bnQgPSAwO1xuICAgICAgdmFyIGJvZHkxID0gdGhpcztcbiAgICAgIHZhciBib2R5MiA9IG90aGVyO1xuICAgICAgdmFyIGNlbnRlcjEgPSBib2R5MS5HZXRXb3JsZENlbnRlcigpO1xuICAgICAgdmFyIGNlbnRlcjIgPSBib2R5Mi5HZXRXb3JsZENlbnRlcigpO1xuICAgICAgdmFyIHZlbG9jaXR5MSA9IGJvZHkxLkdldExpbmVhclZlbG9jaXR5KCkuQ29weSgpO1xuICAgICAgdmFyIHZlbG9jaXR5MiA9IGJvZHkyLkdldExpbmVhclZlbG9jaXR5KCkuQ29weSgpO1xuICAgICAgdmFyIGFuZ3VsYXIxID0gYm9keTEuR2V0QW5ndWxhclZlbG9jaXR5KCk7XG4gICAgICB2YXIgYW5ndWxhciA9IGJvZHkyLkdldEFuZ3VsYXJWZWxvY2l0eSgpO1xuICAgICAgYm9keTEuUmVzZXRNYXNzRGF0YSgpO1xuICAgICAgdGhpcy5TeW5jaHJvbml6ZUZpeHR1cmVzKCk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldE1hc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX21hc3M7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldEluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX0k7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldE1hc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGRhdGEubWFzcyA9IHRoaXMubV9tYXNzO1xuICAgICAgZGF0YS5JID0gdGhpcy5tX0k7XG4gICAgICBkYXRhLmNlbnRlci5TZXRWKHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcik7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldE1hc3NEYXRhID0gZnVuY3Rpb24gKG1hc3NEYXRhKSB7XG4gICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KHRoaXMubV93b3JsZC5Jc0xvY2tlZCgpID09IGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLm1fd29ybGQuSXNMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX3R5cGUgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1faW52TWFzcyA9IDAuMDtcbiAgICAgIHRoaXMubV9JID0gMC4wO1xuICAgICAgdGhpcy5tX2ludkkgPSAwLjA7XG4gICAgICB0aGlzLm1fbWFzcyA9IG1hc3NEYXRhLm1hc3M7XG4gICAgICBpZiAodGhpcy5tX21hc3MgPD0gMC4wKSB7XG4gICAgICAgICB0aGlzLm1fbWFzcyA9IDEuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9pbnZNYXNzID0gMS4wIC8gdGhpcy5tX21hc3M7XG4gICAgICBpZiAobWFzc0RhdGEuSSA+IDAuMCAmJiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfZml4ZWRSb3RhdGlvbkZsYWcpID09IDApIHtcbiAgICAgICAgIHRoaXMubV9JID0gbWFzc0RhdGEuSSAtIHRoaXMubV9tYXNzICogKG1hc3NEYXRhLmNlbnRlci54ICogbWFzc0RhdGEuY2VudGVyLnggKyBtYXNzRGF0YS5jZW50ZXIueSAqIG1hc3NEYXRhLmNlbnRlci55KTtcbiAgICAgICAgIHRoaXMubV9pbnZJID0gMS4wIC8gdGhpcy5tX0k7XG4gICAgICB9XG4gICAgICB2YXIgb2xkQ2VudGVyID0gdGhpcy5tX3N3ZWVwLmMuQ29weSgpO1xuICAgICAgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyLlNldFYobWFzc0RhdGEuY2VudGVyKTtcbiAgICAgIHRoaXMubV9zd2VlcC5jMC5TZXRWKGIyTWF0aC5NdWxYKHRoaXMubV94ZiwgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyKSk7XG4gICAgICB0aGlzLm1fc3dlZXAuYy5TZXRWKHRoaXMubV9zd2VlcC5jMCk7XG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkueCArPSB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKC0odGhpcy5tX3N3ZWVwLmMueSAtIG9sZENlbnRlci55KSk7XG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkueSArPSB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKCsodGhpcy5tX3N3ZWVwLmMueCAtIG9sZENlbnRlci54KSk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlJlc2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fbWFzcyA9IDAuMDtcbiAgICAgIHRoaXMubV9pbnZNYXNzID0gMC4wO1xuICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICB0aGlzLm1faW52SSA9IDAuMDtcbiAgICAgIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlci5TZXRaZXJvKCk7XG4gICAgICBpZiAodGhpcy5tX3R5cGUgPT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkgfHwgdGhpcy5tX3R5cGUgPT0gYjJCb2R5LmIyX2tpbmVtYXRpY0JvZHkpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjZW50ZXIgPSBiMlZlYzIuTWFrZSgwLCAwKTtcbiAgICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgaWYgKGYubV9kZW5zaXR5ID09IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICB9XG4gICAgICAgICB2YXIgbWFzc0RhdGEgPSBmLkdldE1hc3NEYXRhKCk7XG4gICAgICAgICB0aGlzLm1fbWFzcyArPSBtYXNzRGF0YS5tYXNzO1xuICAgICAgICAgY2VudGVyLnggKz0gbWFzc0RhdGEuY2VudGVyLnggKiBtYXNzRGF0YS5tYXNzO1xuICAgICAgICAgY2VudGVyLnkgKz0gbWFzc0RhdGEuY2VudGVyLnkgKiBtYXNzRGF0YS5tYXNzO1xuICAgICAgICAgdGhpcy5tX0kgKz0gbWFzc0RhdGEuSTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1fbWFzcyA+IDAuMCkge1xuICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjAgLyB0aGlzLm1fbWFzcztcbiAgICAgICAgIGNlbnRlci54ICo9IHRoaXMubV9pbnZNYXNzO1xuICAgICAgICAgY2VudGVyLnkgKj0gdGhpcy5tX2ludk1hc3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9tYXNzID0gMS4wO1xuICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX0kgPiAwLjAgJiYgKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2ZpeGVkUm90YXRpb25GbGFnKSA9PSAwKSB7XG4gICAgICAgICB0aGlzLm1fSSAtPSB0aGlzLm1fbWFzcyAqIChjZW50ZXIueCAqIGNlbnRlci54ICsgY2VudGVyLnkgKiBjZW50ZXIueSk7XG4gICAgICAgICB0aGlzLm1fSSAqPSB0aGlzLm1faW5lcnRpYVNjYWxlO1xuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydCh0aGlzLm1fSSA+IDApO1xuICAgICAgICAgdGhpcy5tX2ludkkgPSAxLjAgLyB0aGlzLm1fSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICAgICB0aGlzLm1faW52SSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRDZW50ZXIgPSB0aGlzLm1fc3dlZXAuYy5Db3B5KCk7XG4gICAgICB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIuU2V0VihjZW50ZXIpO1xuICAgICAgdGhpcy5tX3N3ZWVwLmMwLlNldFYoYjJNYXRoLk11bFgodGhpcy5tX3hmLCB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIpKTtcbiAgICAgIHRoaXMubV9zd2VlcC5jLlNldFYodGhpcy5tX3N3ZWVwLmMwKTtcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS54ICs9IHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAoLSh0aGlzLm1fc3dlZXAuYy55IC0gb2xkQ2VudGVyLnkpKTtcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS55ICs9IHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAoKyh0aGlzLm1fc3dlZXAuYy54IC0gb2xkQ2VudGVyLngpKTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0V29ybGRQb2ludCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XG4gICAgICB2YXIgQSA9IHRoaXMubV94Zi5SO1xuICAgICAgdmFyIHUgPSBuZXcgYjJWZWMyKEEuY29sMS54ICogbG9jYWxQb2ludC54ICsgQS5jb2wyLnggKiBsb2NhbFBvaW50LnksIEEuY29sMS55ICogbG9jYWxQb2ludC54ICsgQS5jb2wyLnkgKiBsb2NhbFBvaW50LnkpO1xuICAgICAgdS54ICs9IHRoaXMubV94Zi5wb3NpdGlvbi54O1xuICAgICAgdS55ICs9IHRoaXMubV94Zi5wb3NpdGlvbi55O1xuICAgICAgcmV0dXJuIHU7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldFdvcmxkVmVjdG9yID0gZnVuY3Rpb24gKGxvY2FsVmVjdG9yKSB7XG4gICAgICByZXR1cm4gYjJNYXRoLk11bE1WKHRoaXMubV94Zi5SLCBsb2NhbFZlY3Rvcik7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldExvY2FsUG9pbnQgPSBmdW5jdGlvbiAod29ybGRQb2ludCkge1xuICAgICAgcmV0dXJuIGIyTWF0aC5NdWxYVCh0aGlzLm1feGYsIHdvcmxkUG9pbnQpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRMb2NhbFZlY3RvciA9IGZ1bmN0aW9uICh3b3JsZFZlY3Rvcikge1xuICAgICAgcmV0dXJuIGIyTWF0aC5NdWxUTVYodGhpcy5tX3hmLlIsIHdvcmxkVmVjdG9yKTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50KSB7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMih0aGlzLm1fbGluZWFyVmVsb2NpdHkueCAtIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAod29ybGRQb2ludC55IC0gdGhpcy5tX3N3ZWVwLmMueSksIHRoaXMubV9saW5lYXJWZWxvY2l0eS55ICsgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSAqICh3b3JsZFBvaW50LnggLSB0aGlzLm1fc3dlZXAuYy54KSk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldExpbmVhclZlbG9jaXR5RnJvbUxvY2FsUG9pbnQgPSBmdW5jdGlvbiAobG9jYWxQb2ludCkge1xuICAgICAgdmFyIEEgPSB0aGlzLm1feGYuUjtcbiAgICAgIHZhciB3b3JsZFBvaW50ID0gbmV3IGIyVmVjMihBLmNvbDEueCAqIGxvY2FsUG9pbnQueCArIEEuY29sMi54ICogbG9jYWxQb2ludC55LCBBLmNvbDEueSAqIGxvY2FsUG9pbnQueCArIEEuY29sMi55ICogbG9jYWxQb2ludC55KTtcbiAgICAgIHdvcmxkUG9pbnQueCArPSB0aGlzLm1feGYucG9zaXRpb24ueDtcbiAgICAgIHdvcmxkUG9pbnQueSArPSB0aGlzLm1feGYucG9zaXRpb24ueTtcbiAgICAgIHJldHVybiBuZXcgYjJWZWMyKHRoaXMubV9saW5lYXJWZWxvY2l0eS54IC0gdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSAqICh3b3JsZFBvaW50LnkgLSB0aGlzLm1fc3dlZXAuYy55KSwgdGhpcy5tX2xpbmVhclZlbG9jaXR5LnkgKyB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKHdvcmxkUG9pbnQueCAtIHRoaXMubV9zd2VlcC5jLngpKTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbGluZWFyRGFtcGluZztcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uIChsaW5lYXJEYW1waW5nKSB7XG4gICAgICBpZiAobGluZWFyRGFtcGluZyA9PT0gdW5kZWZpbmVkKSBsaW5lYXJEYW1waW5nID0gMDtcbiAgICAgIHRoaXMubV9saW5lYXJEYW1waW5nID0gbGluZWFyRGFtcGluZztcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0QW5ndWxhckRhbXBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2FuZ3VsYXJEYW1waW5nO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRBbmd1bGFyRGFtcGluZyA9IGZ1bmN0aW9uIChhbmd1bGFyRGFtcGluZykge1xuICAgICAgaWYgKGFuZ3VsYXJEYW1waW5nID09PSB1bmRlZmluZWQpIGFuZ3VsYXJEYW1waW5nID0gMDtcbiAgICAgIHRoaXMubV9hbmd1bGFyRGFtcGluZyA9IGFuZ3VsYXJEYW1waW5nO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHR5cGUgPSAwO1xuICAgICAgaWYgKHRoaXMubV90eXBlID09IHR5cGUpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubV90eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuUmVzZXRNYXNzRGF0YSgpO1xuICAgICAgaWYgKHRoaXMubV90eXBlID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuU2V0WmVybygpO1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fZm9yY2UuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX3RvcnF1ZSA9IDAuMDtcbiAgICAgIGZvciAodmFyIGNlID0gdGhpcy5tX2NvbnRhY3RMaXN0OyBjZTsgY2UgPSBjZS5uZXh0KSB7XG4gICAgICAgICBjZS5jb250YWN0LkZsYWdGb3JGaWx0ZXJpbmcoKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QnVsbGV0ID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYnVsbGV0RmxhZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkJvZHkuZV9idWxsZXRGbGFnO1xuICAgICAgfVxuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5Jc0J1bGxldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfYnVsbGV0RmxhZykgPT0gYjJCb2R5LmVfYnVsbGV0RmxhZztcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0U2xlZXBpbmdBbGxvd2VkID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyAmPSB+YjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICAgICAgICB0aGlzLlNldEF3YWtlKHRydWUpO1xuICAgICAgfVxuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRBd2FrZSA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQm9keS5lX2F3YWtlRmxhZztcbiAgICAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyAmPSB+YjJCb2R5LmVfYXdha2VGbGFnO1xuICAgICAgICAgdGhpcy5tX3NsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5TZXRaZXJvKCk7XG4gICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gMC4wO1xuICAgICAgICAgdGhpcy5tX2ZvcmNlLlNldFplcm8oKTtcbiAgICAgICAgIHRoaXMubV90b3JxdWUgPSAwLjA7XG4gICAgICB9XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLklzQXdha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2F3YWtlRmxhZykgPT0gYjJCb2R5LmVfYXdha2VGbGFnO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRGaXhlZFJvdGF0aW9uID0gZnVuY3Rpb24gKGZpeGVkKSB7XG4gICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcbiAgICAgIH1cbiAgICAgIHRoaXMuUmVzZXRNYXNzRGF0YSgpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5Jc0ZpeGVkUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2ZpeGVkUm90YXRpb25GbGFnKSA9PSBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QWN0aXZlID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgIGlmIChmbGFnID09IHRoaXMuSXNBY3RpdmUoKSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJyb2FkUGhhc2U7XG4gICAgICB2YXIgZjtcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWN0aXZlRmxhZztcbiAgICAgICAgIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICBmb3IgKGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICAgICBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgICAgIGYuQ3JlYXRlUHJveHkoYnJvYWRQaGFzZSwgdGhpcy5tX3hmKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkJvZHkuZV9hY3RpdmVGbGFnO1xuICAgICAgICAgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgIGZvciAoZiA9IHRoaXMubV9maXh0dXJlTGlzdDtcbiAgICAgICAgIGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgICAgZi5EZXN0cm95UHJveHkoYnJvYWRQaGFzZSk7XG4gICAgICAgICB9XG4gICAgICAgICB2YXIgY2UgPSB0aGlzLm1fY29udGFjdExpc3Q7XG4gICAgICAgICB3aGlsZSAoY2UpIHtcbiAgICAgICAgICAgIHZhciBjZTAgPSBjZTtcbiAgICAgICAgICAgIGNlID0gY2UubmV4dDtcbiAgICAgICAgICAgIHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLkRlc3Ryb3koY2UwLmNvbnRhY3QpO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuSXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2FjdGl2ZUZsYWcpID09IGIyQm9keS5lX2FjdGl2ZUZsYWc7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLklzU2xlZXBpbmdBbGxvd2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZykgPT0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldEZpeHR1cmVMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9maXh0dXJlTGlzdDtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0Sm9pbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9qb2ludExpc3Q7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldENvbnRyb2xsZXJMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9jb250cm9sbGVyTGlzdDtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0Q29udGFjdExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9uZXh0O1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRhdGE7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldFdvcmxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV93b3JsZDtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuYjJCb2R5ID0gZnVuY3Rpb24gKGJkLCB3b3JsZCkge1xuICAgICAgdGhpcy5tX2ZsYWdzID0gMDtcbiAgICAgIGlmIChiZC5idWxsZXQpIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9idWxsZXRGbGFnO1xuICAgICAgfVxuICAgICAgaWYgKGJkLmZpeGVkUm90YXRpb24pIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcbiAgICAgIH1cbiAgICAgIGlmIChiZC5hbGxvd1NsZWVwKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICAgICB9XG4gICAgICBpZiAoYmQuYXdha2UpIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9hd2FrZUZsYWc7XG4gICAgICB9XG4gICAgICBpZiAoYmQuYWN0aXZlKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWN0aXZlRmxhZztcbiAgICAgIH1cbiAgICAgIHRoaXMubV93b3JsZCA9IHdvcmxkO1xuICAgICAgdGhpcy5tX3hmLnBvc2l0aW9uLlNldFYoYmQucG9zaXRpb24pO1xuICAgICAgdGhpcy5tX3hmLlIuU2V0KGJkLmFuZ2xlKTtcbiAgICAgIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlci5TZXRaZXJvKCk7XG4gICAgICB0aGlzLm1fc3dlZXAudDAgPSAxLjA7XG4gICAgICB0aGlzLm1fc3dlZXAuYTAgPSB0aGlzLm1fc3dlZXAuYSA9IGJkLmFuZ2xlO1xuICAgICAgdmFyIHRNYXQgPSB0aGlzLm1feGYuUjtcbiAgICAgIHZhciB0VmVjID0gdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgdGhpcy5tX3N3ZWVwLmMueCA9ICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHRoaXMubV9zd2VlcC5jLnkgPSAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICB0aGlzLm1fc3dlZXAuYy54ICs9IHRoaXMubV94Zi5wb3NpdGlvbi54O1xuICAgICAgdGhpcy5tX3N3ZWVwLmMueSArPSB0aGlzLm1feGYucG9zaXRpb24ueTtcbiAgICAgIHRoaXMubV9zd2VlcC5jMC5TZXRWKHRoaXMubV9zd2VlcC5jKTtcbiAgICAgIHRoaXMubV9qb2ludExpc3QgPSBudWxsO1xuICAgICAgdGhpcy5tX2NvbnRyb2xsZXJMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fY29udHJvbGxlckNvdW50ID0gMDtcbiAgICAgIHRoaXMubV9wcmV2ID0gbnVsbDtcbiAgICAgIHRoaXMubV9uZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5TZXRWKGJkLmxpbmVhclZlbG9jaXR5KTtcbiAgICAgIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgPSBiZC5hbmd1bGFyVmVsb2NpdHk7XG4gICAgICB0aGlzLm1fbGluZWFyRGFtcGluZyA9IGJkLmxpbmVhckRhbXBpbmc7XG4gICAgICB0aGlzLm1fYW5ndWxhckRhbXBpbmcgPSBiZC5hbmd1bGFyRGFtcGluZztcbiAgICAgIHRoaXMubV9mb3JjZS5TZXQoMC4wLCAwLjApO1xuICAgICAgdGhpcy5tX3RvcnF1ZSA9IDAuMDtcbiAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICB0aGlzLm1fdHlwZSA9IGJkLnR5cGU7XG4gICAgICBpZiAodGhpcy5tX3R5cGUgPT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICB0aGlzLm1fbWFzcyA9IDEuMDtcbiAgICAgICAgIHRoaXMubV9pbnZNYXNzID0gMS4wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fbWFzcyA9IDAuMDtcbiAgICAgICAgIHRoaXMubV9pbnZNYXNzID0gMC4wO1xuICAgICAgfVxuICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICB0aGlzLm1faW52SSA9IDAuMDtcbiAgICAgIHRoaXMubV9pbmVydGlhU2NhbGUgPSBiZC5pbmVydGlhU2NhbGU7XG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBiZC51c2VyRGF0YTtcbiAgICAgIHRoaXMubV9maXh0dXJlTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fZml4dHVyZUNvdW50ID0gMDtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU3luY2hyb25pemVGaXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB4ZjEgPSBiMkJvZHkuc194ZjE7XG4gICAgICB4ZjEuUi5TZXQodGhpcy5tX3N3ZWVwLmEwKTtcbiAgICAgIHZhciB0TWF0ID0geGYxLlI7XG4gICAgICB2YXIgdFZlYyA9IHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgIHhmMS5wb3NpdGlvbi54ID0gdGhpcy5tX3N3ZWVwLmMwLnggLSAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB4ZjEucG9zaXRpb24ueSA9IHRoaXMubV9zd2VlcC5jMC55IC0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdmFyIGY7XG4gICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcbiAgICAgIGZvciAoZiA9IHRoaXMubV9maXh0dXJlTGlzdDtcbiAgICAgIGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgZi5TeW5jaHJvbml6ZShicm9hZFBoYXNlLCB4ZjEsIHRoaXMubV94Zik7XG4gICAgICB9XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlN5bmNocm9uaXplVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX3hmLlIuU2V0KHRoaXMubV9zd2VlcC5hKTtcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX3hmLlI7XG4gICAgICB2YXIgdFZlYyA9IHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgIHRoaXMubV94Zi5wb3NpdGlvbi54ID0gdGhpcy5tX3N3ZWVwLmMueCAtICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHRoaXMubV94Zi5wb3NpdGlvbi55ID0gdGhpcy5tX3N3ZWVwLmMueSAtICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2hvdWxkQ29sbGlkZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgaWYgKHRoaXMubV90eXBlICE9IGIyQm9keS5iMl9keW5hbWljQm9keSAmJiBvdGhlci5tX3R5cGUgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqbiA9IHRoaXMubV9qb2ludExpc3Q7IGpuOyBqbiA9IGpuLm5leHQpIHtcbiAgICAgICAgIGlmIChqbi5vdGhlciA9PSBvdGhlcikgaWYgKGpuLmpvaW50Lm1fY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkFkdmFuY2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgdCA9IDA7XG4gICAgICB0aGlzLm1fc3dlZXAuQWR2YW5jZSh0KTtcbiAgICAgIHRoaXMubV9zd2VlcC5jLlNldFYodGhpcy5tX3N3ZWVwLmMwKTtcbiAgICAgIHRoaXMubV9zd2VlcC5hID0gdGhpcy5tX3N3ZWVwLmEwO1xuICAgICAgdGhpcy5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuc194ZjEgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQm9keS5lX2lzbGFuZEZsYWcgPSAweDAwMDE7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuZV9hd2FrZUZsYWcgPSAweDAwMDI7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuZV9hbGxvd1NsZWVwRmxhZyA9IDB4MDAwNDtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQm9keS5lX2J1bGxldEZsYWcgPSAweDAwMDg7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZyA9IDB4MDAxMDtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQm9keS5lX2FjdGl2ZUZsYWcgPSAweDAwMjA7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuYjJfc3RhdGljQm9keSA9IDA7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuYjJfa2luZW1hdGljQm9keSA9IDE7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuYjJfZHluYW1pY0JvZHkgPSAyO1xuICAgfSk7XG4gICBiMkJvZHlEZWYuYjJCb2R5RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubGluZWFyVmVsb2NpdHkgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJCb2R5RGVmLnByb3RvdHlwZS5iMkJvZHlEZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnVzZXJEYXRhID0gbnVsbDtcbiAgICAgIHRoaXMucG9zaXRpb24uU2V0KDAuMCwgMC4wKTtcbiAgICAgIHRoaXMuYW5nbGUgPSAwLjA7XG4gICAgICB0aGlzLmxpbmVhclZlbG9jaXR5LlNldCgwLCAwKTtcbiAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gMC4wO1xuICAgICAgdGhpcy5saW5lYXJEYW1waW5nID0gMC4wO1xuICAgICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IDAuMDtcbiAgICAgIHRoaXMuYWxsb3dTbGVlcCA9IHRydWU7XG4gICAgICB0aGlzLmF3YWtlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZml4ZWRSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5idWxsZXQgPSBmYWxzZTtcbiAgICAgIHRoaXMudHlwZSA9IGIyQm9keS5iMl9zdGF0aWNCb2R5O1xuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5pbmVydGlhU2NhbGUgPSAxLjA7XG4gICB9XG4gICBiMkNvbnRhY3RGaWx0ZXIuYjJDb250YWN0RmlsdGVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RGaWx0ZXIucHJvdG90eXBlLlNob3VsZENvbGxpZGUgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XG4gICAgICB2YXIgZmlsdGVyMSA9IGZpeHR1cmVBLkdldEZpbHRlckRhdGEoKTtcbiAgICAgIHZhciBmaWx0ZXIyID0gZml4dHVyZUIuR2V0RmlsdGVyRGF0YSgpO1xuICAgICAgaWYgKGZpbHRlcjEuZ3JvdXBJbmRleCA9PSBmaWx0ZXIyLmdyb3VwSW5kZXggJiYgZmlsdGVyMS5ncm91cEluZGV4ICE9IDApIHtcbiAgICAgICAgIHJldHVybiBmaWx0ZXIxLmdyb3VwSW5kZXggPiAwO1xuICAgICAgfVxuICAgICAgdmFyIGNvbGxpZGUgPSAoZmlsdGVyMS5tYXNrQml0cyAmIGZpbHRlcjIuY2F0ZWdvcnlCaXRzKSAhPSAwICYmIChmaWx0ZXIxLmNhdGVnb3J5Qml0cyAmIGZpbHRlcjIubWFza0JpdHMpICE9IDA7XG4gICAgICByZXR1cm4gY29sbGlkZTtcbiAgIH1cbiAgIGIyQ29udGFjdEZpbHRlci5wcm90b3R5cGUuUmF5Q29sbGlkZSA9IGZ1bmN0aW9uICh1c2VyRGF0YSwgZml4dHVyZSkge1xuICAgICAgaWYgKCF1c2VyRGF0YSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5TaG91bGRDb2xsaWRlKCh1c2VyRGF0YSBpbnN0YW5jZW9mIGIyRml4dHVyZSA/IHVzZXJEYXRhIDogbnVsbCksIGZpeHR1cmUpO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RGaWx0ZXIuYjJfZGVmYXVsdEZpbHRlciA9IG5ldyBiMkNvbnRhY3RGaWx0ZXIoKTtcbiAgIH0pO1xuICAgYjJDb250YWN0SW1wdWxzZS5iMkNvbnRhY3RJbXB1bHNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ub3JtYWxJbXB1bHNlcyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcihiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzKTtcbiAgICAgIHRoaXMudGFuZ2VudEltcHVsc2VzID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xuICAgfTtcbiAgIGIyQ29udGFjdExpc3RlbmVyLmIyQ29udGFjdExpc3RlbmVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RMaXN0ZW5lci5wcm90b3R5cGUuQmVnaW5Db250YWN0ID0gZnVuY3Rpb24gKGNvbnRhY3QpIHt9XG4gICBiMkNvbnRhY3RMaXN0ZW5lci5wcm90b3R5cGUuRW5kQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0KSB7fVxuICAgYjJDb250YWN0TGlzdGVuZXIucHJvdG90eXBlLlByZVNvbHZlID0gZnVuY3Rpb24gKGNvbnRhY3QsIG9sZE1hbmlmb2xkKSB7fVxuICAgYjJDb250YWN0TGlzdGVuZXIucHJvdG90eXBlLlBvc3RTb2x2ZSA9IGZ1bmN0aW9uIChjb250YWN0LCBpbXB1bHNlKSB7fVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lci5iMl9kZWZhdWx0TGlzdGVuZXIgPSBuZXcgYjJDb250YWN0TGlzdGVuZXIoKTtcbiAgIH0pO1xuICAgYjJDb250YWN0TWFuYWdlci5iMkNvbnRhY3RNYW5hZ2VyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RNYW5hZ2VyLnByb3RvdHlwZS5iMkNvbnRhY3RNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX3dvcmxkID0gbnVsbDtcbiAgICAgIHRoaXMubV9jb250YWN0Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2NvbnRhY3RGaWx0ZXIgPSBiMkNvbnRhY3RGaWx0ZXIuYjJfZGVmYXVsdEZpbHRlcjtcbiAgICAgIHRoaXMubV9jb250YWN0TGlzdGVuZXIgPSBiMkNvbnRhY3RMaXN0ZW5lci5iMl9kZWZhdWx0TGlzdGVuZXI7XG4gICAgICB0aGlzLm1fY29udGFjdEZhY3RvcnkgPSBuZXcgYjJDb250YWN0RmFjdG9yeSh0aGlzLm1fYWxsb2NhdG9yKTtcbiAgICAgIHRoaXMubV9icm9hZFBoYXNlID0gbmV3IGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlKCk7XG4gICB9XG4gICBiMkNvbnRhY3RNYW5hZ2VyLnByb3RvdHlwZS5BZGRQYWlyID0gZnVuY3Rpb24gKHByb3h5VXNlckRhdGFBLCBwcm94eVVzZXJEYXRhQikge1xuICAgICAgdmFyIGZpeHR1cmVBID0gKHByb3h5VXNlckRhdGFBIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gcHJveHlVc2VyRGF0YUEgOiBudWxsKTtcbiAgICAgIHZhciBmaXh0dXJlQiA9IChwcm94eVVzZXJEYXRhQiBpbnN0YW5jZW9mIGIyRml4dHVyZSA/IHByb3h5VXNlckRhdGFCIDogbnVsbCk7XG4gICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5HZXRCb2R5KCk7XG4gICAgICBpZiAoYm9keUEgPT0gYm9keUIpIHJldHVybjtcbiAgICAgIHZhciBlZGdlID0gYm9keUIuR2V0Q29udGFjdExpc3QoKTtcbiAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBib2R5QSkge1xuICAgICAgICAgICAgdmFyIGZBID0gZWRnZS5jb250YWN0LkdldEZpeHR1cmVBKCk7XG4gICAgICAgICAgICB2YXIgZkIgPSBlZGdlLmNvbnRhY3QuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgIGlmIChmQSA9PSBmaXh0dXJlQSAmJiBmQiA9PSBmaXh0dXJlQikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGZBID09IGZpeHR1cmVCICYmIGZCID09IGZpeHR1cmVBKSByZXR1cm47XG4gICAgICAgICB9XG4gICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKGJvZHlCLlNob3VsZENvbGxpZGUoYm9keUEpID09IGZhbHNlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2NvbnRhY3RGaWx0ZXIuU2hvdWxkQ29sbGlkZShmaXh0dXJlQSwgZml4dHVyZUIpID09IGZhbHNlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYyA9IHRoaXMubV9jb250YWN0RmFjdG9yeS5DcmVhdGUoZml4dHVyZUEsIGZpeHR1cmVCKTtcbiAgICAgIGZpeHR1cmVBID0gYy5HZXRGaXh0dXJlQSgpO1xuICAgICAgZml4dHVyZUIgPSBjLkdldEZpeHR1cmVCKCk7XG4gICAgICBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgIGJvZHlCID0gZml4dHVyZUIubV9ib2R5O1xuICAgICAgYy5tX3ByZXYgPSBudWxsO1xuICAgICAgYy5tX25leHQgPSB0aGlzLm1fd29ybGQubV9jb250YWN0TGlzdDtcbiAgICAgIGlmICh0aGlzLm1fd29ybGQubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XG4gICAgICAgICB0aGlzLm1fd29ybGQubV9jb250YWN0TGlzdC5tX3ByZXYgPSBjO1xuICAgICAgfVxuICAgICAgdGhpcy5tX3dvcmxkLm1fY29udGFjdExpc3QgPSBjO1xuICAgICAgYy5tX25vZGVBLmNvbnRhY3QgPSBjO1xuICAgICAgYy5tX25vZGVBLm90aGVyID0gYm9keUI7XG4gICAgICBjLm1fbm9kZUEucHJldiA9IG51bGw7XG4gICAgICBjLm1fbm9kZUEubmV4dCA9IGJvZHlBLm1fY29udGFjdExpc3Q7XG4gICAgICBpZiAoYm9keUEubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XG4gICAgICAgICBib2R5QS5tX2NvbnRhY3RMaXN0LnByZXYgPSBjLm1fbm9kZUE7XG4gICAgICB9XG4gICAgICBib2R5QS5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVBO1xuICAgICAgYy5tX25vZGVCLmNvbnRhY3QgPSBjO1xuICAgICAgYy5tX25vZGVCLm90aGVyID0gYm9keUE7XG4gICAgICBjLm1fbm9kZUIucHJldiA9IG51bGw7XG4gICAgICBjLm1fbm9kZUIubmV4dCA9IGJvZHlCLm1fY29udGFjdExpc3Q7XG4gICAgICBpZiAoYm9keUIubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XG4gICAgICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0LnByZXYgPSBjLm1fbm9kZUI7XG4gICAgICB9XG4gICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVCO1xuICAgICAgKyt0aGlzLm1fd29ybGQubV9jb250YWN0Q291bnQ7XG4gICAgICByZXR1cm47XG4gICB9XG4gICBiMkNvbnRhY3RNYW5hZ2VyLnByb3RvdHlwZS5GaW5kTmV3Q29udGFjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fYnJvYWRQaGFzZS5VcGRhdGVQYWlycyhCb3gyRC5nZW5lcmF0ZUNhbGxiYWNrKHRoaXMsIHRoaXMuQWRkUGFpcikpO1xuICAgfVxuICAgYjJDb250YWN0TWFuYWdlci5wcm90b3R5cGUuRGVzdHJveSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgZml4dHVyZUEgPSBjLkdldEZpeHR1cmVBKCk7XG4gICAgICB2YXIgZml4dHVyZUIgPSBjLkdldEZpeHR1cmVCKCk7XG4gICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5HZXRCb2R5KCk7XG4gICAgICBpZiAoYy5Jc1RvdWNoaW5nKCkpIHtcbiAgICAgICAgIHRoaXMubV9jb250YWN0TGlzdGVuZXIuRW5kQ29udGFjdChjKTtcbiAgICAgIH1cbiAgICAgIGlmIChjLm1fcHJldikge1xuICAgICAgICAgYy5tX3ByZXYubV9uZXh0ID0gYy5tX25leHQ7XG4gICAgICB9XG4gICAgICBpZiAoYy5tX25leHQpIHtcbiAgICAgICAgIGMubV9uZXh0Lm1fcHJldiA9IGMubV9wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGMgPT0gdGhpcy5tX3dvcmxkLm1fY29udGFjdExpc3QpIHtcbiAgICAgICAgIHRoaXMubV93b3JsZC5tX2NvbnRhY3RMaXN0ID0gYy5tX25leHQ7XG4gICAgICB9XG4gICAgICBpZiAoYy5tX25vZGVBLnByZXYpIHtcbiAgICAgICAgIGMubV9ub2RlQS5wcmV2Lm5leHQgPSBjLm1fbm9kZUEubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChjLm1fbm9kZUEubmV4dCkge1xuICAgICAgICAgYy5tX25vZGVBLm5leHQucHJldiA9IGMubV9ub2RlQS5wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGMubV9ub2RlQSA9PSBib2R5QS5tX2NvbnRhY3RMaXN0KSB7XG4gICAgICAgICBib2R5QS5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVBLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAoYy5tX25vZGVCLnByZXYpIHtcbiAgICAgICAgIGMubV9ub2RlQi5wcmV2Lm5leHQgPSBjLm1fbm9kZUIubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChjLm1fbm9kZUIubmV4dCkge1xuICAgICAgICAgYy5tX25vZGVCLm5leHQucHJldiA9IGMubV9ub2RlQi5wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGMubV9ub2RlQiA9PSBib2R5Qi5tX2NvbnRhY3RMaXN0KSB7XG4gICAgICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVCLm5leHQ7XG4gICAgICB9XG4gICAgICB0aGlzLm1fY29udGFjdEZhY3RvcnkuRGVzdHJveShjKTtcbiAgICAgIC0tdGhpcy5tX2NvbnRhY3RDb3VudDtcbiAgIH1cbiAgIGIyQ29udGFjdE1hbmFnZXIucHJvdG90eXBlLkNvbGxpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYyA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RMaXN0O1xuICAgICAgd2hpbGUgKGMpIHtcbiAgICAgICAgIHZhciBmaXh0dXJlQSA9IGMuR2V0Rml4dHVyZUEoKTtcbiAgICAgICAgIHZhciBmaXh0dXJlQiA9IGMuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLkdldEJvZHkoKTtcbiAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLkdldEJvZHkoKTtcbiAgICAgICAgIGlmIChib2R5QS5Jc0F3YWtlKCkgPT0gZmFsc2UgJiYgYm9keUIuSXNBd2FrZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICBjID0gYy5HZXROZXh0KCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChjLm1fZmxhZ3MgJiBiMkNvbnRhY3QuZV9maWx0ZXJGbGFnKSB7XG4gICAgICAgICAgICBpZiAoYm9keUIuU2hvdWxkQ29sbGlkZShib2R5QSkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgIHZhciBjTnVrZSA9IGM7XG4gICAgICAgICAgICAgICBjID0gY051a2UuR2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgdGhpcy5EZXN0cm95KGNOdWtlKTtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV9jb250YWN0RmlsdGVyLlNob3VsZENvbGxpZGUoZml4dHVyZUEsIGZpeHR1cmVCKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgY051a2UgPSBjO1xuICAgICAgICAgICAgICAgYyA9IGNOdWtlLkdldE5leHQoKTtcbiAgICAgICAgICAgICAgIHRoaXMuRGVzdHJveShjTnVrZSk7XG4gICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMubV9mbGFncyAmPSB+YjJDb250YWN0LmVfZmlsdGVyRmxhZztcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciBwcm94eUEgPSBmaXh0dXJlQS5tX3Byb3h5O1xuICAgICAgICAgdmFyIHByb3h5QiA9IGZpeHR1cmVCLm1fcHJveHk7XG4gICAgICAgICB2YXIgb3ZlcmxhcCA9IHRoaXMubV9icm9hZFBoYXNlLlRlc3RPdmVybGFwKHByb3h5QSwgcHJveHlCKTtcbiAgICAgICAgIGlmIChvdmVybGFwID09IGZhbHNlKSB7XG4gICAgICAgICAgICBjTnVrZSA9IGM7XG4gICAgICAgICAgICBjID0gY051a2UuR2V0TmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5EZXN0cm95KGNOdWtlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgYy5VcGRhdGUodGhpcy5tX2NvbnRhY3RMaXN0ZW5lcik7XG4gICAgICAgICBjID0gYy5HZXROZXh0KCk7XG4gICAgICB9XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIuc19ldmFsQ1AgPSBuZXcgYjJDb250YWN0UG9pbnQoKTtcbiAgIH0pO1xuICAgYjJEZWJ1Z0RyYXcuYjJEZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5iMkRlYnVnRHJhdyA9IGZ1bmN0aW9uICgpIHt9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0RmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RmxhZ3MgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkFwcGVuZEZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICBpZiAoZmxhZ3MgPT09IHVuZGVmaW5lZCkgZmxhZ3MgPSAwO1xuICAgfVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkNsZWFyRmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0U3ByaXRlID0gZnVuY3Rpb24gKHNwcml0ZSkge31cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRTcHJpdGUgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldERyYXdTY2FsZSA9IGZ1bmN0aW9uIChkcmF3U2NhbGUpIHtcbiAgICAgIGlmIChkcmF3U2NhbGUgPT09IHVuZGVmaW5lZCkgZHJhd1NjYWxlID0gMDtcbiAgIH1cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXREcmF3U2NhbGUgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldExpbmVUaGlja25lc3MgPSBmdW5jdGlvbiAobGluZVRoaWNrbmVzcykge1xuICAgICAgaWYgKGxpbmVUaGlja25lc3MgPT09IHVuZGVmaW5lZCkgbGluZVRoaWNrbmVzcyA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0TGluZVRoaWNrbmVzcyA9IGZ1bmN0aW9uICgpIHt9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0QWxwaGEgPSBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSBhbHBoYSA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0QWxwaGEgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldEZpbGxBbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcbiAgIH1cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRGaWxsQWxwaGEgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldFhGb3JtU2NhbGUgPSBmdW5jdGlvbiAoeGZvcm1TY2FsZSkge1xuICAgICAgaWYgKHhmb3JtU2NhbGUgPT09IHVuZGVmaW5lZCkgeGZvcm1TY2FsZSA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0WEZvcm1TY2FsZSA9IGZ1bmN0aW9uICgpIHt9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1BvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50LCBjb2xvcikge1xuICAgICAgaWYgKHZlcnRleENvdW50ID09PSB1bmRlZmluZWQpIHZlcnRleENvdW50ID0gMDtcbiAgIH1cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3U29saWRQb2x5Z29uID0gZnVuY3Rpb24gKHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCwgY29sb3IpIHtcbiAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PT0gdW5kZWZpbmVkKSB2ZXJ0ZXhDb3VudCA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd0NpcmNsZSA9IGZ1bmN0aW9uIChjZW50ZXIsIHJhZGl1cywgY29sb3IpIHtcbiAgICAgIGlmIChyYWRpdXMgPT09IHVuZGVmaW5lZCkgcmFkaXVzID0gMDtcbiAgIH1cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3U29saWRDaXJjbGUgPSBmdW5jdGlvbiAoY2VudGVyLCByYWRpdXMsIGF4aXMsIGNvbG9yKSB7XG4gICAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHJhZGl1cyA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1NlZ21lbnQgPSBmdW5jdGlvbiAocDEsIHAyLCBjb2xvcikge31cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3VHJhbnNmb3JtID0gZnVuY3Rpb24gKHhmKSB7fVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdy5lX3NoYXBlQml0ID0gMHgwMDAxO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcuZV9qb2ludEJpdCA9IDB4MDAwMjtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfYWFiYkJpdCA9IDB4MDAwNDtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfcGFpckJpdCA9IDB4MDAwODtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfY2VudGVyT2ZNYXNzQml0ID0gMHgwMDEwO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcuZV9jb250cm9sbGVyQml0ID0gMHgwMDIwO1xuICAgfSk7XG4gICBiMkRlc3RydWN0aW9uTGlzdGVuZXIuYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkRlc3RydWN0aW9uTGlzdGVuZXIucHJvdG90eXBlLlNheUdvb2RieWVKb2ludCA9IGZ1bmN0aW9uIChqb2ludCkge31cbiAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lci5wcm90b3R5cGUuU2F5R29vZGJ5ZUZpeHR1cmUgPSBmdW5jdGlvbiAoZml4dHVyZSkge31cbiAgIGIyRmlsdGVyRGF0YS5iMkZpbHRlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhdGVnb3J5Qml0cyA9IDB4MDAwMTtcbiAgICAgIHRoaXMubWFza0JpdHMgPSAweEZGRkY7XG4gICAgICB0aGlzLmdyb3VwSW5kZXggPSAwO1xuICAgfTtcbiAgIGIyRmlsdGVyRGF0YS5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb3B5ID0gbmV3IGIyRmlsdGVyRGF0YSgpO1xuICAgICAgY29weS5jYXRlZ29yeUJpdHMgPSB0aGlzLmNhdGVnb3J5Qml0cztcbiAgICAgIGNvcHkubWFza0JpdHMgPSB0aGlzLm1hc2tCaXRzO1xuICAgICAgY29weS5ncm91cEluZGV4ID0gdGhpcy5ncm91cEluZGV4O1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICB9XG4gICBiMkZpeHR1cmUuYjJGaXh0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX2ZpbHRlciA9IG5ldyBiMkZpbHRlckRhdGEoKTtcbiAgIH07XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLkdldFR5cGUoKTtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuR2V0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5TZXRTZW5zb3IgPSBmdW5jdGlvbiAoc2Vuc29yKSB7XG4gICAgICBpZiAodGhpcy5tX2lzU2Vuc29yID09IHNlbnNvcikgcmV0dXJuO1xuICAgICAgdGhpcy5tX2lzU2Vuc29yID0gc2Vuc29yO1xuICAgICAgaWYgKHRoaXMubV9ib2R5ID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5tX2JvZHkuR2V0Q29udGFjdExpc3QoKTtcbiAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICB2YXIgY29udGFjdCA9IGVkZ2UuY29udGFjdDtcbiAgICAgICAgIHZhciBmaXh0dXJlQSA9IGNvbnRhY3QuR2V0Rml4dHVyZUEoKTtcbiAgICAgICAgIHZhciBmaXh0dXJlQiA9IGNvbnRhY3QuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgIGlmIChmaXh0dXJlQSA9PSB0aGlzIHx8IGZpeHR1cmVCID09IHRoaXMpIGNvbnRhY3QuU2V0U2Vuc29yKGZpeHR1cmVBLklzU2Vuc29yKCkgfHwgZml4dHVyZUIuSXNTZW5zb3IoKSk7XG4gICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgfVxuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5Jc1NlbnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1faXNTZW5zb3I7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldEZpbHRlckRhdGEgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICB0aGlzLm1fZmlsdGVyID0gZmlsdGVyLkNvcHkoKTtcbiAgICAgIGlmICh0aGlzLm1fYm9keSkgcmV0dXJuO1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLm1fYm9keS5HZXRDb250YWN0TGlzdCgpO1xuICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgIHZhciBjb250YWN0ID0gZWRnZS5jb250YWN0O1xuICAgICAgICAgdmFyIGZpeHR1cmVBID0gY29udGFjdC5HZXRGaXh0dXJlQSgpO1xuICAgICAgICAgdmFyIGZpeHR1cmVCID0gY29udGFjdC5HZXRGaXh0dXJlQigpO1xuICAgICAgICAgaWYgKGZpeHR1cmVBID09IHRoaXMgfHwgZml4dHVyZUIgPT0gdGhpcykgY29udGFjdC5GbGFnRm9yRmlsdGVyaW5nKCk7XG4gICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgfVxuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRGaWx0ZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9maWx0ZXIuQ29weSgpO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRCb2R5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5O1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9uZXh0O1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRhdGE7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlRlc3RQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLlRlc3RQb2ludCh0aGlzLm1fYm9keS5HZXRUcmFuc2Zvcm0oKSwgcCk7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9zaGFwZS5SYXlDYXN0KG91dHB1dCwgaW5wdXQsIHRoaXMubV9ib2R5LkdldFRyYW5zZm9ybSgpKTtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuR2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAobWFzc0RhdGEpIHtcbiAgICAgIGlmIChtYXNzRGF0YSA9PT0gdW5kZWZpbmVkKSBtYXNzRGF0YSA9IG51bGw7XG4gICAgICBpZiAobWFzc0RhdGEgPT0gbnVsbCkge1xuICAgICAgICAgbWFzc0RhdGEgPSBuZXcgYjJNYXNzRGF0YSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tX3NoYXBlLkNvbXB1dGVNYXNzKG1hc3NEYXRhLCB0aGlzLm1fZGVuc2l0eSk7XG4gICAgICByZXR1cm4gbWFzc0RhdGE7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldERlbnNpdHkgPSBmdW5jdGlvbiAoZGVuc2l0eSkge1xuICAgICAgaWYgKGRlbnNpdHkgPT09IHVuZGVmaW5lZCkgZGVuc2l0eSA9IDA7XG4gICAgICB0aGlzLm1fZGVuc2l0eSA9IGRlbnNpdHk7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldERlbnNpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RlbnNpdHk7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldEZyaWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9mcmljdGlvbjtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuU2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24pIHtcbiAgICAgIGlmIChmcmljdGlvbiA9PT0gdW5kZWZpbmVkKSBmcmljdGlvbiA9IDA7XG4gICAgICB0aGlzLm1fZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuR2V0UmVzdGl0dXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3Jlc3RpdHV0aW9uO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5TZXRSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uIChyZXN0aXR1dGlvbikge1xuICAgICAgaWYgKHJlc3RpdHV0aW9uID09PSB1bmRlZmluZWQpIHJlc3RpdHV0aW9uID0gMDtcbiAgICAgIHRoaXMubV9yZXN0aXR1dGlvbiA9IHJlc3RpdHV0aW9uO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRBQUJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9hYWJiO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5iMkZpeHR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fYWFiYiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHRoaXMubV91c2VyRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLm1fYm9keSA9IG51bGw7XG4gICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICB0aGlzLm1fc2hhcGUgPSBudWxsO1xuICAgICAgdGhpcy5tX2RlbnNpdHkgPSAwLjA7XG4gICAgICB0aGlzLm1fZnJpY3Rpb24gPSAwLjA7XG4gICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSAwLjA7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkNyZWF0ZSA9IGZ1bmN0aW9uIChib2R5LCB4ZiwgZGVmKSB7XG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBkZWYudXNlckRhdGE7XG4gICAgICB0aGlzLm1fZnJpY3Rpb24gPSBkZWYuZnJpY3Rpb247XG4gICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSBkZWYucmVzdGl0dXRpb247XG4gICAgICB0aGlzLm1fYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICB0aGlzLm1fZmlsdGVyID0gZGVmLmZpbHRlci5Db3B5KCk7XG4gICAgICB0aGlzLm1faXNTZW5zb3IgPSBkZWYuaXNTZW5zb3I7XG4gICAgICB0aGlzLm1fc2hhcGUgPSBkZWYuc2hhcGUuQ29weSgpO1xuICAgICAgdGhpcy5tX2RlbnNpdHkgPSBkZWYuZGVuc2l0eTtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9zaGFwZSA9IG51bGw7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkNyZWF0ZVByb3h5ID0gZnVuY3Rpb24gKGJyb2FkUGhhc2UsIHhmKSB7XG4gICAgICB0aGlzLm1fc2hhcGUuQ29tcHV0ZUFBQkIodGhpcy5tX2FhYmIsIHhmKTtcbiAgICAgIHRoaXMubV9wcm94eSA9IGJyb2FkUGhhc2UuQ3JlYXRlUHJveHkodGhpcy5tX2FhYmIsIHRoaXMpO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5EZXN0cm95UHJveHkgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSkge1xuICAgICAgaWYgKHRoaXMubV9wcm94eSA9PSBudWxsKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicm9hZFBoYXNlLkRlc3Ryb3lQcm94eSh0aGlzLm1fcHJveHkpO1xuICAgICAgdGhpcy5tX3Byb3h5ID0gbnVsbDtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuU3luY2hyb25pemUgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSwgdHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICAgICAgaWYgKCF0aGlzLm1fcHJveHkpIHJldHVybjtcbiAgICAgIHZhciBhYWJiMSA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHZhciBhYWJiMiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHRoaXMubV9zaGFwZS5Db21wdXRlQUFCQihhYWJiMSwgdHJhbnNmb3JtMSk7XG4gICAgICB0aGlzLm1fc2hhcGUuQ29tcHV0ZUFBQkIoYWFiYjIsIHRyYW5zZm9ybTIpO1xuICAgICAgdGhpcy5tX2FhYmIuQ29tYmluZShhYWJiMSwgYWFiYjIpO1xuICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IGIyTWF0aC5TdWJ0cmFjdFZWKHRyYW5zZm9ybTIucG9zaXRpb24sIHRyYW5zZm9ybTEucG9zaXRpb24pO1xuICAgICAgYnJvYWRQaGFzZS5Nb3ZlUHJveHkodGhpcy5tX3Byb3h5LCB0aGlzLm1fYWFiYiwgZGlzcGxhY2VtZW50KTtcbiAgIH1cbiAgIGIyRml4dHVyZURlZi5iMkZpeHR1cmVEZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmZpbHRlciA9IG5ldyBiMkZpbHRlckRhdGEoKTtcbiAgIH07XG4gICBiMkZpeHR1cmVEZWYucHJvdG90eXBlLmIyRml4dHVyZURlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2hhcGUgPSBudWxsO1xuICAgICAgdGhpcy51c2VyRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmZyaWN0aW9uID0gMC4yO1xuICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IDAuMDtcbiAgICAgIHRoaXMuZGVuc2l0eSA9IDAuMDtcbiAgICAgIHRoaXMuZmlsdGVyLmNhdGVnb3J5Qml0cyA9IDB4MDAwMTtcbiAgICAgIHRoaXMuZmlsdGVyLm1hc2tCaXRzID0gMHhGRkZGO1xuICAgICAgdGhpcy5maWx0ZXIuZ3JvdXBJbmRleCA9IDA7XG4gICAgICB0aGlzLmlzU2Vuc29yID0gZmFsc2U7XG4gICB9XG4gICBiMklzbGFuZC5iMklzbGFuZCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJJc2xhbmQucHJvdG90eXBlLmIySXNsYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX2JvZGllcyA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHRoaXMubV9jb250YWN0cyA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHRoaXMubV9qb2ludHMgPSBuZXcgVmVjdG9yKCk7XG4gICB9XG4gICBiMklzbGFuZC5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChib2R5Q2FwYWNpdHksIGNvbnRhY3RDYXBhY2l0eSwgam9pbnRDYXBhY2l0eSwgYWxsb2NhdG9yLCBsaXN0ZW5lciwgY29udGFjdFNvbHZlcikge1xuICAgICAgaWYgKGJvZHlDYXBhY2l0eSA9PT0gdW5kZWZpbmVkKSBib2R5Q2FwYWNpdHkgPSAwO1xuICAgICAgaWYgKGNvbnRhY3RDYXBhY2l0eSA9PT0gdW5kZWZpbmVkKSBjb250YWN0Q2FwYWNpdHkgPSAwO1xuICAgICAgaWYgKGpvaW50Q2FwYWNpdHkgPT09IHVuZGVmaW5lZCkgam9pbnRDYXBhY2l0eSA9IDA7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB0aGlzLm1fYm9keUNhcGFjaXR5ID0gYm9keUNhcGFjaXR5O1xuICAgICAgdGhpcy5tX2NvbnRhY3RDYXBhY2l0eSA9IGNvbnRhY3RDYXBhY2l0eTtcbiAgICAgIHRoaXMubV9qb2ludENhcGFjaXR5ID0gam9pbnRDYXBhY2l0eTtcbiAgICAgIHRoaXMubV9ib2R5Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2NvbnRhY3RDb3VudCA9IDA7XG4gICAgICB0aGlzLm1fam9pbnRDb3VudCA9IDA7XG4gICAgICB0aGlzLm1fYWxsb2NhdG9yID0gYWxsb2NhdG9yO1xuICAgICAgdGhpcy5tX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlciA9IGNvbnRhY3RTb2x2ZXI7XG4gICAgICBmb3IgKGkgPSB0aGlzLm1fYm9kaWVzLmxlbmd0aDtcbiAgICAgIGkgPCBib2R5Q2FwYWNpdHk7IGkrKylcbiAgICAgIHRoaXMubV9ib2RpZXNbaV0gPSBudWxsO1xuICAgICAgZm9yIChpID0gdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDtcbiAgICAgIGkgPCBjb250YWN0Q2FwYWNpdHk7IGkrKylcbiAgICAgIHRoaXMubV9jb250YWN0c1tpXSA9IG51bGw7XG4gICAgICBmb3IgKGkgPSB0aGlzLm1fam9pbnRzLmxlbmd0aDtcbiAgICAgIGkgPCBqb2ludENhcGFjaXR5OyBpKyspXG4gICAgICB0aGlzLm1fam9pbnRzW2ldID0gbnVsbDtcbiAgIH1cbiAgIGIySXNsYW5kLnByb3RvdHlwZS5DbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9ib2R5Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2NvbnRhY3RDb3VudCA9IDA7XG4gICAgICB0aGlzLm1fam9pbnRDb3VudCA9IDA7XG4gICB9XG4gICBiMklzbGFuZC5wcm90b3R5cGUuU29sdmUgPSBmdW5jdGlvbiAoc3RlcCwgZ3Jhdml0eSwgYWxsb3dTbGVlcCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIGI7XG4gICAgICB2YXIgam9pbnQ7XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHRoaXMubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgYiA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICBpZiAoYi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSBjb250aW51ZTtcbiAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICs9IHN0ZXAuZHQgKiAoZ3Jhdml0eS54ICsgYi5tX2ludk1hc3MgKiBiLm1fZm9yY2UueCk7XG4gICAgICAgICBiLm1fbGluZWFyVmVsb2NpdHkueSArPSBzdGVwLmR0ICogKGdyYXZpdHkueSArIGIubV9pbnZNYXNzICogYi5tX2ZvcmNlLnkpO1xuICAgICAgICAgYi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBzdGVwLmR0ICogYi5tX2ludkkgKiBiLm1fdG9ycXVlO1xuICAgICAgICAgYi5tX2xpbmVhclZlbG9jaXR5Lk11bHRpcGx5KGIyTWF0aC5DbGFtcCgxLjAgLSBzdGVwLmR0ICogYi5tX2xpbmVhckRhbXBpbmcsIDAuMCwgMS4wKSk7XG4gICAgICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ICo9IGIyTWF0aC5DbGFtcCgxLjAgLSBzdGVwLmR0ICogYi5tX2FuZ3VsYXJEYW1waW5nLCAwLjAsIDEuMCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlci5Jbml0aWFsaXplKHN0ZXAsIHRoaXMubV9jb250YWN0cywgdGhpcy5tX2NvbnRhY3RDb3VudCwgdGhpcy5tX2FsbG9jYXRvcik7XG4gICAgICB2YXIgY29udGFjdFNvbHZlciA9IHRoaXMubV9jb250YWN0U29sdmVyO1xuICAgICAgY29udGFjdFNvbHZlci5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyhzdGVwKTtcbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgam9pbnQgPSB0aGlzLm1fam9pbnRzW2ldO1xuICAgICAgICAgam9pbnQuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMoc3RlcCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgIGZvciAoaiA9IDA7XG4gICAgICAgICBqIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgam9pbnQgPSB0aGlzLm1fam9pbnRzW2pdO1xuICAgICAgICAgICAgam9pbnQuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHN0ZXApO1xuICAgICAgICAgfVxuICAgICAgICAgY29udGFjdFNvbHZlci5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgam9pbnQgPSB0aGlzLm1fam9pbnRzW2ldO1xuICAgICAgICAgam9pbnQuRmluYWxpemVWZWxvY2l0eUNvbnN0cmFpbnRzKCk7XG4gICAgICB9XG4gICAgICBjb250YWN0U29sdmVyLkZpbmFsaXplVmVsb2NpdHlDb25zdHJhaW50cygpO1xuICAgICAgZm9yIChpID0gMDtcbiAgICAgIGkgPCB0aGlzLm1fYm9keUNvdW50OyArK2kpIHtcbiAgICAgICAgIGIgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSBjb250aW51ZTtcbiAgICAgICAgIHZhciB0cmFuc2xhdGlvblggPSBzdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lng7XG4gICAgICAgICB2YXIgdHJhbnNsYXRpb25ZID0gc3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS55O1xuICAgICAgICAgaWYgKCh0cmFuc2xhdGlvblggKiB0cmFuc2xhdGlvblggKyB0cmFuc2xhdGlvblkgKiB0cmFuc2xhdGlvblkpID4gYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS5Ob3JtYWxpemUoKTtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdGVwLmludl9kdDtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS55ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdGVwLmludl9kdDtcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciByb3RhdGlvbiA9IHN0ZXAuZHQgKiBiLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgaWYgKGIubV9hbmd1bGFyVmVsb2NpdHkgPCAwLjApIHtcbiAgICAgICAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgPSAoLWIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb24gKiBzdGVwLmludl9kdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgPSBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uICogc3RlcC5pbnZfZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBiLm1fc3dlZXAuYzAuU2V0VihiLm1fc3dlZXAuYyk7XG4gICAgICAgICBiLm1fc3dlZXAuYTAgPSBiLm1fc3dlZXAuYTtcbiAgICAgICAgIGIubV9zd2VlcC5jLnggKz0gc3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS54O1xuICAgICAgICAgYi5tX3N3ZWVwLmMueSArPSBzdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lnk7XG4gICAgICAgICBiLm1fc3dlZXAuYSArPSBzdGVwLmR0ICogYi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgIGIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgc3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgdmFyIGNvbnRhY3RzT2theSA9IGNvbnRhY3RTb2x2ZXIuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKGIyU2V0dGluZ3MuYjJfY29udGFjdEJhdW1nYXJ0ZSk7XG4gICAgICAgICB2YXIgam9pbnRzT2theSA9IHRydWU7XG4gICAgICAgICBmb3IgKGogPSAwO1xuICAgICAgICAgaiA8IHRoaXMubV9qb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgIGpvaW50ID0gdGhpcy5tX2pvaW50c1tqXTtcbiAgICAgICAgICAgIHZhciBqb2ludE9rYXkgPSBqb2ludC5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoYjJTZXR0aW5ncy5iMl9jb250YWN0QmF1bWdhcnRlKTtcbiAgICAgICAgICAgIGpvaW50c09rYXkgPSBqb2ludHNPa2F5ICYmIGpvaW50T2theTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChjb250YWN0c09rYXkgJiYgam9pbnRzT2theSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLlJlcG9ydChjb250YWN0U29sdmVyLm1fY29uc3RyYWludHMpO1xuICAgICAgaWYgKGFsbG93U2xlZXApIHtcbiAgICAgICAgIHZhciBtaW5TbGVlcFRpbWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgdmFyIGxpblRvbFNxciA9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xlZXBUb2xlcmFuY2UgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsZWVwVG9sZXJhbmNlO1xuICAgICAgICAgdmFyIGFuZ1RvbFNxciA9IGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsZWVwVG9sZXJhbmNlICogYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xlZXBUb2xlcmFuY2U7XG4gICAgICAgICBmb3IgKGkgPSAwO1xuICAgICAgICAgaSA8IHRoaXMubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgYiA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICAgICBpZiAoYi5HZXRUeXBlKCkgPT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkpIHtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChiLm1fZmxhZ3MgJiBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZykgPT0gMCkge1xuICAgICAgICAgICAgICAgYi5tX3NsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYi5tX2ZsYWdzICYgYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWcpID09IDAgfHwgYi5tX2FuZ3VsYXJWZWxvY2l0eSAqIGIubV9hbmd1bGFyVmVsb2NpdHkgPiBhbmdUb2xTcXIgfHwgYjJNYXRoLkRvdChiLm1fbGluZWFyVmVsb2NpdHksIGIubV9saW5lYXJWZWxvY2l0eSkgPiBsaW5Ub2xTcXIpIHtcbiAgICAgICAgICAgICAgIGIubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICAgICAgICAgICBtaW5TbGVlcFRpbWUgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIGIubV9zbGVlcFRpbWUgKz0gc3RlcC5kdDtcbiAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IGIyTWF0aC5NaW4obWluU2xlZXBUaW1lLCBiLm1fc2xlZXBUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChtaW5TbGVlcFRpbWUgPj0gYjJTZXR0aW5ncy5iMl90aW1lVG9TbGVlcCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgICAgIGkgPCB0aGlzLm1fYm9keUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgIGIgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgYi5TZXRBd2FrZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBiMklzbGFuZC5wcm90b3R5cGUuU29sdmVUT0kgPSBmdW5jdGlvbiAoc3ViU3RlcCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdGhpcy5tX2NvbnRhY3RTb2x2ZXIuSW5pdGlhbGl6ZShzdWJTdGVwLCB0aGlzLm1fY29udGFjdHMsIHRoaXMubV9jb250YWN0Q291bnQsIHRoaXMubV9hbGxvY2F0b3IpO1xuICAgICAgdmFyIGNvbnRhY3RTb2x2ZXIgPSB0aGlzLm1fY29udGFjdFNvbHZlcjtcbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgdGhpcy5tX2pvaW50c1tpXS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyhzdWJTdGVwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgc3ViU3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgY29udGFjdFNvbHZlci5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcbiAgICAgICAgIGZvciAoaiA9IDA7XG4gICAgICAgICBqIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgdGhpcy5tX2pvaW50c1tqXS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoc3ViU3RlcCk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHRoaXMubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgdmFyIGIgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSBjb250aW51ZTtcbiAgICAgICAgIHZhciB0cmFuc2xhdGlvblggPSBzdWJTdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lng7XG4gICAgICAgICB2YXIgdHJhbnNsYXRpb25ZID0gc3ViU3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS55O1xuICAgICAgICAgaWYgKCh0cmFuc2xhdGlvblggKiB0cmFuc2xhdGlvblggKyB0cmFuc2xhdGlvblkgKiB0cmFuc2xhdGlvblkpID4gYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS5Ob3JtYWxpemUoKTtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdWJTdGVwLmludl9kdDtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS55ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdWJTdGVwLmludl9kdDtcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciByb3RhdGlvbiA9IHN1YlN0ZXAuZHQgKiBiLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgaWYgKGIubV9hbmd1bGFyVmVsb2NpdHkgPCAwLjApIHtcbiAgICAgICAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgPSAoLWIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb24gKiBzdWJTdGVwLmludl9kdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgPSBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uICogc3ViU3RlcC5pbnZfZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBiLm1fc3dlZXAuYzAuU2V0VihiLm1fc3dlZXAuYyk7XG4gICAgICAgICBiLm1fc3dlZXAuYTAgPSBiLm1fc3dlZXAuYTtcbiAgICAgICAgIGIubV9zd2VlcC5jLnggKz0gc3ViU3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS54O1xuICAgICAgICAgYi5tX3N3ZWVwLmMueSArPSBzdWJTdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lnk7XG4gICAgICAgICBiLm1fc3dlZXAuYSArPSBzdWJTdGVwLmR0ICogYi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgIGIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBrX3RvaUJhdW1nYXJ0ZSA9IDAuNzU7XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHN1YlN0ZXAucG9zaXRpb25JdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgIHZhciBjb250YWN0c09rYXkgPSBjb250YWN0U29sdmVyLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyhrX3RvaUJhdW1nYXJ0ZSk7XG4gICAgICAgICB2YXIgam9pbnRzT2theSA9IHRydWU7XG4gICAgICAgICBmb3IgKGogPSAwO1xuICAgICAgICAgaiA8IHRoaXMubV9qb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgIHZhciBqb2ludE9rYXkgPSB0aGlzLm1fam9pbnRzW2pdLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyhiMlNldHRpbmdzLmIyX2NvbnRhY3RCYXVtZ2FydGUpO1xuICAgICAgICAgICAgam9pbnRzT2theSA9IGpvaW50c09rYXkgJiYgam9pbnRPa2F5O1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKGNvbnRhY3RzT2theSAmJiBqb2ludHNPa2F5KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuUmVwb3J0KGNvbnRhY3RTb2x2ZXIubV9jb25zdHJhaW50cyk7XG4gICB9XG4gICBiMklzbGFuZC5wcm90b3R5cGUuUmVwb3J0ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICBpZiAodGhpcy5tX2xpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RDb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgYyA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgIHZhciBjYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYy5wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgIGIySXNsYW5kLnNfaW1wdWxzZS5ub3JtYWxJbXB1bHNlc1tqXSA9IGNjLnBvaW50c1tqXS5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgYjJJc2xhbmQuc19pbXB1bHNlLnRhbmdlbnRJbXB1bHNlc1tqXSA9IGNjLnBvaW50c1tqXS50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMubV9saXN0ZW5lci5Qb3N0U29sdmUoYywgYjJJc2xhbmQuc19pbXB1bHNlKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIySXNsYW5kLnByb3RvdHlwZS5BZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgIGJvZHkubV9pc2xhbmRJbmRleCA9IHRoaXMubV9ib2R5Q291bnQ7XG4gICAgICB0aGlzLm1fYm9kaWVzW3RoaXMubV9ib2R5Q291bnQrK10gPSBib2R5O1xuICAgfVxuICAgYjJJc2xhbmQucHJvdG90eXBlLkFkZENvbnRhY3QgPSBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgdGhpcy5tX2NvbnRhY3RzW3RoaXMubV9jb250YWN0Q291bnQrK10gPSBjb250YWN0O1xuICAgfVxuICAgYjJJc2xhbmQucHJvdG90eXBlLkFkZEpvaW50ID0gZnVuY3Rpb24gKGpvaW50KSB7XG4gICAgICB0aGlzLm1fam9pbnRzW3RoaXMubV9qb2ludENvdW50KytdID0gam9pbnQ7XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIySXNsYW5kLnNfaW1wdWxzZSA9IG5ldyBiMkNvbnRhY3RJbXB1bHNlKCk7XG4gICB9KTtcbiAgIGIyVGltZVN0ZXAuYjJUaW1lU3RlcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJUaW1lU3RlcC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHRoaXMuZHQgPSBzdGVwLmR0O1xuICAgICAgdGhpcy5pbnZfZHQgPSBzdGVwLmludl9kdDtcbiAgICAgIHRoaXMucG9zaXRpb25JdGVyYXRpb25zID0gc3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnM7XG4gICAgICB0aGlzLnZlbG9jaXR5SXRlcmF0aW9ucyA9IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zO1xuICAgICAgdGhpcy53YXJtU3RhcnRpbmcgPSBzdGVwLndhcm1TdGFydGluZztcbiAgIH1cbiAgIGIyV29ybGQuYjJXb3JsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc19zdGFjayA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHRoaXMubV9jb250YWN0TWFuYWdlciA9IG5ldyBiMkNvbnRhY3RNYW5hZ2VyKCk7XG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlciA9IG5ldyBiMkNvbnRhY3RTb2x2ZXIoKTtcbiAgICAgIHRoaXMubV9pc2xhbmQgPSBuZXcgYjJJc2xhbmQoKTtcbiAgIH07XG4gICBiMldvcmxkLnByb3RvdHlwZS5iMldvcmxkID0gZnVuY3Rpb24gKGdyYXZpdHksIGRvU2xlZXApIHtcbiAgICAgIHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyID0gbnVsbDtcbiAgICAgIHRoaXMubV9kZWJ1Z0RyYXcgPSBudWxsO1xuICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fam9pbnRMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9jb250cm9sbGVyTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fYm9keUNvdW50ID0gMDtcbiAgICAgIHRoaXMubV9jb250YWN0Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2pvaW50Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2NvbnRyb2xsZXJDb3VudCA9IDA7XG4gICAgICBiMldvcmxkLm1fd2FybVN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIGIyV29ybGQubV9jb250aW51b3VzUGh5c2ljcyA9IHRydWU7XG4gICAgICB0aGlzLm1fYWxsb3dTbGVlcCA9IGRvU2xlZXA7XG4gICAgICB0aGlzLm1fZ3Jhdml0eSA9IGdyYXZpdHk7XG4gICAgICB0aGlzLm1faW52X2R0MCA9IDAuMDtcbiAgICAgIHRoaXMubV9jb250YWN0TWFuYWdlci5tX3dvcmxkID0gdGhpcztcbiAgICAgIHZhciBiZCA9IG5ldyBiMkJvZHlEZWYoKTtcbiAgICAgIHRoaXMubV9ncm91bmRCb2R5ID0gdGhpcy5DcmVhdGVCb2R5KGJkKTtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldERlc3RydWN0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5TZXRDb250YWN0RmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdEZpbHRlciA9IGZpbHRlcjtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldENvbnRhY3RMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5TZXREZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoZGVidWdEcmF3KSB7XG4gICAgICB0aGlzLm1fZGVidWdEcmF3ID0gZGVidWdEcmF3O1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuU2V0QnJvYWRQaGFzZSA9IGZ1bmN0aW9uIChicm9hZFBoYXNlKSB7XG4gICAgICB2YXIgb2xkQnJvYWRQaGFzZSA9IHRoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlID0gYnJvYWRQaGFzZTtcbiAgICAgIGZvciAodmFyIGIgPSB0aGlzLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgZm9yICh2YXIgZiA9IGIubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICBmLm1fcHJveHkgPSBicm9hZFBoYXNlLkNyZWF0ZVByb3h5KG9sZEJyb2FkUGhhc2UuR2V0RmF0QUFCQihmLm1fcHJveHkpLCBmKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZS5WYWxpZGF0ZSgpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0UHJveHlDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlLkdldFByb3h5Q291bnQoKTtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkNyZWF0ZUJvZHkgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICBpZiAodGhpcy5Jc0xvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGIgPSBuZXcgYjJCb2R5KGRlZiwgdGhpcyk7XG4gICAgICBiLm1fcHJldiA9IG51bGw7XG4gICAgICBiLm1fbmV4dCA9IHRoaXMubV9ib2R5TGlzdDtcbiAgICAgIGlmICh0aGlzLm1fYm9keUxpc3QpIHtcbiAgICAgICAgIHRoaXMubV9ib2R5TGlzdC5tX3ByZXYgPSBiO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gYjtcbiAgICAgICsrdGhpcy5tX2JvZHlDb3VudDtcbiAgICAgIHJldHVybiBiO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuRGVzdHJveUJvZHkgPSBmdW5jdGlvbiAoYikge1xuICAgICAgaWYgKHRoaXMuSXNMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgam4gPSBiLm1fam9pbnRMaXN0O1xuICAgICAgd2hpbGUgKGpuKSB7XG4gICAgICAgICB2YXIgam4wID0gam47XG4gICAgICAgICBqbiA9IGpuLm5leHQ7XG4gICAgICAgICBpZiAodGhpcy5tX2Rlc3RydWN0aW9uTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyLlNheUdvb2RieWVKb2ludChqbjAuam9pbnQpO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5EZXN0cm95Sm9pbnQoam4wLmpvaW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2UgPSBiLm1fY29udHJvbGxlckxpc3Q7XG4gICAgICB3aGlsZSAoY29lKSB7XG4gICAgICAgICB2YXIgY29lMCA9IGNvZTtcbiAgICAgICAgIGNvZSA9IGNvZS5uZXh0Q29udHJvbGxlcjtcbiAgICAgICAgIGNvZTAuY29udHJvbGxlci5SZW1vdmVCb2R5KGIpO1xuICAgICAgfVxuICAgICAgdmFyIGNlID0gYi5tX2NvbnRhY3RMaXN0O1xuICAgICAgd2hpbGUgKGNlKSB7XG4gICAgICAgICB2YXIgY2UwID0gY2U7XG4gICAgICAgICBjZSA9IGNlLm5leHQ7XG4gICAgICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIuRGVzdHJveShjZTAuY29udGFjdCk7XG4gICAgICB9XG4gICAgICBiLm1fY29udGFjdExpc3QgPSBudWxsO1xuICAgICAgdmFyIGYgPSBiLm1fZml4dHVyZUxpc3Q7XG4gICAgICB3aGlsZSAoZikge1xuICAgICAgICAgdmFyIGYwID0gZjtcbiAgICAgICAgIGYgPSBmLm1fbmV4dDtcbiAgICAgICAgIGlmICh0aGlzLm1fZGVzdHJ1Y3Rpb25MaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5tX2Rlc3RydWN0aW9uTGlzdGVuZXIuU2F5R29vZGJ5ZUZpeHR1cmUoZjApO1xuICAgICAgICAgfVxuICAgICAgICAgZjAuRGVzdHJveVByb3h5KHRoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2UpO1xuICAgICAgICAgZjAuRGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgYi5tX2ZpeHR1cmVMaXN0ID0gbnVsbDtcbiAgICAgIGIubV9maXh0dXJlQ291bnQgPSAwO1xuICAgICAgaWYgKGIubV9wcmV2KSB7XG4gICAgICAgICBiLm1fcHJldi5tX25leHQgPSBiLm1fbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChiLm1fbmV4dCkge1xuICAgICAgICAgYi5tX25leHQubV9wcmV2ID0gYi5tX3ByZXY7XG4gICAgICB9XG4gICAgICBpZiAoYiA9PSB0aGlzLm1fYm9keUxpc3QpIHtcbiAgICAgICAgIHRoaXMubV9ib2R5TGlzdCA9IGIubV9uZXh0O1xuICAgICAgfS0tdGhpcy5tX2JvZHlDb3VudDtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkNyZWF0ZUpvaW50ID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgdmFyIGogPSBiMkpvaW50LkNyZWF0ZShkZWYsIG51bGwpO1xuICAgICAgai5tX3ByZXYgPSBudWxsO1xuICAgICAgai5tX25leHQgPSB0aGlzLm1fam9pbnRMaXN0O1xuICAgICAgaWYgKHRoaXMubV9qb2ludExpc3QpIHtcbiAgICAgICAgIHRoaXMubV9qb2ludExpc3QubV9wcmV2ID0gajtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9qb2ludExpc3QgPSBqO1xuICAgICAgKyt0aGlzLm1fam9pbnRDb3VudDtcbiAgICAgIGoubV9lZGdlQS5qb2ludCA9IGo7XG4gICAgICBqLm1fZWRnZUEub3RoZXIgPSBqLm1fYm9keUI7XG4gICAgICBqLm1fZWRnZUEucHJldiA9IG51bGw7XG4gICAgICBqLm1fZWRnZUEubmV4dCA9IGoubV9ib2R5QS5tX2pvaW50TGlzdDtcbiAgICAgIGlmIChqLm1fYm9keUEubV9qb2ludExpc3QpIGoubV9ib2R5QS5tX2pvaW50TGlzdC5wcmV2ID0gai5tX2VkZ2VBO1xuICAgICAgai5tX2JvZHlBLm1fam9pbnRMaXN0ID0gai5tX2VkZ2VBO1xuICAgICAgai5tX2VkZ2VCLmpvaW50ID0gajtcbiAgICAgIGoubV9lZGdlQi5vdGhlciA9IGoubV9ib2R5QTtcbiAgICAgIGoubV9lZGdlQi5wcmV2ID0gbnVsbDtcbiAgICAgIGoubV9lZGdlQi5uZXh0ID0gai5tX2JvZHlCLm1fam9pbnRMaXN0O1xuICAgICAgaWYgKGoubV9ib2R5Qi5tX2pvaW50TGlzdCkgai5tX2JvZHlCLm1fam9pbnRMaXN0LnByZXYgPSBqLm1fZWRnZUI7XG4gICAgICBqLm1fYm9keUIubV9qb2ludExpc3QgPSBqLm1fZWRnZUI7XG4gICAgICB2YXIgYm9keUEgPSBkZWYuYm9keUE7XG4gICAgICB2YXIgYm9keUIgPSBkZWYuYm9keUI7XG4gICAgICBpZiAoZGVmLmNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgIHZhciBlZGdlID0gYm9keUIuR2V0Q29udGFjdExpc3QoKTtcbiAgICAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBib2R5QSkge1xuICAgICAgICAgICAgICAgZWRnZS5jb250YWN0LkZsYWdGb3JGaWx0ZXJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gajtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkRlc3Ryb3lKb2ludCA9IGZ1bmN0aW9uIChqKSB7XG4gICAgICB2YXIgY29sbGlkZUNvbm5lY3RlZCA9IGoubV9jb2xsaWRlQ29ubmVjdGVkO1xuICAgICAgaWYgKGoubV9wcmV2KSB7XG4gICAgICAgICBqLm1fcHJldi5tX25leHQgPSBqLm1fbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChqLm1fbmV4dCkge1xuICAgICAgICAgai5tX25leHQubV9wcmV2ID0gai5tX3ByZXY7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PSB0aGlzLm1fam9pbnRMaXN0KSB7XG4gICAgICAgICB0aGlzLm1fam9pbnRMaXN0ID0gai5tX25leHQ7XG4gICAgICB9XG4gICAgICB2YXIgYm9keUEgPSBqLm1fYm9keUE7XG4gICAgICB2YXIgYm9keUIgPSBqLm1fYm9keUI7XG4gICAgICBib2R5QS5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIGJvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgaWYgKGoubV9lZGdlQS5wcmV2KSB7XG4gICAgICAgICBqLm1fZWRnZUEucHJldi5uZXh0ID0gai5tX2VkZ2VBLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAoai5tX2VkZ2VBLm5leHQpIHtcbiAgICAgICAgIGoubV9lZGdlQS5uZXh0LnByZXYgPSBqLm1fZWRnZUEucHJldjtcbiAgICAgIH1cbiAgICAgIGlmIChqLm1fZWRnZUEgPT0gYm9keUEubV9qb2ludExpc3QpIHtcbiAgICAgICAgIGJvZHlBLm1fam9pbnRMaXN0ID0gai5tX2VkZ2VBLm5leHQ7XG4gICAgICB9XG4gICAgICBqLm1fZWRnZUEucHJldiA9IG51bGw7XG4gICAgICBqLm1fZWRnZUEubmV4dCA9IG51bGw7XG4gICAgICBpZiAoai5tX2VkZ2VCLnByZXYpIHtcbiAgICAgICAgIGoubV9lZGdlQi5wcmV2Lm5leHQgPSBqLm1fZWRnZUIubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChqLm1fZWRnZUIubmV4dCkge1xuICAgICAgICAgai5tX2VkZ2VCLm5leHQucHJldiA9IGoubV9lZGdlQi5wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGoubV9lZGdlQiA9PSBib2R5Qi5tX2pvaW50TGlzdCkge1xuICAgICAgICAgYm9keUIubV9qb2ludExpc3QgPSBqLm1fZWRnZUIubmV4dDtcbiAgICAgIH1cbiAgICAgIGoubV9lZGdlQi5wcmV2ID0gbnVsbDtcbiAgICAgIGoubV9lZGdlQi5uZXh0ID0gbnVsbDtcbiAgICAgIGIySm9pbnQuRGVzdHJveShqLCBudWxsKTtcbiAgICAgIC0tdGhpcy5tX2pvaW50Q291bnQ7XG4gICAgICBpZiAoY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSkge1xuICAgICAgICAgdmFyIGVkZ2UgPSBib2R5Qi5HZXRDb250YWN0TGlzdCgpO1xuICAgICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLm90aGVyID09IGJvZHlBKSB7XG4gICAgICAgICAgICAgICBlZGdlLmNvbnRhY3QuRmxhZ0ZvckZpbHRlcmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkFkZENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgYy5tX25leHQgPSB0aGlzLm1fY29udHJvbGxlckxpc3Q7XG4gICAgICBjLm1fcHJldiA9IG51bGw7XG4gICAgICB0aGlzLm1fY29udHJvbGxlckxpc3QgPSBjO1xuICAgICAgYy5tX3dvcmxkID0gdGhpcztcbiAgICAgIHRoaXMubV9jb250cm9sbGVyQ291bnQrKztcbiAgICAgIHJldHVybiBjO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuUmVtb3ZlQ29udHJvbGxlciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5tX3ByZXYpIGMubV9wcmV2Lm1fbmV4dCA9IGMubV9uZXh0O1xuICAgICAgaWYgKGMubV9uZXh0KSBjLm1fbmV4dC5tX3ByZXYgPSBjLm1fcHJldjtcbiAgICAgIGlmICh0aGlzLm1fY29udHJvbGxlckxpc3QgPT0gYykgdGhpcy5tX2NvbnRyb2xsZXJMaXN0ID0gYy5tX25leHQ7XG4gICAgICB0aGlzLm1fY29udHJvbGxlckNvdW50LS07XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5DcmVhdGVDb250cm9sbGVyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChjb250cm9sbGVyLm1fd29ybGQgIT0gdGhpcykgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJvbGxlciBjYW4gb25seSBiZSBhIG1lbWJlciBvZiBvbmUgd29ybGRcIik7XG4gICAgICBjb250cm9sbGVyLm1fbmV4dCA9IHRoaXMubV9jb250cm9sbGVyTGlzdDtcbiAgICAgIGNvbnRyb2xsZXIubV9wcmV2ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm1fY29udHJvbGxlckxpc3QpIHRoaXMubV9jb250cm9sbGVyTGlzdC5tX3ByZXYgPSBjb250cm9sbGVyO1xuICAgICAgdGhpcy5tX2NvbnRyb2xsZXJMaXN0ID0gY29udHJvbGxlcjtcbiAgICAgICsrdGhpcy5tX2NvbnRyb2xsZXJDb3VudDtcbiAgICAgIGNvbnRyb2xsZXIubV93b3JsZCA9IHRoaXM7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkRlc3Ryb3lDb250cm9sbGVyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuQ2xlYXIoKTtcbiAgICAgIGlmIChjb250cm9sbGVyLm1fbmV4dCkgY29udHJvbGxlci5tX25leHQubV9wcmV2ID0gY29udHJvbGxlci5tX3ByZXY7XG4gICAgICBpZiAoY29udHJvbGxlci5tX3ByZXYpIGNvbnRyb2xsZXIubV9wcmV2Lm1fbmV4dCA9IGNvbnRyb2xsZXIubV9uZXh0O1xuICAgICAgaWYgKGNvbnRyb2xsZXIgPT0gdGhpcy5tX2NvbnRyb2xsZXJMaXN0KSB0aGlzLm1fY29udHJvbGxlckxpc3QgPSBjb250cm9sbGVyLm1fbmV4dDtcbiAgICAgIC0tdGhpcy5tX2NvbnRyb2xsZXJDb3VudDtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldFdhcm1TdGFydGluZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICBiMldvcmxkLm1fd2FybVN0YXJ0aW5nID0gZmxhZztcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldENvbnRpbnVvdXNQaHlzaWNzID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgIGIyV29ybGQubV9jb250aW51b3VzUGh5c2ljcyA9IGZsYWc7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5HZXRCb2R5Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlDb3VudDtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkdldEpvaW50Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2pvaW50Q291bnQ7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5HZXRDb250YWN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2NvbnRhY3RDb3VudDtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldEdyYXZpdHkgPSBmdW5jdGlvbiAoZ3Jhdml0eSkge1xuICAgICAgdGhpcy5tX2dyYXZpdHkgPSBncmF2aXR5O1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0R3Jhdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZ3Jhdml0eTtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkdldEdyb3VuZEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2dyb3VuZEJvZHk7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5TdGVwID0gZnVuY3Rpb24gKGR0LCB2ZWxvY2l0eUl0ZXJhdGlvbnMsIHBvc2l0aW9uSXRlcmF0aW9ucykge1xuICAgICAgaWYgKGR0ID09PSB1bmRlZmluZWQpIGR0ID0gMDtcbiAgICAgIGlmICh2ZWxvY2l0eUl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgdmVsb2NpdHlJdGVyYXRpb25zID0gMDtcbiAgICAgIGlmIChwb3NpdGlvbkl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgcG9zaXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgIGlmICh0aGlzLm1fZmxhZ3MgJiBiMldvcmxkLmVfbmV3Rml4dHVyZSkge1xuICAgICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLkZpbmROZXdDb250YWN0cygpO1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMldvcmxkLmVfbmV3Rml4dHVyZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9mbGFncyB8PSBiMldvcmxkLmVfbG9ja2VkO1xuICAgICAgdmFyIHN0ZXAgPSBiMldvcmxkLnNfdGltZXN0ZXAyO1xuICAgICAgc3RlcC5kdCA9IGR0O1xuICAgICAgc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnMgPSB2ZWxvY2l0eUl0ZXJhdGlvbnM7XG4gICAgICBzdGVwLnBvc2l0aW9uSXRlcmF0aW9ucyA9IHBvc2l0aW9uSXRlcmF0aW9ucztcbiAgICAgIGlmIChkdCA+IDAuMCkge1xuICAgICAgICAgc3RlcC5pbnZfZHQgPSAxLjAgLyBkdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgc3RlcC5pbnZfZHQgPSAwLjA7XG4gICAgICB9XG4gICAgICBzdGVwLmR0UmF0aW8gPSB0aGlzLm1faW52X2R0MCAqIGR0O1xuICAgICAgc3RlcC53YXJtU3RhcnRpbmcgPSBiMldvcmxkLm1fd2FybVN0YXJ0aW5nO1xuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLkNvbGxpZGUoKTtcbiAgICAgIGlmIChzdGVwLmR0ID4gMC4wKSB7XG4gICAgICAgICB0aGlzLlNvbHZlKHN0ZXApO1xuICAgICAgfVxuICAgICAgaWYgKGIyV29ybGQubV9jb250aW51b3VzUGh5c2ljcyAmJiBzdGVwLmR0ID4gMC4wKSB7XG4gICAgICAgICB0aGlzLlNvbHZlVE9JKHN0ZXApO1xuICAgICAgfVxuICAgICAgaWYgKHN0ZXAuZHQgPiAwLjApIHtcbiAgICAgICAgIHRoaXMubV9pbnZfZHQwID0gc3RlcC5pbnZfZHQ7XG4gICAgICB9XG4gICAgICB0aGlzLm1fZmxhZ3MgJj0gfmIyV29ybGQuZV9sb2NrZWQ7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5DbGVhckZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGJvZHkgPSB0aGlzLm1fYm9keUxpc3Q7IGJvZHk7IGJvZHkgPSBib2R5Lm1fbmV4dCkge1xuICAgICAgICAgYm9keS5tX2ZvcmNlLlNldFplcm8oKTtcbiAgICAgICAgIGJvZHkubV90b3JxdWUgPSAwLjA7XG4gICAgICB9XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5EcmF3RGVidWdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMubV9kZWJ1Z0RyYXcgPT0gbnVsbCkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2RlYnVnRHJhdy5tX3Nwcml0ZS5ncmFwaGljcy5jbGVhcigpO1xuICAgICAgdmFyIGZsYWdzID0gdGhpcy5tX2RlYnVnRHJhdy5HZXRGbGFncygpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGI7XG4gICAgICB2YXIgZjtcbiAgICAgIHZhciBzO1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgYnA7XG4gICAgICB2YXIgaW52USA9IG5ldyBiMlZlYzI7XG4gICAgICB2YXIgeDEgPSBuZXcgYjJWZWMyO1xuICAgICAgdmFyIHgyID0gbmV3IGIyVmVjMjtcbiAgICAgIHZhciB4ZjtcbiAgICAgIHZhciBiMSA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHZhciBiMiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHZhciB2cyA9IFtuZXcgYjJWZWMyKCksIG5ldyBiMlZlYzIoKSwgbmV3IGIyVmVjMigpLCBuZXcgYjJWZWMyKCldO1xuICAgICAgdmFyIGNvbG9yID0gbmV3IGIyQ29sb3IoMCwgMCwgMCk7XG4gICAgICBpZiAoZmxhZ3MgJiBiMkRlYnVnRHJhdy5lX3NoYXBlQml0KSB7XG4gICAgICAgICBmb3IgKGIgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICAgICBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgICAgICAgIHhmID0gYi5tX3hmO1xuICAgICAgICAgICAgZm9yIChmID0gYi5HZXRGaXh0dXJlTGlzdCgpO1xuICAgICAgICAgICAgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICAgICBzID0gZi5HZXRTaGFwZSgpO1xuICAgICAgICAgICAgICAgaWYgKGIuSXNBY3RpdmUoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgY29sb3IuU2V0KDAuNSwgMC41LCAwLjMpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2hhcGUocywgeGYsIGNvbG9yKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2UgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICAgICAgICAgICBjb2xvci5TZXQoMC41LCAwLjksIDAuNSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLkRyYXdTaGFwZShzLCB4ZiwgY29sb3IpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5HZXRUeXBlKCkgPT0gYjJCb2R5LmIyX2tpbmVtYXRpY0JvZHkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yLlNldCgwLjUsIDAuNSwgMC45KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuRHJhd1NoYXBlKHMsIHhmLCBjb2xvcik7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgY29sb3IuU2V0KDAuNiwgMC42LCAwLjYpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2hhcGUocywgeGYsIGNvbG9yKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29sb3IuU2V0KDAuOSwgMC43LCAwLjcpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2hhcGUocywgeGYsIGNvbG9yKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIGIyRGVidWdEcmF3LmVfam9pbnRCaXQpIHtcbiAgICAgICAgIGZvciAoaiA9IHRoaXMubV9qb2ludExpc3Q7XG4gICAgICAgICBqOyBqID0gai5tX25leHQpIHtcbiAgICAgICAgICAgIHRoaXMuRHJhd0pvaW50KGopO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZsYWdzICYgYjJEZWJ1Z0RyYXcuZV9jb250cm9sbGVyQml0KSB7XG4gICAgICAgICBmb3IgKHZhciBjID0gdGhpcy5tX2NvbnRyb2xsZXJMaXN0OyBjOyBjID0gYy5tX25leHQpIHtcbiAgICAgICAgICAgIGMuRHJhdyh0aGlzLm1fZGVidWdEcmF3KTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIGIyRGVidWdEcmF3LmVfcGFpckJpdCkge1xuICAgICAgICAgY29sb3IuU2V0KDAuMywgMC45LCAwLjkpO1xuICAgICAgICAgZm9yICh2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0TWFuYWdlci5tX2NvbnRhY3RMaXN0OyBjb250YWN0OyBjb250YWN0ID0gY29udGFjdC5HZXROZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQSA9IGNvbnRhY3QuR2V0Rml4dHVyZUEoKTtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IGNvbnRhY3QuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgIHZhciBjQSA9IGZpeHR1cmVBLkdldEFBQkIoKS5HZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHZhciBjQiA9IGZpeHR1cmVCLkdldEFBQkIoKS5HZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NlZ21lbnQoY0EsIGNCLCBjb2xvcik7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MgJiBiMkRlYnVnRHJhdy5lX2FhYmJCaXQpIHtcbiAgICAgICAgIGJwID0gdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgIHZzID0gW25ldyBiMlZlYzIoKSwgbmV3IGIyVmVjMigpLCBuZXcgYjJWZWMyKCksIG5ldyBiMlZlYzIoKV07XG4gICAgICAgICBmb3IgKGIgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICAgICBiOyBiID0gYi5HZXROZXh0KCkpIHtcbiAgICAgICAgICAgIGlmIChiLklzQWN0aXZlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChmID0gYi5HZXRGaXh0dXJlTGlzdCgpO1xuICAgICAgICAgICAgZjsgZiA9IGYuR2V0TmV4dCgpKSB7XG4gICAgICAgICAgICAgICB2YXIgYWFiYiA9IGJwLkdldEZhdEFBQkIoZi5tX3Byb3h5KTtcbiAgICAgICAgICAgICAgIHZzWzBdLlNldChhYWJiLmxvd2VyQm91bmQueCwgYWFiYi5sb3dlckJvdW5kLnkpO1xuICAgICAgICAgICAgICAgdnNbMV0uU2V0KGFhYmIudXBwZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueSk7XG4gICAgICAgICAgICAgICB2c1syXS5TZXQoYWFiYi51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55KTtcbiAgICAgICAgICAgICAgIHZzWzNdLlNldChhYWJiLmxvd2VyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLnkpO1xuICAgICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3UG9seWdvbih2cywgNCwgY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZsYWdzICYgYjJEZWJ1Z0RyYXcuZV9jZW50ZXJPZk1hc3NCaXQpIHtcbiAgICAgICAgIGZvciAoYiA9IHRoaXMubV9ib2R5TGlzdDtcbiAgICAgICAgIGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgICAgeGYgPSBiMldvcmxkLnNfeGY7XG4gICAgICAgICAgICB4Zi5SID0gYi5tX3hmLlI7XG4gICAgICAgICAgICB4Zi5wb3NpdGlvbiA9IGIuR2V0V29ybGRDZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1RyYW5zZm9ybSh4Zik7XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5RdWVyeUFBQkIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFhYmIpIHtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGJyb2FkUGhhc2UgPSBfX3RoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG5cbiAgICAgIGZ1bmN0aW9uIFdvcmxkUXVlcnlXcmFwcGVyKHByb3h5KSB7XG4gICAgICAgICByZXR1cm4gY2FsbGJhY2soYnJvYWRQaGFzZS5HZXRVc2VyRGF0YShwcm94eSkpO1xuICAgICAgfTtcbiAgICAgIGJyb2FkUGhhc2UuUXVlcnkoV29ybGRRdWVyeVdyYXBwZXIsIGFhYmIpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuUXVlcnlTaGFwZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc2hhcGUsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIF9fdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodHJhbnNmb3JtID09PSB1bmRlZmluZWQpIHRyYW5zZm9ybSA9IG51bGw7XG4gICAgICBpZiAodHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgICAgIHRyYW5zZm9ybSA9IG5ldyBiMlRyYW5zZm9ybSgpO1xuICAgICAgICAgdHJhbnNmb3JtLlNldElkZW50aXR5KCk7XG4gICAgICB9XG4gICAgICB2YXIgYnJvYWRQaGFzZSA9IF9fdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcblxuICAgICAgZnVuY3Rpb24gV29ybGRRdWVyeVdyYXBwZXIocHJveHkpIHtcbiAgICAgICAgIHZhciBmaXh0dXJlID0gKGJyb2FkUGhhc2UuR2V0VXNlckRhdGEocHJveHkpIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gYnJvYWRQaGFzZS5HZXRVc2VyRGF0YShwcm94eSkgOiBudWxsKTtcbiAgICAgICAgIGlmIChiMlNoYXBlLlRlc3RPdmVybGFwKHNoYXBlLCB0cmFuc2Zvcm0sIGZpeHR1cmUuR2V0U2hhcGUoKSwgZml4dHVyZS5HZXRCb2R5KCkuR2V0VHJhbnNmb3JtKCkpKSByZXR1cm4gY2FsbGJhY2soZml4dHVyZSk7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICB2YXIgYWFiYiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHNoYXBlLkNvbXB1dGVBQUJCKGFhYmIsIHRyYW5zZm9ybSk7XG4gICAgICBicm9hZFBoYXNlLlF1ZXJ5KFdvcmxkUXVlcnlXcmFwcGVyLCBhYWJiKTtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlF1ZXJ5UG9pbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHApIHtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGJyb2FkUGhhc2UgPSBfX3RoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG5cbiAgICAgIGZ1bmN0aW9uIFdvcmxkUXVlcnlXcmFwcGVyKHByb3h5KSB7XG4gICAgICAgICB2YXIgZml4dHVyZSA9IChicm9hZFBoYXNlLkdldFVzZXJEYXRhKHByb3h5KSBpbnN0YW5jZW9mIGIyRml4dHVyZSA/IGJyb2FkUGhhc2UuR2V0VXNlckRhdGEocHJveHkpIDogbnVsbCk7XG4gICAgICAgICBpZiAoZml4dHVyZS5UZXN0UG9pbnQocCkpIHJldHVybiBjYWxsYmFjayhmaXh0dXJlKTtcbiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIHZhciBhYWJiID0gbmV3IGIyQUFCQigpO1xuICAgICAgYWFiYi5sb3dlckJvdW5kLlNldChwLnggLSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsIHAueSAtIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCk7XG4gICAgICBhYWJiLnVwcGVyQm91bmQuU2V0KHAueCArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgcC55ICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKTtcbiAgICAgIGJyb2FkUGhhc2UuUXVlcnkoV29ybGRRdWVyeVdyYXBwZXIsIGFhYmIpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuUmF5Q2FzdCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcG9pbnQxLCBwb2ludDIpIHtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGJyb2FkUGhhc2UgPSBfX3RoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICB2YXIgb3V0cHV0ID0gbmV3IGIyUmF5Q2FzdE91dHB1dDtcblxuICAgICAgZnVuY3Rpb24gUmF5Q2FzdFdyYXBwZXIoaW5wdXQsIHByb3h5KSB7XG4gICAgICAgICB2YXIgdXNlckRhdGEgPSBicm9hZFBoYXNlLkdldFVzZXJEYXRhKHByb3h5KTtcbiAgICAgICAgIHZhciBmaXh0dXJlID0gKHVzZXJEYXRhIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gdXNlckRhdGEgOiBudWxsKTtcbiAgICAgICAgIHZhciBoaXQgPSBmaXh0dXJlLlJheUNhc3Qob3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICB2YXIgZnJhY3Rpb24gPSBvdXRwdXQuZnJhY3Rpb247XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgYjJWZWMyKCgxLjAgLSBmcmFjdGlvbikgKiBwb2ludDEueCArIGZyYWN0aW9uICogcG9pbnQyLngsICgxLjAgLSBmcmFjdGlvbikgKiBwb2ludDEueSArIGZyYWN0aW9uICogcG9pbnQyLnkpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZpeHR1cmUsIHBvaW50LCBvdXRwdXQubm9ybWFsLCBmcmFjdGlvbik7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gaW5wdXQubWF4RnJhY3Rpb247XG4gICAgICB9O1xuICAgICAgdmFyIGlucHV0ID0gbmV3IGIyUmF5Q2FzdElucHV0KHBvaW50MSwgcG9pbnQyKTtcbiAgICAgIGJyb2FkUGhhc2UuUmF5Q2FzdChSYXlDYXN0V3JhcHBlciwgaW5wdXQpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuUmF5Q2FzdE9uZSA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Mikge1xuICAgICAgdmFyIF9fdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBmdW5jdGlvbiBSYXlDYXN0T25lV3JhcHBlcihmaXh0dXJlLCBwb2ludCwgbm9ybWFsLCBmcmFjdGlvbikge1xuICAgICAgICAgaWYgKGZyYWN0aW9uID09PSB1bmRlZmluZWQpIGZyYWN0aW9uID0gMDtcbiAgICAgICAgIHJlc3VsdCA9IGZpeHR1cmU7XG4gICAgICAgICByZXR1cm4gZnJhY3Rpb247XG4gICAgICB9O1xuICAgICAgX190aGlzLlJheUNhc3QoUmF5Q2FzdE9uZVdyYXBwZXIsIHBvaW50MSwgcG9pbnQyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5SYXlDYXN0QWxsID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgICB2YXIgX190aGlzID0gdGhpcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgVmVjdG9yKCk7XG5cbiAgICAgIGZ1bmN0aW9uIFJheUNhc3RBbGxXcmFwcGVyKGZpeHR1cmUsIHBvaW50LCBub3JtYWwsIGZyYWN0aW9uKSB7XG4gICAgICAgICBpZiAoZnJhY3Rpb24gPT09IHVuZGVmaW5lZCkgZnJhY3Rpb24gPSAwO1xuICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gZml4dHVyZTtcbiAgICAgICAgIHJldHVybiAxO1xuICAgICAgfTtcbiAgICAgIF9fdGhpcy5SYXlDYXN0KFJheUNhc3RBbGxXcmFwcGVyLCBwb2ludDEsIHBvaW50Mik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0Qm9keUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlMaXN0O1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0Sm9pbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9qb2ludExpc3Q7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5HZXRDb250YWN0TGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY29udGFjdExpc3Q7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5Jc0xvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJXb3JsZC5lX2xvY2tlZCkgPiAwO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuU29sdmUgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGI7XG4gICAgICBmb3IgKHZhciBjb250cm9sbGVyID0gdGhpcy5tX2NvbnRyb2xsZXJMaXN0OyBjb250cm9sbGVyOyBjb250cm9sbGVyID0gY29udHJvbGxlci5tX25leHQpIHtcbiAgICAgICAgIGNvbnRyb2xsZXIuU3RlcChzdGVwKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc2xhbmQgPSB0aGlzLm1faXNsYW5kO1xuICAgICAgaXNsYW5kLkluaXRpYWxpemUodGhpcy5tX2JvZHlDb3VudCwgdGhpcy5tX2NvbnRhY3RDb3VudCwgdGhpcy5tX2pvaW50Q291bnQsIG51bGwsIHRoaXMubV9jb250YWN0TWFuYWdlci5tX2NvbnRhY3RMaXN0ZW5lciwgdGhpcy5tX2NvbnRhY3RTb2x2ZXIpO1xuICAgICAgZm9yIChiID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgYjsgYiA9IGIubV9uZXh0KSB7XG4gICAgICAgICBiLm1fZmxhZ3MgJj0gfmIyQm9keS5lX2lzbGFuZEZsYWc7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBjID0gdGhpcy5tX2NvbnRhY3RMaXN0OyBjOyBjID0gYy5tX25leHQpIHtcbiAgICAgICAgIGMubV9mbGFncyAmPSB+YjJDb250YWN0LmVfaXNsYW5kRmxhZztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSB0aGlzLm1fam9pbnRMaXN0OyBqOyBqID0gai5tX25leHQpIHtcbiAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc3RhY2tTaXplID0gcGFyc2VJbnQodGhpcy5tX2JvZHlDb3VudCk7XG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLnNfc3RhY2s7XG4gICAgICBmb3IgKHZhciBzZWVkID0gdGhpcy5tX2JvZHlMaXN0OyBzZWVkOyBzZWVkID0gc2VlZC5tX25leHQpIHtcbiAgICAgICAgIGlmIChzZWVkLm1fZmxhZ3MgJiBiMkJvZHkuZV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChzZWVkLklzQXdha2UoKSA9PSBmYWxzZSB8fCBzZWVkLklzQWN0aXZlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKHNlZWQuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlzbGFuZC5DbGVhcigpO1xuICAgICAgICAgdmFyIHN0YWNrQ291bnQgPSAwO1xuICAgICAgICAgc3RhY2tbc3RhY2tDb3VudCsrXSA9IHNlZWQ7XG4gICAgICAgICBzZWVkLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcbiAgICAgICAgIHdoaWxlIChzdGFja0NvdW50ID4gMCkge1xuICAgICAgICAgICAgYiA9IHN0YWNrWy0tc3RhY2tDb3VudF07XG4gICAgICAgICAgICBpc2xhbmQuQWRkQm9keShiKTtcbiAgICAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgYi5TZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiLkdldFR5cGUoKSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xuICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3RoZXI7XG4gICAgICAgICAgICBmb3IgKHZhciBjZSA9IGIubV9jb250YWN0TGlzdDsgY2U7IGNlID0gY2UubmV4dCkge1xuICAgICAgICAgICAgICAgaWYgKGNlLmNvbnRhY3QubV9mbGFncyAmIGIyQ29udGFjdC5lX2lzbGFuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgaWYgKGNlLmNvbnRhY3QuSXNTZW5zb3IoKSA9PSB0cnVlIHx8IGNlLmNvbnRhY3QuSXNFbmFibGVkKCkgPT0gZmFsc2UgfHwgY2UuY29udGFjdC5Jc1RvdWNoaW5nKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgaXNsYW5kLkFkZENvbnRhY3QoY2UuY29udGFjdCk7XG4gICAgICAgICAgICAgICBjZS5jb250YWN0Lm1fZmxhZ3MgfD0gYjJDb250YWN0LmVfaXNsYW5kRmxhZztcbiAgICAgICAgICAgICAgIG90aGVyID0gY2Uub3RoZXI7XG4gICAgICAgICAgICAgICBpZiAob3RoZXIubV9mbGFncyAmIGIyQm9keS5lX2lzbGFuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgc3RhY2tbc3RhY2tDb3VudCsrXSA9IG90aGVyO1xuICAgICAgICAgICAgICAgb3RoZXIubV9mbGFncyB8PSBiMkJvZHkuZV9pc2xhbmRGbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgam4gPSBiLm1fam9pbnRMaXN0OyBqbjsgam4gPSBqbi5uZXh0KSB7XG4gICAgICAgICAgICAgICBpZiAoam4uam9pbnQubV9pc2xhbmRGbGFnID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgb3RoZXIgPSBqbi5vdGhlcjtcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5Jc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlzbGFuZC5BZGRKb2ludChqbi5qb2ludCk7XG4gICAgICAgICAgICAgICBqbi5qb2ludC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgaWYgKG90aGVyLm1fZmxhZ3MgJiBiMkJvZHkuZV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrQ291bnQrK10gPSBvdGhlcjtcbiAgICAgICAgICAgICAgIG90aGVyLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlzbGFuZC5Tb2x2ZShzdGVwLCB0aGlzLm1fZ3Jhdml0eSwgdGhpcy5tX2FsbG93U2xlZXApO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpc2xhbmQubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgYiA9IGlzbGFuZC5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgIGlmIChiLkdldFR5cGUoKSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xuICAgICAgICAgICAgICAgYi5tX2ZsYWdzICY9IH5iMkJvZHkuZV9pc2xhbmRGbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0gMDtcbiAgICAgIGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgaWYgKCFzdGFja1tpXSkgYnJlYWs7XG4gICAgICAgICBzdGFja1tpXSA9IG51bGw7XG4gICAgICB9XG4gICAgICBmb3IgKGIgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSB8fCBiLklzQWN0aXZlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGIuU3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLkZpbmROZXdDb250YWN0cygpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuU29sdmVUT0kgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGI7XG4gICAgICB2YXIgZkE7XG4gICAgICB2YXIgZkI7XG4gICAgICB2YXIgYkE7XG4gICAgICB2YXIgYkI7XG4gICAgICB2YXIgY0VkZ2U7XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBpc2xhbmQgPSB0aGlzLm1faXNsYW5kO1xuICAgICAgaXNsYW5kLkluaXRpYWxpemUodGhpcy5tX2JvZHlDb3VudCwgYjJTZXR0aW5ncy5iMl9tYXhUT0lDb250YWN0c1BlcklzbGFuZCwgYjJTZXR0aW5ncy5iMl9tYXhUT0lKb2ludHNQZXJJc2xhbmQsIG51bGwsIHRoaXMubV9jb250YWN0TWFuYWdlci5tX2NvbnRhY3RMaXN0ZW5lciwgdGhpcy5tX2NvbnRhY3RTb2x2ZXIpO1xuICAgICAgdmFyIHF1ZXVlID0gYjJXb3JsZC5zX3F1ZXVlO1xuICAgICAgZm9yIChiID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgYjsgYiA9IGIubV9uZXh0KSB7XG4gICAgICAgICBiLm1fZmxhZ3MgJj0gfmIyQm9keS5lX2lzbGFuZEZsYWc7XG4gICAgICAgICBiLm1fc3dlZXAudDAgPSAwLjA7XG4gICAgICB9XG4gICAgICB2YXIgYztcbiAgICAgIGZvciAoYyA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgIGM7IGMgPSBjLm1fbmV4dCkge1xuICAgICAgICAgYy5tX2ZsYWdzICY9IH4gKGIyQ29udGFjdC5lX3RvaUZsYWcgfCBiMkNvbnRhY3QuZV9pc2xhbmRGbGFnKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IHRoaXMubV9qb2ludExpc3Q7XG4gICAgICBqOyBqID0gai5tX25leHQpIHtcbiAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgICB2YXIgbWluQ29udGFjdCA9IG51bGw7XG4gICAgICAgICB2YXIgbWluVE9JID0gMS4wO1xuICAgICAgICAgZm9yIChjID0gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgICAgYzsgYyA9IGMubV9uZXh0KSB7XG4gICAgICAgICAgICBpZiAoYy5Jc1NlbnNvcigpID09IHRydWUgfHwgYy5Jc0VuYWJsZWQoKSA9PSBmYWxzZSB8fCBjLklzQ29udGludW91cygpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b2kgPSAxLjA7XG4gICAgICAgICAgICBpZiAoYy5tX2ZsYWdzICYgYjJDb250YWN0LmVfdG9pRmxhZykge1xuICAgICAgICAgICAgICAgdG9pID0gYy5tX3RvaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgZkEgPSBjLm1fZml4dHVyZUE7XG4gICAgICAgICAgICAgICBmQiA9IGMubV9maXh0dXJlQjtcbiAgICAgICAgICAgICAgIGJBID0gZkEubV9ib2R5O1xuICAgICAgICAgICAgICAgYkIgPSBmQi5tX2JvZHk7XG4gICAgICAgICAgICAgICBpZiAoKGJBLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkgfHwgYkEuSXNBd2FrZSgpID09IGZhbHNlKSAmJiAoYkIuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9keW5hbWljQm9keSB8fCBiQi5Jc0F3YWtlKCkgPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHZhciB0MCA9IGJBLm1fc3dlZXAudDA7XG4gICAgICAgICAgICAgICBpZiAoYkEubV9zd2VlcC50MCA8IGJCLm1fc3dlZXAudDApIHtcbiAgICAgICAgICAgICAgICAgIHQwID0gYkIubV9zd2VlcC50MDtcbiAgICAgICAgICAgICAgICAgIGJBLm1fc3dlZXAuQWR2YW5jZSh0MCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIGlmIChiQi5tX3N3ZWVwLnQwIDwgYkEubV9zd2VlcC50MCkge1xuICAgICAgICAgICAgICAgICAgdDAgPSBiQS5tX3N3ZWVwLnQwO1xuICAgICAgICAgICAgICAgICAgYkIubV9zd2VlcC5BZHZhbmNlKHQwKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHRvaSA9IGMuQ29tcHV0ZVRPSShiQS5tX3N3ZWVwLCBiQi5tX3N3ZWVwKTtcbiAgICAgICAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMC4wIDw9IHRvaSAmJiB0b2kgPD0gMS4wKTtcbiAgICAgICAgICAgICAgIGlmICh0b2kgPiAwLjAgJiYgdG9pIDwgMS4wKSB7XG4gICAgICAgICAgICAgICAgICB0b2kgPSAoMS4wIC0gdG9pKSAqIHQwICsgdG9pO1xuICAgICAgICAgICAgICAgICAgaWYgKHRvaSA+IDEpIHRvaSA9IDE7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBjLm1fdG9pID0gdG9pO1xuICAgICAgICAgICAgICAgYy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3RvaUZsYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTnVtYmVyLk1JTl9WQUxVRSA8IHRvaSAmJiB0b2kgPCBtaW5UT0kpIHtcbiAgICAgICAgICAgICAgIG1pbkNvbnRhY3QgPSBjO1xuICAgICAgICAgICAgICAgbWluVE9JID0gdG9pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKG1pbkNvbnRhY3QgPT0gbnVsbCB8fCAxLjAgLSAxMDAuMCAqIE51bWJlci5NSU5fVkFMVUUgPCBtaW5UT0kpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgICAgZkEgPSBtaW5Db250YWN0Lm1fZml4dHVyZUE7XG4gICAgICAgICBmQiA9IG1pbkNvbnRhY3QubV9maXh0dXJlQjtcbiAgICAgICAgIGJBID0gZkEubV9ib2R5O1xuICAgICAgICAgYkIgPSBmQi5tX2JvZHk7XG4gICAgICAgICBiMldvcmxkLnNfYmFja3VwQS5TZXQoYkEubV9zd2VlcCk7XG4gICAgICAgICBiMldvcmxkLnNfYmFja3VwQi5TZXQoYkIubV9zd2VlcCk7XG4gICAgICAgICBiQS5BZHZhbmNlKG1pblRPSSk7XG4gICAgICAgICBiQi5BZHZhbmNlKG1pblRPSSk7XG4gICAgICAgICBtaW5Db250YWN0LlVwZGF0ZSh0aGlzLm1fY29udGFjdE1hbmFnZXIubV9jb250YWN0TGlzdGVuZXIpO1xuICAgICAgICAgbWluQ29udGFjdC5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV90b2lGbGFnO1xuICAgICAgICAgaWYgKG1pbkNvbnRhY3QuSXNTZW5zb3IoKSA9PSB0cnVlIHx8IG1pbkNvbnRhY3QuSXNFbmFibGVkKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJBLm1fc3dlZXAuU2V0KGIyV29ybGQuc19iYWNrdXBBKTtcbiAgICAgICAgICAgIGJCLm1fc3dlZXAuU2V0KGIyV29ybGQuc19iYWNrdXBCKTtcbiAgICAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAobWluQ29udGFjdC5Jc1RvdWNoaW5nKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIHNlZWQgPSBiQTtcbiAgICAgICAgIGlmIChzZWVkLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcbiAgICAgICAgICAgIHNlZWQgPSBiQjtcbiAgICAgICAgIH1cbiAgICAgICAgIGlzbGFuZC5DbGVhcigpO1xuICAgICAgICAgdmFyIHF1ZXVlU3RhcnQgPSAwO1xuICAgICAgICAgdmFyIHF1ZXVlU2l6ZSA9IDA7XG4gICAgICAgICBxdWV1ZVtxdWV1ZVN0YXJ0ICsgcXVldWVTaXplKytdID0gc2VlZDtcbiAgICAgICAgIHNlZWQubV9mbGFncyB8PSBiMkJvZHkuZV9pc2xhbmRGbGFnO1xuICAgICAgICAgd2hpbGUgKHF1ZXVlU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGIgPSBxdWV1ZVtxdWV1ZVN0YXJ0KytdO1xuICAgICAgICAgICAgLS1xdWV1ZVNpemU7XG4gICAgICAgICAgICBpc2xhbmQuQWRkQm9keShiKTtcbiAgICAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgYi5TZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjRWRnZSA9IGIubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIGNFZGdlOyBjRWRnZSA9IGNFZGdlLm5leHQpIHtcbiAgICAgICAgICAgICAgIGlmIChpc2xhbmQubV9jb250YWN0Q291bnQgPT0gaXNsYW5kLm1fY29udGFjdENhcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChjRWRnZS5jb250YWN0Lm1fZmxhZ3MgJiBiMkNvbnRhY3QuZV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChjRWRnZS5jb250YWN0LklzU2Vuc29yKCkgPT0gdHJ1ZSB8fCBjRWRnZS5jb250YWN0LklzRW5hYmxlZCgpID09IGZhbHNlIHx8IGNFZGdlLmNvbnRhY3QuSXNUb3VjaGluZygpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlzbGFuZC5BZGRDb250YWN0KGNFZGdlLmNvbnRhY3QpO1xuICAgICAgICAgICAgICAgY0VkZ2UuY29udGFjdC5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2lzbGFuZEZsYWc7XG4gICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjRWRnZS5vdGhlcjtcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5tX2ZsYWdzICYgYjJCb2R5LmVfaXNsYW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBpZiAob3RoZXIuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICAgICAgICAgICBvdGhlci5BZHZhbmNlKG1pblRPSSk7XG4gICAgICAgICAgICAgICAgICBvdGhlci5TZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHF1ZXVlW3F1ZXVlU3RhcnQgKyBxdWV1ZVNpemVdID0gb3RoZXI7XG4gICAgICAgICAgICAgICArK3F1ZXVlU2l6ZTtcbiAgICAgICAgICAgICAgIG90aGVyLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGpFZGdlID0gYi5tX2pvaW50TGlzdDsgakVkZ2U7IGpFZGdlID0gakVkZ2UubmV4dCkge1xuICAgICAgICAgICAgICAgaWYgKGlzbGFuZC5tX2pvaW50Q291bnQgPT0gaXNsYW5kLm1fam9pbnRDYXBhY2l0eSkgY29udGludWU7XG4gICAgICAgICAgICAgICBpZiAoakVkZ2Uuam9pbnQubV9pc2xhbmRGbGFnID09IHRydWUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgb3RoZXIgPSBqRWRnZS5vdGhlcjtcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5Jc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlzbGFuZC5BZGRKb2ludChqRWRnZS5qb2ludCk7XG4gICAgICAgICAgICAgICBqRWRnZS5qb2ludC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgaWYgKG90aGVyLm1fZmxhZ3MgJiBiMkJvZHkuZV9pc2xhbmRGbGFnKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkpIHtcbiAgICAgICAgICAgICAgICAgIG90aGVyLkFkdmFuY2UobWluVE9JKTtcbiAgICAgICAgICAgICAgICAgIG90aGVyLlNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgcXVldWVbcXVldWVTdGFydCArIHF1ZXVlU2l6ZV0gPSBvdGhlcjtcbiAgICAgICAgICAgICAgICsrcXVldWVTaXplO1xuICAgICAgICAgICAgICAgb3RoZXIubV9mbGFncyB8PSBiMkJvZHkuZV9pc2xhbmRGbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgdmFyIHN1YlN0ZXAgPSBiMldvcmxkLnNfdGltZXN0ZXA7XG4gICAgICAgICBzdWJTdGVwLndhcm1TdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgc3ViU3RlcC5kdCA9ICgxLjAgLSBtaW5UT0kpICogc3RlcC5kdDtcbiAgICAgICAgIHN1YlN0ZXAuaW52X2R0ID0gMS4wIC8gc3ViU3RlcC5kdDtcbiAgICAgICAgIHN1YlN0ZXAuZHRSYXRpbyA9IDAuMDtcbiAgICAgICAgIHN1YlN0ZXAudmVsb2NpdHlJdGVyYXRpb25zID0gc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnM7XG4gICAgICAgICBzdWJTdGVwLnBvc2l0aW9uSXRlcmF0aW9ucyA9IHN0ZXAucG9zaXRpb25JdGVyYXRpb25zO1xuICAgICAgICAgaXNsYW5kLlNvbHZlVE9JKHN1YlN0ZXApO1xuICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgIGkgPCBpc2xhbmQubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgYiA9IGlzbGFuZC5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgIGIubV9mbGFncyAmPSB+YjJCb2R5LmVfaXNsYW5kRmxhZztcbiAgICAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIuU3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgICAgICAgZm9yIChjRWRnZSA9IGIubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIGNFZGdlOyBjRWRnZSA9IGNFZGdlLm5leHQpIHtcbiAgICAgICAgICAgICAgIGNFZGdlLmNvbnRhY3QubV9mbGFncyAmPSB+YjJDb250YWN0LmVfdG9pRmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGZvciAoaSA9IDA7XG4gICAgICAgICBpIDwgaXNsYW5kLm1fY29udGFjdENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGMgPSBpc2xhbmQubV9jb250YWN0c1tpXTtcbiAgICAgICAgICAgIGMubV9mbGFncyAmPSB+IChiMkNvbnRhY3QuZV90b2lGbGFnIHwgYjJDb250YWN0LmVfaXNsYW5kRmxhZyk7XG4gICAgICAgICB9XG4gICAgICAgICBmb3IgKGkgPSAwO1xuICAgICAgICAgaSA8IGlzbGFuZC5tX2pvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgaiA9IGlzbGFuZC5tX2pvaW50c1tpXTtcbiAgICAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIuRmluZE5ld0NvbnRhY3RzKCk7XG4gICAgICB9XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5EcmF3Sm9pbnQgPSBmdW5jdGlvbiAoam9pbnQpIHtcbiAgICAgIHZhciBiMSA9IGpvaW50LkdldEJvZHlBKCk7XG4gICAgICB2YXIgYjIgPSBqb2ludC5HZXRCb2R5QigpO1xuICAgICAgdmFyIHhmMSA9IGIxLm1feGY7XG4gICAgICB2YXIgeGYyID0gYjIubV94ZjtcbiAgICAgIHZhciB4MSA9IHhmMS5wb3NpdGlvbjtcbiAgICAgIHZhciB4MiA9IHhmMi5wb3NpdGlvbjtcbiAgICAgIHZhciBwMSA9IGpvaW50LkdldEFuY2hvckEoKTtcbiAgICAgIHZhciBwMiA9IGpvaW50LkdldEFuY2hvckIoKTtcbiAgICAgIHZhciBjb2xvciA9IGIyV29ybGQuc19qb2ludENvbG9yO1xuICAgICAgc3dpdGNoIChqb2ludC5tX3R5cGUpIHtcbiAgICAgIGNhc2UgYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQ6XG4gICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHAxLCBwMiwgY29sb3IpO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIySm9pbnQuZV9wdWxsZXlKb2ludDpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwdWxsZXkgPSAoKGpvaW50IGluc3RhbmNlb2YgYjJQdWxsZXlKb2ludCA/IGpvaW50IDogbnVsbCkpO1xuICAgICAgICAgICAgdmFyIHMxID0gcHVsbGV5LkdldEdyb3VuZEFuY2hvckEoKTtcbiAgICAgICAgICAgIHZhciBzMiA9IHB1bGxleS5HZXRHcm91bmRBbmNob3JCKCk7XG4gICAgICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHMxLCBwMSwgY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChzMiwgcDIsIGNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NlZ21lbnQoczEsIHMyLCBjb2xvcik7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJKb2ludC5lX21vdXNlSm9pbnQ6XG4gICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHAxLCBwMiwgY29sb3IpO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgaWYgKGIxICE9IHRoaXMubV9ncm91bmRCb2R5KSB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHgxLCBwMSwgY29sb3IpO1xuICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChwMSwgcDIsIGNvbG9yKTtcbiAgICAgICAgIGlmIChiMiAhPSB0aGlzLm1fZ3JvdW5kQm9keSkgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudCh4MiwgcDIsIGNvbG9yKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkRyYXdTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSwgeGYsIGNvbG9yKSB7XG4gICAgICBzd2l0Y2ggKHNoYXBlLm1fdHlwZSkge1xuICAgICAgY2FzZSBiMlNoYXBlLmVfY2lyY2xlU2hhcGU6XG4gICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY2lyY2xlID0gKChzaGFwZSBpbnN0YW5jZW9mIGIyQ2lyY2xlU2hhcGUgPyBzaGFwZSA6IG51bGwpKTtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBiMk1hdGguTXVsWCh4ZiwgY2lyY2xlLm1fcCk7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gY2lyY2xlLm1fcmFkaXVzO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB4Zi5SLmNvbDE7XG4gICAgICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTb2xpZENpcmNsZShjZW50ZXIsIHJhZGl1cywgYXhpcywgY29sb3IpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGU6XG4gICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgcG9seSA9ICgoc2hhcGUgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IHNoYXBlIDogbnVsbCkpO1xuICAgICAgICAgICAgdmFyIHZlcnRleENvdW50ID0gcGFyc2VJbnQocG9seS5HZXRWZXJ0ZXhDb3VudCgpKTtcbiAgICAgICAgICAgIHZhciBsb2NhbFZlcnRpY2VzID0gcG9seS5HZXRWZXJ0aWNlcygpO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IFZlY3Rvcih2ZXJ0ZXhDb3VudCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwO1xuICAgICAgICAgICAgaSA8IHZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldID0gYjJNYXRoLk11bFgoeGYsIGxvY2FsVmVydGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U29saWRQb2x5Z29uKHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCwgY29sb3IpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIyU2hhcGUuZV9lZGdlU2hhcGU6XG4gICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IChzaGFwZSBpbnN0YW5jZW9mIGIyRWRnZVNoYXBlID8gc2hhcGUgOiBudWxsKTtcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NlZ21lbnQoYjJNYXRoLk11bFgoeGYsIGVkZ2UuR2V0VmVydGV4MSgpKSwgYjJNYXRoLk11bFgoeGYsIGVkZ2UuR2V0VmVydGV4MigpKSwgY29sb3IpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyV29ybGQuc190aW1lc3RlcDIgPSBuZXcgYjJUaW1lU3RlcCgpO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5zX3hmID0gbmV3IGIyVHJhbnNmb3JtKCk7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfYmFja3VwQSA9IG5ldyBiMlN3ZWVwKCk7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfYmFja3VwQiA9IG5ldyBiMlN3ZWVwKCk7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfdGltZXN0ZXAgPSBuZXcgYjJUaW1lU3RlcCgpO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5zX3F1ZXVlID0gbmV3IFZlY3RvcigpO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5zX2pvaW50Q29sb3IgPSBuZXcgYjJDb2xvcigwLjUsIDAuOCwgMC44KTtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyV29ybGQuZV9uZXdGaXh0dXJlID0gMHgwMDAxO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5lX2xvY2tlZCA9IDB4MDAwMjtcbiAgIH0pO1xufSkoKTtcbihmdW5jdGlvbiAoKSB7XG4gICB2YXIgYjJDaXJjbGVTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJDaXJjbGVTaGFwZSxcbiAgICAgIGIyRWRnZUNoYWluRGVmID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VDaGFpbkRlZixcbiAgICAgIGIyRWRnZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VTaGFwZSxcbiAgICAgIGIyTWFzc0RhdGEgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyTWFzc0RhdGEsXG4gICAgICBiMlBvbHlnb25TaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJQb2x5Z29uU2hhcGUsXG4gICAgICBiMlNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLFxuICAgICAgYjJDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDaXJjbGVDb250YWN0LFxuICAgICAgYjJDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LFxuICAgICAgYjJDb250YWN0Q29uc3RyYWludCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdENvbnN0cmFpbnQsXG4gICAgICBiMkNvbnRhY3RDb25zdHJhaW50UG9pbnQgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RDb25zdHJhaW50UG9pbnQsXG4gICAgICBiMkNvbnRhY3RFZGdlID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0RWRnZSxcbiAgICAgIGIyQ29udGFjdEZhY3RvcnkgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RGYWN0b3J5LFxuICAgICAgYjJDb250YWN0UmVnaXN0ZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RSZWdpc3RlcixcbiAgICAgIGIyQ29udGFjdFJlc3VsdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFJlc3VsdCxcbiAgICAgIGIyQ29udGFjdFNvbHZlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFNvbHZlcixcbiAgICAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkVkZ2VBbmRDaXJjbGVDb250YWN0LFxuICAgICAgYjJOdWxsQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyTnVsbENvbnRhY3QsXG4gICAgICBiMlBvbHlBbmRDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCxcbiAgICAgIGIyUG9seUFuZEVkZ2VDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kRWRnZUNvbnRhY3QsXG4gICAgICBiMlBvbHlnb25Db250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5Z29uQ29udGFjdCxcbiAgICAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCxcbiAgICAgIGIyQm9keSA9IEJveDJELkR5bmFtaWNzLmIyQm9keSxcbiAgICAgIGIyQm9keURlZiA9IEJveDJELkR5bmFtaWNzLmIyQm9keURlZixcbiAgICAgIGIyQ29udGFjdEZpbHRlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEZpbHRlcixcbiAgICAgIGIyQ29udGFjdEltcHVsc2UgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RJbXB1bHNlLFxuICAgICAgYjJDb250YWN0TGlzdGVuZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lcixcbiAgICAgIGIyQ29udGFjdE1hbmFnZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RNYW5hZ2VyLFxuICAgICAgYjJEZWJ1Z0RyYXcgPSBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdyxcbiAgICAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcixcbiAgICAgIGIyRmlsdGVyRGF0YSA9IEJveDJELkR5bmFtaWNzLmIyRmlsdGVyRGF0YSxcbiAgICAgIGIyRml4dHVyZSA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZSxcbiAgICAgIGIyRml4dHVyZURlZiA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcbiAgICAgIGIySXNsYW5kID0gQm94MkQuRHluYW1pY3MuYjJJc2xhbmQsXG4gICAgICBiMlRpbWVTdGVwID0gQm94MkQuRHluYW1pY3MuYjJUaW1lU3RlcCxcbiAgICAgIGIyV29ybGQgPSBCb3gyRC5EeW5hbWljcy5iMldvcmxkLFxuICAgICAgYjJDb2xvciA9IEJveDJELkNvbW1vbi5iMkNvbG9yLFxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxuICAgICAgYjJNYXQyMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MjIsXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcbiAgICAgIGIyU3dlZXAgPSBCb3gyRC5Db21tb24uTWF0aC5iMlN3ZWVwLFxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcbiAgICAgIGIyVmVjMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMyxcbiAgICAgIGIyQUFCQiA9IEJveDJELkNvbGxpc2lvbi5iMkFBQkIsXG4gICAgICBiMkJvdW5kID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmQsXG4gICAgICBiMkJvdW5kVmFsdWVzID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmRWYWx1ZXMsXG4gICAgICBiMkNvbGxpc2lvbiA9IEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbixcbiAgICAgIGIyQ29udGFjdElEID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdElELFxuICAgICAgYjJDb250YWN0UG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJDb250YWN0UG9pbnQsXG4gICAgICBiMkRpc3RhbmNlID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2UsXG4gICAgICBiMkRpc3RhbmNlSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZUlucHV0LFxuICAgICAgYjJEaXN0YW5jZU91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlT3V0cHV0LFxuICAgICAgYjJEaXN0YW5jZVByb3h5ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VQcm94eSxcbiAgICAgIGIyRHluYW1pY1RyZWUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSxcbiAgICAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLFxuICAgICAgYjJEeW5hbWljVHJlZU5vZGUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZU5vZGUsXG4gICAgICBiMkR5bmFtaWNUcmVlUGFpciA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlUGFpcixcbiAgICAgIGIyTWFuaWZvbGQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZCxcbiAgICAgIGIyTWFuaWZvbGRQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkUG9pbnQsXG4gICAgICBiMlBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyUG9pbnQsXG4gICAgICBiMlJheUNhc3RJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RJbnB1dCxcbiAgICAgIGIyUmF5Q2FzdE91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RPdXRwdXQsXG4gICAgICBiMlNlZ21lbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJTZWdtZW50LFxuICAgICAgYjJTZXBhcmF0aW9uRnVuY3Rpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJTZXBhcmF0aW9uRnVuY3Rpb24sXG4gICAgICBiMlNpbXBsZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4LFxuICAgICAgYjJTaW1wbGV4Q2FjaGUgPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4Q2FjaGUsXG4gICAgICBiMlNpbXBsZXhWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4VmVydGV4LFxuICAgICAgYjJUaW1lT2ZJbXBhY3QgPSBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QsXG4gICAgICBiMlRPSUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQsXG4gICAgICBiMldvcmxkTWFuaWZvbGQgPSBCb3gyRC5Db2xsaXNpb24uYjJXb3JsZE1hbmlmb2xkLFxuICAgICAgQ2xpcFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5DbGlwVmVydGV4LFxuICAgICAgRmVhdHVyZXMgPSBCb3gyRC5Db2xsaXNpb24uRmVhdHVyZXMsXG4gICAgICBJQnJvYWRQaGFzZSA9IEJveDJELkNvbGxpc2lvbi5JQnJvYWRQaGFzZTtcblxuICAgQm94MkQuaW5oZXJpdChiMkNpcmNsZUNvbnRhY3QsIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdCk7XG4gICBiMkNpcmNsZUNvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xuICAgYjJDaXJjbGVDb250YWN0LmIyQ2lyY2xlQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBiMkNpcmNsZUNvbnRhY3QuQ3JlYXRlID0gZnVuY3Rpb24gKGFsbG9jYXRvcikge1xuICAgICAgcmV0dXJuIG5ldyBiMkNpcmNsZUNvbnRhY3QoKTtcbiAgIH1cbiAgIGIyQ2lyY2xlQ29udGFjdC5EZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhY3QsIGFsbG9jYXRvcikge31cbiAgIGIyQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuUmVzZXQuY2FsbCh0aGlzLCBmaXh0dXJlQSwgZml4dHVyZUIpO1xuICAgfVxuICAgYjJDaXJjbGVDb250YWN0LnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9maXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fZml4dHVyZUIuR2V0Qm9keSgpO1xuICAgICAgYjJDb2xsaXNpb24uQ29sbGlkZUNpcmNsZXModGhpcy5tX21hbmlmb2xkLCAodGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMkNpcmNsZVNoYXBlID8gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgOiBudWxsKSwgYkEubV94ZiwgKHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJDaXJjbGVTaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xuICAgfVxuICAgYjJDb250YWN0LmIyQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9ub2RlQSA9IG5ldyBiMkNvbnRhY3RFZGdlKCk7XG4gICAgICB0aGlzLm1fbm9kZUIgPSBuZXcgYjJDb250YWN0RWRnZSgpO1xuICAgICAgdGhpcy5tX21hbmlmb2xkID0gbmV3IGIyTWFuaWZvbGQoKTtcbiAgICAgIHRoaXMubV9vbGRNYW5pZm9sZCA9IG5ldyBiMk1hbmlmb2xkKCk7XG4gICB9O1xuICAgYjJDb250YWN0LnByb3RvdHlwZS5HZXRNYW5pZm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbWFuaWZvbGQ7XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLkdldFdvcmxkTWFuaWZvbGQgPSBmdW5jdGlvbiAod29ybGRNYW5pZm9sZCkge1xuICAgICAgdmFyIGJvZHlBID0gdGhpcy5tX2ZpeHR1cmVBLkdldEJvZHkoKTtcbiAgICAgIHZhciBib2R5QiA9IHRoaXMubV9maXh0dXJlQi5HZXRCb2R5KCk7XG4gICAgICB2YXIgc2hhcGVBID0gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCk7XG4gICAgICB2YXIgc2hhcGVCID0gdGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCk7XG4gICAgICB3b3JsZE1hbmlmb2xkLkluaXRpYWxpemUodGhpcy5tX21hbmlmb2xkLCBib2R5QS5HZXRUcmFuc2Zvcm0oKSwgc2hhcGVBLm1fcmFkaXVzLCBib2R5Qi5HZXRUcmFuc2Zvcm0oKSwgc2hhcGVCLm1fcmFkaXVzKTtcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuSXNUb3VjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJDb250YWN0LmVfdG91Y2hpbmdGbGFnKSA9PSBiMkNvbnRhY3QuZV90b3VjaGluZ0ZsYWc7XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLklzQ29udGludW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJDb250YWN0LmVfY29udGludW91c0ZsYWcpID09IGIyQ29udGFjdC5lX2NvbnRpbnVvdXNGbGFnO1xuICAgfVxuICAgYjJDb250YWN0LnByb3RvdHlwZS5TZXRTZW5zb3IgPSBmdW5jdGlvbiAoc2Vuc29yKSB7XG4gICAgICBpZiAoc2Vuc29yKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJDb250YWN0LmVfc2Vuc29yRmxhZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV9zZW5zb3JGbGFnO1xuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0LnByb3RvdHlwZS5Jc1NlbnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJDb250YWN0LmVfc2Vuc29yRmxhZykgPT0gYjJDb250YWN0LmVfc2Vuc29yRmxhZztcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuU2V0RW5hYmxlZCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2VuYWJsZWRGbGFnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgJj0gfmIyQ29udGFjdC5lX2VuYWJsZWRGbGFnO1xuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0LnByb3RvdHlwZS5Jc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX2VuYWJsZWRGbGFnKSA9PSBiMkNvbnRhY3QuZV9lbmFibGVkRmxhZztcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuR2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbmV4dDtcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuR2V0Rml4dHVyZUEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2ZpeHR1cmVBO1xuICAgfVxuICAgYjJDb250YWN0LnByb3RvdHlwZS5HZXRGaXh0dXJlQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZml4dHVyZUI7XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLkZsYWdGb3JGaWx0ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJDb250YWN0LmVfZmlsdGVyRmxhZztcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuYjJDb250YWN0ID0gZnVuY3Rpb24gKCkge31cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XG4gICAgICBpZiAoZml4dHVyZUEgPT09IHVuZGVmaW5lZCkgZml4dHVyZUEgPSBudWxsO1xuICAgICAgaWYgKGZpeHR1cmVCID09PSB1bmRlZmluZWQpIGZpeHR1cmVCID0gbnVsbDtcbiAgICAgIHRoaXMubV9mbGFncyA9IGIyQ29udGFjdC5lX2VuYWJsZWRGbGFnO1xuICAgICAgaWYgKCFmaXh0dXJlQSB8fCAhZml4dHVyZUIpIHtcbiAgICAgICAgIHRoaXMubV9maXh0dXJlQSA9IG51bGw7XG4gICAgICAgICB0aGlzLm1fZml4dHVyZUIgPSBudWxsO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpeHR1cmVBLklzU2Vuc29yKCkgfHwgZml4dHVyZUIuSXNTZW5zb3IoKSkge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3NlbnNvckZsYWc7XG4gICAgICB9XG4gICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5HZXRCb2R5KCk7XG4gICAgICBpZiAoYm9keUEuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9keW5hbWljQm9keSB8fCBib2R5QS5Jc0J1bGxldCgpIHx8IGJvZHlCLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkgfHwgYm9keUIuSXNCdWxsZXQoKSkge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2NvbnRpbnVvdXNGbGFnO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2ZpeHR1cmVBID0gZml4dHVyZUE7XG4gICAgICB0aGlzLm1fZml4dHVyZUIgPSBmaXh0dXJlQjtcbiAgICAgIHRoaXMubV9tYW5pZm9sZC5tX3BvaW50Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX3ByZXYgPSBudWxsO1xuICAgICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgICAgdGhpcy5tX25vZGVBLmNvbnRhY3QgPSBudWxsO1xuICAgICAgdGhpcy5tX25vZGVBLnByZXYgPSBudWxsO1xuICAgICAgdGhpcy5tX25vZGVBLm5leHQgPSBudWxsO1xuICAgICAgdGhpcy5tX25vZGVBLm90aGVyID0gbnVsbDtcbiAgICAgIHRoaXMubV9ub2RlQi5jb250YWN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9ub2RlQi5wcmV2ID0gbnVsbDtcbiAgICAgIHRoaXMubV9ub2RlQi5uZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9ub2RlQi5vdGhlciA9IG51bGw7XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLlVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgdmFyIHRNYW5pZm9sZCA9IHRoaXMubV9vbGRNYW5pZm9sZDtcbiAgICAgIHRoaXMubV9vbGRNYW5pZm9sZCA9IHRoaXMubV9tYW5pZm9sZDtcbiAgICAgIHRoaXMubV9tYW5pZm9sZCA9IHRNYW5pZm9sZDtcbiAgICAgIHRoaXMubV9mbGFncyB8PSBiMkNvbnRhY3QuZV9lbmFibGVkRmxhZztcbiAgICAgIHZhciB0b3VjaGluZyA9IGZhbHNlO1xuICAgICAgdmFyIHdhc1RvdWNoaW5nID0gKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZykgPT0gYjJDb250YWN0LmVfdG91Y2hpbmdGbGFnO1xuICAgICAgdmFyIGJvZHlBID0gdGhpcy5tX2ZpeHR1cmVBLm1fYm9keTtcbiAgICAgIHZhciBib2R5QiA9IHRoaXMubV9maXh0dXJlQi5tX2JvZHk7XG4gICAgICB2YXIgYWFiYk92ZXJsYXAgPSB0aGlzLm1fZml4dHVyZUEubV9hYWJiLlRlc3RPdmVybGFwKHRoaXMubV9maXh0dXJlQi5tX2FhYmIpO1xuICAgICAgaWYgKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX3NlbnNvckZsYWcpIHtcbiAgICAgICAgIGlmIChhYWJiT3ZlcmxhcCkge1xuICAgICAgICAgICAgdmFyIHNoYXBlQSA9IHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpO1xuICAgICAgICAgICAgdmFyIHNoYXBlQiA9IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpO1xuICAgICAgICAgICAgdmFyIHhmQSA9IGJvZHlBLkdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdmFyIHhmQiA9IGJvZHlCLkdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdG91Y2hpbmcgPSBiMlNoYXBlLlRlc3RPdmVybGFwKHNoYXBlQSwgeGZBLCBzaGFwZUIsIHhmQik7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLm1fbWFuaWZvbGQubV9wb2ludENvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgaWYgKGJvZHlBLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkgfHwgYm9keUEuSXNCdWxsZXQoKSB8fCBib2R5Qi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5IHx8IGJvZHlCLklzQnVsbGV0KCkpIHtcbiAgICAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkNvbnRhY3QuZV9jb250aW51b3VzRmxhZztcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV9jb250aW51b3VzRmxhZztcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChhYWJiT3ZlcmxhcCkge1xuICAgICAgICAgICAgdGhpcy5FdmFsdWF0ZSgpO1xuICAgICAgICAgICAgdG91Y2hpbmcgPSB0aGlzLm1fbWFuaWZvbGQubV9wb2ludENvdW50ID4gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX21hbmlmb2xkLm1fcG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICB2YXIgbXAyID0gdGhpcy5tX21hbmlmb2xkLm1fcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgbXAyLm1fbm9ybWFsSW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgICAgIG1wMi5tX3RhbmdlbnRJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgICAgdmFyIGlkMiA9IG1wMi5tX2lkO1xuICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1fb2xkTWFuaWZvbGQubV9wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtcDEgPSB0aGlzLm1fb2xkTWFuaWZvbGQubV9wb2ludHNbal07XG4gICAgICAgICAgICAgICAgICBpZiAobXAxLm1faWQua2V5ID09IGlkMi5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgIG1wMi5tX25vcm1hbEltcHVsc2UgPSBtcDEubV9ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgICAgICAgbXAyLm1fdGFuZ2VudEltcHVsc2UgPSBtcDEubV90YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1fbWFuaWZvbGQubV9wb2ludENvdW50ID0gMDtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmICh0b3VjaGluZyAhPSB3YXNUb3VjaGluZykge1xuICAgICAgICAgICAgYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICBib2R5Qi5TZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b3VjaGluZykge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV90b3VjaGluZ0ZsYWc7XG4gICAgICB9XG4gICAgICBpZiAod2FzVG91Y2hpbmcgPT0gZmFsc2UgJiYgdG91Y2hpbmcgPT0gdHJ1ZSkge1xuICAgICAgICAgbGlzdGVuZXIuQmVnaW5Db250YWN0KHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHdhc1RvdWNoaW5nID09IHRydWUgJiYgdG91Y2hpbmcgPT0gZmFsc2UpIHtcbiAgICAgICAgIGxpc3RlbmVyLkVuZENvbnRhY3QodGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX3NlbnNvckZsYWcpID09IDApIHtcbiAgICAgICAgIGxpc3RlbmVyLlByZVNvbHZlKHRoaXMsIHRoaXMubV9vbGRNYW5pZm9sZCk7XG4gICAgICB9XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLkV2YWx1YXRlID0gZnVuY3Rpb24gKCkge31cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuQ29tcHV0ZVRPSSA9IGZ1bmN0aW9uIChzd2VlcEEsIHN3ZWVwQikge1xuICAgICAgYjJDb250YWN0LnNfaW5wdXQucHJveHlBLlNldCh0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSk7XG4gICAgICBiMkNvbnRhY3Quc19pbnB1dC5wcm94eUIuU2V0KHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpKTtcbiAgICAgIGIyQ29udGFjdC5zX2lucHV0LnN3ZWVwQSA9IHN3ZWVwQTtcbiAgICAgIGIyQ29udGFjdC5zX2lucHV0LnN3ZWVwQiA9IHN3ZWVwQjtcbiAgICAgIGIyQ29udGFjdC5zX2lucHV0LnRvbGVyYW5jZSA9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcbiAgICAgIHJldHVybiBiMlRpbWVPZkltcGFjdC5UaW1lT2ZJbXBhY3QoYjJDb250YWN0LnNfaW5wdXQpO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuZV9zZW5zb3JGbGFnID0gMHgwMDAxO1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmVfY29udGludW91c0ZsYWcgPSAweDAwMDI7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuZV9pc2xhbmRGbGFnID0gMHgwMDA0O1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmVfdG9pRmxhZyA9IDB4MDAwODtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZyA9IDB4MDAxMDtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5lX2VuYWJsZWRGbGFnID0gMHgwMDIwO1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmVfZmlsdGVyRmxhZyA9IDB4MDA0MDtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5zX2lucHV0ID0gbmV3IGIyVE9JSW5wdXQoKTtcbiAgIH0pO1xuICAgYjJDb250YWN0Q29uc3RyYWludC5iMkNvbnRhY3RDb25zdHJhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sb2NhbFBsYW5lTm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5ub3JtYWwgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm5vcm1hbE1hc3MgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgdGhpcy5LID0gbmV3IGIyTWF0MjIoKTtcbiAgIH07XG4gICBiMkNvbnRhY3RDb25zdHJhaW50LnByb3RvdHlwZS5iMkNvbnRhY3RDb25zdHJhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb2ludHMgPSBuZXcgVmVjdG9yKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzOyBpKyspIHtcbiAgICAgICAgIHRoaXMucG9pbnRzW2ldID0gbmV3IGIyQ29udGFjdENvbnN0cmFpbnRQb2ludCgpO1xuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0Q29uc3RyYWludFBvaW50LmIyQ29udGFjdENvbnN0cmFpbnRQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubG9jYWxQb2ludCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMuckEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLnJCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyQ29udGFjdEVkZ2UuYjJDb250YWN0RWRnZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJDb250YWN0RmFjdG9yeS5iMkNvbnRhY3RGYWN0b3J5ID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RGYWN0b3J5LnByb3RvdHlwZS5iMkNvbnRhY3RGYWN0b3J5ID0gZnVuY3Rpb24gKGFsbG9jYXRvcikge1xuICAgICAgdGhpcy5tX2FsbG9jYXRvciA9IGFsbG9jYXRvcjtcbiAgICAgIHRoaXMuSW5pdGlhbGl6ZVJlZ2lzdGVycygpO1xuICAgfVxuICAgYjJDb250YWN0RmFjdG9yeS5wcm90b3R5cGUuQWRkVHlwZSA9IGZ1bmN0aW9uIChjcmVhdGVGY24sIGRlc3Ryb3lGY24sIHR5cGUxLCB0eXBlMikge1xuICAgICAgaWYgKHR5cGUxID09PSB1bmRlZmluZWQpIHR5cGUxID0gMDtcbiAgICAgIGlmICh0eXBlMiA9PT0gdW5kZWZpbmVkKSB0eXBlMiA9IDA7XG4gICAgICB0aGlzLm1fcmVnaXN0ZXJzW3R5cGUxXVt0eXBlMl0uY3JlYXRlRmNuID0gY3JlYXRlRmNuO1xuICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdLmRlc3Ryb3lGY24gPSBkZXN0cm95RmNuO1xuICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdLnByaW1hcnkgPSB0cnVlO1xuICAgICAgaWYgKHR5cGUxICE9IHR5cGUyKSB7XG4gICAgICAgICB0aGlzLm1fcmVnaXN0ZXJzW3R5cGUyXVt0eXBlMV0uY3JlYXRlRmNuID0gY3JlYXRlRmNuO1xuICAgICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMl1bdHlwZTFdLmRlc3Ryb3lGY24gPSBkZXN0cm95RmNuO1xuICAgICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMl1bdHlwZTFdLnByaW1hcnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQ29udGFjdEZhY3RvcnkucHJvdG90eXBlLkluaXRpYWxpemVSZWdpc3RlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fcmVnaXN0ZXJzID0gbmV3IFZlY3RvcihiMlNoYXBlLmVfc2hhcGVUeXBlQ291bnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNoYXBlLmVfc2hhcGVUeXBlQ291bnQ7IGkrKykge1xuICAgICAgICAgdGhpcy5tX3JlZ2lzdGVyc1tpXSA9IG5ldyBWZWN0b3IoYjJTaGFwZS5lX3NoYXBlVHlwZUNvdW50KTtcbiAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYjJTaGFwZS5lX3NoYXBlVHlwZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMubV9yZWdpc3RlcnNbaV1bal0gPSBuZXcgYjJDb250YWN0UmVnaXN0ZXIoKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuQWRkVHlwZShiMkNpcmNsZUNvbnRhY3QuQ3JlYXRlLCBiMkNpcmNsZUNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX2NpcmNsZVNoYXBlLCBiMlNoYXBlLmVfY2lyY2xlU2hhcGUpO1xuICAgICAgdGhpcy5BZGRUeXBlKGIyUG9seUFuZENpcmNsZUNvbnRhY3QuQ3JlYXRlLCBiMlBvbHlBbmRDaXJjbGVDb250YWN0LkRlc3Ryb3ksIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUsIGIyU2hhcGUuZV9jaXJjbGVTaGFwZSk7XG4gICAgICB0aGlzLkFkZFR5cGUoYjJQb2x5Z29uQ29udGFjdC5DcmVhdGUsIGIyUG9seWdvbkNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX3BvbHlnb25TaGFwZSwgYjJTaGFwZS5lX3BvbHlnb25TaGFwZSk7XG4gICAgICB0aGlzLkFkZFR5cGUoYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5DcmVhdGUsIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX2VkZ2VTaGFwZSwgYjJTaGFwZS5lX2NpcmNsZVNoYXBlKTtcbiAgICAgIHRoaXMuQWRkVHlwZShiMlBvbHlBbmRFZGdlQ29udGFjdC5DcmVhdGUsIGIyUG9seUFuZEVkZ2VDb250YWN0LkRlc3Ryb3ksIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUsIGIyU2hhcGUuZV9lZGdlU2hhcGUpO1xuICAgfVxuICAgYjJDb250YWN0RmFjdG9yeS5wcm90b3R5cGUuQ3JlYXRlID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xuICAgICAgdmFyIHR5cGUxID0gcGFyc2VJbnQoZml4dHVyZUEuR2V0VHlwZSgpKTtcbiAgICAgIHZhciB0eXBlMiA9IHBhcnNlSW50KGZpeHR1cmVCLkdldFR5cGUoKSk7XG4gICAgICB2YXIgcmVnID0gdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdO1xuICAgICAgdmFyIGM7XG4gICAgICBpZiAocmVnLnBvb2wpIHtcbiAgICAgICAgIGMgPSByZWcucG9vbDtcbiAgICAgICAgIHJlZy5wb29sID0gYy5tX25leHQ7XG4gICAgICAgICByZWcucG9vbENvdW50LS07XG4gICAgICAgICBjLlJlc2V0KGZpeHR1cmVBLCBmaXh0dXJlQik7XG4gICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHZhciBjcmVhdGVGY24gPSByZWcuY3JlYXRlRmNuO1xuICAgICAgaWYgKGNyZWF0ZUZjbiAhPSBudWxsKSB7XG4gICAgICAgICBpZiAocmVnLnByaW1hcnkpIHtcbiAgICAgICAgICAgIGMgPSBjcmVhdGVGY24odGhpcy5tX2FsbG9jYXRvcik7XG4gICAgICAgICAgICBjLlJlc2V0KGZpeHR1cmVBLCBmaXh0dXJlQik7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyA9IGNyZWF0ZUZjbih0aGlzLm1fYWxsb2NhdG9yKTtcbiAgICAgICAgICAgIGMuUmVzZXQoZml4dHVyZUIsIGZpeHR1cmVBKTtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQ29udGFjdEZhY3RvcnkucHJvdG90eXBlLkRlc3Ryb3kgPSBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgaWYgKGNvbnRhY3QubV9tYW5pZm9sZC5tX3BvaW50Q291bnQgPiAwKSB7XG4gICAgICAgICBjb250YWN0Lm1fZml4dHVyZUEubV9ib2R5LlNldEF3YWtlKHRydWUpO1xuICAgICAgICAgY29udGFjdC5tX2ZpeHR1cmVCLm1fYm9keS5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlMSA9IHBhcnNlSW50KGNvbnRhY3QubV9maXh0dXJlQS5HZXRUeXBlKCkpO1xuICAgICAgdmFyIHR5cGUyID0gcGFyc2VJbnQoY29udGFjdC5tX2ZpeHR1cmVCLkdldFR5cGUoKSk7XG4gICAgICB2YXIgcmVnID0gdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdO1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgIHJlZy5wb29sQ291bnQrKztcbiAgICAgICAgIGNvbnRhY3QubV9uZXh0ID0gcmVnLnBvb2w7XG4gICAgICAgICByZWcucG9vbCA9IGNvbnRhY3Q7XG4gICAgICB9XG4gICAgICB2YXIgZGVzdHJveUZjbiA9IHJlZy5kZXN0cm95RmNuO1xuICAgICAgZGVzdHJveUZjbihjb250YWN0LCB0aGlzLm1fYWxsb2NhdG9yKTtcbiAgIH1cbiAgIGIyQ29udGFjdFJlZ2lzdGVyLmIyQ29udGFjdFJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RSZXN1bHQuYjJDb250YWN0UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5pZCA9IG5ldyBiMkNvbnRhY3RJRCgpO1xuICAgfTtcbiAgIGIyQ29udGFjdFNvbHZlci5iMkNvbnRhY3RTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fc3RlcCA9IG5ldyBiMlRpbWVTdGVwKCk7XG4gICAgICB0aGlzLm1fY29uc3RyYWludHMgPSBuZXcgVmVjdG9yKCk7XG4gICB9O1xuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5iMkNvbnRhY3RTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKHN0ZXAsIGNvbnRhY3RzLCBjb250YWN0Q291bnQsIGFsbG9jYXRvcikge1xuICAgICAgaWYgKGNvbnRhY3RDb3VudCA9PT0gdW5kZWZpbmVkKSBjb250YWN0Q291bnQgPSAwO1xuICAgICAgdmFyIGNvbnRhY3Q7XG4gICAgICB0aGlzLm1fc3RlcC5TZXQoc3RlcCk7XG4gICAgICB0aGlzLm1fYWxsb2NhdG9yID0gYWxsb2NhdG9yO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHRWZWM7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHRoaXMubV9jb25zdHJhaW50Q291bnQgPSBjb250YWN0Q291bnQ7XG4gICAgICB3aGlsZSAodGhpcy5tX2NvbnN0cmFpbnRzLmxlbmd0aCA8IHRoaXMubV9jb25zdHJhaW50Q291bnQpIHtcbiAgICAgICAgIHRoaXMubV9jb25zdHJhaW50c1t0aGlzLm1fY29uc3RyYWludHMubGVuZ3RoXSA9IG5ldyBiMkNvbnRhY3RDb25zdHJhaW50KCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IGNvbnRhY3RDb3VudDsgKytpKSB7XG4gICAgICAgICBjb250YWN0ID0gY29udGFjdHNbaV07XG4gICAgICAgICB2YXIgZml4dHVyZUEgPSBjb250YWN0Lm1fZml4dHVyZUE7XG4gICAgICAgICB2YXIgZml4dHVyZUIgPSBjb250YWN0Lm1fZml4dHVyZUI7XG4gICAgICAgICB2YXIgc2hhcGVBID0gZml4dHVyZUEubV9zaGFwZTtcbiAgICAgICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5tX3NoYXBlO1xuICAgICAgICAgdmFyIHJhZGl1c0EgPSBzaGFwZUEubV9yYWRpdXM7XG4gICAgICAgICB2YXIgcmFkaXVzQiA9IHNoYXBlQi5tX3JhZGl1cztcbiAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgIHZhciBtYW5pZm9sZCA9IGNvbnRhY3QuR2V0TWFuaWZvbGQoKTtcbiAgICAgICAgIHZhciBmcmljdGlvbiA9IGIyU2V0dGluZ3MuYjJNaXhGcmljdGlvbihmaXh0dXJlQS5HZXRGcmljdGlvbigpLCBmaXh0dXJlQi5HZXRGcmljdGlvbigpKTtcbiAgICAgICAgIHZhciByZXN0aXR1dGlvbiA9IGIyU2V0dGluZ3MuYjJNaXhSZXN0aXR1dGlvbihmaXh0dXJlQS5HZXRSZXN0aXR1dGlvbigpLCBmaXh0dXJlQi5HZXRSZXN0aXR1dGlvbigpKTtcbiAgICAgICAgIHZhciB2QVggPSBib2R5QS5tX2xpbmVhclZlbG9jaXR5Lng7XG4gICAgICAgICB2YXIgdkFZID0gYm9keUEubV9saW5lYXJWZWxvY2l0eS55O1xuICAgICAgICAgdmFyIHZCWCA9IGJvZHlCLm1fbGluZWFyVmVsb2NpdHkueDtcbiAgICAgICAgIHZhciB2QlkgPSBib2R5Qi5tX2xpbmVhclZlbG9jaXR5Lnk7XG4gICAgICAgICB2YXIgd0EgPSBib2R5QS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgIHZhciB3QiA9IGJvZHlCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChtYW5pZm9sZC5tX3BvaW50Q291bnQgPiAwKTtcbiAgICAgICAgIGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQuSW5pdGlhbGl6ZShtYW5pZm9sZCwgYm9keUEubV94ZiwgcmFkaXVzQSwgYm9keUIubV94ZiwgcmFkaXVzQik7XG4gICAgICAgICB2YXIgbm9ybWFsWCA9IGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQubV9ub3JtYWwueDtcbiAgICAgICAgIHZhciBub3JtYWxZID0gYjJDb250YWN0U29sdmVyLnNfd29ybGRNYW5pZm9sZC5tX25vcm1hbC55O1xuICAgICAgICAgdmFyIGNjID0gdGhpcy5tX2NvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgY2MuYm9keUEgPSBib2R5QTtcbiAgICAgICAgIGNjLmJvZHlCID0gYm9keUI7XG4gICAgICAgICBjYy5tYW5pZm9sZCA9IG1hbmlmb2xkO1xuICAgICAgICAgY2Mubm9ybWFsLnggPSBub3JtYWxYO1xuICAgICAgICAgY2Mubm9ybWFsLnkgPSBub3JtYWxZO1xuICAgICAgICAgY2MucG9pbnRDb3VudCA9IG1hbmlmb2xkLm1fcG9pbnRDb3VudDtcbiAgICAgICAgIGNjLmZyaWN0aW9uID0gZnJpY3Rpb247XG4gICAgICAgICBjYy5yZXN0aXR1dGlvbiA9IHJlc3RpdHV0aW9uO1xuICAgICAgICAgY2MubG9jYWxQbGFuZU5vcm1hbC54ID0gbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLng7XG4gICAgICAgICBjYy5sb2NhbFBsYW5lTm9ybWFsLnkgPSBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueTtcbiAgICAgICAgIGNjLmxvY2FsUG9pbnQueCA9IG1hbmlmb2xkLm1fbG9jYWxQb2ludC54O1xuICAgICAgICAgY2MubG9jYWxQb2ludC55ID0gbWFuaWZvbGQubV9sb2NhbFBvaW50Lnk7XG4gICAgICAgICBjYy5yYWRpdXMgPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICAgICAgIGNjLnR5cGUgPSBtYW5pZm9sZC5tX3R5cGU7XG4gICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNjLnBvaW50Q291bnQ7ICsraykge1xuICAgICAgICAgICAgdmFyIGNwID0gbWFuaWZvbGQubV9wb2ludHNba107XG4gICAgICAgICAgICB2YXIgY2NwID0gY2MucG9pbnRzW2tdO1xuICAgICAgICAgICAgY2NwLm5vcm1hbEltcHVsc2UgPSBjcC5tX25vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICBjY3AudGFuZ2VudEltcHVsc2UgPSBjcC5tX3RhbmdlbnRJbXB1bHNlO1xuICAgICAgICAgICAgY2NwLmxvY2FsUG9pbnQuU2V0VihjcC5tX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgdmFyIHJBWCA9IGNjcC5yQS54ID0gYjJDb250YWN0U29sdmVyLnNfd29ybGRNYW5pZm9sZC5tX3BvaW50c1trXS54IC0gYm9keUEubV9zd2VlcC5jLng7XG4gICAgICAgICAgICB2YXIgckFZID0gY2NwLnJBLnkgPSBiMkNvbnRhY3RTb2x2ZXIuc193b3JsZE1hbmlmb2xkLm1fcG9pbnRzW2tdLnkgLSBib2R5QS5tX3N3ZWVwLmMueTtcbiAgICAgICAgICAgIHZhciByQlggPSBjY3AuckIueCA9IGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQubV9wb2ludHNba10ueCAtIGJvZHlCLm1fc3dlZXAuYy54O1xuICAgICAgICAgICAgdmFyIHJCWSA9IGNjcC5yQi55ID0gYjJDb250YWN0U29sdmVyLnNfd29ybGRNYW5pZm9sZC5tX3BvaW50c1trXS55IC0gYm9keUIubV9zd2VlcC5jLnk7XG4gICAgICAgICAgICB2YXIgcm5BID0gckFYICogbm9ybWFsWSAtIHJBWSAqIG5vcm1hbFg7XG4gICAgICAgICAgICB2YXIgcm5CID0gckJYICogbm9ybWFsWSAtIHJCWSAqIG5vcm1hbFg7XG4gICAgICAgICAgICBybkEgKj0gcm5BO1xuICAgICAgICAgICAgcm5CICo9IHJuQjtcbiAgICAgICAgICAgIHZhciBrTm9ybWFsID0gYm9keUEubV9pbnZNYXNzICsgYm9keUIubV9pbnZNYXNzICsgYm9keUEubV9pbnZJICogcm5BICsgYm9keUIubV9pbnZJICogcm5CO1xuICAgICAgICAgICAgY2NwLm5vcm1hbE1hc3MgPSAxLjAgLyBrTm9ybWFsO1xuICAgICAgICAgICAgdmFyIGtFcXVhbGl6ZWQgPSBib2R5QS5tX21hc3MgKiBib2R5QS5tX2ludk1hc3MgKyBib2R5Qi5tX21hc3MgKiBib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICBrRXF1YWxpemVkICs9IGJvZHlBLm1fbWFzcyAqIGJvZHlBLm1faW52SSAqIHJuQSArIGJvZHlCLm1fbWFzcyAqIGJvZHlCLm1faW52SSAqIHJuQjtcbiAgICAgICAgICAgIGNjcC5lcXVhbGl6ZWRNYXNzID0gMS4wIC8ga0VxdWFsaXplZDtcbiAgICAgICAgICAgIHZhciB0YW5nZW50WCA9IG5vcm1hbFk7XG4gICAgICAgICAgICB2YXIgdGFuZ2VudFkgPSAoLW5vcm1hbFgpO1xuICAgICAgICAgICAgdmFyIHJ0QSA9IHJBWCAqIHRhbmdlbnRZIC0gckFZICogdGFuZ2VudFg7XG4gICAgICAgICAgICB2YXIgcnRCID0gckJYICogdGFuZ2VudFkgLSByQlkgKiB0YW5nZW50WDtcbiAgICAgICAgICAgIHJ0QSAqPSBydEE7XG4gICAgICAgICAgICBydEIgKj0gcnRCO1xuICAgICAgICAgICAgdmFyIGtUYW5nZW50ID0gYm9keUEubV9pbnZNYXNzICsgYm9keUIubV9pbnZNYXNzICsgYm9keUEubV9pbnZJICogcnRBICsgYm9keUIubV9pbnZJICogcnRCO1xuICAgICAgICAgICAgY2NwLnRhbmdlbnRNYXNzID0gMS4wIC8ga1RhbmdlbnQ7XG4gICAgICAgICAgICBjY3AudmVsb2NpdHlCaWFzID0gMC4wO1xuICAgICAgICAgICAgdmFyIHRYID0gdkJYICsgKCgtd0IgKiByQlkpKSAtIHZBWCAtICgoLXdBICogckFZKSk7XG4gICAgICAgICAgICB2YXIgdFkgPSB2QlkgKyAod0IgKiByQlgpIC0gdkFZIC0gKHdBICogckFYKTtcbiAgICAgICAgICAgIHZhciB2UmVsID0gY2Mubm9ybWFsLnggKiB0WCArIGNjLm5vcm1hbC55ICogdFk7XG4gICAgICAgICAgICBpZiAodlJlbCA8ICgtYjJTZXR0aW5ncy5iMl92ZWxvY2l0eVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgIGNjcC52ZWxvY2l0eUJpYXMgKz0gKC1jYy5yZXN0aXR1dGlvbiAqIHZSZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKGNjLnBvaW50Q291bnQgPT0gMikge1xuICAgICAgICAgICAgdmFyIGNjcDEgPSBjYy5wb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgY2NwMiA9IGNjLnBvaW50c1sxXTtcbiAgICAgICAgICAgIHZhciBpbnZNYXNzQSA9IGJvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHZhciBpbnZJQSA9IGJvZHlBLm1faW52STtcbiAgICAgICAgICAgIHZhciBpbnZNYXNzQiA9IGJvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHZhciBpbnZJQiA9IGJvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBybjFBID0gY2NwMS5yQS54ICogbm9ybWFsWSAtIGNjcDEuckEueSAqIG5vcm1hbFg7XG4gICAgICAgICAgICB2YXIgcm4xQiA9IGNjcDEuckIueCAqIG5vcm1hbFkgLSBjY3AxLnJCLnkgKiBub3JtYWxYO1xuICAgICAgICAgICAgdmFyIHJuMkEgPSBjY3AyLnJBLnggKiBub3JtYWxZIC0gY2NwMi5yQS55ICogbm9ybWFsWDtcbiAgICAgICAgICAgIHZhciBybjJCID0gY2NwMi5yQi54ICogbm9ybWFsWSAtIGNjcDIuckIueSAqIG5vcm1hbFg7XG4gICAgICAgICAgICB2YXIgazExID0gaW52TWFzc0EgKyBpbnZNYXNzQiArIGludklBICogcm4xQSAqIHJuMUEgKyBpbnZJQiAqIHJuMUIgKiBybjFCO1xuICAgICAgICAgICAgdmFyIGsyMiA9IGludk1hc3NBICsgaW52TWFzc0IgKyBpbnZJQSAqIHJuMkEgKiBybjJBICsgaW52SUIgKiBybjJCICogcm4yQjtcbiAgICAgICAgICAgIHZhciBrMTIgPSBpbnZNYXNzQSArIGludk1hc3NCICsgaW52SUEgKiBybjFBICogcm4yQSArIGludklCICogcm4xQiAqIHJuMkI7XG4gICAgICAgICAgICB2YXIga19tYXhDb25kaXRpb25OdW1iZXIgPSAxMDAuMDtcbiAgICAgICAgICAgIGlmIChrMTEgKiBrMTEgPCBrX21heENvbmRpdGlvbk51bWJlciAqIChrMTEgKiBrMjIgLSBrMTIgKiBrMTIpKSB7XG4gICAgICAgICAgICAgICBjYy5LLmNvbDEuU2V0KGsxMSwgazEyKTtcbiAgICAgICAgICAgICAgIGNjLksuY29sMi5TZXQoazEyLCBrMjIpO1xuICAgICAgICAgICAgICAgY2MuSy5HZXRJbnZlcnNlKGNjLm5vcm1hbE1hc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICBjYy5wb2ludENvdW50ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIGIyQ29udGFjdFNvbHZlci5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIHRWZWM7XG4gICAgICB2YXIgdFZlYzI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnN0cmFpbnRDb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgYyA9IHRoaXMubV9jb25zdHJhaW50c1tpXTtcbiAgICAgICAgIHZhciBib2R5QSA9IGMuYm9keUE7XG4gICAgICAgICB2YXIgYm9keUIgPSBjLmJvZHlCO1xuICAgICAgICAgdmFyIGludk1hc3NBID0gYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgdmFyIGludklBID0gYm9keUEubV9pbnZJO1xuICAgICAgICAgdmFyIGludk1hc3NCID0gYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgdmFyIGludklCID0gYm9keUIubV9pbnZJO1xuICAgICAgICAgdmFyIG5vcm1hbFggPSBjLm5vcm1hbC54O1xuICAgICAgICAgdmFyIG5vcm1hbFkgPSBjLm5vcm1hbC55O1xuICAgICAgICAgdmFyIHRhbmdlbnRYID0gbm9ybWFsWTtcbiAgICAgICAgIHZhciB0YW5nZW50WSA9ICgtbm9ybWFsWCk7XG4gICAgICAgICB2YXIgdFggPSAwO1xuICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgdmFyIHRDb3VudCA9IDA7XG4gICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgIHRDb3VudCA9IGMucG9pbnRDb3VudDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7XG4gICAgICAgICAgICBqIDwgdENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgIHZhciBjY3AgPSBjLnBvaW50c1tqXTtcbiAgICAgICAgICAgICAgIGNjcC5ub3JtYWxJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgIGNjcC50YW5nZW50SW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICAgICAgICB2YXIgUFggPSBjY3Aubm9ybWFsSW1wdWxzZSAqIG5vcm1hbFggKyBjY3AudGFuZ2VudEltcHVsc2UgKiB0YW5nZW50WDtcbiAgICAgICAgICAgICAgIHZhciBQWSA9IGNjcC5ub3JtYWxJbXB1bHNlICogbm9ybWFsWSArIGNjcC50YW5nZW50SW1wdWxzZSAqIHRhbmdlbnRZO1xuICAgICAgICAgICAgICAgYm9keUEubV9hbmd1bGFyVmVsb2NpdHkgLT0gaW52SUEgKiAoY2NwLnJBLnggKiBQWSAtIGNjcC5yQS55ICogUFgpO1xuICAgICAgICAgICAgICAgYm9keUEubV9saW5lYXJWZWxvY2l0eS54IC09IGludk1hc3NBICogUFg7XG4gICAgICAgICAgICAgICBib2R5QS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gaW52TWFzc0EgKiBQWTtcbiAgICAgICAgICAgICAgIGJvZHlCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGludklCICogKGNjcC5yQi54ICogUFkgLSBjY3AuckIueSAqIFBYKTtcbiAgICAgICAgICAgICAgIGJvZHlCLm1fbGluZWFyVmVsb2NpdHkueCArPSBpbnZNYXNzQiAqIFBYO1xuICAgICAgICAgICAgICAgYm9keUIubV9saW5lYXJWZWxvY2l0eS55ICs9IGludk1hc3NCICogUFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRDb3VudCA9IGMucG9pbnRDb3VudDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7XG4gICAgICAgICAgICBqIDwgdENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgIHZhciBjY3AyID0gYy5wb2ludHNbal07XG4gICAgICAgICAgICAgICBjY3AyLm5vcm1hbEltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICAgICBjY3AyLnRhbmdlbnRJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB2YXIgY2NwO1xuICAgICAgdmFyIHJBWCA9IDA7XG4gICAgICB2YXIgckFZID0gMDtcbiAgICAgIHZhciByQlggPSAwO1xuICAgICAgdmFyIHJCWSA9IDA7XG4gICAgICB2YXIgZHZYID0gMDtcbiAgICAgIHZhciBkdlkgPSAwO1xuICAgICAgdmFyIHZuID0gMDtcbiAgICAgIHZhciB2dCA9IDA7XG4gICAgICB2YXIgbGFtYmRhID0gMDtcbiAgICAgIHZhciBtYXhGcmljdGlvbiA9IDA7XG4gICAgICB2YXIgbmV3SW1wdWxzZSA9IDA7XG4gICAgICB2YXIgUFggPSAwO1xuICAgICAgdmFyIFBZID0gMDtcbiAgICAgIHZhciBkWCA9IDA7XG4gICAgICB2YXIgZFkgPSAwO1xuICAgICAgdmFyIFAxWCA9IDA7XG4gICAgICB2YXIgUDFZID0gMDtcbiAgICAgIHZhciBQMlggPSAwO1xuICAgICAgdmFyIFAyWSA9IDA7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29uc3RyYWludENvdW50OyArK2kpIHtcbiAgICAgICAgIHZhciBjID0gdGhpcy5tX2NvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgdmFyIGJvZHlBID0gYy5ib2R5QTtcbiAgICAgICAgIHZhciBib2R5QiA9IGMuYm9keUI7XG4gICAgICAgICB2YXIgd0EgPSBib2R5QS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgIHZhciB3QiA9IGJvZHlCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgdmFyIHZBID0gYm9keUEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgICAgIHZhciB2QiA9IGJvZHlCLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICAgICB2YXIgaW52TWFzc0EgPSBib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICB2YXIgaW52SUEgPSBib2R5QS5tX2ludkk7XG4gICAgICAgICB2YXIgaW52TWFzc0IgPSBib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICB2YXIgaW52SUIgPSBib2R5Qi5tX2ludkk7XG4gICAgICAgICB2YXIgbm9ybWFsWCA9IGMubm9ybWFsLng7XG4gICAgICAgICB2YXIgbm9ybWFsWSA9IGMubm9ybWFsLnk7XG4gICAgICAgICB2YXIgdGFuZ2VudFggPSBub3JtYWxZO1xuICAgICAgICAgdmFyIHRhbmdlbnRZID0gKC1ub3JtYWxYKTtcbiAgICAgICAgIHZhciBmcmljdGlvbiA9IGMuZnJpY3Rpb247XG4gICAgICAgICB2YXIgdFggPSAwO1xuICAgICAgICAgZm9yIChqID0gMDtcbiAgICAgICAgIGogPCBjLnBvaW50Q291bnQ7IGorKykge1xuICAgICAgICAgICAgY2NwID0gYy5wb2ludHNbal07XG4gICAgICAgICAgICBkdlggPSB2Qi54IC0gd0IgKiBjY3AuckIueSAtIHZBLnggKyB3QSAqIGNjcC5yQS55O1xuICAgICAgICAgICAgZHZZID0gdkIueSArIHdCICogY2NwLnJCLnggLSB2QS55IC0gd0EgKiBjY3AuckEueDtcbiAgICAgICAgICAgIHZ0ID0gZHZYICogdGFuZ2VudFggKyBkdlkgKiB0YW5nZW50WTtcbiAgICAgICAgICAgIGxhbWJkYSA9IGNjcC50YW5nZW50TWFzcyAqICgtdnQpO1xuICAgICAgICAgICAgbWF4RnJpY3Rpb24gPSBmcmljdGlvbiAqIGNjcC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IGIyTWF0aC5DbGFtcChjY3AudGFuZ2VudEltcHVsc2UgKyBsYW1iZGEsICgtbWF4RnJpY3Rpb24pLCBtYXhGcmljdGlvbik7XG4gICAgICAgICAgICBsYW1iZGEgPSBuZXdJbXB1bHNlIC0gY2NwLnRhbmdlbnRJbXB1bHNlO1xuICAgICAgICAgICAgUFggPSBsYW1iZGEgKiB0YW5nZW50WDtcbiAgICAgICAgICAgIFBZID0gbGFtYmRhICogdGFuZ2VudFk7XG4gICAgICAgICAgICB2QS54IC09IGludk1hc3NBICogUFg7XG4gICAgICAgICAgICB2QS55IC09IGludk1hc3NBICogUFk7XG4gICAgICAgICAgICB3QSAtPSBpbnZJQSAqIChjY3AuckEueCAqIFBZIC0gY2NwLnJBLnkgKiBQWCk7XG4gICAgICAgICAgICB2Qi54ICs9IGludk1hc3NCICogUFg7XG4gICAgICAgICAgICB2Qi55ICs9IGludk1hc3NCICogUFk7XG4gICAgICAgICAgICB3QiArPSBpbnZJQiAqIChjY3AuckIueCAqIFBZIC0gY2NwLnJCLnkgKiBQWCk7XG4gICAgICAgICAgICBjY3AudGFuZ2VudEltcHVsc2UgPSBuZXdJbXB1bHNlO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIHRDb3VudCA9IHBhcnNlSW50KGMucG9pbnRDb3VudCk7XG4gICAgICAgICBpZiAoYy5wb2ludENvdW50ID09IDEpIHtcbiAgICAgICAgICAgIGNjcCA9IGMucG9pbnRzWzBdO1xuICAgICAgICAgICAgZHZYID0gdkIueCArICgoLXdCICogY2NwLnJCLnkpKSAtIHZBLnggLSAoKC13QSAqIGNjcC5yQS55KSk7XG4gICAgICAgICAgICBkdlkgPSB2Qi55ICsgKHdCICogY2NwLnJCLngpIC0gdkEueSAtICh3QSAqIGNjcC5yQS54KTtcbiAgICAgICAgICAgIHZuID0gZHZYICogbm9ybWFsWCArIGR2WSAqIG5vcm1hbFk7XG4gICAgICAgICAgICBsYW1iZGEgPSAoLWNjcC5ub3JtYWxNYXNzICogKHZuIC0gY2NwLnZlbG9jaXR5QmlhcykpO1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IGNjcC5ub3JtYWxJbXB1bHNlICsgbGFtYmRhO1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IG5ld0ltcHVsc2UgPiAwID8gbmV3SW1wdWxzZSA6IDAuMDtcbiAgICAgICAgICAgIGxhbWJkYSA9IG5ld0ltcHVsc2UgLSBjY3Aubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgIFBYID0gbGFtYmRhICogbm9ybWFsWDtcbiAgICAgICAgICAgIFBZID0gbGFtYmRhICogbm9ybWFsWTtcbiAgICAgICAgICAgIHZBLnggLT0gaW52TWFzc0EgKiBQWDtcbiAgICAgICAgICAgIHZBLnkgLT0gaW52TWFzc0EgKiBQWTtcbiAgICAgICAgICAgIHdBIC09IGludklBICogKGNjcC5yQS54ICogUFkgLSBjY3AuckEueSAqIFBYKTtcbiAgICAgICAgICAgIHZCLnggKz0gaW52TWFzc0IgKiBQWDtcbiAgICAgICAgICAgIHZCLnkgKz0gaW52TWFzc0IgKiBQWTtcbiAgICAgICAgICAgIHdCICs9IGludklCICogKGNjcC5yQi54ICogUFkgLSBjY3AuckIueSAqIFBYKTtcbiAgICAgICAgICAgIGNjcC5ub3JtYWxJbXB1bHNlID0gbmV3SW1wdWxzZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNwMSA9IGMucG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGNwMiA9IGMucG9pbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGFYID0gY3AxLm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICB2YXIgYVkgPSBjcDIubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgIHZhciBkdjFYID0gdkIueCAtIHdCICogY3AxLnJCLnkgLSB2QS54ICsgd0EgKiBjcDEuckEueTtcbiAgICAgICAgICAgIHZhciBkdjFZID0gdkIueSArIHdCICogY3AxLnJCLnggLSB2QS55IC0gd0EgKiBjcDEuckEueDtcbiAgICAgICAgICAgIHZhciBkdjJYID0gdkIueCAtIHdCICogY3AyLnJCLnkgLSB2QS54ICsgd0EgKiBjcDIuckEueTtcbiAgICAgICAgICAgIHZhciBkdjJZID0gdkIueSArIHdCICogY3AyLnJCLnggLSB2QS55IC0gd0EgKiBjcDIuckEueDtcbiAgICAgICAgICAgIHZhciB2bjEgPSBkdjFYICogbm9ybWFsWCArIGR2MVkgKiBub3JtYWxZO1xuICAgICAgICAgICAgdmFyIHZuMiA9IGR2MlggKiBub3JtYWxYICsgZHYyWSAqIG5vcm1hbFk7XG4gICAgICAgICAgICB2YXIgYlggPSB2bjEgLSBjcDEudmVsb2NpdHlCaWFzO1xuICAgICAgICAgICAgdmFyIGJZID0gdm4yIC0gY3AyLnZlbG9jaXR5QmlhcztcbiAgICAgICAgICAgIHRNYXQgPSBjLks7XG4gICAgICAgICAgICBiWCAtPSB0TWF0LmNvbDEueCAqIGFYICsgdE1hdC5jb2wyLnggKiBhWTtcbiAgICAgICAgICAgIGJZIC09IHRNYXQuY29sMS55ICogYVggKyB0TWF0LmNvbDIueSAqIGFZO1xuICAgICAgICAgICAgdmFyIGtfZXJyb3JUb2wgPSAwLjAwMTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgIHRNYXQgPSBjLm5vcm1hbE1hc3M7XG4gICAgICAgICAgICAgICB2YXIgeFggPSAoLSh0TWF0LmNvbDEueCAqIGJYICsgdE1hdC5jb2wyLnggKiBiWSkpO1xuICAgICAgICAgICAgICAgdmFyIHhZID0gKC0odE1hdC5jb2wxLnkgKiBiWCArIHRNYXQuY29sMi55ICogYlkpKTtcbiAgICAgICAgICAgICAgIGlmICh4WCA+PSAwLjAgJiYgeFkgPj0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICBkWCA9IHhYIC0gYVg7XG4gICAgICAgICAgICAgICAgICBkWSA9IHhZIC0gYVk7XG4gICAgICAgICAgICAgICAgICBQMVggPSBkWCAqIG5vcm1hbFg7XG4gICAgICAgICAgICAgICAgICBQMVkgPSBkWCAqIG5vcm1hbFk7XG4gICAgICAgICAgICAgICAgICBQMlggPSBkWSAqIG5vcm1hbFg7XG4gICAgICAgICAgICAgICAgICBQMlkgPSBkWSAqIG5vcm1hbFk7XG4gICAgICAgICAgICAgICAgICB2QS54IC09IGludk1hc3NBICogKFAxWCArIFAyWCk7XG4gICAgICAgICAgICAgICAgICB2QS55IC09IGludk1hc3NBICogKFAxWSArIFAyWSk7XG4gICAgICAgICAgICAgICAgICB3QSAtPSBpbnZJQSAqIChjcDEuckEueCAqIFAxWSAtIGNwMS5yQS55ICogUDFYICsgY3AyLnJBLnggKiBQMlkgLSBjcDIuckEueSAqIFAyWCk7XG4gICAgICAgICAgICAgICAgICB2Qi54ICs9IGludk1hc3NCICogKFAxWCArIFAyWCk7XG4gICAgICAgICAgICAgICAgICB2Qi55ICs9IGludk1hc3NCICogKFAxWSArIFAyWSk7XG4gICAgICAgICAgICAgICAgICB3QiArPSBpbnZJQiAqIChjcDEuckIueCAqIFAxWSAtIGNwMS5yQi55ICogUDFYICsgY3AyLnJCLnggKiBQMlkgLSBjcDIuckIueSAqIFAyWCk7XG4gICAgICAgICAgICAgICAgICBjcDEubm9ybWFsSW1wdWxzZSA9IHhYO1xuICAgICAgICAgICAgICAgICAgY3AyLm5vcm1hbEltcHVsc2UgPSB4WTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgeFggPSAoLWNwMS5ub3JtYWxNYXNzICogYlgpO1xuICAgICAgICAgICAgICAgeFkgPSAwLjA7XG4gICAgICAgICAgICAgICB2bjEgPSAwLjA7XG4gICAgICAgICAgICAgICB2bjIgPSBjLksuY29sMS55ICogeFggKyBiWTtcbiAgICAgICAgICAgICAgIGlmICh4WCA+PSAwLjAgJiYgdm4yID49IDAuMCkge1xuICAgICAgICAgICAgICAgICAgZFggPSB4WCAtIGFYO1xuICAgICAgICAgICAgICAgICAgZFkgPSB4WSAtIGFZO1xuICAgICAgICAgICAgICAgICAgUDFYID0gZFggKiBub3JtYWxYO1xuICAgICAgICAgICAgICAgICAgUDFZID0gZFggKiBub3JtYWxZO1xuICAgICAgICAgICAgICAgICAgUDJYID0gZFkgKiBub3JtYWxYO1xuICAgICAgICAgICAgICAgICAgUDJZID0gZFkgKiBub3JtYWxZO1xuICAgICAgICAgICAgICAgICAgdkEueCAtPSBpbnZNYXNzQSAqIChQMVggKyBQMlgpO1xuICAgICAgICAgICAgICAgICAgdkEueSAtPSBpbnZNYXNzQSAqIChQMVkgKyBQMlkpO1xuICAgICAgICAgICAgICAgICAgd0EgLT0gaW52SUEgKiAoY3AxLnJBLnggKiBQMVkgLSBjcDEuckEueSAqIFAxWCArIGNwMi5yQS54ICogUDJZIC0gY3AyLnJBLnkgKiBQMlgpO1xuICAgICAgICAgICAgICAgICAgdkIueCArPSBpbnZNYXNzQiAqIChQMVggKyBQMlgpO1xuICAgICAgICAgICAgICAgICAgdkIueSArPSBpbnZNYXNzQiAqIChQMVkgKyBQMlkpO1xuICAgICAgICAgICAgICAgICAgd0IgKz0gaW52SUIgKiAoY3AxLnJCLnggKiBQMVkgLSBjcDEuckIueSAqIFAxWCArIGNwMi5yQi54ICogUDJZIC0gY3AyLnJCLnkgKiBQMlgpO1xuICAgICAgICAgICAgICAgICAgY3AxLm5vcm1hbEltcHVsc2UgPSB4WDtcbiAgICAgICAgICAgICAgICAgIGNwMi5ub3JtYWxJbXB1bHNlID0geFk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHhYID0gMC4wO1xuICAgICAgICAgICAgICAgeFkgPSAoLWNwMi5ub3JtYWxNYXNzICogYlkpO1xuICAgICAgICAgICAgICAgdm4xID0gYy5LLmNvbDIueCAqIHhZICsgYlg7XG4gICAgICAgICAgICAgICB2bjIgPSAwLjA7XG4gICAgICAgICAgICAgICBpZiAoeFkgPj0gMC4wICYmIHZuMSA+PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgIGRYID0geFggLSBhWDtcbiAgICAgICAgICAgICAgICAgIGRZID0geFkgLSBhWTtcbiAgICAgICAgICAgICAgICAgIFAxWCA9IGRYICogbm9ybWFsWDtcbiAgICAgICAgICAgICAgICAgIFAxWSA9IGRYICogbm9ybWFsWTtcbiAgICAgICAgICAgICAgICAgIFAyWCA9IGRZICogbm9ybWFsWDtcbiAgICAgICAgICAgICAgICAgIFAyWSA9IGRZICogbm9ybWFsWTtcbiAgICAgICAgICAgICAgICAgIHZBLnggLT0gaW52TWFzc0EgKiAoUDFYICsgUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZBLnkgLT0gaW52TWFzc0EgKiAoUDFZICsgUDJZKTtcbiAgICAgICAgICAgICAgICAgIHdBIC09IGludklBICogKGNwMS5yQS54ICogUDFZIC0gY3AxLnJBLnkgKiBQMVggKyBjcDIuckEueCAqIFAyWSAtIGNwMi5yQS55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZCLnggKz0gaW52TWFzc0IgKiAoUDFYICsgUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZCLnkgKz0gaW52TWFzc0IgKiAoUDFZICsgUDJZKTtcbiAgICAgICAgICAgICAgICAgIHdCICs9IGludklCICogKGNwMS5yQi54ICogUDFZIC0gY3AxLnJCLnkgKiBQMVggKyBjcDIuckIueCAqIFAyWSAtIGNwMi5yQi55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAgIGNwMS5ub3JtYWxJbXB1bHNlID0geFg7XG4gICAgICAgICAgICAgICAgICBjcDIubm9ybWFsSW1wdWxzZSA9IHhZO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB4WCA9IDAuMDtcbiAgICAgICAgICAgICAgIHhZID0gMC4wO1xuICAgICAgICAgICAgICAgdm4xID0gYlg7XG4gICAgICAgICAgICAgICB2bjIgPSBiWTtcbiAgICAgICAgICAgICAgIGlmICh2bjEgPj0gMC4wICYmIHZuMiA+PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgIGRYID0geFggLSBhWDtcbiAgICAgICAgICAgICAgICAgIGRZID0geFkgLSBhWTtcbiAgICAgICAgICAgICAgICAgIFAxWCA9IGRYICogbm9ybWFsWDtcbiAgICAgICAgICAgICAgICAgIFAxWSA9IGRYICogbm9ybWFsWTtcbiAgICAgICAgICAgICAgICAgIFAyWCA9IGRZICogbm9ybWFsWDtcbiAgICAgICAgICAgICAgICAgIFAyWSA9IGRZICogbm9ybWFsWTtcbiAgICAgICAgICAgICAgICAgIHZBLnggLT0gaW52TWFzc0EgKiAoUDFYICsgUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZBLnkgLT0gaW52TWFzc0EgKiAoUDFZICsgUDJZKTtcbiAgICAgICAgICAgICAgICAgIHdBIC09IGludklBICogKGNwMS5yQS54ICogUDFZIC0gY3AxLnJBLnkgKiBQMVggKyBjcDIuckEueCAqIFAyWSAtIGNwMi5yQS55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZCLnggKz0gaW52TWFzc0IgKiAoUDFYICsgUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZCLnkgKz0gaW52TWFzc0IgKiAoUDFZICsgUDJZKTtcbiAgICAgICAgICAgICAgICAgIHdCICs9IGludklCICogKGNwMS5yQi54ICogUDFZIC0gY3AxLnJCLnkgKiBQMVggKyBjcDIuckIueCAqIFAyWSAtIGNwMi5yQi55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAgIGNwMS5ub3JtYWxJbXB1bHNlID0geFg7XG4gICAgICAgICAgICAgICAgICBjcDIubm9ybWFsSW1wdWxzZSA9IHhZO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGJvZHlBLm1fYW5ndWxhclZlbG9jaXR5ID0gd0E7XG4gICAgICAgICBib2R5Qi5tX2FuZ3VsYXJWZWxvY2l0eSA9IHdCO1xuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5GaW5hbGl6ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb25zdHJhaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgdmFyIGMgPSB0aGlzLm1fY29uc3RyYWludHNbaV07XG4gICAgICAgICB2YXIgbSA9IGMubWFuaWZvbGQ7XG4gICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMucG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQxID0gbS5tX3BvaW50c1tqXTtcbiAgICAgICAgICAgIHZhciBwb2ludDIgPSBjLnBvaW50c1tqXTtcbiAgICAgICAgICAgIHBvaW50MS5tX25vcm1hbEltcHVsc2UgPSBwb2ludDIubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgIHBvaW50MS5tX3RhbmdlbnRJbXB1bHNlID0gcG9pbnQyLnRhbmdlbnRJbXB1bHNlO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICB2YXIgbWluU2VwYXJhdGlvbiA9IDAuMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnN0cmFpbnRDb3VudDsgaSsrKSB7XG4gICAgICAgICB2YXIgYyA9IHRoaXMubV9jb25zdHJhaW50c1tpXTtcbiAgICAgICAgIHZhciBib2R5QSA9IGMuYm9keUE7XG4gICAgICAgICB2YXIgYm9keUIgPSBjLmJvZHlCO1xuICAgICAgICAgdmFyIGludk1hc3NBID0gYm9keUEubV9tYXNzICogYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgdmFyIGludklBID0gYm9keUEubV9tYXNzICogYm9keUEubV9pbnZJO1xuICAgICAgICAgdmFyIGludk1hc3NCID0gYm9keUIubV9tYXNzICogYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgdmFyIGludklCID0gYm9keUIubV9tYXNzICogYm9keUIubV9pbnZJO1xuICAgICAgICAgYjJDb250YWN0U29sdmVyLnNfcHNtLkluaXRpYWxpemUoYyk7XG4gICAgICAgICB2YXIgbm9ybWFsID0gYjJDb250YWN0U29sdmVyLnNfcHNtLm1fbm9ybWFsO1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLnBvaW50Q291bnQ7IGorKykge1xuICAgICAgICAgICAgdmFyIGNjcCA9IGMucG9pbnRzW2pdO1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gYjJDb250YWN0U29sdmVyLnNfcHNtLm1fcG9pbnRzW2pdO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBiMkNvbnRhY3RTb2x2ZXIuc19wc20ubV9zZXBhcmF0aW9uc1tqXTtcbiAgICAgICAgICAgIHZhciByQVggPSBwb2ludC54IC0gYm9keUEubV9zd2VlcC5jLng7XG4gICAgICAgICAgICB2YXIgckFZID0gcG9pbnQueSAtIGJvZHlBLm1fc3dlZXAuYy55O1xuICAgICAgICAgICAgdmFyIHJCWCA9IHBvaW50LnggLSBib2R5Qi5tX3N3ZWVwLmMueDtcbiAgICAgICAgICAgIHZhciByQlkgPSBwb2ludC55IC0gYm9keUIubV9zd2VlcC5jLnk7XG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uID0gbWluU2VwYXJhdGlvbiA8IHNlcGFyYXRpb24gPyBtaW5TZXBhcmF0aW9uIDogc2VwYXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBDID0gYjJNYXRoLkNsYW1wKGJhdW1nYXJ0ZSAqIChzZXBhcmF0aW9uICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSwgKC1iMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pLCAwLjApO1xuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAoLWNjcC5lcXVhbGl6ZWRNYXNzICogQyk7XG4gICAgICAgICAgICB2YXIgUFggPSBpbXB1bHNlICogbm9ybWFsLng7XG4gICAgICAgICAgICB2YXIgUFkgPSBpbXB1bHNlICogbm9ybWFsLnk7Ym9keUEubV9zd2VlcC5jLnggLT0gaW52TWFzc0EgKiBQWDtcbiAgICAgICAgICAgIGJvZHlBLm1fc3dlZXAuYy55IC09IGludk1hc3NBICogUFk7XG4gICAgICAgICAgICBib2R5QS5tX3N3ZWVwLmEgLT0gaW52SUEgKiAockFYICogUFkgLSByQVkgKiBQWCk7XG4gICAgICAgICAgICBib2R5QS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgYm9keUIubV9zd2VlcC5jLnggKz0gaW52TWFzc0IgKiBQWDtcbiAgICAgICAgICAgIGJvZHlCLm1fc3dlZXAuYy55ICs9IGludk1hc3NCICogUFk7XG4gICAgICAgICAgICBib2R5Qi5tX3N3ZWVwLmEgKz0gaW52SUIgKiAockJYICogUFkgLSByQlkgKiBQWCk7XG4gICAgICAgICAgICBib2R5Qi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pblNlcGFyYXRpb24gPiAoLTEuNSAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCk7XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQgPSBuZXcgYjJXb3JsZE1hbmlmb2xkKCk7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RTb2x2ZXIuc19wc20gPSBuZXcgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkKCk7XG4gICB9KTtcbiAgIEJveDJELmluaGVyaXQoYjJFZGdlQW5kQ2lyY2xlQ29udGFjdCwgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0KTtcbiAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5iMkVkZ2VBbmRDaXJjbGVDb250YWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QuQ3JlYXRlID0gZnVuY3Rpb24gKGFsbG9jYXRvcikge1xuICAgICAgcmV0dXJuIG5ldyBiMkVkZ2VBbmRDaXJjbGVDb250YWN0KCk7XG4gICB9XG4gICBiMkVkZ2VBbmRDaXJjbGVDb250YWN0LkRlc3Ryb3kgPSBmdW5jdGlvbiAoY29udGFjdCwgYWxsb2NhdG9yKSB7fVxuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuUmVzZXQuY2FsbCh0aGlzLCBmaXh0dXJlQSwgZml4dHVyZUIpO1xuICAgfVxuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuRXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fZml4dHVyZUEuR2V0Qm9keSgpO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2ZpeHR1cmVCLkdldEJvZHkoKTtcbiAgICAgIHRoaXMuYjJDb2xsaWRlRWRnZUFuZENpcmNsZSh0aGlzLm1fbWFuaWZvbGQsICh0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSBpbnN0YW5jZW9mIGIyRWRnZVNoYXBlID8gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgOiBudWxsKSwgYkEubV94ZiwgKHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJDaXJjbGVTaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xuICAgfVxuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuYjJDb2xsaWRlRWRnZUFuZENpcmNsZSA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgZWRnZSwgeGYxLCBjaXJjbGUsIHhmMikge31cbiAgIEJveDJELmluaGVyaXQoYjJOdWxsQ29udGFjdCwgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0KTtcbiAgIGIyTnVsbENvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xuICAgYjJOdWxsQ29udGFjdC5iMk51bGxDb250YWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIGIyTnVsbENvbnRhY3QucHJvdG90eXBlLmIyTnVsbENvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJDb250YWN0LmNhbGwodGhpcyk7XG4gICB9XG4gICBiMk51bGxDb250YWN0LnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHt9XG4gICBCb3gyRC5pbmhlcml0KGIyUG9seUFuZENpcmNsZUNvbnRhY3QsIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdCk7XG4gICBiMlBvbHlBbmRDaXJjbGVDb250YWN0LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LnByb3RvdHlwZTtcbiAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBiMlBvbHlBbmRDaXJjbGVDb250YWN0LkNyZWF0ZSA9IGZ1bmN0aW9uIChhbGxvY2F0b3IpIHtcbiAgICAgIHJldHVybiBuZXcgYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCgpO1xuICAgfVxuICAgYjJQb2x5QW5kQ2lyY2xlQ29udGFjdC5EZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhY3QsIGFsbG9jYXRvcikge31cbiAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xuICAgICAgdGhpcy5fX3N1cGVyLlJlc2V0LmNhbGwodGhpcywgZml4dHVyZUEsIGZpeHR1cmVCKTtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZml4dHVyZUEuR2V0VHlwZSgpID09IGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUpO1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmaXh0dXJlQi5HZXRUeXBlKCkgPT0gYjJTaGFwZS5lX2NpcmNsZVNoYXBlKTtcbiAgIH1cbiAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLkV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2ZpeHR1cmVBLm1fYm9keTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9maXh0dXJlQi5tX2JvZHk7XG4gICAgICBiMkNvbGxpc2lvbi5Db2xsaWRlUG9seWdvbkFuZENpcmNsZSh0aGlzLm1fbWFuaWZvbGQsICh0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSBpbnN0YW5jZW9mIGIyUG9seWdvblNoYXBlID8gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgOiBudWxsKSwgYkEubV94ZiwgKHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJDaXJjbGVTaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMlBvbHlBbmRFZGdlQ29udGFjdCwgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0KTtcbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LnByb3RvdHlwZTtcbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LmIyUG9seUFuZEVkZ2VDb250YWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LkNyZWF0ZSA9IGZ1bmN0aW9uIChhbGxvY2F0b3IpIHtcbiAgICAgIHJldHVybiBuZXcgYjJQb2x5QW5kRWRnZUNvbnRhY3QoKTtcbiAgIH1cbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LkRlc3Ryb3kgPSBmdW5jdGlvbiAoY29udGFjdCwgYWxsb2NhdG9yKSB7fVxuICAgYjJQb2x5QW5kRWRnZUNvbnRhY3QucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xuICAgICAgdGhpcy5fX3N1cGVyLlJlc2V0LmNhbGwodGhpcywgZml4dHVyZUEsIGZpeHR1cmVCKTtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZml4dHVyZUEuR2V0VHlwZSgpID09IGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUpO1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmaXh0dXJlQi5HZXRUeXBlKCkgPT0gYjJTaGFwZS5lX2VkZ2VTaGFwZSk7XG4gICB9XG4gICBiMlBvbHlBbmRFZGdlQ29udGFjdC5wcm90b3R5cGUuRXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fZml4dHVyZUEuR2V0Qm9keSgpO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2ZpeHR1cmVCLkdldEJvZHkoKTtcbiAgICAgIHRoaXMuYjJDb2xsaWRlUG9seUFuZEVkZ2UodGhpcy5tX21hbmlmb2xkLCAodGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpIDogbnVsbCksIGJBLm1feGYsICh0aGlzLm1fZml4dHVyZUIuR2V0U2hhcGUoKSBpbnN0YW5jZW9mIGIyRWRnZVNoYXBlID8gdGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCkgOiBudWxsKSwgYkIubV94Zik7XG4gICB9XG4gICBiMlBvbHlBbmRFZGdlQ29udGFjdC5wcm90b3R5cGUuYjJDb2xsaWRlUG9seUFuZEVkZ2UgPSBmdW5jdGlvbiAobWFuaWZvbGQsIHBvbHlnb24sIHhmMSwgZWRnZSwgeGYyKSB7fVxuICAgQm94MkQuaW5oZXJpdChiMlBvbHlnb25Db250YWN0LCBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QpO1xuICAgYjJQb2x5Z29uQ29udGFjdC5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5wcm90b3R5cGU7XG4gICBiMlBvbHlnb25Db250YWN0LmIyUG9seWdvbkNvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuYjJDb250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgYjJQb2x5Z29uQ29udGFjdC5DcmVhdGUgPSBmdW5jdGlvbiAoYWxsb2NhdG9yKSB7XG4gICAgICByZXR1cm4gbmV3IGIyUG9seWdvbkNvbnRhY3QoKTtcbiAgIH1cbiAgIGIyUG9seWdvbkNvbnRhY3QuRGVzdHJveSA9IGZ1bmN0aW9uIChjb250YWN0LCBhbGxvY2F0b3IpIHt9XG4gICBiMlBvbHlnb25Db250YWN0LnByb3RvdHlwZS5SZXNldCA9IGZ1bmN0aW9uIChmaXh0dXJlQSwgZml4dHVyZUIpIHtcbiAgICAgIHRoaXMuX19zdXBlci5SZXNldC5jYWxsKHRoaXMsIGZpeHR1cmVBLCBmaXh0dXJlQik7XG4gICB9XG4gICBiMlBvbHlnb25Db250YWN0LnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9maXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fZml4dHVyZUIuR2V0Qm9keSgpO1xuICAgICAgYjJDb2xsaXNpb24uQ29sbGlkZVBvbHlnb25zKHRoaXMubV9tYW5pZm9sZCwgKHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyB0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSA6IG51bGwpLCBiQS5tX3hmLCAodGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xuICAgfVxuICAgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLnByb3RvdHlwZS5iMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fbm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3NlcGFyYXRpb25zID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xuICAgICAgdGhpcy5tX3BvaW50cyA9IG5ldyBWZWN0b3IoYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xuICAgICAgICAgdGhpcy5tX3BvaW50c1tpXSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZC5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChjYykge1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChjYy5wb2ludENvdW50ID4gMCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgY2xpcFBvaW50WCA9IDA7XG4gICAgICB2YXIgY2xpcFBvaW50WSA9IDA7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdmFyIHBsYW5lUG9pbnRYID0gMDtcbiAgICAgIHZhciBwbGFuZVBvaW50WSA9IDA7XG4gICAgICBzd2l0Y2ggKGNjLnR5cGUpIHtcbiAgICAgIGNhc2UgYjJNYW5pZm9sZC5lX2NpcmNsZXM6XG4gICAgICAgICB7XG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUEubV94Zi5SO1xuICAgICAgICAgICAgdFZlYyA9IGNjLmxvY2FsUG9pbnQ7XG4gICAgICAgICAgICB2YXIgcG9pbnRBWCA9IGNjLmJvZHlBLm1feGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgICAgIHZhciBwb2ludEFZID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlCLm1feGYuUjtcbiAgICAgICAgICAgIHRWZWMgPSBjYy5wb2ludHNbMF0ubG9jYWxQb2ludDtcbiAgICAgICAgICAgIHZhciBwb2ludEJYID0gY2MuYm9keUIubV94Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgdmFyIHBvaW50QlkgPSBjYy5ib2R5Qi5tX3hmLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICAgICB2YXIgZFggPSBwb2ludEJYIC0gcG9pbnRBWDtcbiAgICAgICAgICAgIHZhciBkWSA9IHBvaW50QlkgLSBwb2ludEFZO1xuICAgICAgICAgICAgdmFyIGQyID0gZFggKiBkWCArIGRZICogZFk7XG4gICAgICAgICAgICBpZiAoZDIgPiBOdW1iZXIuTUlOX1ZBTFVFICogTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoZDIpO1xuICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ID0gZFggLyBkO1xuICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ID0gZFkgLyBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggPSAxLjA7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fcG9pbnRzWzBdLnggPSAwLjUgKiAocG9pbnRBWCArIHBvaW50QlgpO1xuICAgICAgICAgICAgdGhpcy5tX3BvaW50c1swXS55ID0gMC41ICogKHBvaW50QVkgKyBwb2ludEJZKTtcbiAgICAgICAgICAgIHRoaXMubV9zZXBhcmF0aW9uc1swXSA9IGRYICogdGhpcy5tX25vcm1hbC54ICsgZFkgKiB0aGlzLm1fbm9ybWFsLnkgLSBjYy5yYWRpdXM7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJNYW5pZm9sZC5lX2ZhY2VBOlxuICAgICAgICAge1xuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlBLm1feGYuUjtcbiAgICAgICAgICAgIHRWZWMgPSBjYy5sb2NhbFBsYW5lTm9ybWFsO1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ID0gdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUEubV94Zi5SO1xuICAgICAgICAgICAgdFZlYyA9IGNjLmxvY2FsUG9pbnQ7XG4gICAgICAgICAgICBwbGFuZVBvaW50WCA9IGNjLmJvZHlBLm1feGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgICAgIHBsYW5lUG9pbnRZID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlCLm1feGYuUjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7XG4gICAgICAgICAgICBpIDwgY2MucG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICB0VmVjID0gY2MucG9pbnRzW2ldLmxvY2FsUG9pbnQ7XG4gICAgICAgICAgICAgICBjbGlwUG9pbnRYID0gY2MuYm9keUIubV94Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgICAgY2xpcFBvaW50WSA9IGNjLmJvZHlCLm1feGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgICAgICAgICAgIHRoaXMubV9zZXBhcmF0aW9uc1tpXSA9IChjbGlwUG9pbnRYIC0gcGxhbmVQb2ludFgpICogdGhpcy5tX25vcm1hbC54ICsgKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiB0aGlzLm1fbm9ybWFsLnkgLSBjYy5yYWRpdXM7XG4gICAgICAgICAgICAgICB0aGlzLm1fcG9pbnRzW2ldLnggPSBjbGlwUG9pbnRYO1xuICAgICAgICAgICAgICAgdGhpcy5tX3BvaW50c1tpXS55ID0gY2xpcFBvaW50WTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMk1hbmlmb2xkLmVfZmFjZUI6XG4gICAgICAgICB7XG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUIubV94Zi5SO1xuICAgICAgICAgICAgdFZlYyA9IGNjLmxvY2FsUGxhbmVOb3JtYWw7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHRNYXQgPSBjYy5ib2R5Qi5tX3hmLlI7XG4gICAgICAgICAgICB0VmVjID0gY2MubG9jYWxQb2ludDtcbiAgICAgICAgICAgIHBsYW5lUG9pbnRYID0gY2MuYm9keUIubV94Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgcGxhbmVQb2ludFkgPSBjYy5ib2R5Qi5tX3hmLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUEubV94Zi5SO1xuICAgICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgICAgIGkgPCBjYy5wb2ludENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgIHRWZWMgPSBjYy5wb2ludHNbaV0ubG9jYWxQb2ludDtcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFggPSBjYy5ib2R5QS5tX3hmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICAgICAgICAgICBjbGlwUG9pbnRZID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgICAgdGhpcy5tX3NlcGFyYXRpb25zW2ldID0gKGNsaXBQb2ludFggLSBwbGFuZVBvaW50WCkgKiB0aGlzLm1fbm9ybWFsLnggKyAoY2xpcFBvaW50WSAtIHBsYW5lUG9pbnRZKSAqIHRoaXMubV9ub3JtYWwueSAtIGNjLnJhZGl1cztcbiAgICAgICAgICAgICAgIHRoaXMubV9wb2ludHNbaV0uU2V0KGNsaXBQb2ludFgsIGNsaXBQb2ludFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ICo9ICgtMSk7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgKj0gKC0xKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQuY2lyY2xlUG9pbnRBID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmNpcmNsZVBvaW50QiA9IG5ldyBiMlZlYzIoKTtcbiAgIH0pO1xufSkoKTtcbihmdW5jdGlvbiAoKSB7XG4gICB2YXIgYjJCb2R5ID0gQm94MkQuRHluYW1pY3MuYjJCb2R5LFxuICAgICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxuICAgICAgYjJDb250YWN0SW1wdWxzZSA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEltcHVsc2UsXG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLFxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXG4gICAgICBiMkRlYnVnRHJhdyA9IEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LFxuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gQm94MkQuRHluYW1pY3MuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLFxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxuICAgICAgYjJGaXh0dXJlID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlLFxuICAgICAgYjJGaXh0dXJlRGVmID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmLFxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcbiAgICAgIGIyVGltZVN0ZXAgPSBCb3gyRC5EeW5hbWljcy5iMlRpbWVTdGVwLFxuICAgICAgYjJXb3JsZCA9IEJveDJELkR5bmFtaWNzLmIyV29ybGQsXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcbiAgICAgIGIyTWF0MzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDMzLFxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXG4gICAgICBiMlRyYW5zZm9ybSA9IEJveDJELkNvbW1vbi5NYXRoLmIyVHJhbnNmb3JtLFxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxuICAgICAgYjJDb2xvciA9IEJveDJELkNvbW1vbi5iMkNvbG9yLFxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxuICAgICAgYjJDaXJjbGVTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJDaXJjbGVTaGFwZSxcbiAgICAgIGIyRWRnZUNoYWluRGVmID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VDaGFpbkRlZixcbiAgICAgIGIyRWRnZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VTaGFwZSxcbiAgICAgIGIyTWFzc0RhdGEgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyTWFzc0RhdGEsXG4gICAgICBiMlBvbHlnb25TaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJQb2x5Z29uU2hhcGUsXG4gICAgICBiMlNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLFxuICAgICAgYjJCdW95YW5jeUNvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkJ1b3lhbmN5Q29udHJvbGxlcixcbiAgICAgIGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnN0YW50QWNjZWxDb250cm9sbGVyLFxuICAgICAgYjJDb25zdGFudEZvcmNlQ29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIsXG4gICAgICBiMkNvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXIsXG4gICAgICBiMkNvbnRyb2xsZXJFZGdlID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyRWRnZSxcbiAgICAgIGIyR3Jhdml0eUNvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkdyYXZpdHlDb250cm9sbGVyLFxuICAgICAgYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXI7XG5cbiAgIEJveDJELmluaGVyaXQoYjJCdW95YW5jeUNvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMkJ1b3lhbmN5Q29udHJvbGxlci5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICBiMkJ1b3lhbmN5Q29udHJvbGxlci5iMkJ1b3lhbmN5Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IGIyVmVjMigwLCAoLTEpKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuZGVuc2l0eSA9IDA7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IGIyVmVjMigwLCAwKTtcbiAgICAgIHRoaXMubGluZWFyRHJhZyA9IDI7XG4gICAgICB0aGlzLmFuZ3VsYXJEcmFnID0gMTtcbiAgICAgIHRoaXMudXNlRGVuc2l0eSA9IGZhbHNlO1xuICAgICAgdGhpcy51c2VXb3JsZEdyYXZpdHkgPSB0cnVlO1xuICAgICAgdGhpcy5ncmF2aXR5ID0gbnVsbDtcbiAgIH07XG4gICBiMkJ1b3lhbmN5Q29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICBpZiAoIXRoaXMubV9ib2R5TGlzdCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMudXNlV29ybGRHcmF2aXR5KSB7XG4gICAgICAgICB0aGlzLmdyYXZpdHkgPSB0aGlzLkdldFdvcmxkKCkuR2V0R3Jhdml0eSgpLkNvcHkoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLm1fYm9keUxpc3Q7IGk7IGkgPSBpLm5leHRCb2R5KSB7XG4gICAgICAgICB2YXIgYm9keSA9IGkuYm9keTtcbiAgICAgICAgIGlmIChib2R5LklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICB9XG4gICAgICAgICB2YXIgYXJlYWMgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICB2YXIgbWFzc2MgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICAgICAgIHZhciBtYXNzID0gMC4wO1xuICAgICAgICAgZm9yICh2YXIgZml4dHVyZSA9IGJvZHkuR2V0Rml4dHVyZUxpc3QoKTsgZml4dHVyZTsgZml4dHVyZSA9IGZpeHR1cmUuR2V0TmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc2MgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICAgICB2YXIgc2FyZWEgPSBmaXh0dXJlLkdldFNoYXBlKCkuQ29tcHV0ZVN1Ym1lcmdlZEFyZWEodGhpcy5ub3JtYWwsIHRoaXMub2Zmc2V0LCBib2R5LkdldFRyYW5zZm9ybSgpLCBzYyk7XG4gICAgICAgICAgICBhcmVhICs9IHNhcmVhO1xuICAgICAgICAgICAgYXJlYWMueCArPSBzYXJlYSAqIHNjLng7XG4gICAgICAgICAgICBhcmVhYy55ICs9IHNhcmVhICogc2MueTtcbiAgICAgICAgICAgIHZhciBzaGFwZURlbnNpdHkgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlRGVuc2l0eSkge1xuICAgICAgICAgICAgICAgc2hhcGVEZW5zaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgc2hhcGVEZW5zaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc3MgKz0gc2FyZWEgKiBzaGFwZURlbnNpdHk7XG4gICAgICAgICAgICBtYXNzYy54ICs9IHNhcmVhICogc2MueCAqIHNoYXBlRGVuc2l0eTtcbiAgICAgICAgICAgIG1hc3NjLnkgKz0gc2FyZWEgKiBzYy55ICogc2hhcGVEZW5zaXR5O1xuICAgICAgICAgfVxuICAgICAgICAgYXJlYWMueCAvPSBhcmVhO1xuICAgICAgICAgYXJlYWMueSAvPSBhcmVhO1xuICAgICAgICAgbWFzc2MueCAvPSBtYXNzO1xuICAgICAgICAgbWFzc2MueSAvPSBtYXNzO1xuICAgICAgICAgaWYgKGFyZWEgPCBOdW1iZXIuTUlOX1ZBTFVFKSBjb250aW51ZTtcbiAgICAgICAgIHZhciBidW95YW5jeUZvcmNlID0gdGhpcy5ncmF2aXR5LkdldE5lZ2F0aXZlKCk7XG4gICAgICAgICBidW95YW5jeUZvcmNlLk11bHRpcGx5KHRoaXMuZGVuc2l0eSAqIGFyZWEpO1xuICAgICAgICAgYm9keS5BcHBseUZvcmNlKGJ1b3lhbmN5Rm9yY2UsIG1hc3NjKTtcbiAgICAgICAgIHZhciBkcmFnRm9yY2UgPSBib2R5LkdldExpbmVhclZlbG9jaXR5RnJvbVdvcmxkUG9pbnQoYXJlYWMpO1xuICAgICAgICAgZHJhZ0ZvcmNlLlN1YnRyYWN0KHRoaXMudmVsb2NpdHkpO1xuICAgICAgICAgZHJhZ0ZvcmNlLk11bHRpcGx5KCgtdGhpcy5saW5lYXJEcmFnICogYXJlYSkpO1xuICAgICAgICAgYm9keS5BcHBseUZvcmNlKGRyYWdGb3JjZSwgYXJlYWMpO1xuICAgICAgICAgYm9keS5BcHBseVRvcnF1ZSgoLWJvZHkuR2V0SW5lcnRpYSgpIC8gYm9keS5HZXRNYXNzKCkgKiBhcmVhICogYm9keS5HZXRBbmd1bGFyVmVsb2NpdHkoKSAqIHRoaXMuYW5ndWxhckRyYWcpKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQnVveWFuY3lDb250cm9sbGVyLnByb3RvdHlwZS5EcmF3ID0gZnVuY3Rpb24gKGRlYnVnRHJhdykge1xuICAgICAgdmFyIHIgPSAxMDAwO1xuICAgICAgdmFyIHAxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdmFyIHAyID0gbmV3IGIyVmVjMigpO1xuICAgICAgcDEueCA9IHRoaXMubm9ybWFsLnggKiB0aGlzLm9mZnNldCArIHRoaXMubm9ybWFsLnkgKiByO1xuICAgICAgcDEueSA9IHRoaXMubm9ybWFsLnkgKiB0aGlzLm9mZnNldCAtIHRoaXMubm9ybWFsLnggKiByO1xuICAgICAgcDIueCA9IHRoaXMubm9ybWFsLnggKiB0aGlzLm9mZnNldCAtIHRoaXMubm9ybWFsLnkgKiByO1xuICAgICAgcDIueSA9IHRoaXMubm9ybWFsLnkgKiB0aGlzLm9mZnNldCArIHRoaXMubm9ybWFsLnggKiByO1xuICAgICAgdmFyIGNvbG9yID0gbmV3IGIyQ29sb3IoMCwgMCwgMSk7XG4gICAgICBkZWJ1Z0RyYXcuRHJhd1NlZ21lbnQocDEsIHAyLCBjb2xvcik7XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMkNvbnN0YW50QWNjZWxDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgIGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIuYjJDb25zdGFudEFjY2VsQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuQSA9IG5ldyBiMlZlYzIoMCwgMCk7XG4gICB9O1xuICAgYjJDb25zdGFudEFjY2VsQ29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgc21hbGxBID0gbmV3IGIyVmVjMih0aGlzLkEueCAqIHN0ZXAuZHQsIHRoaXMuQS55ICogc3RlcC5kdCk7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5tX2JvZHlMaXN0OyBpOyBpID0gaS5uZXh0Qm9keSkge1xuICAgICAgICAgdmFyIGJvZHkgPSBpLmJvZHk7XG4gICAgICAgICBpZiAoIWJvZHkuSXNBd2FrZSgpKSBjb250aW51ZTtcbiAgICAgICAgIGJvZHkuU2V0TGluZWFyVmVsb2NpdHkobmV3IGIyVmVjMihib2R5LkdldExpbmVhclZlbG9jaXR5KCkueCArIHNtYWxsQS54LCBib2R5LkdldExpbmVhclZlbG9jaXR5KCkueSArIHNtYWxsQS55KSk7XG4gICAgICB9XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgIGIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIuYjJDb25zdGFudEZvcmNlQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuRiA9IG5ldyBiMlZlYzIoMCwgMCk7XG4gICB9O1xuICAgYjJDb25zdGFudEZvcmNlQ29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5tX2JvZHlMaXN0OyBpOyBpID0gaS5uZXh0Qm9keSkge1xuICAgICAgICAgdmFyIGJvZHkgPSBpLmJvZHk7XG4gICAgICAgICBpZiAoIWJvZHkuSXNBd2FrZSgpKSBjb250aW51ZTtcbiAgICAgICAgIGJvZHkuQXBwbHlGb3JjZSh0aGlzLkYsIGJvZHkuR2V0V29ybGRDZW50ZXIoKSk7XG4gICAgICB9XG4gICB9XG4gICBiMkNvbnRyb2xsZXIuYjJDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLlN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge31cbiAgIGIyQ29udHJvbGxlci5wcm90b3R5cGUuRHJhdyA9IGZ1bmN0aW9uIChkZWJ1Z0RyYXcpIHt9XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkFkZEJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgdmFyIGVkZ2UgPSBuZXcgYjJDb250cm9sbGVyRWRnZSgpO1xuICAgICAgZWRnZS5jb250cm9sbGVyID0gdGhpcztcbiAgICAgIGVkZ2UuYm9keSA9IGJvZHk7XG4gICAgICBlZGdlLm5leHRCb2R5ID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgZWRnZS5wcmV2Qm9keSA9IG51bGw7XG4gICAgICB0aGlzLm1fYm9keUxpc3QgPSBlZGdlO1xuICAgICAgaWYgKGVkZ2UubmV4dEJvZHkpIGVkZ2UubmV4dEJvZHkucHJldkJvZHkgPSBlZGdlO1xuICAgICAgdGhpcy5tX2JvZHlDb3VudCsrO1xuICAgICAgZWRnZS5uZXh0Q29udHJvbGxlciA9IGJvZHkubV9jb250cm9sbGVyTGlzdDtcbiAgICAgIGVkZ2UucHJldkNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgYm9keS5tX2NvbnRyb2xsZXJMaXN0ID0gZWRnZTtcbiAgICAgIGlmIChlZGdlLm5leHRDb250cm9sbGVyKSBlZGdlLm5leHRDb250cm9sbGVyLnByZXZDb250cm9sbGVyID0gZWRnZTtcbiAgICAgIGJvZHkubV9jb250cm9sbGVyQ291bnQrKztcbiAgIH1cbiAgIGIyQ29udHJvbGxlci5wcm90b3R5cGUuUmVtb3ZlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICB2YXIgZWRnZSA9IGJvZHkubV9jb250cm9sbGVyTGlzdDtcbiAgICAgIHdoaWxlIChlZGdlICYmIGVkZ2UuY29udHJvbGxlciAhPSB0aGlzKVxuICAgICAgZWRnZSA9IGVkZ2UubmV4dENvbnRyb2xsZXI7XG4gICAgICBpZiAoZWRnZS5wcmV2Qm9keSkgZWRnZS5wcmV2Qm9keS5uZXh0Qm9keSA9IGVkZ2UubmV4dEJvZHk7XG4gICAgICBpZiAoZWRnZS5uZXh0Qm9keSkgZWRnZS5uZXh0Qm9keS5wcmV2Qm9keSA9IGVkZ2UucHJldkJvZHk7XG4gICAgICBpZiAoZWRnZS5uZXh0Q29udHJvbGxlcikgZWRnZS5uZXh0Q29udHJvbGxlci5wcmV2Q29udHJvbGxlciA9IGVkZ2UucHJldkNvbnRyb2xsZXI7XG4gICAgICBpZiAoZWRnZS5wcmV2Q29udHJvbGxlcikgZWRnZS5wcmV2Q29udHJvbGxlci5uZXh0Q29udHJvbGxlciA9IGVkZ2UubmV4dENvbnRyb2xsZXI7XG4gICAgICBpZiAodGhpcy5tX2JvZHlMaXN0ID09IGVkZ2UpIHRoaXMubV9ib2R5TGlzdCA9IGVkZ2UubmV4dEJvZHk7XG4gICAgICBpZiAoYm9keS5tX2NvbnRyb2xsZXJMaXN0ID09IGVkZ2UpIGJvZHkubV9jb250cm9sbGVyTGlzdCA9IGVkZ2UubmV4dENvbnRyb2xsZXI7XG4gICAgICBib2R5Lm1fY29udHJvbGxlckNvdW50LS07XG4gICAgICB0aGlzLm1fYm9keUNvdW50LS07XG4gICB9XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRoaXMubV9ib2R5TGlzdClcbiAgICAgIHRoaXMuUmVtb3ZlQm9keSh0aGlzLm1fYm9keUxpc3QuYm9keSk7XG4gICB9XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX25leHQ7XG4gICB9XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkdldFdvcmxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV93b3JsZDtcbiAgIH1cbiAgIGIyQ29udHJvbGxlci5wcm90b3R5cGUuR2V0Qm9keUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlMaXN0O1xuICAgfVxuICAgYjJDb250cm9sbGVyRWRnZS5iMkNvbnRyb2xsZXJFZGdlID0gZnVuY3Rpb24gKCkge307XG4gICBCb3gyRC5pbmhlcml0KGIyR3Jhdml0eUNvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMkdyYXZpdHlDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgIGIyR3Jhdml0eUNvbnRyb2xsZXIuYjJHcmF2aXR5Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuRyA9IDE7XG4gICAgICB0aGlzLmludlNxciA9IHRydWU7XG4gICB9O1xuICAgYjJHcmF2aXR5Q29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgaSA9IG51bGw7XG4gICAgICB2YXIgYm9keTEgPSBudWxsO1xuICAgICAgdmFyIHAxID0gbnVsbDtcbiAgICAgIHZhciBtYXNzMSA9IDA7XG4gICAgICB2YXIgaiA9IG51bGw7XG4gICAgICB2YXIgYm9keTIgPSBudWxsO1xuICAgICAgdmFyIHAyID0gbnVsbDtcbiAgICAgIHZhciBkeCA9IDA7XG4gICAgICB2YXIgZHkgPSAwO1xuICAgICAgdmFyIHIyID0gMDtcbiAgICAgIHZhciBmID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmludlNxcikge1xuICAgICAgICAgZm9yIChpID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgICAgaTsgaSA9IGkubmV4dEJvZHkpIHtcbiAgICAgICAgICAgIGJvZHkxID0gaS5ib2R5O1xuICAgICAgICAgICAgcDEgPSBib2R5MS5HZXRXb3JsZENlbnRlcigpO1xuICAgICAgICAgICAgbWFzczEgPSBib2R5MS5HZXRNYXNzKCk7XG4gICAgICAgICAgICBmb3IgKGogPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICAgICAgICBqICE9IGk7IGogPSBqLm5leHRCb2R5KSB7XG4gICAgICAgICAgICAgICBib2R5MiA9IGouYm9keTtcbiAgICAgICAgICAgICAgIHAyID0gYm9keTIuR2V0V29ybGRDZW50ZXIoKTtcbiAgICAgICAgICAgICAgIGR4ID0gcDIueCAtIHAxLng7XG4gICAgICAgICAgICAgICBkeSA9IHAyLnkgLSBwMS55O1xuICAgICAgICAgICAgICAgcjIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgICAgIGlmIChyMiA8IE51bWJlci5NSU5fVkFMVUUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgZiA9IG5ldyBiMlZlYzIoZHgsIGR5KTtcbiAgICAgICAgICAgICAgIGYuTXVsdGlwbHkodGhpcy5HIC8gcjIgLyBNYXRoLnNxcnQocjIpICogbWFzczEgKiBib2R5Mi5HZXRNYXNzKCkpO1xuICAgICAgICAgICAgICAgaWYgKGJvZHkxLklzQXdha2UoKSkgYm9keTEuQXBwbHlGb3JjZShmLCBwMSk7XG4gICAgICAgICAgICAgICBmLk11bHRpcGx5KCgtMSkpO1xuICAgICAgICAgICAgICAgaWYgKGJvZHkyLklzQXdha2UoKSkgYm9keTIuQXBwbHlGb3JjZShmLCBwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIGZvciAoaSA9IHRoaXMubV9ib2R5TGlzdDtcbiAgICAgICAgIGk7IGkgPSBpLm5leHRCb2R5KSB7XG4gICAgICAgICAgICBib2R5MSA9IGkuYm9keTtcbiAgICAgICAgICAgIHAxID0gYm9keTEuR2V0V29ybGRDZW50ZXIoKTtcbiAgICAgICAgICAgIG1hc3MxID0gYm9keTEuR2V0TWFzcygpO1xuICAgICAgICAgICAgZm9yIChqID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgICAgICAgaiAhPSBpOyBqID0gai5uZXh0Qm9keSkge1xuICAgICAgICAgICAgICAgYm9keTIgPSBqLmJvZHk7XG4gICAgICAgICAgICAgICBwMiA9IGJvZHkyLkdldFdvcmxkQ2VudGVyKCk7XG4gICAgICAgICAgICAgICBkeCA9IHAyLnggLSBwMS54O1xuICAgICAgICAgICAgICAgZHkgPSBwMi55IC0gcDEueTtcbiAgICAgICAgICAgICAgIHIyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgICAgICAgICBpZiAocjIgPCBOdW1iZXIuTUlOX1ZBTFVFKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgIGYgPSBuZXcgYjJWZWMyKGR4LCBkeSk7XG4gICAgICAgICAgICAgICBmLk11bHRpcGx5KHRoaXMuRyAvIHIyICogbWFzczEgKiBib2R5Mi5HZXRNYXNzKCkpO1xuICAgICAgICAgICAgICAgaWYgKGJvZHkxLklzQXdha2UoKSkgYm9keTEuQXBwbHlGb3JjZShmLCBwMSk7XG4gICAgICAgICAgICAgICBmLk11bHRpcGx5KCgtMSkpO1xuICAgICAgICAgICAgICAgaWYgKGJvZHkyLklzQXdha2UoKSkgYm9keTIuQXBwbHlGb3JjZShmLCBwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMlRlbnNvckRhbXBpbmdDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgIGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIuYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuVCA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1heFRpbWVzdGVwID0gMDtcbiAgIH07XG4gICBiMlRlbnNvckRhbXBpbmdDb250cm9sbGVyLnByb3RvdHlwZS5TZXRBeGlzQWxpZ25lZCA9IGZ1bmN0aW9uICh4RGFtcGluZywgeURhbXBpbmcpIHtcbiAgICAgIGlmICh4RGFtcGluZyA9PT0gdW5kZWZpbmVkKSB4RGFtcGluZyA9IDA7XG4gICAgICBpZiAoeURhbXBpbmcgPT09IHVuZGVmaW5lZCkgeURhbXBpbmcgPSAwO1xuICAgICAgdGhpcy5ULmNvbDEueCA9ICgteERhbXBpbmcpO1xuICAgICAgdGhpcy5ULmNvbDEueSA9IDA7XG4gICAgICB0aGlzLlQuY29sMi54ID0gMDtcbiAgICAgIHRoaXMuVC5jb2wyLnkgPSAoLXlEYW1waW5nKTtcbiAgICAgIGlmICh4RGFtcGluZyA+IDAgfHwgeURhbXBpbmcgPiAwKSB7XG4gICAgICAgICB0aGlzLm1heFRpbWVzdGVwID0gMSAvIE1hdGgubWF4KHhEYW1waW5nLCB5RGFtcGluZyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubWF4VGltZXN0ZXAgPSAwO1xuICAgICAgfVxuICAgfVxuICAgYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgdGltZXN0ZXAgPSBzdGVwLmR0O1xuICAgICAgaWYgKHRpbWVzdGVwIDw9IE51bWJlci5NSU5fVkFMVUUpIHJldHVybjtcbiAgICAgIGlmICh0aW1lc3RlcCA+IHRoaXMubWF4VGltZXN0ZXAgJiYgdGhpcy5tYXhUaW1lc3RlcCA+IDApIHRpbWVzdGVwID0gdGhpcy5tYXhUaW1lc3RlcDtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLm1fYm9keUxpc3Q7IGk7IGkgPSBpLm5leHRCb2R5KSB7XG4gICAgICAgICB2YXIgYm9keSA9IGkuYm9keTtcbiAgICAgICAgIGlmICghYm9keS5Jc0F3YWtlKCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGRhbXBpbmcgPSBib2R5LkdldFdvcmxkVmVjdG9yKGIyTWF0aC5NdWxNVih0aGlzLlQsIGJvZHkuR2V0TG9jYWxWZWN0b3IoYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpKSkpO1xuICAgICAgICAgYm9keS5TZXRMaW5lYXJWZWxvY2l0eShuZXcgYjJWZWMyKGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKS54ICsgZGFtcGluZy54ICogdGltZXN0ZXAsIGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKS55ICsgZGFtcGluZy55ICogdGltZXN0ZXApKTtcbiAgICAgIH1cbiAgIH1cbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcbiAgICAgIGIyU2V0dGluZ3MgPSBCb3gyRC5Db21tb24uYjJTZXR0aW5ncyxcbiAgICAgIGIyTWF0MjIgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDIyLFxuICAgICAgYjJNYXQzMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MzMsXG4gICAgICBiMk1hdGggPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGgsXG4gICAgICBiMlN3ZWVwID0gQm94MkQuQ29tbW9uLk1hdGguYjJTd2VlcCxcbiAgICAgIGIyVHJhbnNmb3JtID0gQm94MkQuQ29tbW9uLk1hdGguYjJUcmFuc2Zvcm0sXG4gICAgICBiMlZlYzIgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzIsXG4gICAgICBiMlZlYzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzMsXG4gICAgICBiMkRpc3RhbmNlSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50LFxuICAgICAgYjJEaXN0YW5jZUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyRGlzdGFuY2VKb2ludERlZixcbiAgICAgIGIyRnJpY3Rpb25Kb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkZyaWN0aW9uSm9pbnQsXG4gICAgICBiMkZyaWN0aW9uSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJGcmljdGlvbkpvaW50RGVmLFxuICAgICAgYjJHZWFySm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJHZWFySm9pbnQsXG4gICAgICBiMkdlYXJKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkdlYXJKb2ludERlZixcbiAgICAgIGIySmFjb2JpYW4gPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKYWNvYmlhbixcbiAgICAgIGIySm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCxcbiAgICAgIGIySm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZixcbiAgICAgIGIySm9pbnRFZGdlID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnRFZGdlLFxuICAgICAgYjJMaW5lSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJMaW5lSm9pbnQsXG4gICAgICBiMkxpbmVKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkxpbmVKb2ludERlZixcbiAgICAgIGIyTW91c2VKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMk1vdXNlSm9pbnQsXG4gICAgICBiMk1vdXNlSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJNb3VzZUpvaW50RGVmLFxuICAgICAgYjJQcmlzbWF0aWNKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlByaXNtYXRpY0pvaW50LFxuICAgICAgYjJQcmlzbWF0aWNKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlByaXNtYXRpY0pvaW50RGVmLFxuICAgICAgYjJQdWxsZXlKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlB1bGxleUpvaW50LFxuICAgICAgYjJQdWxsZXlKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlB1bGxleUpvaW50RGVmLFxuICAgICAgYjJSZXZvbHV0ZUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludCxcbiAgICAgIGIyUmV2b2x1dGVKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlJldm9sdXRlSm9pbnREZWYsXG4gICAgICBiMldlbGRKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMldlbGRKb2ludCxcbiAgICAgIGIyV2VsZEpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyV2VsZEpvaW50RGVmLFxuICAgICAgYjJCb2R5ID0gQm94MkQuRHluYW1pY3MuYjJCb2R5LFxuICAgICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxuICAgICAgYjJDb250YWN0SW1wdWxzZSA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEltcHVsc2UsXG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLFxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXG4gICAgICBiMkRlYnVnRHJhdyA9IEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LFxuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gQm94MkQuRHluYW1pY3MuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLFxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxuICAgICAgYjJGaXh0dXJlID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlLFxuICAgICAgYjJGaXh0dXJlRGVmID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmLFxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcbiAgICAgIGIyVGltZVN0ZXAgPSBCb3gyRC5EeW5hbWljcy5iMlRpbWVTdGVwLFxuICAgICAgYjJXb3JsZCA9IEJveDJELkR5bmFtaWNzLmIyV29ybGQ7XG5cbiAgIEJveDJELmluaGVyaXQoYjJEaXN0YW5jZUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMkRpc3RhbmNlSm9pbnQuYjJEaXN0YW5jZUpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fdSA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMik7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV91LngsIGludl9kdCAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3UueSk7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIDAuMDtcbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuR2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGg7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLlNldExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgbGVuZ3RoID0gMDtcbiAgICAgIHRoaXMubV9sZW5ndGggPSBsZW5ndGg7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLlNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChoeikge1xuICAgICAgaWYgKGh6ID09PSB1bmRlZmluZWQpIGh6ID0gMDtcbiAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xuICAgfVxuICAgYjJEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5HZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuU2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICBpZiAocmF0aW8gPT09IHVuZGVmaW5lZCkgcmF0aW8gPSAwO1xuICAgICAgdGhpcy5tX2RhbXBpbmdSYXRpbyA9IHJhdGlvO1xuICAgfVxuICAgYjJEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5iMkRpc3RhbmNlSm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgdFkgPSAwO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMS5TZXRWKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMi5TZXRWKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgdGhpcy5tX2xlbmd0aCA9IGRlZi5sZW5ndGg7XG4gICAgICB0aGlzLm1fZnJlcXVlbmN5SHogPSBkZWYuZnJlcXVlbmN5SHo7XG4gICAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gZGVmLmRhbXBpbmdSYXRpbztcbiAgICAgIHRoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgdGhpcy5tX2dhbW1hID0gMC4wO1xuICAgICAgdGhpcy5tX2JpYXMgPSAwLjA7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xuICAgICAgcjFYID0gdFg7XG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgIHIyWCA9IHRYO1xuICAgICAgdGhpcy5tX3UueCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XG4gICAgICB0aGlzLm1fdS55ID0gYkIubV9zd2VlcC5jLnkgKyByMlkgLSBiQS5tX3N3ZWVwLmMueSAtIHIxWTtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodGhpcy5tX3UueCAqIHRoaXMubV91LnggKyB0aGlzLm1fdS55ICogdGhpcy5tX3UueSk7XG4gICAgICBpZiAobGVuZ3RoID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XG4gICAgICAgICB0aGlzLm1fdS5NdWx0aXBseSgxLjAgLyBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fdS5TZXRaZXJvKCk7XG4gICAgICB9XG4gICAgICB2YXIgY3IxdSA9IChyMVggKiB0aGlzLm1fdS55IC0gcjFZICogdGhpcy5tX3UueCk7XG4gICAgICB2YXIgY3IydSA9IChyMlggKiB0aGlzLm1fdS55IC0gcjJZICogdGhpcy5tX3UueCk7XG4gICAgICB2YXIgaW52TWFzcyA9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNyMXUgKiBjcjF1ICsgYkIubV9pbnZNYXNzICsgYkIubV9pbnZJICogY3IydSAqIGNyMnU7XG4gICAgICB0aGlzLm1fbWFzcyA9IGludk1hc3MgIT0gMC4wID8gMS4wIC8gaW52TWFzcyA6IDAuMDtcbiAgICAgIGlmICh0aGlzLm1fZnJlcXVlbmN5SHogPiAwLjApIHtcbiAgICAgICAgIHZhciBDID0gbGVuZ3RoIC0gdGhpcy5tX2xlbmd0aDtcbiAgICAgICAgIHZhciBvbWVnYSA9IDIuMCAqIE1hdGguUEkgKiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgICB2YXIgZCA9IDIuMCAqIHRoaXMubV9tYXNzICogdGhpcy5tX2RhbXBpbmdSYXRpbyAqIG9tZWdhO1xuICAgICAgICAgdmFyIGsgPSB0aGlzLm1fbWFzcyAqIG9tZWdhICogb21lZ2E7XG4gICAgICAgICB0aGlzLm1fZ2FtbWEgPSBzdGVwLmR0ICogKGQgKyBzdGVwLmR0ICogayk7XG4gICAgICAgICB0aGlzLm1fZ2FtbWEgPSB0aGlzLm1fZ2FtbWEgIT0gMC4wID8gMSAvIHRoaXMubV9nYW1tYSA6IDAuMDtcbiAgICAgICAgIHRoaXMubV9iaWFzID0gQyAqIHN0ZXAuZHQgKiBrICogdGhpcy5tX2dhbW1hO1xuICAgICAgICAgdGhpcy5tX21hc3MgPSBpbnZNYXNzICsgdGhpcy5tX2dhbW1hO1xuICAgICAgICAgdGhpcy5tX21hc3MgPSB0aGlzLm1fbWFzcyAhPSAwLjAgPyAxLjAgLyB0aGlzLm1fbWFzcyA6IDAuMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fdS54O1xuICAgICAgICAgdmFyIFBZID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fdS55O1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54IC09IGJBLm1faW52TWFzcyAqIFBYO1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55IC09IGJBLm1faW52TWFzcyAqIFBZO1xuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgLT0gYkEubV9pbnZJICogKHIxWCAqIFBZIC0gcjFZICogUFgpO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS54ICs9IGJCLm1faW52TWFzcyAqIFBYO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IGJCLm1faW52TWFzcyAqIFBZO1xuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogKHIyWCAqIFBZIC0gcjJZICogUFgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdmFyIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xuICAgICAgcjFYID0gdFg7XG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgIHIyWCA9IHRYO1xuICAgICAgdmFyIHYxWCA9IGJBLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFZKSk7XG4gICAgICB2YXIgdjFZID0gYkEubV9saW5lYXJWZWxvY2l0eS55ICsgKGJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFYKTtcbiAgICAgIHZhciB2MlggPSBiQi5tX2xpbmVhclZlbG9jaXR5LnggKyAoKC1iQi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIyWSkpO1xuICAgICAgdmFyIHYyWSA9IGJCLm1fbGluZWFyVmVsb2NpdHkueSArIChiQi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIyWCk7XG4gICAgICB2YXIgQ2RvdCA9ICh0aGlzLm1fdS54ICogKHYyWCAtIHYxWCkgKyB0aGlzLm1fdS55ICogKHYyWSAtIHYxWSkpO1xuICAgICAgdmFyIGltcHVsc2UgPSAoLXRoaXMubV9tYXNzICogKENkb3QgKyB0aGlzLm1fYmlhcyArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlKSk7XG4gICAgICB0aGlzLm1faW1wdWxzZSArPSBpbXB1bHNlO1xuICAgICAgdmFyIFBYID0gaW1wdWxzZSAqIHRoaXMubV91Lng7XG4gICAgICB2YXIgUFkgPSBpbXB1bHNlICogdGhpcy5tX3UueTtcbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCAtPSBiQS5tX2ludk1hc3MgKiBQWDtcbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSAtPSBiQS5tX2ludk1hc3MgKiBQWTtcbiAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5IC09IGJBLm1faW52SSAqIChyMVggKiBQWSAtIHIxWSAqIFBYKTtcbiAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBQWDtcbiAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQi5tX2ludk1hc3MgKiBQWTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJCLm1faW52SSAqIChyMlggKiBQWSAtIHIyWSAqIFBYKTtcbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHZhciB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICByMlggPSB0WDtcbiAgICAgIHZhciBkWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XG4gICAgICB2YXIgZFkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWSAtIGJBLm1fc3dlZXAuYy55IC0gcjFZO1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG4gICAgICBkWCAvPSBsZW5ndGg7XG4gICAgICBkWSAvPSBsZW5ndGg7XG4gICAgICB2YXIgQyA9IGxlbmd0aCAtIHRoaXMubV9sZW5ndGg7XG4gICAgICBDID0gYjJNYXRoLkNsYW1wKEMsICgtYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKSwgYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgIHZhciBpbXB1bHNlID0gKC10aGlzLm1fbWFzcyAqIEMpO1xuICAgICAgdGhpcy5tX3UuU2V0KGRYLCBkWSk7XG4gICAgICB2YXIgUFggPSBpbXB1bHNlICogdGhpcy5tX3UueDtcbiAgICAgIHZhciBQWSA9IGltcHVsc2UgKiB0aGlzLm1fdS55O1xuICAgICAgYkEubV9zd2VlcC5jLnggLT0gYkEubV9pbnZNYXNzICogUFg7XG4gICAgICBiQS5tX3N3ZWVwLmMueSAtPSBiQS5tX2ludk1hc3MgKiBQWTtcbiAgICAgIGJBLm1fc3dlZXAuYSAtPSBiQS5tX2ludkkgKiAocjFYICogUFkgLSByMVkgKiBQWCk7XG4gICAgICBiQi5tX3N3ZWVwLmMueCArPSBiQi5tX2ludk1hc3MgKiBQWDtcbiAgICAgIGJCLm1fc3dlZXAuYy55ICs9IGJCLm1faW52TWFzcyAqIFBZO1xuICAgICAgYkIubV9zd2VlcC5hICs9IGJCLm1faW52SSAqIChyMlggKiBQWSAtIHIyWSAqIFBYKTtcbiAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuIGIyTWF0aC5BYnMoQykgPCBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyRGlzdGFuY2VKb2ludERlZiwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYpO1xuICAgYjJEaXN0YW5jZUpvaW50RGVmLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYucHJvdG90eXBlO1xuICAgYjJEaXN0YW5jZUpvaW50RGVmLmIyRGlzdGFuY2VKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJEaXN0YW5jZUpvaW50RGVmLnByb3RvdHlwZS5iMkRpc3RhbmNlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQ7XG4gICAgICB0aGlzLmxlbmd0aCA9IDEuMDtcbiAgICAgIHRoaXMuZnJlcXVlbmN5SHogPSAwLjA7XG4gICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IDAuMDtcbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludERlZi5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChiQSwgYkIsIGFuY2hvckEsIGFuY2hvckIpIHtcbiAgICAgIHRoaXMuYm9keUEgPSBiQTtcbiAgICAgIHRoaXMuYm9keUIgPSBiQjtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBLlNldFYodGhpcy5ib2R5QS5HZXRMb2NhbFBvaW50KGFuY2hvckEpKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldFYodGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvckIpKTtcbiAgICAgIHZhciBkWCA9IGFuY2hvckIueCAtIGFuY2hvckEueDtcbiAgICAgIHZhciBkWSA9IGFuY2hvckIueSAtIGFuY2hvckEueTtcbiAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcbiAgICAgIHRoaXMuZnJlcXVlbmN5SHogPSAwLjA7XG4gICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IDAuMDtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJGcmljdGlvbkpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMkZyaWN0aW9uSm9pbnQuYjJGcmljdGlvbkpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbGluZWFyTWFzcyA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1fbGluZWFySW1wdWxzZSA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1fbGluZWFySW1wdWxzZS54LCBpbnZfZHQgKiB0aGlzLm1fbGluZWFySW1wdWxzZS55KTtcbiAgIH1cbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xuICAgfVxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5TZXRNYXhGb3JjZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgaWYgKGZvcmNlID09PSB1bmRlZmluZWQpIGZvcmNlID0gMDtcbiAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGZvcmNlO1xuICAgfVxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5HZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLlNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcbiAgICAgIGlmICh0b3JxdWUgPT09IHVuZGVmaW5lZCkgdG9ycXVlID0gMDtcbiAgICAgIHRoaXMubV9tYXhUb3JxdWUgPSB0b3JxdWU7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbWF4VG9ycXVlO1xuICAgfVxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5iMkZyaWN0aW9uSm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JCLlNldFYoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICB0aGlzLm1fbGluZWFyTWFzcy5TZXRaZXJvKCk7XG4gICAgICB0aGlzLm1fYW5ndWxhck1hc3MgPSAwLjA7XG4gICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5TZXRaZXJvKCk7XG4gICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1fbWF4Rm9yY2UgPSBkZWYubWF4Rm9yY2U7XG4gICAgICB0aGlzLm1fbWF4VG9ycXVlID0gZGVmLm1heFRvcnF1ZTtcbiAgIH1cbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgckFZID0gdGhpcy5tX2xvY2FsQW5jaG9yQS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQVggKyB0TWF0LmNvbDIueCAqIHJBWSk7XG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XG4gICAgICByQVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHJCWSA9IHRoaXMubV9sb2NhbEFuY2hvckIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckJYICsgdE1hdC5jb2wyLnggKiByQlkpO1xuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xuICAgICAgckJYID0gdFg7XG4gICAgICB2YXIgbUEgPSBiQS5tX2ludk1hc3M7XG4gICAgICB2YXIgbUIgPSBiQi5tX2ludk1hc3M7XG4gICAgICB2YXIgaUEgPSBiQS5tX2ludkk7XG4gICAgICB2YXIgaUIgPSBiQi5tX2ludkk7XG4gICAgICB2YXIgSyA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICBLLmNvbDEueCA9IG1BICsgbUI7XG4gICAgICBLLmNvbDIueCA9IDAuMDtcbiAgICAgIEsuY29sMS55ID0gMC4wO1xuICAgICAgSy5jb2wyLnkgPSBtQSArIG1CO1xuICAgICAgSy5jb2wxLnggKz0gaUEgKiByQVkgKiByQVk7XG4gICAgICBLLmNvbDIueCArPSAoLWlBICogckFYICogckFZKTtcbiAgICAgIEsuY29sMS55ICs9ICgtaUEgKiByQVggKiByQVkpO1xuICAgICAgSy5jb2wyLnkgKz0gaUEgKiByQVggKiByQVg7XG4gICAgICBLLmNvbDEueCArPSBpQiAqIHJCWSAqIHJCWTtcbiAgICAgIEsuY29sMi54ICs9ICgtaUIgKiByQlggKiByQlkpO1xuICAgICAgSy5jb2wxLnkgKz0gKC1pQiAqIHJCWCAqIHJCWSk7XG4gICAgICBLLmNvbDIueSArPSBpQiAqIHJCWCAqIHJCWDtcbiAgICAgIEsuR2V0SW52ZXJzZSh0aGlzLm1fbGluZWFyTWFzcyk7XG4gICAgICB0aGlzLm1fYW5ndWxhck1hc3MgPSBpQSArIGlCO1xuICAgICAgaWYgKHRoaXMubV9hbmd1bGFyTWFzcyA+IDAuMCkge1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJNYXNzID0gMS4wIC8gdGhpcy5tX2FuZ3VsYXJNYXNzO1xuICAgICAgfVxuICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS54ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLnkgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHZhciBQID0gdGhpcy5tX2xpbmVhckltcHVsc2U7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggLT0gbUEgKiBQLng7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gbUEgKiBQLnk7XG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSAtPSBpQSAqIChyQVggKiBQLnkgLSByQVkgKiBQLnggKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS54ICs9IG1CICogUC54O1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IG1CICogUC55O1xuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gaUIgKiAockJYICogUC55IC0gckJZICogUC54ICsgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UuU2V0WmVybygpO1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMC4wO1xuICAgICAgfVxuICAgfVxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHZBID0gYkEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3QSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIHZCID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3QiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xuICAgICAgdmFyIG1CID0gYkIubV9pbnZNYXNzO1xuICAgICAgdmFyIGlBID0gYkEubV9pbnZJO1xuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgckFZID0gdGhpcy5tX2xvY2FsQW5jaG9yQS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQVggKyB0TWF0LmNvbDIueCAqIHJBWSk7XG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XG4gICAgICByQVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHJCWSA9IHRoaXMubV9sb2NhbEFuY2hvckIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckJYICsgdE1hdC5jb2wyLnggKiByQlkpO1xuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xuICAgICAgckJYID0gdFg7XG4gICAgICB2YXIgbWF4SW1wdWxzZSA9IDA7IHtcbiAgICAgICAgIHZhciBDZG90ID0gd0IgLSB3QTtcbiAgICAgICAgIHZhciBpbXB1bHNlID0gKC10aGlzLm1fYW5ndWxhck1hc3MgKiBDZG90KTtcbiAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xuICAgICAgICAgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4VG9ycXVlO1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gYjJNYXRoLkNsYW1wKHRoaXMubV9hbmd1bGFySW1wdWxzZSArIGltcHVsc2UsICgtbWF4SW1wdWxzZSksIG1heEltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9hbmd1bGFySW1wdWxzZSAtIG9sZEltcHVsc2U7XG4gICAgICAgICB3QSAtPSBpQSAqIGltcHVsc2U7XG4gICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XG4gICAgICB9IHtcbiAgICAgICAgIHZhciBDZG90WCA9IHZCLnggLSB3QiAqIHJCWSAtIHZBLnggKyB3QSAqIHJBWTtcbiAgICAgICAgIHZhciBDZG90WSA9IHZCLnkgKyB3QiAqIHJCWCAtIHZBLnkgLSB3QSAqIHJBWDtcbiAgICAgICAgIHZhciBpbXB1bHNlViA9IGIyTWF0aC5NdWxNVih0aGlzLm1fbGluZWFyTWFzcywgbmV3IGIyVmVjMigoLUNkb3RYKSwgKC1DZG90WSkpKTtcbiAgICAgICAgIHZhciBvbGRJbXB1bHNlViA9IHRoaXMubV9saW5lYXJJbXB1bHNlLkNvcHkoKTtcbiAgICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLkFkZChpbXB1bHNlVik7XG4gICAgICAgICBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhGb3JjZTtcbiAgICAgICAgIGlmICh0aGlzLm1fbGluZWFySW1wdWxzZS5MZW5ndGhTcXVhcmVkKCkgPiBtYXhJbXB1bHNlICogbWF4SW1wdWxzZSkge1xuICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UuTm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5NdWx0aXBseShtYXhJbXB1bHNlKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGltcHVsc2VWID0gYjJNYXRoLlN1YnRyYWN0VlYodGhpcy5tX2xpbmVhckltcHVsc2UsIG9sZEltcHVsc2VWKTtcbiAgICAgICAgIHZBLnggLT0gbUEgKiBpbXB1bHNlVi54O1xuICAgICAgICAgdkEueSAtPSBtQSAqIGltcHVsc2VWLnk7XG4gICAgICAgICB3QSAtPSBpQSAqIChyQVggKiBpbXB1bHNlVi55IC0gckFZICogaW1wdWxzZVYueCk7XG4gICAgICAgICB2Qi54ICs9IG1CICogaW1wdWxzZVYueDtcbiAgICAgICAgIHZCLnkgKz0gbUIgKiBpbXB1bHNlVi55O1xuICAgICAgICAgd0IgKz0gaUIgKiAockJYICogaW1wdWxzZVYueSAtIHJCWSAqIGltcHVsc2VWLngpO1xuICAgICAgfVxuICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgPSB3QTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ID0gd0I7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChiYXVtZ2FydGUpIHtcbiAgICAgIGlmIChiYXVtZ2FydGUgPT09IHVuZGVmaW5lZCkgYmF1bWdhcnRlID0gMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMkZyaWN0aW9uSm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyRnJpY3Rpb25Kb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcbiAgIGIyRnJpY3Rpb25Kb2ludERlZi5iMkZyaWN0aW9uSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyRnJpY3Rpb25Kb2ludERlZi5wcm90b3R5cGUuYjJGcmljdGlvbkpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudHlwZSA9IGIySm9pbnQuZV9mcmljdGlvbkpvaW50O1xuICAgICAgdGhpcy5tYXhGb3JjZSA9IDAuMDtcbiAgICAgIHRoaXMubWF4VG9ycXVlID0gMC4wO1xuICAgfVxuICAgYjJGcmljdGlvbkpvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgYW5jaG9yKSB7XG4gICAgICB0aGlzLmJvZHlBID0gYkE7XG4gICAgICB0aGlzLmJvZHlCID0gYkI7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQS5TZXRWKHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3IpKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldFYodGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcikpO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMkdlYXJKb2ludCwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQpO1xuICAgYjJHZWFySm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMkdlYXJKb2ludC5iMkdlYXJKb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9KID0gbmV3IGIySmFjb2JpYW4oKTtcbiAgIH07XG4gICBiMkdlYXJKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IxKTtcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xuICAgfVxuICAgYjJHZWFySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLnkpO1xuICAgfVxuICAgYjJHZWFySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgdmFyIHRNYXQgPSB0aGlzLm1fYm9keUIubV94Zi5SO1xuICAgICAgdmFyIHJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB2YXIgdFggPSB0TWF0LmNvbDEueCAqIHJYICsgdE1hdC5jb2wyLnggKiByWTtcbiAgICAgIHJZID0gdE1hdC5jb2wxLnkgKiByWCArIHRNYXQuY29sMi55ICogclk7XG4gICAgICByWCA9IHRYO1xuICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLng7XG4gICAgICB2YXIgUFkgPSB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueTtcbiAgICAgIHJldHVybiBpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5hbmd1bGFyQiAtIHJYICogUFkgKyByWSAqIFBYKTtcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5HZXRSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fcmF0aW87XG4gICB9XG4gICBiMkdlYXJKb2ludC5wcm90b3R5cGUuU2V0UmF0aW8gPSBmdW5jdGlvbiAocmF0aW8pIHtcbiAgICAgIGlmIChyYXRpbyA9PT0gdW5kZWZpbmVkKSByYXRpbyA9IDA7XG4gICAgICB0aGlzLm1fcmF0aW8gPSByYXRpbztcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5iMkdlYXJKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50LmNhbGwodGhpcywgZGVmKTtcbiAgICAgIHZhciB0eXBlMSA9IHBhcnNlSW50KGRlZi5qb2ludDEubV90eXBlKTtcbiAgICAgIHZhciB0eXBlMiA9IHBhcnNlSW50KGRlZi5qb2ludDIubV90eXBlKTtcbiAgICAgIHRoaXMubV9yZXZvbHV0ZTEgPSBudWxsO1xuICAgICAgdGhpcy5tX3ByaXNtYXRpYzEgPSBudWxsO1xuICAgICAgdGhpcy5tX3Jldm9sdXRlMiA9IG51bGw7XG4gICAgICB0aGlzLm1fcHJpc21hdGljMiA9IG51bGw7XG4gICAgICB2YXIgY29vcmRpbmF0ZTEgPSAwO1xuICAgICAgdmFyIGNvb3JkaW5hdGUyID0gMDtcbiAgICAgIHRoaXMubV9ncm91bmQxID0gZGVmLmpvaW50MS5HZXRCb2R5QSgpO1xuICAgICAgdGhpcy5tX2JvZHlBID0gZGVmLmpvaW50MS5HZXRCb2R5QigpO1xuICAgICAgaWYgKHR5cGUxID09IGIySm9pbnQuZV9yZXZvbHV0ZUpvaW50KSB7XG4gICAgICAgICB0aGlzLm1fcmV2b2x1dGUxID0gKGRlZi5qb2ludDEgaW5zdGFuY2VvZiBiMlJldm9sdXRlSm9pbnQgPyBkZWYuam9pbnQxIDogbnVsbCk7XG4gICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMS5TZXRWKHRoaXMubV9yZXZvbHV0ZTEubV9sb2NhbEFuY2hvcjEpO1xuICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMS5TZXRWKHRoaXMubV9yZXZvbHV0ZTEubV9sb2NhbEFuY2hvcjIpO1xuICAgICAgICAgY29vcmRpbmF0ZTEgPSB0aGlzLm1fcmV2b2x1dGUxLkdldEpvaW50QW5nbGUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3ByaXNtYXRpYzEgPSAoZGVmLmpvaW50MSBpbnN0YW5jZW9mIGIyUHJpc21hdGljSm9pbnQgPyBkZWYuam9pbnQxIDogbnVsbCk7XG4gICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMS5TZXRWKHRoaXMubV9wcmlzbWF0aWMxLm1fbG9jYWxBbmNob3IxKTtcbiAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEuU2V0Vih0aGlzLm1fcHJpc21hdGljMS5tX2xvY2FsQW5jaG9yMik7XG4gICAgICAgICBjb29yZGluYXRlMSA9IHRoaXMubV9wcmlzbWF0aWMxLkdldEpvaW50VHJhbnNsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9ncm91bmQyID0gZGVmLmpvaW50Mi5HZXRCb2R5QSgpO1xuICAgICAgdGhpcy5tX2JvZHlCID0gZGVmLmpvaW50Mi5HZXRCb2R5QigpO1xuICAgICAgaWYgKHR5cGUyID09IGIySm9pbnQuZV9yZXZvbHV0ZUpvaW50KSB7XG4gICAgICAgICB0aGlzLm1fcmV2b2x1dGUyID0gKGRlZi5qb2ludDIgaW5zdGFuY2VvZiBiMlJldm9sdXRlSm9pbnQgPyBkZWYuam9pbnQyIDogbnVsbCk7XG4gICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMi5TZXRWKHRoaXMubV9yZXZvbHV0ZTIubV9sb2NhbEFuY2hvcjEpO1xuICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMi5TZXRWKHRoaXMubV9yZXZvbHV0ZTIubV9sb2NhbEFuY2hvcjIpO1xuICAgICAgICAgY29vcmRpbmF0ZTIgPSB0aGlzLm1fcmV2b2x1dGUyLkdldEpvaW50QW5nbGUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3ByaXNtYXRpYzIgPSAoZGVmLmpvaW50MiBpbnN0YW5jZW9mIGIyUHJpc21hdGljSm9pbnQgPyBkZWYuam9pbnQyIDogbnVsbCk7XG4gICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMi5TZXRWKHRoaXMubV9wcmlzbWF0aWMyLm1fbG9jYWxBbmNob3IxKTtcbiAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIuU2V0Vih0aGlzLm1fcHJpc21hdGljMi5tX2xvY2FsQW5jaG9yMik7XG4gICAgICAgICBjb29yZGluYXRlMiA9IHRoaXMubV9wcmlzbWF0aWMyLkdldEpvaW50VHJhbnNsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9yYXRpbyA9IGRlZi5yYXRpbztcbiAgICAgIHRoaXMubV9jb25zdGFudCA9IGNvb3JkaW5hdGUxICsgdGhpcy5tX3JhdGlvICogY29vcmRpbmF0ZTI7XG4gICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgZzEgPSB0aGlzLm1fZ3JvdW5kMTtcbiAgICAgIHZhciBnMiA9IHRoaXMubV9ncm91bmQyO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHVnWCA9IDA7XG4gICAgICB2YXIgdWdZID0gMDtcbiAgICAgIHZhciByWCA9IDA7XG4gICAgICB2YXIgclkgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFZlYztcbiAgICAgIHZhciBjcnVnID0gMDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgSyA9IDAuMDtcbiAgICAgIHRoaXMubV9KLlNldFplcm8oKTtcbiAgICAgIGlmICh0aGlzLm1fcmV2b2x1dGUxKSB7XG4gICAgICAgICB0aGlzLm1fSi5hbmd1bGFyQSA9ICgtMS4wKTtcbiAgICAgICAgIEsgKz0gYkEubV9pbnZJO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0TWF0ID0gZzEubV94Zi5SO1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9wcmlzbWF0aWMxLm1fbG9jYWxYQXhpczE7XG4gICAgICAgICB1Z1ggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgdWdZID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICAgICByWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgICAgIHJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSB0TWF0LmNvbDEueCAqIHJYICsgdE1hdC5jb2wyLnggKiByWTtcbiAgICAgICAgIHJZID0gdE1hdC5jb2wxLnkgKiByWCArIHRNYXQuY29sMi55ICogclk7XG4gICAgICAgICByWCA9IHRYO1xuICAgICAgICAgY3J1ZyA9IHJYICogdWdZIC0gclkgKiB1Z1g7XG4gICAgICAgICB0aGlzLm1fSi5saW5lYXJBLlNldCgoLXVnWCksICgtdWdZKSk7XG4gICAgICAgICB0aGlzLm1fSi5hbmd1bGFyQSA9ICgtY3J1Zyk7XG4gICAgICAgICBLICs9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNydWcgKiBjcnVnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9yZXZvbHV0ZTIpIHtcbiAgICAgICAgIHRoaXMubV9KLmFuZ3VsYXJCID0gKC10aGlzLm1fcmF0aW8pO1xuICAgICAgICAgSyArPSB0aGlzLm1fcmF0aW8gKiB0aGlzLm1fcmF0aW8gKiBiQi5tX2ludkk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRNYXQgPSBnMi5tX3hmLlI7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX3ByaXNtYXRpYzIubV9sb2NhbFhBeGlzMTtcbiAgICAgICAgIHVnWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICB1Z1kgPSB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xuICAgICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgICAgIHJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgclkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICAgICB0WCA9IHRNYXQuY29sMS54ICogclggKyB0TWF0LmNvbDIueCAqIHJZO1xuICAgICAgICAgclkgPSB0TWF0LmNvbDEueSAqIHJYICsgdE1hdC5jb2wyLnkgKiByWTtcbiAgICAgICAgIHJYID0gdFg7XG4gICAgICAgICBjcnVnID0gclggKiB1Z1kgLSByWSAqIHVnWDtcbiAgICAgICAgIHRoaXMubV9KLmxpbmVhckIuU2V0KCgtdGhpcy5tX3JhdGlvICogdWdYKSwgKC10aGlzLm1fcmF0aW8gKiB1Z1kpKTtcbiAgICAgICAgIHRoaXMubV9KLmFuZ3VsYXJCID0gKC10aGlzLm1fcmF0aW8gKiBjcnVnKTtcbiAgICAgICAgIEsgKz0gdGhpcy5tX3JhdGlvICogdGhpcy5tX3JhdGlvICogKGJCLm1faW52TWFzcyArIGJCLm1faW52SSAqIGNydWcgKiBjcnVnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9tYXNzID0gSyA+IDAuMCA/IDEuMCAvIEsgOiAwLjA7XG4gICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQS5tX2ludk1hc3MgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueDtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQS5tX2ludk1hc3MgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueTtcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJBLm1faW52SSAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX0ouYW5ndWxhckE7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkIubV9pbnZNYXNzICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLng7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLnk7XG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQi5tX2ludkkgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmFuZ3VsYXJCO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIENkb3QgPSB0aGlzLm1fSi5Db21wdXRlKGJBLm1fbGluZWFyVmVsb2NpdHksIGJBLm1fYW5ndWxhclZlbG9jaXR5LCBiQi5tX2xpbmVhclZlbG9jaXR5LCBiQi5tX2FuZ3VsYXJWZWxvY2l0eSk7XG4gICAgICB2YXIgaW1wdWxzZSA9ICgtdGhpcy5tX21hc3MgKiBDZG90KTtcbiAgICAgIHRoaXMubV9pbXB1bHNlICs9IGltcHVsc2U7XG4gICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkEubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueDtcbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQS5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQS55O1xuICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkEubV9pbnZJICogaW1wdWxzZSAqIHRoaXMubV9KLmFuZ3VsYXJBO1xuICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS54ICs9IGJCLm1faW52TWFzcyAqIGltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLng7XG4gICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJCLm1faW52SSAqIGltcHVsc2UgKiB0aGlzLm1fSi5hbmd1bGFyQjtcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICB2YXIgbGluZWFyRXJyb3IgPSAwLjA7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgY29vcmRpbmF0ZTEgPSAwO1xuICAgICAgdmFyIGNvb3JkaW5hdGUyID0gMDtcbiAgICAgIGlmICh0aGlzLm1fcmV2b2x1dGUxKSB7XG4gICAgICAgICBjb29yZGluYXRlMSA9IHRoaXMubV9yZXZvbHV0ZTEuR2V0Sm9pbnRBbmdsZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBjb29yZGluYXRlMSA9IHRoaXMubV9wcmlzbWF0aWMxLkdldEpvaW50VHJhbnNsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1fcmV2b2x1dGUyKSB7XG4gICAgICAgICBjb29yZGluYXRlMiA9IHRoaXMubV9yZXZvbHV0ZTIuR2V0Sm9pbnRBbmdsZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBjb29yZGluYXRlMiA9IHRoaXMubV9wcmlzbWF0aWMyLkdldEpvaW50VHJhbnNsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHZhciBDID0gdGhpcy5tX2NvbnN0YW50IC0gKGNvb3JkaW5hdGUxICsgdGhpcy5tX3JhdGlvICogY29vcmRpbmF0ZTIpO1xuICAgICAgdmFyIGltcHVsc2UgPSAoLXRoaXMubV9tYXNzICogQyk7XG4gICAgICBiQS5tX3N3ZWVwLmMueCArPSBiQS5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQS54O1xuICAgICAgYkEubV9zd2VlcC5jLnkgKz0gYkEubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueTtcbiAgICAgIGJBLm1fc3dlZXAuYSArPSBiQS5tX2ludkkgKiBpbXB1bHNlICogdGhpcy5tX0ouYW5ndWxhckE7XG4gICAgICBiQi5tX3N3ZWVwLmMueCArPSBiQi5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQi54O1xuICAgICAgYkIubV9zd2VlcC5jLnkgKz0gYkIubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueTtcbiAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiBpbXB1bHNlICogdGhpcy5tX0ouYW5ndWxhckI7XG4gICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJHZWFySm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyR2VhckpvaW50RGVmLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYucHJvdG90eXBlO1xuICAgYjJHZWFySm9pbnREZWYuYjJHZWFySm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgYjJHZWFySm9pbnREZWYucHJvdG90eXBlLmIyR2VhckpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudHlwZSA9IGIySm9pbnQuZV9nZWFySm9pbnQ7XG4gICAgICB0aGlzLmpvaW50MSA9IG51bGw7XG4gICAgICB0aGlzLmpvaW50MiA9IG51bGw7XG4gICAgICB0aGlzLnJhdGlvID0gMS4wO1xuICAgfVxuICAgYjJKYWNvYmlhbi5iMkphY29iaWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5saW5lYXJBID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5saW5lYXJCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIySmFjb2JpYW4ucHJvdG90eXBlLlNldFplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxpbmVhckEuU2V0WmVybygpO1xuICAgICAgdGhpcy5hbmd1bGFyQSA9IDAuMDtcbiAgICAgIHRoaXMubGluZWFyQi5TZXRaZXJvKCk7XG4gICAgICB0aGlzLmFuZ3VsYXJCID0gMC4wO1xuICAgfVxuICAgYjJKYWNvYmlhbi5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHgxLCBhMSwgeDIsIGEyKSB7XG4gICAgICBpZiAoYTEgPT09IHVuZGVmaW5lZCkgYTEgPSAwO1xuICAgICAgaWYgKGEyID09PSB1bmRlZmluZWQpIGEyID0gMDtcbiAgICAgIHRoaXMubGluZWFyQS5TZXRWKHgxKTtcbiAgICAgIHRoaXMuYW5ndWxhckEgPSBhMTtcbiAgICAgIHRoaXMubGluZWFyQi5TZXRWKHgyKTtcbiAgICAgIHRoaXMuYW5ndWxhckIgPSBhMjtcbiAgIH1cbiAgIGIySmFjb2JpYW4ucHJvdG90eXBlLkNvbXB1dGUgPSBmdW5jdGlvbiAoeDEsIGExLCB4MiwgYTIpIHtcbiAgICAgIGlmIChhMSA9PT0gdW5kZWZpbmVkKSBhMSA9IDA7XG4gICAgICBpZiAoYTIgPT09IHVuZGVmaW5lZCkgYTIgPSAwO1xuICAgICAgcmV0dXJuICh0aGlzLmxpbmVhckEueCAqIHgxLnggKyB0aGlzLmxpbmVhckEueSAqIHgxLnkpICsgdGhpcy5hbmd1bGFyQSAqIGExICsgKHRoaXMubGluZWFyQi54ICogeDIueCArIHRoaXMubGluZWFyQi55ICogeDIueSkgKyB0aGlzLmFuZ3VsYXJCICogYTI7XG4gICB9XG4gICBiMkpvaW50LmIySm9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fZWRnZUEgPSBuZXcgYjJKb2ludEVkZ2UoKTtcbiAgICAgIHRoaXMubV9lZGdlQiA9IG5ldyBiMkpvaW50RWRnZSgpO1xuICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJKb2ludC5wcm90b3R5cGUuR2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIDAuMDtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEJvZHlBID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QTtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEJvZHlCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QjtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX25leHQ7XG4gICB9XG4gICBiMkpvaW50LnByb3RvdHlwZS5HZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XG4gICB9XG4gICBiMkpvaW50LnByb3RvdHlwZS5TZXRVc2VyRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBkYXRhO1xuICAgfVxuICAgYjJKb2ludC5wcm90b3R5cGUuSXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLklzQWN0aXZlKCkgJiYgdGhpcy5tX2JvZHlCLklzQWN0aXZlKCk7XG4gICB9XG4gICBiMkpvaW50LkNyZWF0ZSA9IGZ1bmN0aW9uIChkZWYsIGFsbG9jYXRvcikge1xuICAgICAgdmFyIGpvaW50ID0gbnVsbDtcbiAgICAgIHN3aXRjaCAoZGVmLnR5cGUpIHtcbiAgICAgIGNhc2UgYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQ6XG4gICAgICAgICB7XG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMkRpc3RhbmNlSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyRGlzdGFuY2VKb2ludERlZiA/IGRlZiA6IG51bGwpKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMkpvaW50LmVfbW91c2VKb2ludDpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyTW91c2VKb2ludCgoZGVmIGluc3RhbmNlb2YgYjJNb3VzZUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIySm9pbnQuZV9wcmlzbWF0aWNKb2ludDpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyUHJpc21hdGljSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyUHJpc21hdGljSm9pbnREZWYgPyBkZWYgOiBudWxsKSk7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJKb2ludC5lX3Jldm9sdXRlSm9pbnQ6XG4gICAgICAgICB7XG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMlJldm9sdXRlSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyUmV2b2x1dGVKb2ludERlZiA/IGRlZiA6IG51bGwpKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMkpvaW50LmVfcHVsbGV5Sm9pbnQ6XG4gICAgICAgICB7XG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMlB1bGxleUpvaW50KChkZWYgaW5zdGFuY2VvZiBiMlB1bGxleUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIySm9pbnQuZV9nZWFySm9pbnQ6XG4gICAgICAgICB7XG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMkdlYXJKb2ludCgoZGVmIGluc3RhbmNlb2YgYjJHZWFySm9pbnREZWYgPyBkZWYgOiBudWxsKSk7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJKb2ludC5lX2xpbmVKb2ludDpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyTGluZUpvaW50KChkZWYgaW5zdGFuY2VvZiBiMkxpbmVKb2ludERlZiA/IGRlZiA6IG51bGwpKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMkpvaW50LmVfd2VsZEpvaW50OlxuICAgICAgICAge1xuICAgICAgICAgICAgam9pbnQgPSBuZXcgYjJXZWxkSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyV2VsZEpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIySm9pbnQuZV9mcmljdGlvbkpvaW50OlxuICAgICAgICAge1xuICAgICAgICAgICAgam9pbnQgPSBuZXcgYjJGcmljdGlvbkpvaW50KChkZWYgaW5zdGFuY2VvZiBiMkZyaWN0aW9uSm9pbnREZWYgPyBkZWYgOiBudWxsKSk7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBqb2ludDtcbiAgIH1cbiAgIGIySm9pbnQuRGVzdHJveSA9IGZ1bmN0aW9uIChqb2ludCwgYWxsb2NhdG9yKSB7fVxuICAgYjJKb2ludC5wcm90b3R5cGUuYjJKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZGVmLmJvZHlBICE9IGRlZi5ib2R5Qik7XG4gICAgICB0aGlzLm1fdHlwZSA9IGRlZi50eXBlO1xuICAgICAgdGhpcy5tX3ByZXYgPSBudWxsO1xuICAgICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgICAgdGhpcy5tX2JvZHlBID0gZGVmLmJvZHlBO1xuICAgICAgdGhpcy5tX2JvZHlCID0gZGVmLmJvZHlCO1xuICAgICAgdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQgPSBkZWYuY29sbGlkZUNvbm5lY3RlZDtcbiAgICAgIHRoaXMubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBkZWYudXNlckRhdGE7XG4gICB9XG4gICBiMkpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7fVxuICAgYjJKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHt9XG4gICBiMkpvaW50LnByb3RvdHlwZS5GaW5hbGl6ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX3Vua25vd25Kb2ludCA9IDA7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX3Jldm9sdXRlSm9pbnQgPSAxO1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9wcmlzbWF0aWNKb2ludCA9IDI7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQgPSAzO1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9wdWxsZXlKb2ludCA9IDQ7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX21vdXNlSm9pbnQgPSA1O1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9nZWFySm9pbnQgPSA2O1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9saW5lSm9pbnQgPSA3O1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV93ZWxkSm9pbnQgPSA4O1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9mcmljdGlvbkpvaW50ID0gOTtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmVfaW5hY3RpdmVMaW1pdCA9IDA7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2F0TG93ZXJMaW1pdCA9IDE7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2F0VXBwZXJMaW1pdCA9IDI7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2VxdWFsTGltaXRzID0gMztcbiAgIH0pO1xuICAgYjJKb2ludERlZi5iMkpvaW50RGVmID0gZnVuY3Rpb24gKCkge307XG4gICBiMkpvaW50RGVmLnByb3RvdHlwZS5iMkpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX3Vua25vd25Kb2ludDtcbiAgICAgIHRoaXMudXNlckRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5ib2R5QSA9IG51bGw7XG4gICAgICB0aGlzLmJvZHlCID0gbnVsbDtcbiAgICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IGZhbHNlO1xuICAgfVxuICAgYjJKb2ludEVkZ2UuYjJKb2ludEVkZ2UgPSBmdW5jdGlvbiAoKSB7fTtcbiAgIEJveDJELmluaGVyaXQoYjJMaW5lSm9pbnQsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50KTtcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQucHJvdG90eXBlO1xuICAgYjJMaW5lSm9pbnQuYjJMaW5lSm9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5iMkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbFhBeGlzMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbFlBeGlzMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9heGlzID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3BlcnAgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fSyA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1faW1wdWxzZSA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IxKTtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnkpICogdGhpcy5tX2F4aXMueCksIGludl9kdCAqICh0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3BlcnAueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueSkgKiB0aGlzLm1fYXhpcy55KSk7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueTtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRKb2ludFRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgcDEgPSBiQS5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjEpO1xuICAgICAgdmFyIHAyID0gYkIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IyKTtcbiAgICAgIHZhciBkWCA9IHAyLnggLSBwMS54O1xuICAgICAgdmFyIGRZID0gcDIueSAtIHAxLnk7XG4gICAgICB2YXIgYXhpcyA9IGJBLkdldFdvcmxkVmVjdG9yKHRoaXMubV9sb2NhbFhBeGlzMSk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSBheGlzLnggKiBkWCArIGF4aXMueSAqIGRZO1xuICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldEpvaW50U3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHZhciB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICByMlggPSB0WDtcbiAgICAgIHZhciBwMVggPSBiQS5tX3N3ZWVwLmMueCArIHIxWDtcbiAgICAgIHZhciBwMVkgPSBiQS5tX3N3ZWVwLmMueSArIHIxWTtcbiAgICAgIHZhciBwMlggPSBiQi5tX3N3ZWVwLmMueCArIHIyWDtcbiAgICAgIHZhciBwMlkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWTtcbiAgICAgIHZhciBkWCA9IHAyWCAtIHAxWDtcbiAgICAgIHZhciBkWSA9IHAyWSAtIHAxWTtcbiAgICAgIHZhciBheGlzID0gYkEuR2V0V29ybGRWZWN0b3IodGhpcy5tX2xvY2FsWEF4aXMxKTtcbiAgICAgIHZhciB2MSA9IGJBLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdjIgPSBiQi5tX2xpbmVhclZlbG9jaXR5O1xuICAgICAgdmFyIHcxID0gYkEubV9hbmd1bGFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzIgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciBzcGVlZCA9IChkWCAqICgoLXcxICogYXhpcy55KSkgKyBkWSAqICh3MSAqIGF4aXMueCkpICsgKGF4aXMueCAqICgoKHYyLnggKyAoKC13MiAqIHIyWSkpKSAtIHYxLngpIC0gKCgtdzEgKiByMVkpKSkgKyBheGlzLnkgKiAoKCh2Mi55ICsgKHcyICogcjJYKSkgLSB2MS55KSAtICh3MSAqIHIxWCkpKTtcbiAgICAgIHJldHVybiBzcGVlZDtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Jc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTGltaXQ7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuRW5hYmxlTGltaXQgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZmxhZztcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRMb3dlckxpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldFVwcGVyTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb247XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuU2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQpIGxvd2VyID0gMDtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB1cHBlciA9IDA7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiA9IGxvd2VyO1xuICAgICAgdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gPSB1cHBlcjtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Jc01vdG9yRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTW90b3I7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuRW5hYmxlTW90b3IgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZmxhZztcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5TZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XG4gICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkgc3BlZWQgPSAwO1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBzcGVlZDtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9tb3RvclNwZWVkO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLlNldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSA9PT0gdW5kZWZpbmVkKSBmb3JjZSA9IDA7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fbWF4TW90b3JGb3JjZSA9IGZvcmNlO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX21heE1vdG9yRm9yY2U7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0TW90b3JGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLmIyTGluZUpvaW50ID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIHRZID0gMDtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEuU2V0VihkZWYubG9jYWxBbmNob3JBKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIuU2V0VihkZWYubG9jYWxBbmNob3JCKTtcbiAgICAgIHRoaXMubV9sb2NhbFhBeGlzMS5TZXRWKGRlZi5sb2NhbEF4aXNBKTtcbiAgICAgIHRoaXMubV9sb2NhbFlBeGlzMS54ID0gKC10aGlzLm1fbG9jYWxYQXhpczEueSk7XG4gICAgICB0aGlzLm1fbG9jYWxZQXhpczEueSA9IHRoaXMubV9sb2NhbFhBeGlzMS54O1xuICAgICAgdGhpcy5tX2ltcHVsc2UuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IDAuMDtcbiAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiA9IGRlZi5sb3dlclRyYW5zbGF0aW9uO1xuICAgICAgdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gPSBkZWYudXBwZXJUcmFuc2xhdGlvbjtcbiAgICAgIHRoaXMubV9tYXhNb3RvckZvcmNlID0gZGVmLm1heE1vdG9yRm9yY2U7XG4gICAgICB0aGlzLm1fbW90b3JTcGVlZCA9IGRlZi5tb3RvclNwZWVkO1xuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZGVmLmVuYWJsZUxpbWl0O1xuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZGVmLmVuYWJsZU1vdG9yO1xuICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdDtcbiAgICAgIHRoaXMubV9heGlzLlNldFplcm8oKTtcbiAgICAgIHRoaXMubV9wZXJwLlNldFplcm8oKTtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBLlNldFYoYkEuR2V0TG9jYWxDZW50ZXIoKSk7XG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCLlNldFYoYkIuR2V0TG9jYWxDZW50ZXIoKSk7XG4gICAgICB2YXIgeGYxID0gYkEuR2V0VHJhbnNmb3JtKCk7XG4gICAgICB2YXIgeGYyID0gYkIuR2V0VHJhbnNmb3JtKCk7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIHRoaXMubV9sb2NhbENlbnRlckEueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJBLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSB0aGlzLm1fbG9jYWxDZW50ZXJCLng7XG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gdGhpcy5tX2xvY2FsQ2VudGVyQi55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICByMlggPSB0WDtcbiAgICAgIHZhciBkWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XG4gICAgICB2YXIgZFkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWSAtIGJBLm1fc3dlZXAuYy55IC0gcjFZO1xuICAgICAgdGhpcy5tX2ludk1hc3NBID0gYkEubV9pbnZNYXNzO1xuICAgICAgdGhpcy5tX2ludk1hc3NCID0gYkIubV9pbnZNYXNzO1xuICAgICAgdGhpcy5tX2ludklBID0gYkEubV9pbnZJO1xuICAgICAgdGhpcy5tX2ludklCID0gYkIubV9pbnZJOyB7XG4gICAgICAgICB0aGlzLm1fYXhpcy5TZXRWKGIyTWF0aC5NdWxNVih4ZjEuUiwgdGhpcy5tX2xvY2FsWEF4aXMxKSk7XG4gICAgICAgICB0aGlzLm1fYTEgPSAoZFggKyByMVgpICogdGhpcy5tX2F4aXMueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgICAgdGhpcy5tX2EyID0gcjJYICogdGhpcy5tX2F4aXMueSAtIHIyWSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gdGhpcy5tX2ludk1hc3NBICsgdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklBICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgdGhpcy5tX2ludklCICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IHRoaXMubV9tb3Rvck1hc3MgPiBOdW1iZXIuTUlOX1ZBTFVFID8gMS4wIC8gdGhpcy5tX21vdG9yTWFzcyA6IDAuMDtcbiAgICAgIH0ge1xuICAgICAgICAgdGhpcy5tX3BlcnAuU2V0VihiMk1hdGguTXVsTVYoeGYxLlIsIHRoaXMubV9sb2NhbFlBeGlzMSkpO1xuICAgICAgICAgdGhpcy5tX3MxID0gKGRYICsgcjFYKSAqIHRoaXMubV9wZXJwLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX3BlcnAueDtcbiAgICAgICAgIHRoaXMubV9zMiA9IHIyWCAqIHRoaXMubV9wZXJwLnkgLSByMlkgKiB0aGlzLm1fcGVycC54O1xuICAgICAgICAgdmFyIG0xID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgdmFyIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgdmFyIGkxID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgdmFyIGkyID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgdGhpcy5tX0suY29sMS54ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX3MxICogdGhpcy5tX3MxICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fczI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wxLnkgPSBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX0suY29sMi54ID0gdGhpcy5tX0suY29sMS55O1xuICAgICAgICAgdGhpcy5tX0suY29sMi55ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fYTIgKiB0aGlzLm1fYTI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XG4gICAgICAgICB2YXIgam9pbnRUcmFuc2l0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xuICAgICAgICAgaWYgKGIyTWF0aC5BYnModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2VxdWFsTGltaXRzO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2l0aW9uIDw9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfYXRMb3dlckxpbWl0O1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKGpvaW50VHJhbnNpdGlvbiA+PSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gMC4wO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnkpICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIHZhciBQWSA9IHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fcGVycC55ICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS55KSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICB2YXIgTDEgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MxICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS55KSAqIHRoaXMubV9hMTtcbiAgICAgICAgIHZhciBMMiA9IHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fczIgKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnkpICogdGhpcy5tX2EyO1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgLT0gdGhpcy5tX2ludklBICogTDE7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gdGhpcy5tX2ludk1hc3NCICogUFg7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UuU2V0WmVybygpO1xuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHYxID0gYkEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3MSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIHYyID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3MiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIFBYID0gMDtcbiAgICAgIHZhciBQWSA9IDA7XG4gICAgICB2YXIgTDEgPSAwO1xuICAgICAgdmFyIEwyID0gMDtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2VxdWFsTGltaXRzKSB7XG4gICAgICAgICB2YXIgQ2RvdCA9IHRoaXMubV9heGlzLnggKiAodjIueCAtIHYxLngpICsgdGhpcy5tX2F4aXMueSAqICh2Mi55IC0gdjEueSkgKyB0aGlzLm1fYTIgKiB3MiAtIHRoaXMubV9hMSAqIHcxO1xuICAgICAgICAgdmFyIGltcHVsc2UgPSB0aGlzLm1fbW90b3JNYXNzICogKHRoaXMubV9tb3RvclNwZWVkIC0gQ2RvdCk7XG4gICAgICAgICB2YXIgb2xkSW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2U7XG4gICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4TW90b3JGb3JjZTtcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSBiMk1hdGguQ2xhbXAodGhpcy5tX21vdG9ySW1wdWxzZSArIGltcHVsc2UsICgtbWF4SW1wdWxzZSksIG1heEltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgUFggPSBpbXB1bHNlICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIFBZID0gaW1wdWxzZSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICBMMSA9IGltcHVsc2UgKiB0aGlzLm1fYTE7XG4gICAgICAgICBMMiA9IGltcHVsc2UgKiB0aGlzLm1fYTI7XG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIHZhciBDZG90MSA9IHRoaXMubV9wZXJwLnggKiAodjIueCAtIHYxLngpICsgdGhpcy5tX3BlcnAueSAqICh2Mi55IC0gdjEueSkgKyB0aGlzLm1fczIgKiB3MiAtIHRoaXMubV9zMSAqIHcxO1xuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdCkge1xuICAgICAgICAgdmFyIENkb3QyID0gdGhpcy5tX2F4aXMueCAqICh2Mi54IC0gdjEueCkgKyB0aGlzLm1fYXhpcy55ICogKHYyLnkgLSB2MS55KSArIHRoaXMubV9hMiAqIHcyIC0gdGhpcy5tX2ExICogdzE7XG4gICAgICAgICB2YXIgZjEgPSB0aGlzLm1faW1wdWxzZS5Db3B5KCk7XG4gICAgICAgICB2YXIgZGYgPSB0aGlzLm1fSy5Tb2x2ZShuZXcgYjJWZWMyKCksICgtQ2RvdDEpLCAoLUNkb3QyKSk7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5BZGQoZGYpO1xuICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgPSBiMk1hdGguTWF4KHRoaXMubV9pbXB1bHNlLnksIDAuMCk7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gYjJNYXRoLk1pbih0aGlzLm1faW1wdWxzZS55LCAwLjApO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGIgPSAoLUNkb3QxKSAtICh0aGlzLm1faW1wdWxzZS55IC0gZjEueSkgKiB0aGlzLm1fSy5jb2wyLng7XG4gICAgICAgICB2YXIgZjJyID0gMDtcbiAgICAgICAgIGlmICh0aGlzLm1fSy5jb2wxLnggIT0gMC4wKSB7XG4gICAgICAgICAgICBmMnIgPSBiIC8gdGhpcy5tX0suY29sMS54ICsgZjEueDtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZjJyID0gZjEueDtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggPSBmMnI7XG4gICAgICAgICBkZi54ID0gdGhpcy5tX2ltcHVsc2UueCAtIGYxLng7XG4gICAgICAgICBkZi55ID0gdGhpcy5tX2ltcHVsc2UueSAtIGYxLnk7XG4gICAgICAgICBQWCA9IGRmLnggKiB0aGlzLm1fcGVycC54ICsgZGYueSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICBQWSA9IGRmLnggKiB0aGlzLm1fcGVycC55ICsgZGYueSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICBMMSA9IGRmLnggKiB0aGlzLm1fczEgKyBkZi55ICogdGhpcy5tX2ExO1xuICAgICAgICAgTDIgPSBkZi54ICogdGhpcy5tX3MyICsgZGYueSAqIHRoaXMubV9hMjtcbiAgICAgICAgIHYxLnggLT0gdGhpcy5tX2ludk1hc3NBICogUFg7XG4gICAgICAgICB2MS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xuICAgICAgICAgdzEgLT0gdGhpcy5tX2ludklBICogTDE7XG4gICAgICAgICB2Mi54ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBYO1xuICAgICAgICAgdjIueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcbiAgICAgICAgIHcyICs9IHRoaXMubV9pbnZJQiAqIEwyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB2YXIgZGYyID0gMDtcbiAgICAgICAgIGlmICh0aGlzLm1fSy5jb2wxLnggIT0gMC4wKSB7XG4gICAgICAgICAgICBkZjIgPSAoKC1DZG90MSkpIC8gdGhpcy5tX0suY29sMS54O1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZjIgPSAwLjA7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICs9IGRmMjtcbiAgICAgICAgIFBYID0gZGYyICogdGhpcy5tX3BlcnAueDtcbiAgICAgICAgIFBZID0gZGYyICogdGhpcy5tX3BlcnAueTtcbiAgICAgICAgIEwxID0gZGYyICogdGhpcy5tX3MxO1xuICAgICAgICAgTDIgPSBkZjIgKiB0aGlzLm1fczI7XG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkuU2V0Vih2MSk7XG4gICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHcxO1xuICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS5TZXRWKHYyKTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ID0gdzI7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xuICAgICAgdmFyIGxpbWl0QyA9IDA7XG4gICAgICB2YXIgb2xkTGltaXRJbXB1bHNlID0gMDtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHZhciBjMSA9IGJBLm1fc3dlZXAuYztcbiAgICAgIHZhciBhMSA9IGJBLm1fc3dlZXAuYTtcbiAgICAgIHZhciBjMiA9IGJCLm1fc3dlZXAuYztcbiAgICAgIHZhciBhMiA9IGJCLm1fc3dlZXAuYTtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIHZhciBtMSA9IDA7XG4gICAgICB2YXIgbTIgPSAwO1xuICAgICAgdmFyIGkxID0gMDtcbiAgICAgIHZhciBpMiA9IDA7XG4gICAgICB2YXIgbGluZWFyRXJyb3IgPSAwLjA7XG4gICAgICB2YXIgYW5ndWxhckVycm9yID0gMC4wO1xuICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdmFyIEMyID0gMC4wO1xuICAgICAgdmFyIFIxID0gYjJNYXQyMi5Gcm9tQW5nbGUoYTEpO1xuICAgICAgdmFyIFIyID0gYjJNYXQyMi5Gcm9tQW5nbGUoYTIpO1xuICAgICAgdE1hdCA9IFIxO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIHRoaXMubV9sb2NhbENlbnRlckEueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJBLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IFIyO1xuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIHRoaXMubV9sb2NhbENlbnRlckIueDtcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJCLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgIHIyWCA9IHRYO1xuICAgICAgdmFyIGRYID0gYzIueCArIHIyWCAtIGMxLnggLSByMVg7XG4gICAgICB2YXIgZFkgPSBjMi55ICsgcjJZIC0gYzEueSAtIHIxWTtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQpIHtcbiAgICAgICAgIHRoaXMubV9heGlzID0gYjJNYXRoLk11bE1WKFIxLCB0aGlzLm1fbG9jYWxYQXhpczEpO1xuICAgICAgICAgdGhpcy5tX2ExID0gKGRYICsgcjFYKSAqIHRoaXMubV9heGlzLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIHRoaXMubV9hMiA9IHIyWCAqIHRoaXMubV9heGlzLnkgLSByMlkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xuICAgICAgICAgaWYgKGIyTWF0aC5BYnModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIGIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbik7XG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IGIyTWF0aC5BYnModHJhbnNsYXRpb24pO1xuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKHRyYW5zbGF0aW9uIDw9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICBDMiA9IGIyTWF0aC5DbGFtcCh0cmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIDAuMCk7XG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uIC0gdHJhbnNsYXRpb247XG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPj0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uIC0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsIDAuMCwgYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gdHJhbnNsYXRpb24gLSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbjtcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm1fcGVycCA9IGIyTWF0aC5NdWxNVihSMSwgdGhpcy5tX2xvY2FsWUF4aXMxKTtcbiAgICAgIHRoaXMubV9zMSA9IChkWCArIHIxWCkgKiB0aGlzLm1fcGVycC55IC0gKGRZICsgcjFZKSAqIHRoaXMubV9wZXJwLng7XG4gICAgICB0aGlzLm1fczIgPSByMlggKiB0aGlzLm1fcGVycC55IC0gcjJZICogdGhpcy5tX3BlcnAueDtcbiAgICAgIHZhciBpbXB1bHNlID0gbmV3IGIyVmVjMigpO1xuICAgICAgdmFyIEMxID0gdGhpcy5tX3BlcnAueCAqIGRYICsgdGhpcy5tX3BlcnAueSAqIGRZO1xuICAgICAgbGluZWFyRXJyb3IgPSBiMk1hdGguTWF4KGxpbmVhckVycm9yLCBiMk1hdGguQWJzKEMxKSk7XG4gICAgICBhbmd1bGFyRXJyb3IgPSAwLjA7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICBtMSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgaTEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICBpMiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDEueCA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX3MyO1xuICAgICAgICAgdGhpcy5tX0suY29sMS55ID0gaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fYTEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9hMjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueCA9IHRoaXMubV9LLmNvbDEueTtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueSA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX0suU29sdmUoaW1wdWxzZSwgKC1DMSksICgtQzIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgbTEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICBtMiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgIGkxID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgaTIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICB2YXIgazExID0gbTEgKyBtMiArIGkxICogdGhpcy5tX3MxICogdGhpcy5tX3MxICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fczI7XG4gICAgICAgICB2YXIgaW1wdWxzZTEgPSAwO1xuICAgICAgICAgaWYgKGsxMSAhPSAwLjApIHtcbiAgICAgICAgICAgIGltcHVsc2UxID0gKCgtQzEpKSAvIGsxMTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW1wdWxzZTEgPSAwLjA7XG4gICAgICAgICB9XG4gICAgICAgICBpbXB1bHNlLnggPSBpbXB1bHNlMTtcbiAgICAgICAgIGltcHVsc2UueSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIHZhciBQWCA9IGltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyBpbXB1bHNlLnkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgdmFyIFBZID0gaW1wdWxzZS54ICogdGhpcy5tX3BlcnAueSArIGltcHVsc2UueSAqIHRoaXMubV9heGlzLnk7XG4gICAgICB2YXIgTDEgPSBpbXB1bHNlLnggKiB0aGlzLm1fczEgKyBpbXB1bHNlLnkgKiB0aGlzLm1fYTE7XG4gICAgICB2YXIgTDIgPSBpbXB1bHNlLnggKiB0aGlzLm1fczIgKyBpbXB1bHNlLnkgKiB0aGlzLm1fYTI7XG4gICAgICBjMS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgYzEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgIGExIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgYzIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgIGMyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICBhMiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIGJBLm1fc3dlZXAuYSA9IGExO1xuICAgICAgYkIubV9zd2VlcC5hID0gYTI7XG4gICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8PSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3A7XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyTGluZUpvaW50RGVmLCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZik7XG4gICBiMkxpbmVKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcbiAgIGIyTGluZUpvaW50RGVmLmIyTGluZUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYuYjJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBeGlzQSA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkxpbmVKb2ludERlZi5wcm90b3R5cGUuYjJMaW5lSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX2xpbmVKb2ludDtcbiAgICAgIHRoaXMubG9jYWxBeGlzQS5TZXQoMS4wLCAwLjApO1xuICAgICAgdGhpcy5lbmFibGVMaW1pdCA9IGZhbHNlO1xuICAgICAgdGhpcy5sb3dlclRyYW5zbGF0aW9uID0gMC4wO1xuICAgICAgdGhpcy51cHBlclRyYW5zbGF0aW9uID0gMC4wO1xuICAgICAgdGhpcy5lbmFibGVNb3RvciA9IGZhbHNlO1xuICAgICAgdGhpcy5tYXhNb3RvckZvcmNlID0gMC4wO1xuICAgICAgdGhpcy5tb3RvclNwZWVkID0gMC4wO1xuICAgfVxuICAgYjJMaW5lSm9pbnREZWYucHJvdG90eXBlLkluaXRpYWxpemUgPSBmdW5jdGlvbiAoYkEsIGJCLCBhbmNob3IsIGF4aXMpIHtcbiAgICAgIHRoaXMuYm9keUEgPSBiQTtcbiAgICAgIHRoaXMuYm9keUIgPSBiQjtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gdGhpcy5ib2R5QS5HZXRMb2NhbFBvaW50KGFuY2hvcik7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHRoaXMuYm9keUIuR2V0TG9jYWxQb2ludChhbmNob3IpO1xuICAgICAgdGhpcy5sb2NhbEF4aXNBID0gdGhpcy5ib2R5QS5HZXRMb2NhbFZlY3RvcihheGlzKTtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJNb3VzZUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMk1vdXNlSm9pbnQuYjJNb3VzZUpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5LID0gbmV3IGIyTWF0MjIoKTtcbiAgICAgIHRoaXMuSzEgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgdGhpcy5LMiA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fdGFyZ2V0ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2ltcHVsc2UgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbWFzcyA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1fQyA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3RhcmdldDtcbiAgIH1cbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IpO1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueSk7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIDAuMDtcbiAgIH1cbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuR2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV90YXJnZXQ7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLlNldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLm1fYm9keUIuSXNBd2FrZSgpID09IGZhbHNlKSB7XG4gICAgICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLlNldE1heEZvcmNlID0gZnVuY3Rpb24gKG1heEZvcmNlKSB7XG4gICAgICBpZiAobWF4Rm9yY2UgPT09IHVuZGVmaW5lZCkgbWF4Rm9yY2UgPSAwO1xuICAgICAgdGhpcy5tX21heEZvcmNlID0gbWF4Rm9yY2U7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLlNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChoeikge1xuICAgICAgaWYgKGh6ID09PSB1bmRlZmluZWQpIGh6ID0gMDtcbiAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcbiAgIH1cbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuU2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICBpZiAocmF0aW8gPT09IHVuZGVmaW5lZCkgcmF0aW8gPSAwO1xuICAgICAgdGhpcy5tX2RhbXBpbmdSYXRpbyA9IHJhdGlvO1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5iMk1vdXNlSm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XG4gICAgICB0aGlzLm1fdGFyZ2V0LlNldFYoZGVmLnRhcmdldCk7XG4gICAgICB2YXIgdFggPSB0aGlzLm1fdGFyZ2V0LnggLSB0aGlzLm1fYm9keUIubV94Zi5wb3NpdGlvbi54O1xuICAgICAgdmFyIHRZID0gdGhpcy5tX3RhcmdldC55IC0gdGhpcy5tX2JvZHlCLm1feGYucG9zaXRpb24ueTtcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX2JvZHlCLm1feGYuUjtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvci54ID0gKHRYICogdE1hdC5jb2wxLnggKyB0WSAqIHRNYXQuY29sMS55KTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvci55ID0gKHRYICogdE1hdC5jb2wyLnggKyB0WSAqIHRNYXQuY29sMi55KTtcbiAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGRlZi5tYXhGb3JjZTtcbiAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGRlZi5mcmVxdWVuY3lIejtcbiAgICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSBkZWYuZGFtcGluZ1JhdGlvO1xuICAgICAgdGhpcy5tX2JldGEgPSAwLjA7XG4gICAgICB0aGlzLm1fZ2FtbWEgPSAwLjA7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciBiID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIG1hc3MgPSBiLkdldE1hc3MoKTtcbiAgICAgIHZhciBvbWVnYSA9IDIuMCAqIE1hdGguUEkgKiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICB2YXIgZCA9IDIuMCAqIG1hc3MgKiB0aGlzLm1fZGFtcGluZ1JhdGlvICogb21lZ2E7XG4gICAgICB2YXIgayA9IG1hc3MgKiBvbWVnYSAqIG9tZWdhO1xuICAgICAgdGhpcy5tX2dhbW1hID0gc3RlcC5kdCAqIChkICsgc3RlcC5kdCAqIGspO1xuICAgICAgdGhpcy5tX2dhbW1hID0gdGhpcy5tX2dhbW1hICE9IDAgPyAxIC8gdGhpcy5tX2dhbW1hIDogMC4wO1xuICAgICAgdGhpcy5tX2JldGEgPSBzdGVwLmR0ICogayAqIHRoaXMubV9nYW1tYTtcbiAgICAgIHZhciB0TWF0O3RNYXQgPSBiLm1feGYuUjtcbiAgICAgIHZhciByWCA9IHRoaXMubV9sb2NhbEFuY2hvci54IC0gYi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgclkgPSB0aGlzLm1fbG9jYWxBbmNob3IueSAtIGIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdmFyIHRYID0gKHRNYXQuY29sMS54ICogclggKyB0TWF0LmNvbDIueCAqIHJZKTtyWSA9ICh0TWF0LmNvbDEueSAqIHJYICsgdE1hdC5jb2wyLnkgKiByWSk7XG4gICAgICByWCA9IHRYO1xuICAgICAgdmFyIGludk1hc3MgPSBiLm1faW52TWFzcztcbiAgICAgIHZhciBpbnZJID0gYi5tX2ludkk7dGhpcy5LMS5jb2wxLnggPSBpbnZNYXNzO1xuICAgICAgdGhpcy5LMS5jb2wyLnggPSAwLjA7XG4gICAgICB0aGlzLksxLmNvbDEueSA9IDAuMDtcbiAgICAgIHRoaXMuSzEuY29sMi55ID0gaW52TWFzcztcbiAgICAgIHRoaXMuSzIuY29sMS54ID0gaW52SSAqIHJZICogclk7XG4gICAgICB0aGlzLksyLmNvbDIueCA9ICgtaW52SSAqIHJYICogclkpO1xuICAgICAgdGhpcy5LMi5jb2wxLnkgPSAoLWludkkgKiByWCAqIHJZKTtcbiAgICAgIHRoaXMuSzIuY29sMi55ID0gaW52SSAqIHJYICogclg7XG4gICAgICB0aGlzLksuU2V0TSh0aGlzLksxKTtcbiAgICAgIHRoaXMuSy5BZGRNKHRoaXMuSzIpO1xuICAgICAgdGhpcy5LLmNvbDEueCArPSB0aGlzLm1fZ2FtbWE7XG4gICAgICB0aGlzLksuY29sMi55ICs9IHRoaXMubV9nYW1tYTtcbiAgICAgIHRoaXMuSy5HZXRJbnZlcnNlKHRoaXMubV9tYXNzKTtcbiAgICAgIHRoaXMubV9DLnggPSBiLm1fc3dlZXAuYy54ICsgclggLSB0aGlzLm1fdGFyZ2V0Lng7XG4gICAgICB0aGlzLm1fQy55ID0gYi5tX3N3ZWVwLmMueSArIHJZIC0gdGhpcy5tX3RhcmdldC55O1xuICAgICAgYi5tX2FuZ3VsYXJWZWxvY2l0eSAqPSAwLjk4O1xuICAgICAgdGhpcy5tX2ltcHVsc2UueCAqPSBzdGVwLmR0UmF0aW87XG4gICAgICB0aGlzLm1faW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICs9IGludk1hc3MgKiB0aGlzLm1faW1wdWxzZS54O1xuICAgICAgYi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gaW52TWFzcyAqIHRoaXMubV9pbXB1bHNlLnk7XG4gICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ICs9IGludkkgKiAoclggKiB0aGlzLm1faW1wdWxzZS55IC0gclkgKiB0aGlzLm1faW1wdWxzZS54KTtcbiAgIH1cbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciBiID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIHRZID0gMDtcbiAgICAgIHRNYXQgPSBiLm1feGYuUjtcbiAgICAgIHZhciByWCA9IHRoaXMubV9sb2NhbEFuY2hvci54IC0gYi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgclkgPSB0aGlzLm1fbG9jYWxBbmNob3IueSAtIGIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByWCArIHRNYXQuY29sMi54ICogclkpO1xuICAgICAgclkgPSAodE1hdC5jb2wxLnkgKiByWCArIHRNYXQuY29sMi55ICogclkpO1xuICAgICAgclggPSB0WDtcbiAgICAgIHZhciBDZG90WCA9IGIubV9saW5lYXJWZWxvY2l0eS54ICsgKCgtYi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHJZKSk7XG4gICAgICB2YXIgQ2RvdFkgPSBiLm1fbGluZWFyVmVsb2NpdHkueSArIChiLm1fYW5ndWxhclZlbG9jaXR5ICogclgpO1xuICAgICAgdE1hdCA9IHRoaXMubV9tYXNzO1xuICAgICAgdFggPSBDZG90WCArIHRoaXMubV9iZXRhICogdGhpcy5tX0MueCArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlLng7XG4gICAgICB0WSA9IENkb3RZICsgdGhpcy5tX2JldGEgKiB0aGlzLm1fQy55ICsgdGhpcy5tX2dhbW1hICogdGhpcy5tX2ltcHVsc2UueTtcbiAgICAgIHZhciBpbXB1bHNlWCA9ICgtKHRNYXQuY29sMS54ICogdFggKyB0TWF0LmNvbDIueCAqIHRZKSk7XG4gICAgICB2YXIgaW1wdWxzZVkgPSAoLSh0TWF0LmNvbDEueSAqIHRYICsgdE1hdC5jb2wyLnkgKiB0WSkpO1xuICAgICAgdmFyIG9sZEltcHVsc2VYID0gdGhpcy5tX2ltcHVsc2UueDtcbiAgICAgIHZhciBvbGRJbXB1bHNlWSA9IHRoaXMubV9pbXB1bHNlLnk7XG4gICAgICB0aGlzLm1faW1wdWxzZS54ICs9IGltcHVsc2VYO1xuICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSBpbXB1bHNlWTtcbiAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhGb3JjZTtcbiAgICAgIGlmICh0aGlzLm1faW1wdWxzZS5MZW5ndGhTcXVhcmVkKCkgPiBtYXhJbXB1bHNlICogbWF4SW1wdWxzZSkge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UuTXVsdGlwbHkobWF4SW1wdWxzZSAvIHRoaXMubV9pbXB1bHNlLkxlbmd0aCgpKTtcbiAgICAgIH1cbiAgICAgIGltcHVsc2VYID0gdGhpcy5tX2ltcHVsc2UueCAtIG9sZEltcHVsc2VYO1xuICAgICAgaW1wdWxzZVkgPSB0aGlzLm1faW1wdWxzZS55IC0gb2xkSW1wdWxzZVk7XG4gICAgICBiLm1fbGluZWFyVmVsb2NpdHkueCArPSBiLm1faW52TWFzcyAqIGltcHVsc2VYO1xuICAgICAgYi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYi5tX2ludk1hc3MgKiBpbXB1bHNlWTtcbiAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYi5tX2ludkkgKiAoclggKiBpbXB1bHNlWSAtIHJZICogaW1wdWxzZVgpO1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJNb3VzZUpvaW50RGVmLCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZik7XG4gICBiMk1vdXNlSm9pbnREZWYucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5wcm90b3R5cGU7XG4gICBiMk1vdXNlSm9pbnREZWYuYjJNb3VzZUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYuYjJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy50YXJnZXQgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJNb3VzZUpvaW50RGVmLnByb3RvdHlwZS5iMk1vdXNlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX21vdXNlSm9pbnQ7XG4gICAgICB0aGlzLm1heEZvcmNlID0gMC4wO1xuICAgICAgdGhpcy5mcmVxdWVuY3lIeiA9IDUuMDtcbiAgICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gMC43O1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMlByaXNtYXRpY0pvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQucHJvdG90eXBlO1xuICAgYjJQcmlzbWF0aWNKb2ludC5iMlByaXNtYXRpY0pvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxYQXhpczEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxZQXhpczEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fYXhpcyA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9wZXJwID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX0sgPSBuZXcgYjJNYXQzMygpO1xuICAgICAgdGhpcy5tX2ltcHVsc2UgPSBuZXcgYjJWZWMzKCk7XG4gICB9O1xuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IxKTtcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMik7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogKHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fcGVycC54ICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KSAqIHRoaXMubV9heGlzLngpLCBpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnkgKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopICogdGhpcy5tX2F4aXMueSkpO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueTtcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldEpvaW50VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciBwMSA9IGJBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICAgICB2YXIgcDIgPSBiQi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xuICAgICAgdmFyIGRYID0gcDIueCAtIHAxLng7XG4gICAgICB2YXIgZFkgPSBwMi55IC0gcDEueTtcbiAgICAgIHZhciBheGlzID0gYkEuR2V0V29ybGRWZWN0b3IodGhpcy5tX2xvY2FsWEF4aXMxKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IGF4aXMueCAqIGRYICsgYXhpcy55ICogZFk7XG4gICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5HZXRKb2ludFNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICByMVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgcDFYID0gYkEubV9zd2VlcC5jLnggKyByMVg7XG4gICAgICB2YXIgcDFZID0gYkEubV9zd2VlcC5jLnkgKyByMVk7XG4gICAgICB2YXIgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XG4gICAgICB2YXIgcDJZID0gYkIubV9zd2VlcC5jLnkgKyByMlk7XG4gICAgICB2YXIgZFggPSBwMlggLSBwMVg7XG4gICAgICB2YXIgZFkgPSBwMlkgLSBwMVk7XG4gICAgICB2YXIgYXhpcyA9IGJBLkdldFdvcmxkVmVjdG9yKHRoaXMubV9sb2NhbFhBeGlzMSk7XG4gICAgICB2YXIgdjEgPSBiQS5tX2xpbmVhclZlbG9jaXR5O1xuICAgICAgdmFyIHYyID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3MSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIHcyID0gYkIubV9hbmd1bGFyVmVsb2NpdHk7XG4gICAgICB2YXIgc3BlZWQgPSAoZFggKiAoKC13MSAqIGF4aXMueSkpICsgZFkgKiAodzEgKiBheGlzLngpKSArIChheGlzLnggKiAoKCh2Mi54ICsgKCgtdzIgKiByMlkpKSkgLSB2MS54KSAtICgoLXcxICogcjFZKSkpICsgYXhpcy55ICogKCgodjIueSArICh3MiAqIHIyWCkpIC0gdjEueSkgLSAodzEgKiByMVgpKSk7XG4gICAgICByZXR1cm4gc3BlZWQ7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Jc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTGltaXQ7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5FbmFibGVMaW1pdCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fZW5hYmxlTGltaXQgPSBmbGFnO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0TG93ZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbjtcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldFVwcGVyTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb247XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5TZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCkgbG93ZXIgPSAwO1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHVwcGVyID0gMDtcbiAgICAgIHRoaXMubV9ib2R5QS5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIHRoaXMubV9ib2R5Qi5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uID0gbG93ZXI7XG4gICAgICB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiA9IHVwcGVyO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuSXNNb3RvckVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2VuYWJsZU1vdG9yO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuRW5hYmxlTW90b3IgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZmxhZztcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLlNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcbiAgICAgIGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSBzcGVlZCA9IDA7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fbW90b3JTcGVlZCA9IHNwZWVkO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbW90b3JTcGVlZDtcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLlNldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSA9PT0gdW5kZWZpbmVkKSBmb3JjZSA9IDA7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fbWF4TW90b3JGb3JjZSA9IGZvcmNlO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0TW90b3JGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuYjJQcmlzbWF0aWNKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50LmNhbGwodGhpcywgZGVmKTtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIHZhciB0WSA9IDA7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyLlNldFYoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICB0aGlzLm1fbG9jYWxYQXhpczEuU2V0VihkZWYubG9jYWxBeGlzQSk7XG4gICAgICB0aGlzLm1fbG9jYWxZQXhpczEueCA9ICgtdGhpcy5tX2xvY2FsWEF4aXMxLnkpO1xuICAgICAgdGhpcy5tX2xvY2FsWUF4aXMxLnkgPSB0aGlzLm1fbG9jYWxYQXhpczEueDtcbiAgICAgIHRoaXMubV9yZWZBbmdsZSA9IGRlZi5yZWZlcmVuY2VBbmdsZTtcbiAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAwLjA7XG4gICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gPSBkZWYubG93ZXJUcmFuc2xhdGlvbjtcbiAgICAgIHRoaXMubV91cHBlclRyYW5zbGF0aW9uID0gZGVmLnVwcGVyVHJhbnNsYXRpb247XG4gICAgICB0aGlzLm1fbWF4TW90b3JGb3JjZSA9IGRlZi5tYXhNb3RvckZvcmNlO1xuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBkZWYubW90b3JTcGVlZDtcbiAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcbiAgICAgIHRoaXMubV9lbmFibGVNb3RvciA9IGRlZi5lbmFibGVNb3RvcjtcbiAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICB0aGlzLm1fYXhpcy5TZXRaZXJvKCk7XG4gICAgICB0aGlzLm1fcGVycC5TZXRaZXJvKCk7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBLlNldFYoYkEuR2V0TG9jYWxDZW50ZXIoKSk7XG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCLlNldFYoYkIuR2V0TG9jYWxDZW50ZXIoKSk7XG4gICAgICB2YXIgeGYxID0gYkEuR2V0VHJhbnNmb3JtKCk7XG4gICAgICB2YXIgeGYyID0gYkIuR2V0VHJhbnNmb3JtKCk7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIHRoaXMubV9sb2NhbENlbnRlckEueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJBLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSB0aGlzLm1fbG9jYWxDZW50ZXJCLng7XG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gdGhpcy5tX2xvY2FsQ2VudGVyQi55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICByMlggPSB0WDtcbiAgICAgIHZhciBkWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XG4gICAgICB2YXIgZFkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWSAtIGJBLm1fc3dlZXAuYy55IC0gcjFZO1xuICAgICAgdGhpcy5tX2ludk1hc3NBID0gYkEubV9pbnZNYXNzO1xuICAgICAgdGhpcy5tX2ludk1hc3NCID0gYkIubV9pbnZNYXNzO1xuICAgICAgdGhpcy5tX2ludklBID0gYkEubV9pbnZJO1xuICAgICAgdGhpcy5tX2ludklCID0gYkIubV9pbnZJOyB7XG4gICAgICAgICB0aGlzLm1fYXhpcy5TZXRWKGIyTWF0aC5NdWxNVih4ZjEuUiwgdGhpcy5tX2xvY2FsWEF4aXMxKSk7XG4gICAgICAgICB0aGlzLm1fYTEgPSAoZFggKyByMVgpICogdGhpcy5tX2F4aXMueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgICAgdGhpcy5tX2EyID0gcjJYICogdGhpcy5tX2F4aXMueSAtIHIyWSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gdGhpcy5tX2ludk1hc3NBICsgdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklBICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgdGhpcy5tX2ludklCICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgaWYgKHRoaXMubV9tb3Rvck1hc3MgPiBOdW1iZXIuTUlOX1ZBTFVFKSB0aGlzLm1fbW90b3JNYXNzID0gMS4wIC8gdGhpcy5tX21vdG9yTWFzcztcbiAgICAgIH0ge1xuICAgICAgICAgdGhpcy5tX3BlcnAuU2V0VihiMk1hdGguTXVsTVYoeGYxLlIsIHRoaXMubV9sb2NhbFlBeGlzMSkpO1xuICAgICAgICAgdGhpcy5tX3MxID0gKGRYICsgcjFYKSAqIHRoaXMubV9wZXJwLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX3BlcnAueDtcbiAgICAgICAgIHRoaXMubV9zMiA9IHIyWCAqIHRoaXMubV9wZXJwLnkgLSByMlkgKiB0aGlzLm1fcGVycC54O1xuICAgICAgICAgdmFyIG0xID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgdmFyIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgdmFyIGkxID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgdmFyIGkyID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgdGhpcy5tX0suY29sMS54ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX3MxICogdGhpcy5tX3MxICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fczI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wxLnkgPSBpMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyO1xuICAgICAgICAgdGhpcy5tX0suY29sMS56ID0gaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fYTEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9hMjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueCA9IHRoaXMubV9LLmNvbDEueTtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueSA9IGkxICsgaTI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnogPSBpMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX0suY29sMy54ID0gdGhpcy5tX0suY29sMS56O1xuICAgICAgICAgdGhpcy5tX0suY29sMy55ID0gdGhpcy5tX0suY29sMi56O1xuICAgICAgICAgdGhpcy5tX0suY29sMy56ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fYTIgKiB0aGlzLm1fYTI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XG4gICAgICAgICB2YXIgam9pbnRUcmFuc2l0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xuICAgICAgICAgaWYgKGIyTWF0aC5BYnModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2VxdWFsTGltaXRzO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2l0aW9uIDw9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfYXRMb3dlckxpbWl0O1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKGpvaW50VHJhbnNpdGlvbiA+PSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIHZhciBQWSA9IHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fcGVycC55ICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICB2YXIgTDEgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MxICsgdGhpcy5tX2ltcHVsc2UueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYTE7XG4gICAgICAgICB2YXIgTDIgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MyICsgdGhpcy5tX2ltcHVsc2UueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYTI7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggLT0gdGhpcy5tX2ludk1hc3NBICogUFg7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gdGhpcy5tX2ludk1hc3NBICogUFk7XG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSAtPSB0aGlzLm1faW52SUEgKiBMMTtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMubV9pbnZJQiAqIEwyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5TZXRaZXJvKCk7XG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgfVxuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHZhciB2MSA9IGJBLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzEgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciB2MiA9IGJCLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzIgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciBQWCA9IDA7XG4gICAgICB2YXIgUFkgPSAwO1xuICAgICAgdmFyIEwxID0gMDtcbiAgICAgIHZhciBMMiA9IDA7XG4gICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yICYmIHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9lcXVhbExpbWl0cykge1xuICAgICAgICAgdmFyIENkb3QgPSB0aGlzLm1fYXhpcy54ICogKHYyLnggLSB2MS54KSArIHRoaXMubV9heGlzLnkgKiAodjIueSAtIHYxLnkpICsgdGhpcy5tX2EyICogdzIgLSB0aGlzLm1fYTEgKiB3MTtcbiAgICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5tX21vdG9yTWFzcyAqICh0aGlzLm1fbW90b3JTcGVlZCAtIENkb3QpO1xuICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBzdGVwLmR0ICogdGhpcy5tX21heE1vdG9yRm9yY2U7XG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gYjJNYXRoLkNsYW1wKHRoaXMubV9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAoLW1heEltcHVsc2UpLCBtYXhJbXB1bHNlKTtcbiAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgIFBYID0gaW1wdWxzZSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICBQWSA9IGltcHVsc2UgKiB0aGlzLm1fYXhpcy55O1xuICAgICAgICAgTDEgPSBpbXB1bHNlICogdGhpcy5tX2ExO1xuICAgICAgICAgTDIgPSBpbXB1bHNlICogdGhpcy5tX2EyO1xuICAgICAgICAgdjEueCAtPSB0aGlzLm1faW52TWFzc0EgKiBQWDtcbiAgICAgICAgIHYxLnkgLT0gdGhpcy5tX2ludk1hc3NBICogUFk7XG4gICAgICAgICB3MSAtPSB0aGlzLm1faW52SUEgKiBMMTtcbiAgICAgICAgIHYyLnggKz0gdGhpcy5tX2ludk1hc3NCICogUFg7XG4gICAgICAgICB2Mi55ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBZO1xuICAgICAgICAgdzIgKz0gdGhpcy5tX2ludklCICogTDI7XG4gICAgICB9XG4gICAgICB2YXIgQ2RvdDFYID0gdGhpcy5tX3BlcnAueCAqICh2Mi54IC0gdjEueCkgKyB0aGlzLm1fcGVycC55ICogKHYyLnkgLSB2MS55KSArIHRoaXMubV9zMiAqIHcyIC0gdGhpcy5tX3MxICogdzE7XG4gICAgICB2YXIgQ2RvdDFZID0gdzIgLSB3MTtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQpIHtcbiAgICAgICAgIHZhciBDZG90MiA9IHRoaXMubV9heGlzLnggKiAodjIueCAtIHYxLngpICsgdGhpcy5tX2F4aXMueSAqICh2Mi55IC0gdjEueSkgKyB0aGlzLm1fYTIgKiB3MiAtIHRoaXMubV9hMSAqIHcxO1xuICAgICAgICAgdmFyIGYxID0gdGhpcy5tX2ltcHVsc2UuQ29weSgpO1xuICAgICAgICAgdmFyIGRmID0gdGhpcy5tX0suU29sdmUzMyhuZXcgYjJWZWMzKCksICgtQ2RvdDFYKSwgKC1DZG90MVkpLCAoLUNkb3QyKSk7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5BZGQoZGYpO1xuICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSBiMk1hdGguTWF4KHRoaXMubV9pbXB1bHNlLnosIDAuMCk7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gYjJNYXRoLk1pbih0aGlzLm1faW1wdWxzZS56LCAwLjApO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGJYID0gKC1DZG90MVgpIC0gKHRoaXMubV9pbXB1bHNlLnogLSBmMS56KSAqIHRoaXMubV9LLmNvbDMueDtcbiAgICAgICAgIHZhciBiWSA9ICgtQ2RvdDFZKSAtICh0aGlzLm1faW1wdWxzZS56IC0gZjEueikgKiB0aGlzLm1fSy5jb2wzLnk7XG4gICAgICAgICB2YXIgZjJyID0gdGhpcy5tX0suU29sdmUyMihuZXcgYjJWZWMyKCksIGJYLCBiWSk7XG4gICAgICAgICBmMnIueCArPSBmMS54O1xuICAgICAgICAgZjJyLnkgKz0gZjEueTtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggPSBmMnIueDtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgPSBmMnIueTtcbiAgICAgICAgIGRmLnggPSB0aGlzLm1faW1wdWxzZS54IC0gZjEueDtcbiAgICAgICAgIGRmLnkgPSB0aGlzLm1faW1wdWxzZS55IC0gZjEueTtcbiAgICAgICAgIGRmLnogPSB0aGlzLm1faW1wdWxzZS56IC0gZjEuejtcbiAgICAgICAgIFBYID0gZGYueCAqIHRoaXMubV9wZXJwLnggKyBkZi56ICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIFBZID0gZGYueCAqIHRoaXMubV9wZXJwLnkgKyBkZi56ICogdGhpcy5tX2F4aXMueTtcbiAgICAgICAgIEwxID0gZGYueCAqIHRoaXMubV9zMSArIGRmLnkgKyBkZi56ICogdGhpcy5tX2ExO1xuICAgICAgICAgTDIgPSBkZi54ICogdGhpcy5tX3MyICsgZGYueSArIGRmLnogKiB0aGlzLm1fYTI7XG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdmFyIGRmMiA9IHRoaXMubV9LLlNvbHZlMjIobmV3IGIyVmVjMigpLCAoLUNkb3QxWCksICgtQ2RvdDFZKSk7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICs9IGRmMi54O1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSBkZjIueTtcbiAgICAgICAgIFBYID0gZGYyLnggKiB0aGlzLm1fcGVycC54O1xuICAgICAgICAgUFkgPSBkZjIueCAqIHRoaXMubV9wZXJwLnk7XG4gICAgICAgICBMMSA9IGRmMi54ICogdGhpcy5tX3MxICsgZGYyLnk7XG4gICAgICAgICBMMiA9IGRmMi54ICogdGhpcy5tX3MyICsgZGYyLnk7XG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkuU2V0Vih2MSk7XG4gICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHcxO1xuICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS5TZXRWKHYyKTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ID0gdzI7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICB2YXIgbGltaXRDID0gMDtcbiAgICAgIHZhciBvbGRMaW1pdEltcHVsc2UgPSAwO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIGMxID0gYkEubV9zd2VlcC5jO1xuICAgICAgdmFyIGExID0gYkEubV9zd2VlcC5hO1xuICAgICAgdmFyIGMyID0gYkIubV9zd2VlcC5jO1xuICAgICAgdmFyIGEyID0gYkIubV9zd2VlcC5hO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIG0xID0gMDtcbiAgICAgIHZhciBtMiA9IDA7XG4gICAgICB2YXIgaTEgPSAwO1xuICAgICAgdmFyIGkyID0gMDtcbiAgICAgIHZhciBsaW5lYXJFcnJvciA9IDAuMDtcbiAgICAgIHZhciBhbmd1bGFyRXJyb3IgPSAwLjA7XG4gICAgICB2YXIgYWN0aXZlID0gZmFsc2U7XG4gICAgICB2YXIgQzIgPSAwLjA7XG4gICAgICB2YXIgUjEgPSBiMk1hdDIyLkZyb21BbmdsZShhMSk7XG4gICAgICB2YXIgUjIgPSBiMk1hdDIyLkZyb21BbmdsZShhMik7XG4gICAgICB0TWF0ID0gUjE7XG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gdGhpcy5tX2xvY2FsQ2VudGVyQS54O1xuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIHRoaXMubV9sb2NhbENlbnRlckEueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xuICAgICAgcjFYID0gdFg7XG4gICAgICB0TWF0ID0gUjI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gdGhpcy5tX2xvY2FsQ2VudGVyQi54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIHRoaXMubV9sb2NhbENlbnRlckIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgZFggPSBjMi54ICsgcjJYIC0gYzEueCAtIHIxWDtcbiAgICAgIHZhciBkWSA9IGMyLnkgKyByMlkgLSBjMS55IC0gcjFZO1xuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCkge1xuICAgICAgICAgdGhpcy5tX2F4aXMgPSBiMk1hdGguTXVsTVYoUjEsIHRoaXMubV9sb2NhbFhBeGlzMSk7XG4gICAgICAgICB0aGlzLm1fYTEgPSAoZFggKyByMVgpICogdGhpcy5tX2F4aXMueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgICAgdGhpcy5tX2EyID0gcjJYICogdGhpcy5tX2F4aXMueSAtIHIyWSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLm1fYXhpcy54ICogZFggKyB0aGlzLm1fYXhpcy55ICogZFk7XG4gICAgICAgICBpZiAoYjJNYXRoLkFicyh0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSA8IDIuMCAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xuICAgICAgICAgICAgQzIgPSBiMk1hdGguQ2xhbXAodHJhbnNsYXRpb24sICgtYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKSwgYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gYjJNYXRoLkFicyh0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPD0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uIC0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsICgtYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKSwgMC4wKTtcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gLSB0cmFuc2xhdGlvbjtcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0cmFuc2xhdGlvbiA+PSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgQzIgPSBiMk1hdGguQ2xhbXAodHJhbnNsYXRpb24gLSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgMC4wLCBiMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgbGluZWFyRXJyb3IgPSB0cmFuc2xhdGlvbiAtIHRoaXMubV91cHBlclRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubV9wZXJwID0gYjJNYXRoLk11bE1WKFIxLCB0aGlzLm1fbG9jYWxZQXhpczEpO1xuICAgICAgdGhpcy5tX3MxID0gKGRYICsgcjFYKSAqIHRoaXMubV9wZXJwLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX3BlcnAueDtcbiAgICAgIHRoaXMubV9zMiA9IHIyWCAqIHRoaXMubV9wZXJwLnkgLSByMlkgKiB0aGlzLm1fcGVycC54O1xuICAgICAgdmFyIGltcHVsc2UgPSBuZXcgYjJWZWMzKCk7XG4gICAgICB2YXIgQzFYID0gdGhpcy5tX3BlcnAueCAqIGRYICsgdGhpcy5tX3BlcnAueSAqIGRZO1xuICAgICAgdmFyIEMxWSA9IGEyIC0gYTEgLSB0aGlzLm1fcmVmQW5nbGU7XG4gICAgICBsaW5lYXJFcnJvciA9IGIyTWF0aC5NYXgobGluZWFyRXJyb3IsIGIyTWF0aC5BYnMoQzFYKSk7XG4gICAgICBhbmd1bGFyRXJyb3IgPSBiMk1hdGguQWJzKEMxWSk7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICBtMSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgaTEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICBpMiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDEueCA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX3MyO1xuICAgICAgICAgdGhpcy5tX0suY29sMS55ID0gaTEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDEueiA9IGkxICogdGhpcy5tX3MxICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fYTI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnggPSB0aGlzLm1fSy5jb2wxLnk7XG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnkgPSBpMSArIGkyO1xuICAgICAgICAgdGhpcy5tX0suY29sMi56ID0gaTEgKiB0aGlzLm1fYTEgKyBpMiAqIHRoaXMubV9hMjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDMueCA9IHRoaXMubV9LLmNvbDEuejtcbiAgICAgICAgIHRoaXMubV9LLmNvbDMueSA9IHRoaXMubV9LLmNvbDIuejtcbiAgICAgICAgIHRoaXMubV9LLmNvbDMueiA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX0suU29sdmUzMyhpbXB1bHNlLCAoLUMxWCksICgtQzFZKSwgKC1DMikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBtMSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgaTEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICBpMiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgIHZhciBrMTEgPSBtMSArIG0yICsgaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9zMjtcbiAgICAgICAgIHZhciBrMTIgPSBpMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyO1xuICAgICAgICAgdmFyIGsyMiA9IGkxICsgaTI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wxLlNldChrMTEsIGsxMiwgMC4wKTtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIuU2V0KGsxMiwgazIyLCAwLjApO1xuICAgICAgICAgdmFyIGltcHVsc2UxID0gdGhpcy5tX0suU29sdmUyMihuZXcgYjJWZWMyKCksICgtQzFYKSwgKC1DMVkpKTtcbiAgICAgICAgIGltcHVsc2UueCA9IGltcHVsc2UxLng7XG4gICAgICAgICBpbXB1bHNlLnkgPSBpbXB1bHNlMS55O1xuICAgICAgICAgaW1wdWxzZS56ID0gMC4wO1xuICAgICAgfVxuICAgICAgdmFyIFBYID0gaW1wdWxzZS54ICogdGhpcy5tX3BlcnAueCArIGltcHVsc2UueiAqIHRoaXMubV9heGlzLng7XG4gICAgICB2YXIgUFkgPSBpbXB1bHNlLnggKiB0aGlzLm1fcGVycC55ICsgaW1wdWxzZS56ICogdGhpcy5tX2F4aXMueTtcbiAgICAgIHZhciBMMSA9IGltcHVsc2UueCAqIHRoaXMubV9zMSArIGltcHVsc2UueSArIGltcHVsc2UueiAqIHRoaXMubV9hMTtcbiAgICAgIHZhciBMMiA9IGltcHVsc2UueCAqIHRoaXMubV9zMiArIGltcHVsc2UueSArIGltcHVsc2UueiAqIHRoaXMubV9hMjtcbiAgICAgIGMxLnggLT0gdGhpcy5tX2ludk1hc3NBICogUFg7XG4gICAgICBjMS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xuICAgICAgYTEgLT0gdGhpcy5tX2ludklBICogTDE7XG4gICAgICBjMi54ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBYO1xuICAgICAgYzIueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcbiAgICAgIGEyICs9IHRoaXMubV9pbnZJQiAqIEwyO1xuICAgICAgYkEubV9zd2VlcC5hID0gYTE7XG4gICAgICBiQi5tX3N3ZWVwLmEgPSBhMjtcbiAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuIGxpbmVhckVycm9yIDw9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcDtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJQcmlzbWF0aWNKb2ludERlZiwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYpO1xuICAgYjJQcmlzbWF0aWNKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcbiAgIGIyUHJpc21hdGljSm9pbnREZWYuYjJQcmlzbWF0aWNKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmxvY2FsQXhpc0EgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJQcmlzbWF0aWNKb2ludERlZi5wcm90b3R5cGUuYjJQcmlzbWF0aWNKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50RGVmLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfcHJpc21hdGljSm9pbnQ7XG4gICAgICB0aGlzLmxvY2FsQXhpc0EuU2V0KDEuMCwgMC4wKTtcbiAgICAgIHRoaXMucmVmZXJlbmNlQW5nbGUgPSAwLjA7XG4gICAgICB0aGlzLmVuYWJsZUxpbWl0ID0gZmFsc2U7XG4gICAgICB0aGlzLmxvd2VyVHJhbnNsYXRpb24gPSAwLjA7XG4gICAgICB0aGlzLnVwcGVyVHJhbnNsYXRpb24gPSAwLjA7XG4gICAgICB0aGlzLmVuYWJsZU1vdG9yID0gZmFsc2U7XG4gICAgICB0aGlzLm1heE1vdG9yRm9yY2UgPSAwLjA7XG4gICAgICB0aGlzLm1vdG9yU3BlZWQgPSAwLjA7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgYW5jaG9yLCBheGlzKSB7XG4gICAgICB0aGlzLmJvZHlBID0gYkE7XG4gICAgICB0aGlzLmJvZHlCID0gYkI7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3IpO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSB0aGlzLmJvZHlCLkdldExvY2FsUG9pbnQoYW5jaG9yKTtcbiAgICAgIHRoaXMubG9jYWxBeGlzQSA9IHRoaXMuYm9keUEuR2V0TG9jYWxWZWN0b3IoYXhpcyk7XG4gICAgICB0aGlzLnJlZmVyZW5jZUFuZ2xlID0gdGhpcy5ib2R5Qi5HZXRBbmdsZSgpIC0gdGhpcy5ib2R5QS5HZXRBbmdsZSgpO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMlB1bGxleUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQucHJvdG90eXBlO1xuICAgYjJQdWxsZXlKb2ludC5iMlB1bGxleUpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3UxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3UyID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICB9XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcbiAgICAgIHJldHVybiBuZXcgYjJWZWMyKGludl9kdCAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3UyLngsIGludl9kdCAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3UyLnkpO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gMC4wO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0R3JvdW5kQW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLkNvcHkoKTtcbiAgICAgIGEuQWRkKHRoaXMubV9ncm91bmRBbmNob3IxKTtcbiAgICAgIHJldHVybiBhO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0R3JvdW5kQW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLkNvcHkoKTtcbiAgICAgIGEuQWRkKHRoaXMubV9ncm91bmRBbmNob3IyKTtcbiAgICAgIHJldHVybiBhO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0TGVuZ3RoMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwID0gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICAgICB2YXIgc1ggPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueCArIHRoaXMubV9ncm91bmRBbmNob3IxLng7XG4gICAgICB2YXIgc1kgPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueSArIHRoaXMubV9ncm91bmRBbmNob3IxLnk7XG4gICAgICB2YXIgZFggPSBwLnggLSBzWDtcbiAgICAgIHZhciBkWSA9IHAueSAtIHNZO1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG4gICB9XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5HZXRMZW5ndGgyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IyKTtcbiAgICAgIHZhciBzWCA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi54ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueDtcbiAgICAgIHZhciBzWSA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi55ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueTtcbiAgICAgIHZhciBkWCA9IHAueCAtIHNYO1xuICAgICAgdmFyIGRZID0gcC55IC0gc1k7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcbiAgIH1cbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkdldFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9yYXRpbztcbiAgIH1cbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLmIyUHVsbGV5Sm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgdFkgPSAwO1xuICAgICAgdGhpcy5tX2dyb3VuZCA9IHRoaXMubV9ib2R5QS5tX3dvcmxkLm1fZ3JvdW5kQm9keTtcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IxLnggPSBkZWYuZ3JvdW5kQW5jaG9yQS54IC0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLng7XG4gICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMS55ID0gZGVmLmdyb3VuZEFuY2hvckEueSAtIHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi55O1xuICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjIueCA9IGRlZi5ncm91bmRBbmNob3JCLnggLSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueDtcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IyLnkgPSBkZWYuZ3JvdW5kQW5jaG9yQi55IC0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyLlNldFYoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICB0aGlzLm1fcmF0aW8gPSBkZWYucmF0aW87XG4gICAgICB0aGlzLm1fY29uc3RhbnQgPSBkZWYubGVuZ3RoQSArIHRoaXMubV9yYXRpbyAqIGRlZi5sZW5ndGhCO1xuICAgICAgdGhpcy5tX21heExlbmd0aDEgPSBiMk1hdGguTWluKGRlZi5tYXhMZW5ndGhBLCB0aGlzLm1fY29uc3RhbnQgLSB0aGlzLm1fcmF0aW8gKiBiMlB1bGxleUpvaW50LmIyX21pblB1bGxleUxlbmd0aCk7XG4gICAgICB0aGlzLm1fbWF4TGVuZ3RoMiA9IGIyTWF0aC5NaW4oZGVmLm1heExlbmd0aEIsICh0aGlzLm1fY29uc3RhbnQgLSBiMlB1bGxleUpvaW50LmIyX21pblB1bGxleUxlbmd0aCkgLyB0aGlzLm1fcmF0aW8pO1xuICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMSA9IDAuMDtcbiAgICAgIHRoaXMubV9saW1pdEltcHVsc2UyID0gMC4wO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICByMVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgcDFYID0gYkEubV9zd2VlcC5jLnggKyByMVg7XG4gICAgICB2YXIgcDFZID0gYkEubV9zd2VlcC5jLnkgKyByMVk7XG4gICAgICB2YXIgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XG4gICAgICB2YXIgcDJZID0gYkIubV9zd2VlcC5jLnkgKyByMlk7XG4gICAgICB2YXIgczFYID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnggKyB0aGlzLm1fZ3JvdW5kQW5jaG9yMS54O1xuICAgICAgdmFyIHMxWSA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi55ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjEueTtcbiAgICAgIHZhciBzMlggPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueCArIHRoaXMubV9ncm91bmRBbmNob3IyLng7XG4gICAgICB2YXIgczJZID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnkgKyB0aGlzLm1fZ3JvdW5kQW5jaG9yMi55O1xuICAgICAgdGhpcy5tX3UxLlNldChwMVggLSBzMVgsIHAxWSAtIHMxWSk7XG4gICAgICB0aGlzLm1fdTIuU2V0KHAyWCAtIHMyWCwgcDJZIC0gczJZKTtcbiAgICAgIHZhciBsZW5ndGgxID0gdGhpcy5tX3UxLkxlbmd0aCgpO1xuICAgICAgdmFyIGxlbmd0aDIgPSB0aGlzLm1fdTIuTGVuZ3RoKCk7XG4gICAgICBpZiAobGVuZ3RoMSA+IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xuICAgICAgICAgdGhpcy5tX3UxLk11bHRpcGx5KDEuMCAvIGxlbmd0aDEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fdTEuU2V0WmVybygpO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aDIgPiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcbiAgICAgICAgIHRoaXMubV91Mi5NdWx0aXBseSgxLjAgLyBsZW5ndGgyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3UyLlNldFplcm8oKTtcbiAgICAgIH1cbiAgICAgIHZhciBDID0gdGhpcy5tX2NvbnN0YW50IC0gbGVuZ3RoMSAtIHRoaXMubV9yYXRpbyAqIGxlbmd0aDI7XG4gICAgICBpZiAoQyA+IDAuMCkge1xuICAgICAgICAgdGhpcy5tX3N0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3N0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGgxIDwgdGhpcy5tX21heExlbmd0aDEpIHtcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlMSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xuICAgICAgICAgdGhpcy5tX2xpbWl0SW1wdWxzZTEgPSAwLjA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlMSA9IGIySm9pbnQuZV9hdFVwcGVyTGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoMiA8IHRoaXMubV9tYXhMZW5ndGgyKSB7XG4gICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZTIgPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdDtcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UyID0gMC4wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZTIgPSBiMkpvaW50LmVfYXRVcHBlckxpbWl0O1xuICAgICAgfVxuICAgICAgdmFyIGNyMXUxID0gcjFYICogdGhpcy5tX3UxLnkgLSByMVkgKiB0aGlzLm1fdTEueDtcbiAgICAgIHZhciBjcjJ1MiA9IHIyWCAqIHRoaXMubV91Mi55IC0gcjJZICogdGhpcy5tX3UyLng7XG4gICAgICB0aGlzLm1fbGltaXRNYXNzMSA9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNyMXUxICogY3IxdTE7XG4gICAgICB0aGlzLm1fbGltaXRNYXNzMiA9IGJCLm1faW52TWFzcyArIGJCLm1faW52SSAqIGNyMnUyICogY3IydTI7XG4gICAgICB0aGlzLm1fcHVsbGV5TWFzcyA9IHRoaXMubV9saW1pdE1hc3MxICsgdGhpcy5tX3JhdGlvICogdGhpcy5tX3JhdGlvICogdGhpcy5tX2xpbWl0TWFzczI7XG4gICAgICB0aGlzLm1fbGltaXRNYXNzMSA9IDEuMCAvIHRoaXMubV9saW1pdE1hc3MxO1xuICAgICAgdGhpcy5tX2xpbWl0TWFzczIgPSAxLjAgLyB0aGlzLm1fbGltaXRNYXNzMjtcbiAgICAgIHRoaXMubV9wdWxsZXlNYXNzID0gMS4wIC8gdGhpcy5tX3B1bGxleU1hc3M7XG4gICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UxICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UyICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHZhciBQMVggPSAoKC10aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMSkgKiB0aGlzLm1fdTEueDtcbiAgICAgICAgIHZhciBQMVkgPSAoKC10aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMSkgKiB0aGlzLm1fdTEueTtcbiAgICAgICAgIHZhciBQMlggPSAoKC10aGlzLm1fcmF0aW8gKiB0aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMikgKiB0aGlzLm1fdTIueDtcbiAgICAgICAgIHZhciBQMlkgPSAoKC10aGlzLm1fcmF0aW8gKiB0aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMikgKiB0aGlzLm1fdTIueTtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQS5tX2ludk1hc3MgKiBQMVg7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkEubV9pbnZNYXNzICogUDFZO1xuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkEubV9pbnZJICogKHIxWCAqIFAxWSAtIHIxWSAqIFAxWCk7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkIubV9pbnZNYXNzICogUDJYO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IGJCLm1faW52TWFzcyAqIFAyWTtcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJCLm1faW52SSAqIChyMlggKiBQMlkgLSByMlkgKiBQMlgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UxID0gMC4wO1xuICAgICAgICAgdGhpcy5tX2xpbWl0SW1wdWxzZTIgPSAwLjA7XG4gICAgICB9XG4gICB9XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICByMVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgdjFYID0gMDtcbiAgICAgIHZhciB2MVkgPSAwO1xuICAgICAgdmFyIHYyWCA9IDA7XG4gICAgICB2YXIgdjJZID0gMDtcbiAgICAgIHZhciBQMVggPSAwO1xuICAgICAgdmFyIFAxWSA9IDA7XG4gICAgICB2YXIgUDJYID0gMDtcbiAgICAgIHZhciBQMlkgPSAwO1xuICAgICAgdmFyIENkb3QgPSAwO1xuICAgICAgdmFyIGltcHVsc2UgPSAwO1xuICAgICAgdmFyIG9sZEltcHVsc2UgPSAwO1xuICAgICAgaWYgKHRoaXMubV9zdGF0ZSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICB2MVggPSBiQS5tX2xpbmVhclZlbG9jaXR5LnggKyAoKC1iQS5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIxWSkpO1xuICAgICAgICAgdjFZID0gYkEubV9saW5lYXJWZWxvY2l0eS55ICsgKGJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFYKTtcbiAgICAgICAgIHYyWCA9IGJCLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJCLm1fYW5ndWxhclZlbG9jaXR5ICogcjJZKSk7XG4gICAgICAgICB2MlkgPSBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKyAoYkIubV9hbmd1bGFyVmVsb2NpdHkgKiByMlgpO1xuICAgICAgICAgQ2RvdCA9ICgtKHRoaXMubV91MS54ICogdjFYICsgdGhpcy5tX3UxLnkgKiB2MVkpKSAtIHRoaXMubV9yYXRpbyAqICh0aGlzLm1fdTIueCAqIHYyWCArIHRoaXMubV91Mi55ICogdjJZKTtcbiAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fcHVsbGV5TWFzcyAqICgoLUNkb3QpKTtcbiAgICAgICAgIG9sZEltcHVsc2UgPSB0aGlzLm1faW1wdWxzZTtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlID0gYjJNYXRoLk1heCgwLjAsIHRoaXMubV9pbXB1bHNlICsgaW1wdWxzZSk7XG4gICAgICAgICBpbXB1bHNlID0gdGhpcy5tX2ltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgUDFYID0gKC1pbXB1bHNlICogdGhpcy5tX3UxLngpO1xuICAgICAgICAgUDFZID0gKC1pbXB1bHNlICogdGhpcy5tX3UxLnkpO1xuICAgICAgICAgUDJYID0gKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlICogdGhpcy5tX3UyLngpO1xuICAgICAgICAgUDJZID0gKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlICogdGhpcy5tX3UyLnkpO1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54ICs9IGJBLm1faW52TWFzcyAqIFAxWDtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQS5tX2ludk1hc3MgKiBQMVk7XG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQS5tX2ludkkgKiAocjFYICogUDFZIC0gcjFZICogUDFYKTtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBQMlg7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogUDJZO1xuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogKHIyWCAqIFAyWSAtIHIyWSAqIFAyWCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUxID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgIHYxWCA9IGJBLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFZKSk7XG4gICAgICAgICB2MVkgPSBiQS5tX2xpbmVhclZlbG9jaXR5LnkgKyAoYkEubV9hbmd1bGFyVmVsb2NpdHkgKiByMVgpO1xuICAgICAgICAgQ2RvdCA9ICgtKHRoaXMubV91MS54ICogdjFYICsgdGhpcy5tX3UxLnkgKiB2MVkpKTtcbiAgICAgICAgIGltcHVsc2UgPSAoLXRoaXMubV9saW1pdE1hc3MxICogQ2RvdCk7XG4gICAgICAgICBvbGRJbXB1bHNlID0gdGhpcy5tX2xpbWl0SW1wdWxzZTE7XG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMSA9IGIyTWF0aC5NYXgoMC4wLCB0aGlzLm1fbGltaXRJbXB1bHNlMSArIGltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9saW1pdEltcHVsc2UxIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgIFAxWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS54KTtcbiAgICAgICAgIFAxWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS55KTtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQS5tX2ludk1hc3MgKiBQMVg7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkEubV9pbnZNYXNzICogUDFZO1xuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkEubV9pbnZJICogKHIxWCAqIFAxWSAtIHIxWSAqIFAxWCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUyID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgIHYyWCA9IGJCLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJCLm1fYW5ndWxhclZlbG9jaXR5ICogcjJZKSk7XG4gICAgICAgICB2MlkgPSBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKyAoYkIubV9hbmd1bGFyVmVsb2NpdHkgKiByMlgpO1xuICAgICAgICAgQ2RvdCA9ICgtKHRoaXMubV91Mi54ICogdjJYICsgdGhpcy5tX3UyLnkgKiB2MlkpKTtcbiAgICAgICAgIGltcHVsc2UgPSAoLXRoaXMubV9saW1pdE1hc3MyICogQ2RvdCk7XG4gICAgICAgICBvbGRJbXB1bHNlID0gdGhpcy5tX2xpbWl0SW1wdWxzZTI7XG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMiA9IGIyTWF0aC5NYXgoMC4wLCB0aGlzLm1fbGltaXRJbXB1bHNlMiArIGltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9saW1pdEltcHVsc2UyIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgIFAyWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91Mi54KTtcbiAgICAgICAgIFAyWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91Mi55KTtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBQMlg7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogUDJZO1xuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogKHIyWCAqIFAyWSAtIHIyWSAqIFAyWCk7XG4gICAgICB9XG4gICB9XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciBzMVggPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueCArIHRoaXMubV9ncm91bmRBbmNob3IxLng7XG4gICAgICB2YXIgczFZID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnkgKyB0aGlzLm1fZ3JvdW5kQW5jaG9yMS55O1xuICAgICAgdmFyIHMyWCA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi54ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueDtcbiAgICAgIHZhciBzMlkgPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueSArIHRoaXMubV9ncm91bmRBbmNob3IyLnk7XG4gICAgICB2YXIgcjFYID0gMDtcbiAgICAgIHZhciByMVkgPSAwO1xuICAgICAgdmFyIHIyWCA9IDA7XG4gICAgICB2YXIgcjJZID0gMDtcbiAgICAgIHZhciBwMVggPSAwO1xuICAgICAgdmFyIHAxWSA9IDA7XG4gICAgICB2YXIgcDJYID0gMDtcbiAgICAgIHZhciBwMlkgPSAwO1xuICAgICAgdmFyIGxlbmd0aDEgPSAwO1xuICAgICAgdmFyIGxlbmd0aDIgPSAwO1xuICAgICAgdmFyIEMgPSAwO1xuICAgICAgdmFyIGltcHVsc2UgPSAwO1xuICAgICAgdmFyIG9sZEltcHVsc2UgPSAwO1xuICAgICAgdmFyIG9sZExpbWl0UG9zaXRpb25JbXB1bHNlID0gMDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgbGluZWFyRXJyb3IgPSAwLjA7XG4gICAgICBpZiAodGhpcy5tX3N0YXRlID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICAgICByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICAgICByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgICAgIHIxWCA9IHRYO1xuICAgICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgICAgIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgICAgIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgICAgcjJYID0gdFg7XG4gICAgICAgICBwMVggPSBiQS5tX3N3ZWVwLmMueCArIHIxWDtcbiAgICAgICAgIHAxWSA9IGJBLm1fc3dlZXAuYy55ICsgcjFZO1xuICAgICAgICAgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XG4gICAgICAgICBwMlkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWTtcbiAgICAgICAgIHRoaXMubV91MS5TZXQocDFYIC0gczFYLCBwMVkgLSBzMVkpO1xuICAgICAgICAgdGhpcy5tX3UyLlNldChwMlggLSBzMlgsIHAyWSAtIHMyWSk7XG4gICAgICAgICBsZW5ndGgxID0gdGhpcy5tX3UxLkxlbmd0aCgpO1xuICAgICAgICAgbGVuZ3RoMiA9IHRoaXMubV91Mi5MZW5ndGgoKTtcbiAgICAgICAgIGlmIChsZW5ndGgxID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICB0aGlzLm1fdTEuTXVsdGlwbHkoMS4wIC8gbGVuZ3RoMSk7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV91MS5TZXRaZXJvKCk7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAobGVuZ3RoMiA+IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xuICAgICAgICAgICAgdGhpcy5tX3UyLk11bHRpcGx5KDEuMCAvIGxlbmd0aDIpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1fdTIuU2V0WmVybygpO1xuICAgICAgICAgfVxuICAgICAgICAgQyA9IHRoaXMubV9jb25zdGFudCAtIGxlbmd0aDEgLSB0aGlzLm1fcmF0aW8gKiBsZW5ndGgyO1xuICAgICAgICAgbGluZWFyRXJyb3IgPSBiMk1hdGguTWF4KGxpbmVhckVycm9yLCAoLUMpKTtcbiAgICAgICAgIEMgPSBiMk1hdGguQ2xhbXAoQyArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgKC1iMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pLCAwLjApO1xuICAgICAgICAgaW1wdWxzZSA9ICgtdGhpcy5tX3B1bGxleU1hc3MgKiBDKTtcbiAgICAgICAgIHAxWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS54KTtcbiAgICAgICAgIHAxWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS55KTtcbiAgICAgICAgIHAyWCA9ICgtdGhpcy5tX3JhdGlvICogaW1wdWxzZSAqIHRoaXMubV91Mi54KTtcbiAgICAgICAgIHAyWSA9ICgtdGhpcy5tX3JhdGlvICogaW1wdWxzZSAqIHRoaXMubV91Mi55KTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy54ICs9IGJBLm1faW52TWFzcyAqIHAxWDtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy55ICs9IGJBLm1faW52TWFzcyAqIHAxWTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYSArPSBiQS5tX2ludkkgKiAocjFYICogcDFZIC0gcjFZICogcDFYKTtcbiAgICAgICAgIGJCLm1fc3dlZXAuYy54ICs9IGJCLm1faW52TWFzcyAqIHAyWDtcbiAgICAgICAgIGJCLm1fc3dlZXAuYy55ICs9IGJCLm1faW52TWFzcyAqIHAyWTtcbiAgICAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiAocjJYICogcDJZIC0gcjJZICogcDJYKTtcbiAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlMSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgICAgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICAgICByMVggPSB0WDtcbiAgICAgICAgIHAxWCA9IGJBLm1fc3dlZXAuYy54ICsgcjFYO1xuICAgICAgICAgcDFZID0gYkEubV9zd2VlcC5jLnkgKyByMVk7XG4gICAgICAgICB0aGlzLm1fdTEuU2V0KHAxWCAtIHMxWCwgcDFZIC0gczFZKTtcbiAgICAgICAgIGxlbmd0aDEgPSB0aGlzLm1fdTEuTGVuZ3RoKCk7XG4gICAgICAgICBpZiAobGVuZ3RoMSA+IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xuICAgICAgICAgICAgdGhpcy5tX3UxLnggKj0gMS4wIC8gbGVuZ3RoMTtcbiAgICAgICAgICAgIHRoaXMubV91MS55ICo9IDEuMCAvIGxlbmd0aDE7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV91MS5TZXRaZXJvKCk7XG4gICAgICAgICB9XG4gICAgICAgICBDID0gdGhpcy5tX21heExlbmd0aDEgLSBsZW5ndGgxO1xuICAgICAgICAgbGluZWFyRXJyb3IgPSBiMk1hdGguTWF4KGxpbmVhckVycm9yLCAoLUMpKTtcbiAgICAgICAgIEMgPSBiMk1hdGguQ2xhbXAoQyArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgKC1iMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pLCAwLjApO1xuICAgICAgICAgaW1wdWxzZSA9ICgtdGhpcy5tX2xpbWl0TWFzczEgKiBDKTtcbiAgICAgICAgIHAxWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS54KTtcbiAgICAgICAgIHAxWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS55KTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy54ICs9IGJBLm1faW52TWFzcyAqIHAxWDtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy55ICs9IGJBLm1faW52TWFzcyAqIHAxWTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYSArPSBiQS5tX2ludkkgKiAocjFYICogcDFZIC0gcjFZICogcDFYKTtcbiAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUyID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICAgICByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICAgICByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgICAgIHIyWCA9IHRYO1xuICAgICAgICAgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XG4gICAgICAgICBwMlkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWTtcbiAgICAgICAgIHRoaXMubV91Mi5TZXQocDJYIC0gczJYLCBwMlkgLSBzMlkpO1xuICAgICAgICAgbGVuZ3RoMiA9IHRoaXMubV91Mi5MZW5ndGgoKTtcbiAgICAgICAgIGlmIChsZW5ndGgyID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICB0aGlzLm1fdTIueCAqPSAxLjAgLyBsZW5ndGgyO1xuICAgICAgICAgICAgdGhpcy5tX3UyLnkgKj0gMS4wIC8gbGVuZ3RoMjtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX3UyLlNldFplcm8oKTtcbiAgICAgICAgIH1cbiAgICAgICAgIEMgPSB0aGlzLm1fbWF4TGVuZ3RoMiAtIGxlbmd0aDI7XG4gICAgICAgICBsaW5lYXJFcnJvciA9IGIyTWF0aC5NYXgobGluZWFyRXJyb3IsICgtQykpO1xuICAgICAgICAgQyA9IGIyTWF0aC5DbGFtcChDICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIDAuMCk7XG4gICAgICAgICBpbXB1bHNlID0gKC10aGlzLm1fbGltaXRNYXNzMiAqIEMpO1xuICAgICAgICAgcDJYID0gKC1pbXB1bHNlICogdGhpcy5tX3UyLngpO1xuICAgICAgICAgcDJZID0gKC1pbXB1bHNlICogdGhpcy5tX3UyLnkpO1xuICAgICAgICAgYkIubV9zd2VlcC5jLnggKz0gYkIubV9pbnZNYXNzICogcDJYO1xuICAgICAgICAgYkIubV9zd2VlcC5jLnkgKz0gYkIubV9pbnZNYXNzICogcDJZO1xuICAgICAgICAgYkIubV9zd2VlcC5hICs9IGJCLm1faW52SSAqIChyMlggKiBwMlkgLSByMlkgKiBwMlgpO1xuICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnQuYjJfbWluUHVsbGV5TGVuZ3RoID0gMi4wO1xuICAgfSk7XG4gICBCb3gyRC5pbmhlcml0KGIyUHVsbGV5Sm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyUHVsbGV5Sm9pbnREZWYucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5wcm90b3R5cGU7XG4gICBiMlB1bGxleUpvaW50RGVmLmIyUHVsbGV5Sm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmdyb3VuZEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmdyb3VuZEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyUHVsbGV5Sm9pbnREZWYucHJvdG90eXBlLmIyUHVsbGV5Sm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX3B1bGxleUpvaW50O1xuICAgICAgdGhpcy5ncm91bmRBbmNob3JBLlNldCgoLTEuMCksIDEuMCk7XG4gICAgICB0aGlzLmdyb3VuZEFuY2hvckIuU2V0KDEuMCwgMS4wKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBLlNldCgoLTEuMCksIDAuMCk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQi5TZXQoMS4wLCAwLjApO1xuICAgICAgdGhpcy5sZW5ndGhBID0gMC4wO1xuICAgICAgdGhpcy5tYXhMZW5ndGhBID0gMC4wO1xuICAgICAgdGhpcy5sZW5ndGhCID0gMC4wO1xuICAgICAgdGhpcy5tYXhMZW5ndGhCID0gMC4wO1xuICAgICAgdGhpcy5yYXRpbyA9IDEuMDtcbiAgICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IHRydWU7XG4gICB9XG4gICBiMlB1bGxleUpvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgZ2FBLCBnYUIsIGFuY2hvckEsIGFuY2hvckIsIHIpIHtcbiAgICAgIGlmIChyID09PSB1bmRlZmluZWQpIHIgPSAwO1xuICAgICAgdGhpcy5ib2R5QSA9IGJBO1xuICAgICAgdGhpcy5ib2R5QiA9IGJCO1xuICAgICAgdGhpcy5ncm91bmRBbmNob3JBLlNldFYoZ2FBKTtcbiAgICAgIHRoaXMuZ3JvdW5kQW5jaG9yQi5TZXRWKGdhQik7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3JBKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gdGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvckIpO1xuICAgICAgdmFyIGQxWCA9IGFuY2hvckEueCAtIGdhQS54O1xuICAgICAgdmFyIGQxWSA9IGFuY2hvckEueSAtIGdhQS55O1xuICAgICAgdGhpcy5sZW5ndGhBID0gTWF0aC5zcXJ0KGQxWCAqIGQxWCArIGQxWSAqIGQxWSk7XG4gICAgICB2YXIgZDJYID0gYW5jaG9yQi54IC0gZ2FCLng7XG4gICAgICB2YXIgZDJZID0gYW5jaG9yQi55IC0gZ2FCLnk7XG4gICAgICB0aGlzLmxlbmd0aEIgPSBNYXRoLnNxcnQoZDJYICogZDJYICsgZDJZICogZDJZKTtcbiAgICAgIHRoaXMucmF0aW8gPSByO1xuICAgICAgdmFyIEMgPSB0aGlzLmxlbmd0aEEgKyB0aGlzLnJhdGlvICogdGhpcy5sZW5ndGhCO1xuICAgICAgdGhpcy5tYXhMZW5ndGhBID0gQyAtIHRoaXMucmF0aW8gKiBiMlB1bGxleUpvaW50LmIyX21pblB1bGxleUxlbmd0aDtcbiAgICAgIHRoaXMubWF4TGVuZ3RoQiA9IChDIC0gYjJQdWxsZXlKb2ludC5iMl9taW5QdWxsZXlMZW5ndGgpIC8gdGhpcy5yYXRpbztcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJSZXZvbHV0ZUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMlJldm9sdXRlSm9pbnQuYjJSZXZvbHV0ZUpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5LID0gbmV3IGIyTWF0MjIoKTtcbiAgICAgIHRoaXMuSzEgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgdGhpcy5LMiA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLkszID0gbmV3IGIyTWF0MjIoKTtcbiAgICAgIHRoaXMuaW1wdWxzZTMgPSBuZXcgYjJWZWMzKCk7XG4gICAgICB0aGlzLmltcHVsc2UyID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5yZWR1Y2VkID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1faW1wdWxzZSA9IG5ldyBiMlZlYzMoKTtcbiAgICAgIHRoaXMubV9tYXNzID0gbmV3IGIyTWF0MzMoKTtcbiAgIH07XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMik7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS54LCBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS55KTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UuejtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0Sm9pbnRBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIubV9zd2VlcC5hIC0gdGhpcy5tX2JvZHlBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0Sm9pbnRTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIubV9hbmd1bGFyVmVsb2NpdHkgLSB0aGlzLm1fYm9keUEubV9hbmd1bGFyVmVsb2NpdHk7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLklzTGltaXRFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVMaW1pdDtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuRW5hYmxlTGltaXQgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZmxhZztcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0TG93ZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbG93ZXJBbmdsZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0VXBwZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdXBwZXJBbmdsZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuU2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQpIGxvd2VyID0gMDtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB1cHBlciA9IDA7XG4gICAgICB0aGlzLm1fbG93ZXJBbmdsZSA9IGxvd2VyO1xuICAgICAgdGhpcy5tX3VwcGVyQW5nbGUgPSB1cHBlcjtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuSXNNb3RvckVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5tX2VuYWJsZU1vdG9yO1xuICAgfVxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5FbmFibGVNb3RvciA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBmbGFnO1xuICAgfVxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5TZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XG4gICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkgc3BlZWQgPSAwO1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBzcGVlZDtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbW90b3JTcGVlZDtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuU2V0TWF4TW90b3JUb3JxdWUgPSBmdW5jdGlvbiAodG9ycXVlKSB7XG4gICAgICBpZiAodG9ycXVlID09PSB1bmRlZmluZWQpIHRvcnF1ZSA9IDA7XG4gICAgICB0aGlzLm1fbWF4TW90b3JUb3JxdWUgPSB0b3JxdWU7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldE1vdG9yVG9ycXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuYjJSZXZvbHV0ZUpvaW50ID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMS5TZXRWKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMi5TZXRWKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gZGVmLnJlZmVyZW5jZUFuZ2xlO1xuICAgICAgdGhpcy5tX2ltcHVsc2UuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgIHRoaXMubV9sb3dlckFuZ2xlID0gZGVmLmxvd2VyQW5nbGU7XG4gICAgICB0aGlzLm1fdXBwZXJBbmdsZSA9IGRlZi51cHBlckFuZ2xlO1xuICAgICAgdGhpcy5tX21heE1vdG9yVG9ycXVlID0gZGVmLm1heE1vdG9yVG9ycXVlO1xuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBkZWYubW90b3JTcGVlZDtcbiAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcbiAgICAgIHRoaXMubV9lbmFibGVNb3RvciA9IGRlZi5lbmFibGVNb3RvcjtcbiAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgfHwgdGhpcy5tX2VuYWJsZUxpbWl0KSB7fVxuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICByMVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgbTEgPSBiQS5tX2ludk1hc3M7XG4gICAgICB2YXIgbTIgPSBiQi5tX2ludk1hc3M7XG4gICAgICB2YXIgaTEgPSBiQS5tX2ludkk7XG4gICAgICB2YXIgaTIgPSBiQi5tX2ludkk7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnggPSBtMSArIG0yICsgcjFZICogcjFZICogaTEgKyByMlkgKiByMlkgKiBpMjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDIueCA9ICgtcjFZICogcjFYICogaTEpIC0gcjJZICogcjJYICogaTI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wzLnggPSAoLXIxWSAqIGkxKSAtIHIyWSAqIGkyO1xuICAgICAgdGhpcy5tX21hc3MuY29sMS55ID0gdGhpcy5tX21hc3MuY29sMi54O1xuICAgICAgdGhpcy5tX21hc3MuY29sMi55ID0gbTEgKyBtMiArIHIxWCAqIHIxWCAqIGkxICsgcjJYICogcjJYICogaTI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wzLnkgPSByMVggKiBpMSArIHIyWCAqIGkyO1xuICAgICAgdGhpcy5tX21hc3MuY29sMS56ID0gdGhpcy5tX21hc3MuY29sMy54O1xuICAgICAgdGhpcy5tX21hc3MuY29sMi56ID0gdGhpcy5tX21hc3MuY29sMy55O1xuICAgICAgdGhpcy5tX21hc3MuY29sMy56ID0gaTEgKyBpMjtcbiAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAxLjAgLyAoaTEgKyBpMik7XG4gICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yID09IGZhbHNlKSB7XG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCkge1xuICAgICAgICAgdmFyIGpvaW50QW5nbGUgPSBiQi5tX3N3ZWVwLmEgLSBiQS5tX3N3ZWVwLmEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgICBpZiAoYjJNYXRoLkFicyh0aGlzLm1fdXBwZXJBbmdsZSAtIHRoaXMubV9sb3dlckFuZ2xlKSA8IDIuMCAqIGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3ApIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2VxdWFsTGltaXRzO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAoam9pbnRBbmdsZSA8PSB0aGlzLm1fbG93ZXJBbmdsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9hdExvd2VyTGltaXQ7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmIChqb2ludEFuZ2xlID49IHRoaXMubV91cHBlckFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdDtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHZhciBQWCA9IHRoaXMubV9pbXB1bHNlLng7XG4gICAgICAgICB2YXIgUFkgPSB0aGlzLm1faW1wdWxzZS55O1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54IC09IG0xICogUFg7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gbTEgKiBQWTtcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5IC09IGkxICogKChyMVggKiBQWSAtIHIxWSAqIFBYKSArIHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KTtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBtMiAqIFBYO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IG0yICogUFk7XG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBpMiAqICgocjJYICogUFkgLSByMlkgKiBQWCkgKyB0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICB9XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLlNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgbmV3SW1wdWxzZSA9IDA7XG4gICAgICB2YXIgcjFYID0gMDtcbiAgICAgIHZhciByMVkgPSAwO1xuICAgICAgdmFyIHIyWCA9IDA7XG4gICAgICB2YXIgcjJZID0gMDtcbiAgICAgIHZhciB2MSA9IGJBLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzEgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciB2MiA9IGJCLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzIgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciBtMSA9IGJBLm1faW52TWFzcztcbiAgICAgIHZhciBtMiA9IGJCLm1faW52TWFzcztcbiAgICAgIHZhciBpMSA9IGJBLm1faW52STtcbiAgICAgIHZhciBpMiA9IGJCLm1faW52STtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2VxdWFsTGltaXRzKSB7XG4gICAgICAgICB2YXIgQ2RvdCA9IHcyIC0gdzEgLSB0aGlzLm1fbW90b3JTcGVlZDtcbiAgICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5tX21vdG9yTWFzcyAqICgoLUNkb3QpKTtcbiAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZTtcbiAgICAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSBiMk1hdGguQ2xhbXAodGhpcy5tX21vdG9ySW1wdWxzZSArIGltcHVsc2UsICgtbWF4SW1wdWxzZSksIG1heEltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgdzEgLT0gaTEgKiBpbXB1bHNlO1xuICAgICAgICAgdzIgKz0gaTIgKiBpbXB1bHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdCkge1xuICAgICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgICAgIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgICAgIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xuICAgICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xuICAgICAgICAgcjFYID0gdFg7XG4gICAgICAgICB0TWF0ID0gYkIubV94Zi5SO1xuICAgICAgICAgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICAgICByMlggPSB0WDtcbiAgICAgICAgIHZhciBDZG90MVggPSB2Mi54ICsgKCgtdzIgKiByMlkpKSAtIHYxLnggLSAoKC13MSAqIHIxWSkpO1xuICAgICAgICAgdmFyIENkb3QxWSA9IHYyLnkgKyAodzIgKiByMlgpIC0gdjEueSAtICh3MSAqIHIxWCk7XG4gICAgICAgICB2YXIgQ2RvdDIgPSB3MiAtIHcxO1xuICAgICAgICAgdGhpcy5tX21hc3MuU29sdmUzMyh0aGlzLmltcHVsc2UzLCAoLUNkb3QxWCksICgtQ2RvdDFZKSwgKC1DZG90MikpO1xuICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9lcXVhbExpbWl0cykge1xuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuQWRkKHRoaXMuaW1wdWxzZTMpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlLnogKyB0aGlzLmltcHVsc2UzLno7XG4gICAgICAgICAgICBpZiAobmV3SW1wdWxzZSA8IDAuMCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX21hc3MuU29sdmUyMih0aGlzLnJlZHVjZWQsICgtQ2RvdDFYKSwgKC1DZG90MVkpKTtcbiAgICAgICAgICAgICAgIHRoaXMuaW1wdWxzZTMueCA9IHRoaXMucmVkdWNlZC54O1xuICAgICAgICAgICAgICAgdGhpcy5pbXB1bHNlMy55ID0gdGhpcy5yZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICB0aGlzLmltcHVsc2UzLnogPSAoLXRoaXMubV9pbXB1bHNlLnopO1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSB0aGlzLnJlZHVjZWQueDtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gdGhpcy5yZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlLnogKyB0aGlzLmltcHVsc2UzLno7XG4gICAgICAgICAgICBpZiAobmV3SW1wdWxzZSA+IDAuMCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX21hc3MuU29sdmUyMih0aGlzLnJlZHVjZWQsICgtQ2RvdDFYKSwgKC1DZG90MVkpKTtcbiAgICAgICAgICAgICAgIHRoaXMuaW1wdWxzZTMueCA9IHRoaXMucmVkdWNlZC54O1xuICAgICAgICAgICAgICAgdGhpcy5pbXB1bHNlMy55ID0gdGhpcy5yZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICB0aGlzLmltcHVsc2UzLnogPSAoLXRoaXMubV9pbXB1bHNlLnopO1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSB0aGlzLnJlZHVjZWQueDtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gdGhpcy5yZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgdjEueCAtPSBtMSAqIHRoaXMuaW1wdWxzZTMueDtcbiAgICAgICAgIHYxLnkgLT0gbTEgKiB0aGlzLmltcHVsc2UzLnk7XG4gICAgICAgICB3MSAtPSBpMSAqIChyMVggKiB0aGlzLmltcHVsc2UzLnkgLSByMVkgKiB0aGlzLmltcHVsc2UzLnggKyB0aGlzLmltcHVsc2UzLnopO1xuICAgICAgICAgdjIueCArPSBtMiAqIHRoaXMuaW1wdWxzZTMueDtcbiAgICAgICAgIHYyLnkgKz0gbTIgKiB0aGlzLmltcHVsc2UzLnk7XG4gICAgICAgICB3MiArPSBpMiAqIChyMlggKiB0aGlzLmltcHVsc2UzLnkgLSByMlkgKiB0aGlzLmltcHVsc2UzLnggKyB0aGlzLmltcHVsc2UzLnopO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgICAgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICAgICByMVggPSB0WDtcbiAgICAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICAgICByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICAgICByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgICAgIHIyWCA9IHRYO1xuICAgICAgICAgdmFyIENkb3RYID0gdjIueCArICgoLXcyICogcjJZKSkgLSB2MS54IC0gKCgtdzEgKiByMVkpKTtcbiAgICAgICAgIHZhciBDZG90WSA9IHYyLnkgKyAodzIgKiByMlgpIC0gdjEueSAtICh3MSAqIHIxWCk7XG4gICAgICAgICB0aGlzLm1fbWFzcy5Tb2x2ZTIyKHRoaXMuaW1wdWxzZTIsICgtQ2RvdFgpLCAoLUNkb3RZKSk7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICs9IHRoaXMuaW1wdWxzZTIueDtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gdGhpcy5pbXB1bHNlMi55O1xuICAgICAgICAgdjEueCAtPSBtMSAqIHRoaXMuaW1wdWxzZTIueDtcbiAgICAgICAgIHYxLnkgLT0gbTEgKiB0aGlzLmltcHVsc2UyLnk7XG4gICAgICAgICB3MSAtPSBpMSAqIChyMVggKiB0aGlzLmltcHVsc2UyLnkgLSByMVkgKiB0aGlzLmltcHVsc2UyLngpO1xuICAgICAgICAgdjIueCArPSBtMiAqIHRoaXMuaW1wdWxzZTIueDtcbiAgICAgICAgIHYyLnkgKz0gbTIgKiB0aGlzLmltcHVsc2UyLnk7XG4gICAgICAgICB3MiArPSBpMiAqIChyMlggKiB0aGlzLmltcHVsc2UyLnkgLSByMlkgKiB0aGlzLmltcHVsc2UyLngpO1xuICAgICAgfVxuICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS5TZXRWKHYxKTtcbiAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5ID0gdzE7XG4gICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LlNldFYodjIpO1xuICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgPSB3MjtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xuICAgICAgdmFyIG9sZExpbWl0SW1wdWxzZSA9IDA7XG4gICAgICB2YXIgQyA9IDA7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHZhciBhbmd1bGFyRXJyb3IgPSAwLjA7XG4gICAgICB2YXIgcG9zaXRpb25FcnJvciA9IDAuMDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgaW1wdWxzZVggPSAwO1xuICAgICAgdmFyIGltcHVsc2VZID0gMDtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQpIHtcbiAgICAgICAgIHZhciBhbmdsZSA9IGJCLm1fc3dlZXAuYSAtIGJBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgIHZhciBsaW1pdEltcHVsc2UgPSAwLjA7XG4gICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2VxdWFsTGltaXRzKSB7XG4gICAgICAgICAgICBDID0gYjJNYXRoLkNsYW1wKGFuZ2xlIC0gdGhpcy5tX2xvd2VyQW5nbGUsICgtYjJTZXR0aW5ncy5iMl9tYXhBbmd1bGFyQ29ycmVjdGlvbiksIGIyU2V0dGluZ3MuYjJfbWF4QW5ndWxhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gKC10aGlzLm1fbW90b3JNYXNzICogQyk7XG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBiMk1hdGguQWJzKEMpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgQyA9IGFuZ2xlIC0gdGhpcy5tX2xvd2VyQW5nbGU7XG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSAoLUMpO1xuICAgICAgICAgICAgQyA9IGIyTWF0aC5DbGFtcChDICsgYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcCwgKC1iMlNldHRpbmdzLmIyX21heEFuZ3VsYXJDb3JyZWN0aW9uKSwgMC4wKTtcbiAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9ICgtdGhpcy5tX21vdG9yTWFzcyAqIEMpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgQyA9IGFuZ2xlIC0gdGhpcy5tX3VwcGVyQW5nbGU7XG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBDO1xuICAgICAgICAgICAgQyA9IGIyTWF0aC5DbGFtcChDIC0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcCwgMC4wLCBiMlNldHRpbmdzLmIyX21heEFuZ3VsYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9ICgtdGhpcy5tX21vdG9yTWFzcyAqIEMpO1xuICAgICAgICAgfVxuICAgICAgICAgYkEubV9zd2VlcC5hIC09IGJBLm1faW52SSAqIGxpbWl0SW1wdWxzZTtcbiAgICAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiBsaW1pdEltcHVsc2U7XG4gICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH0ge1xuICAgICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICAgICByMVggPSB0WDtcbiAgICAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgICAgcjJYID0gdFg7XG4gICAgICAgICB2YXIgQ1ggPSBiQi5tX3N3ZWVwLmMueCArIHIyWCAtIGJBLm1fc3dlZXAuYy54IC0gcjFYO1xuICAgICAgICAgdmFyIENZID0gYkIubV9zd2VlcC5jLnkgKyByMlkgLSBiQS5tX3N3ZWVwLmMueSAtIHIxWTtcbiAgICAgICAgIHZhciBDTGVuZ3RoU3F1YXJlZCA9IENYICogQ1ggKyBDWSAqIENZO1xuICAgICAgICAgdmFyIENMZW5ndGggPSBNYXRoLnNxcnQoQ0xlbmd0aFNxdWFyZWQpO1xuICAgICAgICAgcG9zaXRpb25FcnJvciA9IENMZW5ndGg7XG4gICAgICAgICB2YXIgaW52TWFzczEgPSBiQS5tX2ludk1hc3M7XG4gICAgICAgICB2YXIgaW52TWFzczIgPSBiQi5tX2ludk1hc3M7XG4gICAgICAgICB2YXIgaW52STEgPSBiQS5tX2ludkk7XG4gICAgICAgICB2YXIgaW52STIgPSBiQi5tX2ludkk7XG4gICAgICAgICB2YXIga19hbGxvd2VkU3RyZXRjaCA9IDEwLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XG4gICAgICAgICBpZiAoQ0xlbmd0aFNxdWFyZWQgPiBrX2FsbG93ZWRTdHJldGNoICoga19hbGxvd2VkU3RyZXRjaCkge1xuICAgICAgICAgICAgdmFyIHVYID0gQ1ggLyBDTGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHVZID0gQ1kgLyBDTGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGsgPSBpbnZNYXNzMSArIGludk1hc3MyO1xuICAgICAgICAgICAgdmFyIG0gPSAxLjAgLyBrO1xuICAgICAgICAgICAgaW1wdWxzZVggPSBtICogKCgtQ1gpKTtcbiAgICAgICAgICAgIGltcHVsc2VZID0gbSAqICgoLUNZKSk7XG4gICAgICAgICAgICB2YXIga19iZXRhID0gMC41O1xuICAgICAgICAgICAgYkEubV9zd2VlcC5jLnggLT0ga19iZXRhICogaW52TWFzczEgKiBpbXB1bHNlWDtcbiAgICAgICAgICAgIGJBLm1fc3dlZXAuYy55IC09IGtfYmV0YSAqIGludk1hc3MxICogaW1wdWxzZVk7XG4gICAgICAgICAgICBiQi5tX3N3ZWVwLmMueCArPSBrX2JldGEgKiBpbnZNYXNzMiAqIGltcHVsc2VYO1xuICAgICAgICAgICAgYkIubV9zd2VlcC5jLnkgKz0ga19iZXRhICogaW52TWFzczIgKiBpbXB1bHNlWTtcbiAgICAgICAgICAgIENYID0gYkIubV9zd2VlcC5jLnggKyByMlggLSBiQS5tX3N3ZWVwLmMueCAtIHIxWDtcbiAgICAgICAgICAgIENZID0gYkIubV9zd2VlcC5jLnkgKyByMlkgLSBiQS5tX3N3ZWVwLmMueSAtIHIxWTtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuSzEuY29sMS54ID0gaW52TWFzczEgKyBpbnZNYXNzMjtcbiAgICAgICAgIHRoaXMuSzEuY29sMi54ID0gMC4wO1xuICAgICAgICAgdGhpcy5LMS5jb2wxLnkgPSAwLjA7XG4gICAgICAgICB0aGlzLksxLmNvbDIueSA9IGludk1hc3MxICsgaW52TWFzczI7XG4gICAgICAgICB0aGlzLksyLmNvbDEueCA9IGludkkxICogcjFZICogcjFZO1xuICAgICAgICAgdGhpcy5LMi5jb2wyLnggPSAoLWludkkxICogcjFYICogcjFZKTtcbiAgICAgICAgIHRoaXMuSzIuY29sMS55ID0gKC1pbnZJMSAqIHIxWCAqIHIxWSk7XG4gICAgICAgICB0aGlzLksyLmNvbDIueSA9IGludkkxICogcjFYICogcjFYO1xuICAgICAgICAgdGhpcy5LMy5jb2wxLnggPSBpbnZJMiAqIHIyWSAqIHIyWTtcbiAgICAgICAgIHRoaXMuSzMuY29sMi54ID0gKC1pbnZJMiAqIHIyWCAqIHIyWSk7XG4gICAgICAgICB0aGlzLkszLmNvbDEueSA9ICgtaW52STIgKiByMlggKiByMlkpO1xuICAgICAgICAgdGhpcy5LMy5jb2wyLnkgPSBpbnZJMiAqIHIyWCAqIHIyWDtcbiAgICAgICAgIHRoaXMuSy5TZXRNKHRoaXMuSzEpO1xuICAgICAgICAgdGhpcy5LLkFkZE0odGhpcy5LMik7XG4gICAgICAgICB0aGlzLksuQWRkTSh0aGlzLkszKTtcbiAgICAgICAgIHRoaXMuSy5Tb2x2ZShiMlJldm9sdXRlSm9pbnQudEltcHVsc2UsICgtQ1gpLCAoLUNZKSk7XG4gICAgICAgICBpbXB1bHNlWCA9IGIyUmV2b2x1dGVKb2ludC50SW1wdWxzZS54O1xuICAgICAgICAgaW1wdWxzZVkgPSBiMlJldm9sdXRlSm9pbnQudEltcHVsc2UueTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy54IC09IGJBLm1faW52TWFzcyAqIGltcHVsc2VYO1xuICAgICAgICAgYkEubV9zd2VlcC5jLnkgLT0gYkEubV9pbnZNYXNzICogaW1wdWxzZVk7XG4gICAgICAgICBiQS5tX3N3ZWVwLmEgLT0gYkEubV9pbnZJICogKHIxWCAqIGltcHVsc2VZIC0gcjFZICogaW1wdWxzZVgpO1xuICAgICAgICAgYkIubV9zd2VlcC5jLnggKz0gYkIubV9pbnZNYXNzICogaW1wdWxzZVg7XG4gICAgICAgICBiQi5tX3N3ZWVwLmMueSArPSBiQi5tX2ludk1hc3MgKiBpbXB1bHNlWTtcbiAgICAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiAocjJYICogaW1wdWxzZVkgLSByMlkgKiBpbXB1bHNlWCk7XG4gICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcDtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludC50SW1wdWxzZSA9IG5ldyBiMlZlYzIoKTtcbiAgIH0pO1xuICAgQm94MkQuaW5oZXJpdChiMlJldm9sdXRlSm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyUmV2b2x1dGVKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcbiAgIGIyUmV2b2x1dGVKb2ludERlZi5iMlJldm9sdXRlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyUmV2b2x1dGVKb2ludERlZi5wcm90b3R5cGUuYjJSZXZvbHV0ZUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudHlwZSA9IGIySm9pbnQuZV9yZXZvbHV0ZUpvaW50O1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckEuU2V0KDAuMCwgMC4wKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldCgwLjAsIDAuMCk7XG4gICAgICB0aGlzLnJlZmVyZW5jZUFuZ2xlID0gMC4wO1xuICAgICAgdGhpcy5sb3dlckFuZ2xlID0gMC4wO1xuICAgICAgdGhpcy51cHBlckFuZ2xlID0gMC4wO1xuICAgICAgdGhpcy5tYXhNb3RvclRvcnF1ZSA9IDAuMDtcbiAgICAgIHRoaXMubW90b3JTcGVlZCA9IDAuMDtcbiAgICAgIHRoaXMuZW5hYmxlTGltaXQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW5hYmxlTW90b3IgPSBmYWxzZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludERlZi5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChiQSwgYkIsIGFuY2hvcikge1xuICAgICAgdGhpcy5ib2R5QSA9IGJBO1xuICAgICAgdGhpcy5ib2R5QiA9IGJCO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSB0aGlzLmJvZHlBLkdldExvY2FsUG9pbnQoYW5jaG9yKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gdGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcik7XG4gICAgICB0aGlzLnJlZmVyZW5jZUFuZ2xlID0gdGhpcy5ib2R5Qi5HZXRBbmdsZSgpIC0gdGhpcy5ib2R5QS5HZXRBbmdsZSgpO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMldlbGRKb2ludCwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQpO1xuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMldlbGRKb2ludC5iMldlbGRKb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2ltcHVsc2UgPSBuZXcgYjJWZWMzKCk7XG4gICAgICB0aGlzLm1fbWFzcyA9IG5ldyBiMk1hdDMzKCk7XG4gICB9O1xuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICB9XG4gICBiMldlbGRKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgIH1cbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueSk7XG4gICB9XG4gICBiMldlbGRKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UuejtcbiAgIH1cbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5iMldlbGRKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50LmNhbGwodGhpcywgZGVmKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuU2V0VihkZWYubG9jYWxBbmNob3JBKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuU2V0VihkZWYubG9jYWxBbmNob3JCKTtcbiAgICAgIHRoaXMubV9yZWZlcmVuY2VBbmdsZSA9IGRlZi5yZWZlcmVuY2VBbmdsZTtcbiAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgIHRoaXMubV9tYXNzID0gbmV3IGIyTWF0MzMoKTtcbiAgIH1cbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHJBWCA9IHRoaXMubV9sb2NhbEFuY2hvckEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByQVkgPSB0aGlzLm1fbG9jYWxBbmNob3JBLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHJBWCArIHRNYXQuY29sMi54ICogckFZKTtcbiAgICAgIHJBWSA9ICh0TWF0LmNvbDEueSAqIHJBWCArIHRNYXQuY29sMi55ICogckFZKTtcbiAgICAgIHJBWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByQlggPSB0aGlzLm1fbG9jYWxBbmNob3JCLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgckJZID0gdGhpcy5tX2xvY2FsQW5jaG9yQi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQlggKyB0TWF0LmNvbDIueCAqIHJCWSk7XG4gICAgICByQlkgPSAodE1hdC5jb2wxLnkgKiByQlggKyB0TWF0LmNvbDIueSAqIHJCWSk7XG4gICAgICByQlggPSB0WDtcbiAgICAgIHZhciBtQSA9IGJBLm1faW52TWFzcztcbiAgICAgIHZhciBtQiA9IGJCLm1faW52TWFzcztcbiAgICAgIHZhciBpQSA9IGJBLm1faW52STtcbiAgICAgIHZhciBpQiA9IGJCLm1faW52STtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDEueCA9IG1BICsgbUIgKyByQVkgKiByQVkgKiBpQSArIHJCWSAqIHJCWSAqIGlCO1xuICAgICAgdGhpcy5tX21hc3MuY29sMi54ID0gKC1yQVkgKiByQVggKiBpQSkgLSByQlkgKiByQlggKiBpQjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueCA9ICgtckFZICogaUEpIC0gckJZICogaUI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnkgPSB0aGlzLm1fbWFzcy5jb2wyLng7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnkgPSBtQSArIG1CICsgckFYICogckFYICogaUEgKyByQlggKiByQlggKiBpQjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueSA9IHJBWCAqIGlBICsgckJYICogaUI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnogPSB0aGlzLm1fbWFzcy5jb2wzLng7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnogPSB0aGlzLm1fbWFzcy5jb2wzLnk7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wzLnogPSBpQSArIGlCO1xuICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggLT0gbUEgKiB0aGlzLm1faW1wdWxzZS54O1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55IC09IG1BICogdGhpcy5tX2ltcHVsc2UueTtcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5IC09IGlBICogKHJBWCAqIHRoaXMubV9pbXB1bHNlLnkgLSByQVkgKiB0aGlzLm1faW1wdWxzZS54ICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gbUIgKiB0aGlzLm1faW1wdWxzZS54O1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IG1CICogdGhpcy5tX2ltcHVsc2UueTtcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGlCICogKHJCWCAqIHRoaXMubV9pbXB1bHNlLnkgLSByQlkgKiB0aGlzLm1faW1wdWxzZS54ICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHZBID0gYkEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3QSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIHZCID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3QiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xuICAgICAgdmFyIG1CID0gYkIubV9pbnZNYXNzO1xuICAgICAgdmFyIGlBID0gYkEubV9pbnZJO1xuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgckFZID0gdGhpcy5tX2xvY2FsQW5jaG9yQS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQVggKyB0TWF0LmNvbDIueCAqIHJBWSk7XG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XG4gICAgICByQVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHJCWSA9IHRoaXMubV9sb2NhbEFuY2hvckIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckJYICsgdE1hdC5jb2wyLnggKiByQlkpO1xuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xuICAgICAgckJYID0gdFg7XG4gICAgICB2YXIgQ2RvdDFYID0gdkIueCAtIHdCICogckJZIC0gdkEueCArIHdBICogckFZO1xuICAgICAgdmFyIENkb3QxWSA9IHZCLnkgKyB3QiAqIHJCWCAtIHZBLnkgLSB3QSAqIHJBWDtcbiAgICAgIHZhciBDZG90MiA9IHdCIC0gd0E7XG4gICAgICB2YXIgaW1wdWxzZSA9IG5ldyBiMlZlYzMoKTtcbiAgICAgIHRoaXMubV9tYXNzLlNvbHZlMzMoaW1wdWxzZSwgKC1DZG90MVgpLCAoLUNkb3QxWSksICgtQ2RvdDIpKTtcbiAgICAgIHRoaXMubV9pbXB1bHNlLkFkZChpbXB1bHNlKTtcbiAgICAgIHZBLnggLT0gbUEgKiBpbXB1bHNlLng7XG4gICAgICB2QS55IC09IG1BICogaW1wdWxzZS55O1xuICAgICAgd0EgLT0gaUEgKiAockFYICogaW1wdWxzZS55IC0gckFZICogaW1wdWxzZS54ICsgaW1wdWxzZS56KTtcbiAgICAgIHZCLnggKz0gbUIgKiBpbXB1bHNlLng7XG4gICAgICB2Qi55ICs9IG1CICogaW1wdWxzZS55O1xuICAgICAgd0IgKz0gaUIgKiAockJYICogaW1wdWxzZS55IC0gckJZICogaW1wdWxzZS54ICsgaW1wdWxzZS56KTtcbiAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5ID0gd0E7XG4gICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSA9IHdCO1xuICAgfVxuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChiYXVtZ2FydGUpIHtcbiAgICAgIGlmIChiYXVtZ2FydGUgPT09IHVuZGVmaW5lZCkgYmF1bWdhcnRlID0gMDtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICB2YXIgckFYID0gdGhpcy5tX2xvY2FsQW5jaG9yQS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHJBWSA9IHRoaXMubV9sb2NhbEFuY2hvckEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckFYICsgdE1hdC5jb2wyLnggKiByQVkpO1xuICAgICAgckFZID0gKHRNYXQuY29sMS55ICogckFYICsgdE1hdC5jb2wyLnkgKiByQVkpO1xuICAgICAgckFYID0gdFg7XG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xuICAgICAgdmFyIHJCWCA9IHRoaXMubV9sb2NhbEFuY2hvckIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByQlkgPSB0aGlzLm1fbG9jYWxBbmNob3JCLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHJCWCArIHRNYXQuY29sMi54ICogckJZKTtcbiAgICAgIHJCWSA9ICh0TWF0LmNvbDEueSAqIHJCWCArIHRNYXQuY29sMi55ICogckJZKTtcbiAgICAgIHJCWCA9IHRYO1xuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xuICAgICAgdmFyIG1CID0gYkIubV9pbnZNYXNzO1xuICAgICAgdmFyIGlBID0gYkEubV9pbnZJO1xuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xuICAgICAgdmFyIEMxWCA9IGJCLm1fc3dlZXAuYy54ICsgckJYIC0gYkEubV9zd2VlcC5jLnggLSByQVg7XG4gICAgICB2YXIgQzFZID0gYkIubV9zd2VlcC5jLnkgKyByQlkgLSBiQS5tX3N3ZWVwLmMueSAtIHJBWTtcbiAgICAgIHZhciBDMiA9IGJCLm1fc3dlZXAuYSAtIGJBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgIHZhciBrX2FsbG93ZWRTdHJldGNoID0gMTAuMCAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcbiAgICAgIHZhciBwb3NpdGlvbkVycm9yID0gTWF0aC5zcXJ0KEMxWCAqIEMxWCArIEMxWSAqIEMxWSk7XG4gICAgICB2YXIgYW5ndWxhckVycm9yID0gYjJNYXRoLkFicyhDMik7XG4gICAgICBpZiAocG9zaXRpb25FcnJvciA+IGtfYWxsb3dlZFN0cmV0Y2gpIHtcbiAgICAgICAgIGlBICo9IDEuMDtcbiAgICAgICAgIGlCICo9IDEuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9tYXNzLmNvbDEueCA9IG1BICsgbUIgKyByQVkgKiByQVkgKiBpQSArIHJCWSAqIHJCWSAqIGlCO1xuICAgICAgdGhpcy5tX21hc3MuY29sMi54ID0gKC1yQVkgKiByQVggKiBpQSkgLSByQlkgKiByQlggKiBpQjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueCA9ICgtckFZICogaUEpIC0gckJZICogaUI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnkgPSB0aGlzLm1fbWFzcy5jb2wyLng7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnkgPSBtQSArIG1CICsgckFYICogckFYICogaUEgKyByQlggKiByQlggKiBpQjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueSA9IHJBWCAqIGlBICsgckJYICogaUI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnogPSB0aGlzLm1fbWFzcy5jb2wzLng7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnogPSB0aGlzLm1fbWFzcy5jb2wzLnk7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wzLnogPSBpQSArIGlCO1xuICAgICAgdmFyIGltcHVsc2UgPSBuZXcgYjJWZWMzKCk7XG4gICAgICB0aGlzLm1fbWFzcy5Tb2x2ZTMzKGltcHVsc2UsICgtQzFYKSwgKC1DMVkpLCAoLUMyKSk7XG4gICAgICBiQS5tX3N3ZWVwLmMueCAtPSBtQSAqIGltcHVsc2UueDtcbiAgICAgIGJBLm1fc3dlZXAuYy55IC09IG1BICogaW1wdWxzZS55O1xuICAgICAgYkEubV9zd2VlcC5hIC09IGlBICogKHJBWCAqIGltcHVsc2UueSAtIHJBWSAqIGltcHVsc2UueCArIGltcHVsc2Uueik7XG4gICAgICBiQi5tX3N3ZWVwLmMueCArPSBtQiAqIGltcHVsc2UueDtcbiAgICAgIGJCLm1fc3dlZXAuYy55ICs9IG1CICogaW1wdWxzZS55O1xuICAgICAgYkIubV9zd2VlcC5hICs9IGlCICogKHJCWCAqIGltcHVsc2UueSAtIHJCWSAqIGltcHVsc2UueCArIGltcHVsc2Uueik7XG4gICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcDtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJXZWxkSm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyV2VsZEpvaW50RGVmLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYucHJvdG90eXBlO1xuICAgYjJXZWxkSm9pbnREZWYuYjJXZWxkSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyV2VsZEpvaW50RGVmLnByb3RvdHlwZS5iMldlbGRKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50RGVmLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfd2VsZEpvaW50O1xuICAgICAgdGhpcy5yZWZlcmVuY2VBbmdsZSA9IDAuMDtcbiAgIH1cbiAgIGIyV2VsZEpvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgYW5jaG9yKSB7XG4gICAgICB0aGlzLmJvZHlBID0gYkE7XG4gICAgICB0aGlzLmJvZHlCID0gYkI7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQS5TZXRWKHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3IpKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldFYodGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcikpO1xuICAgICAgdGhpcy5yZWZlcmVuY2VBbmdsZSA9IHRoaXMuYm9keUIuR2V0QW5nbGUoKSAtIHRoaXMuYm9keUEuR2V0QW5nbGUoKTtcbiAgIH1cbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyRGVidWdEcmF3ID0gQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXc7XG4gICBiMkRlYnVnRHJhdy5iMkRlYnVnRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9kcmF3U2NhbGUgPSAxLjA7XG4gICAgICB0aGlzLm1fbGluZVRoaWNrbmVzcyA9IDEuMDtcbiAgICAgIHRoaXMubV9hbHBoYSA9IDEuMDtcbiAgICAgIHRoaXMubV9maWxsQWxwaGEgPSAxLjA7XG4gICAgICB0aGlzLm1feGZvcm1TY2FsZSA9IDEuMDtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgLy8jV09SS0FST1VORFxuICAgICAgdGhpcy5tX3Nwcml0ZSA9IHtcbiAgICAgICAgIGdyYXBoaWNzOiB7XG4gICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgX190aGlzLm1fY3R4LmNsZWFyUmVjdCgwLCAwLCBfX3RoaXMubV9jdHguY2FudmFzLndpZHRoLCBfX3RoaXMubV9jdHguY2FudmFzLmhlaWdodClcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH07XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLl9jb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEpIHtcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyAoKGNvbG9yICYgMHhGRjAwMDApID4+IDE2KSArIFwiLFwiICsgKChjb2xvciAmIDB4RkYwMCkgPj4gOCkgKyBcIixcIiArIChjb2xvciAmIDB4RkYpICsgXCIsXCIgKyBhbHBoYSArIFwiKVwiO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5iMkRlYnVnRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9kcmF3RmxhZ3MgPSAwO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXRGbGFncyA9IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgaWYgKGZsYWdzID09PSB1bmRlZmluZWQpIGZsYWdzID0gMDtcbiAgICAgIHRoaXMubV9kcmF3RmxhZ3MgPSBmbGFncztcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RyYXdGbGFncztcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuQXBwZW5kRmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XG4gICAgICB0aGlzLm1fZHJhd0ZsYWdzIHw9IGZsYWdzO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5DbGVhckZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICBpZiAoZmxhZ3MgPT09IHVuZGVmaW5lZCkgZmxhZ3MgPSAwO1xuICAgICAgdGhpcy5tX2RyYXdGbGFncyAmPSB+ZmxhZ3M7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldFNwcml0ZSA9IGZ1bmN0aW9uIChzcHJpdGUpIHtcbiAgICAgIHRoaXMubV9jdHggPSBzcHJpdGU7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkdldFNwcml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY3R4O1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXREcmF3U2NhbGUgPSBmdW5jdGlvbiAoZHJhd1NjYWxlKSB7XG4gICAgICBpZiAoZHJhd1NjYWxlID09PSB1bmRlZmluZWQpIGRyYXdTY2FsZSA9IDA7XG4gICAgICB0aGlzLm1fZHJhd1NjYWxlID0gZHJhd1NjYWxlO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXREcmF3U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RyYXdTY2FsZTtcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0TGluZVRoaWNrbmVzcyA9IGZ1bmN0aW9uIChsaW5lVGhpY2tuZXNzKSB7XG4gICAgICBpZiAobGluZVRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkKSBsaW5lVGhpY2tuZXNzID0gMDtcbiAgICAgIHRoaXMubV9saW5lVGhpY2tuZXNzID0gbGluZVRoaWNrbmVzcztcbiAgICAgIHRoaXMubV9jdHguc3Ryb2tlV2lkdGggPSBsaW5lVGhpY2tuZXNzO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRMaW5lVGhpY2tuZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9saW5lVGhpY2tuZXNzO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXRBbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcbiAgICAgIHRoaXMubV9hbHBoYSA9IGFscGhhO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRBbHBoYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYWxwaGE7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldEZpbGxBbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcbiAgICAgIHRoaXMubV9maWxsQWxwaGEgPSBhbHBoYTtcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RmlsbEFscGhhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9maWxsQWxwaGE7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldFhGb3JtU2NhbGUgPSBmdW5jdGlvbiAoeGZvcm1TY2FsZSkge1xuICAgICAgaWYgKHhmb3JtU2NhbGUgPT09IHVuZGVmaW5lZCkgeGZvcm1TY2FsZSA9IDA7XG4gICAgICB0aGlzLm1feGZvcm1TY2FsZSA9IHhmb3JtU2NhbGU7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkdldFhGb3JtU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3hmb3JtU2NhbGU7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdQb2x5Z29uID0gZnVuY3Rpb24gKHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCwgY29sb3IpIHtcbiAgICAgIGlmICghdmVydGV4Q291bnQpIHJldHVybjtcbiAgICAgIHZhciBzID0gdGhpcy5tX2N0eDtcbiAgICAgIHZhciBkcmF3U2NhbGUgPSB0aGlzLm1fZHJhd1NjYWxlO1xuICAgICAgcy5iZWdpblBhdGgoKTtcbiAgICAgIHMuc3Ryb2tlU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2FscGhhKTtcbiAgICAgIHMubW92ZVRvKHZlcnRpY2VzWzBdLnggKiBkcmF3U2NhbGUsIHZlcnRpY2VzWzBdLnkgKiBkcmF3U2NhbGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XG4gICAgICAgICBzLmxpbmVUbyh2ZXJ0aWNlc1tpXS54ICogZHJhd1NjYWxlLCB2ZXJ0aWNlc1tpXS55ICogZHJhd1NjYWxlKTtcbiAgICAgIH1cbiAgICAgIHMubGluZVRvKHZlcnRpY2VzWzBdLnggKiBkcmF3U2NhbGUsIHZlcnRpY2VzWzBdLnkgKiBkcmF3U2NhbGUpO1xuICAgICAgcy5jbG9zZVBhdGgoKTtcbiAgICAgIHMuc3Ryb2tlKCk7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdTb2xpZFBvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50LCBjb2xvcikge1xuICAgICAgaWYgKCF2ZXJ0ZXhDb3VudCkgcmV0dXJuO1xuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4O1xuICAgICAgdmFyIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGU7XG4gICAgICBzLmJlZ2luUGF0aCgpO1xuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKGNvbG9yLmNvbG9yLCB0aGlzLm1fYWxwaGEpO1xuICAgICAgcy5maWxsU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2ZpbGxBbHBoYSk7XG4gICAgICBzLm1vdmVUbyh2ZXJ0aWNlc1swXS54ICogZHJhd1NjYWxlLCB2ZXJ0aWNlc1swXS55ICogZHJhd1NjYWxlKTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgICAgICAgcy5saW5lVG8odmVydGljZXNbaV0ueCAqIGRyYXdTY2FsZSwgdmVydGljZXNbaV0ueSAqIGRyYXdTY2FsZSk7XG4gICAgICB9XG4gICAgICBzLmxpbmVUbyh2ZXJ0aWNlc1swXS54ICogZHJhd1NjYWxlLCB2ZXJ0aWNlc1swXS55ICogZHJhd1NjYWxlKTtcbiAgICAgIHMuY2xvc2VQYXRoKCk7XG4gICAgICBzLmZpbGwoKTtcbiAgICAgIHMuc3Ryb2tlKCk7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdDaXJjbGUgPSBmdW5jdGlvbiAoY2VudGVyLCByYWRpdXMsIGNvbG9yKSB7XG4gICAgICBpZiAoIXJhZGl1cykgcmV0dXJuO1xuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4O1xuICAgICAgdmFyIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGU7XG4gICAgICBzLmJlZ2luUGF0aCgpO1xuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKGNvbG9yLmNvbG9yLCB0aGlzLm1fYWxwaGEpO1xuICAgICAgcy5hcmMoY2VudGVyLnggKiBkcmF3U2NhbGUsIGNlbnRlci55ICogZHJhd1NjYWxlLCByYWRpdXMgKiBkcmF3U2NhbGUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgIHMuY2xvc2VQYXRoKCk7XG4gICAgICBzLnN0cm9rZSgpO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3U29saWRDaXJjbGUgPSBmdW5jdGlvbiAoY2VudGVyLCByYWRpdXMsIGF4aXMsIGNvbG9yKSB7XG4gICAgICBpZiAoIXJhZGl1cykgcmV0dXJuO1xuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4LFxuICAgICAgICAgZHJhd1NjYWxlID0gdGhpcy5tX2RyYXdTY2FsZSxcbiAgICAgICAgIGN4ID0gY2VudGVyLnggKiBkcmF3U2NhbGUsXG4gICAgICAgICBjeSA9IGNlbnRlci55ICogZHJhd1NjYWxlO1xuICAgICAgcy5tb3ZlVG8oMCwgMCk7XG4gICAgICBzLmJlZ2luUGF0aCgpO1xuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKGNvbG9yLmNvbG9yLCB0aGlzLm1fYWxwaGEpO1xuICAgICAgcy5maWxsU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2ZpbGxBbHBoYSk7XG4gICAgICBzLmFyYyhjeCwgY3ksIHJhZGl1cyAqIGRyYXdTY2FsZSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgcy5tb3ZlVG8oY3gsIGN5KTtcbiAgICAgIHMubGluZVRvKChjZW50ZXIueCArIGF4aXMueCAqIHJhZGl1cykgKiBkcmF3U2NhbGUsIChjZW50ZXIueSArIGF4aXMueSAqIHJhZGl1cykgKiBkcmF3U2NhbGUpO1xuICAgICAgcy5jbG9zZVBhdGgoKTtcbiAgICAgIHMuZmlsbCgpO1xuICAgICAgcy5zdHJva2UoKTtcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1NlZ21lbnQgPSBmdW5jdGlvbiAocDEsIHAyLCBjb2xvcikge1xuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4LFxuICAgICAgICAgZHJhd1NjYWxlID0gdGhpcy5tX2RyYXdTY2FsZTtcbiAgICAgIHMuc3Ryb2tlU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2FscGhhKTtcbiAgICAgIHMuYmVnaW5QYXRoKCk7XG4gICAgICBzLm1vdmVUbyhwMS54ICogZHJhd1NjYWxlLCBwMS55ICogZHJhd1NjYWxlKTtcbiAgICAgIHMubGluZVRvKHAyLnggKiBkcmF3U2NhbGUsIHAyLnkgKiBkcmF3U2NhbGUpO1xuICAgICAgcy5jbG9zZVBhdGgoKTtcbiAgICAgIHMuc3Ryb2tlKCk7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoeGYpIHtcbiAgICAgIHZhciBzID0gdGhpcy5tX2N0eCxcbiAgICAgICAgIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGU7XG4gICAgICBzLmJlZ2luUGF0aCgpO1xuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKDB4ZmYwMDAwLCB0aGlzLm1fYWxwaGEpO1xuICAgICAgcy5tb3ZlVG8oeGYucG9zaXRpb24ueCAqIGRyYXdTY2FsZSwgeGYucG9zaXRpb24ueSAqIGRyYXdTY2FsZSk7XG4gICAgICBzLmxpbmVUbygoeGYucG9zaXRpb24ueCArIHRoaXMubV94Zm9ybVNjYWxlICogeGYuUi5jb2wxLngpICogZHJhd1NjYWxlLCAoeGYucG9zaXRpb24ueSArIHRoaXMubV94Zm9ybVNjYWxlICogeGYuUi5jb2wxLnkpICogZHJhd1NjYWxlKTtcblxuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKDB4ZmYwMCwgdGhpcy5tX2FscGhhKTtcbiAgICAgIHMubW92ZVRvKHhmLnBvc2l0aW9uLnggKiBkcmF3U2NhbGUsIHhmLnBvc2l0aW9uLnkgKiBkcmF3U2NhbGUpO1xuICAgICAgcy5saW5lVG8oKHhmLnBvc2l0aW9uLnggKyB0aGlzLm1feGZvcm1TY2FsZSAqIHhmLlIuY29sMi54KSAqIGRyYXdTY2FsZSwgKHhmLnBvc2l0aW9uLnkgKyB0aGlzLm1feGZvcm1TY2FsZSAqIHhmLlIuY29sMi55KSAqIGRyYXdTY2FsZSk7XG4gICAgICBzLmNsb3NlUGF0aCgpO1xuICAgICAgcy5zdHJva2UoKTtcbiAgIH07XG59KSgpOyAvL3Bvc3QtZGVmaW5pdGlvbnNcbnZhciBpO1xuZm9yIChpID0gMDsgaSA8IEJveDJELnBvc3REZWZzLmxlbmd0aDsgKytpKSBCb3gyRC5wb3N0RGVmc1tpXSgpO1xuZGVsZXRlIEJveDJELnBvc3REZWZzO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQm94MkQ7IiwiLyoqXG4gKiBAbGljZW5zZVxuICogcGl4aS5qcyAtIHYxLjUuMlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIE1hdCBHcm92ZXNcbiAqIGh0dHA6Ly9nb29kYm95ZGlnaXRhbC5jb20vXG4gKlxuICogQ29tcGlsZWQ6IDIwMTQtMDMtMzFcbiAqXG4gKiBwaXhpLmpzIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKi9cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuKGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXM7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIFBJWElcbiAqL1xudmFyIFBJWEkgPSBQSVhJIHx8IHt9O1xuXG4vKiBcbiogXG4qIFRoaXMgZmlsZSBjb250YWlucyBhIGxvdCBvZiBwaXhpIGNvbnN0cyB3aGljaCBhcmUgdXNlZCBhY3Jvc3MgdGhlIHJlbmRlcmluZyBlbmdpbmVcbiogQGNsYXNzIENvbnN0c1xuKi9cblBJWEkuV0VCR0xfUkVOREVSRVIgPSAwO1xuUElYSS5DQU5WQVNfUkVOREVSRVIgPSAxO1xuXG4vLyB1c2VmdWwgZm9yIHRlc3RpbmcgYWdhaW5zdCBpZiB5b3VyIGxpYiBpcyB1c2luZyBwaXhpLlxuUElYSS5WRVJTSU9OID0gXCJ2MS41LjJcIjtcblxuLy8gdGhlIHZhcmlvdXMgYmxlbmQgbW9kZXMgc3VwcG9ydGVkIGJ5IHBpeGlcblBJWEkuYmxlbmRNb2RlcyA9IHtcbiAgICBOT1JNQUw6MCxcbiAgICBBREQ6MSxcbiAgICBNVUxUSVBMWToyLFxuICAgIFNDUkVFTjozLFxuICAgIE9WRVJMQVk6NCxcbiAgICBEQVJLRU46NSxcbiAgICBMSUdIVEVOOjYsXG4gICAgQ09MT1JfRE9ER0U6NyxcbiAgICBDT0xPUl9CVVJOOjgsXG4gICAgSEFSRF9MSUdIVDo5LFxuICAgIFNPRlRfTElHSFQ6MTAsXG4gICAgRElGRkVSRU5DRToxMSxcbiAgICBFWENMVVNJT046MTIsXG4gICAgSFVFOjEzLFxuICAgIFNBVFVSQVRJT046MTQsXG4gICAgQ09MT1I6MTUsXG4gICAgTFVNSU5PU0lUWToxNlxufTtcblxuLy8gdGhlIHNjYWxlIG1vZGVzXG5QSVhJLnNjYWxlTW9kZXMgPSB7XG4gICAgREVGQVVMVDowLFxuICAgIExJTkVBUjowLFxuICAgIE5FQVJFU1Q6MVxufTtcblxuLy8gaW50ZXJhY3Rpb24gZnJlcXVlbmN5IFxuUElYSS5JTlRFUkFDVElPTl9GUkVRVUVOQ1kgPSAzMDtcblBJWEkuQVVUT19QUkVWRU5UX0RFRkFVTFQgPSB0cnVlO1xuXG5QSVhJLlJBRF9UT19ERUcgPSAxODAgLyBNYXRoLlBJO1xuUElYSS5ERUdfVE9fUkFEID0gTWF0aC5QSSAvIDE4MDtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGUgUG9pbnQgb2JqZWN0IHJlcHJlc2VudHMgYSBsb2NhdGlvbiBpbiBhIHR3by1kaW1lbnNpb25hbCBjb29yZGluYXRlIHN5c3RlbSwgd2hlcmUgeCByZXByZXNlbnRzIHRoZSBob3Jpem9udGFsIGF4aXMgYW5kIHkgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgYXhpcy5cbiAqXG4gKiBAY2xhc3MgUG9pbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHgge051bWJlcn0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gKi9cblBJWEkuUG9pbnQgPSBmdW5jdGlvbih4LCB5KVxue1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB4XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IHggfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB5XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnRcbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtQb2ludH0gYSBjb3B5IG9mIHRoZSBwb2ludFxuICovXG5QSVhJLlBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKClcbntcbiAgICByZXR1cm4gbmV3IFBJWEkuUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5Qb2ludDtcblxuUElYSS5Qb2ludC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAoICh5ICE9PSAwKSA/IHRoaXMueCA6IDAgKSA7XG59O1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tL1xuICovXG5cbi8qKlxuICogdGhlIFJlY3RhbmdsZSBvYmplY3QgaXMgYW4gYXJlYSBkZWZpbmVkIGJ5IGl0cyBwb3NpdGlvbiwgYXMgaW5kaWNhdGVkIGJ5IGl0cyB0b3AtbGVmdCBjb3JuZXIgcG9pbnQgKHgsIHkpIGFuZCBieSBpdHMgd2lkdGggYW5kIGl0cyBoZWlnaHQuXG4gKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZCBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmQgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSBUaGUgb3ZlcmFsbCB3aWR0aCBvZiB0aGlzIHJlY3RhbmdsZVxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSBUaGUgb3ZlcmFsbCBoZWlnaHQgb2YgdGhpcyByZWN0YW5nbGVcbiAqL1xuUElYSS5SZWN0YW5nbGUgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB4XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IHggfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB5XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUmVjdGFuZ2xlXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7UmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJlY3RhbmdsZVxuICovXG5QSVhJLlJlY3RhbmdsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIG5ldyBQSVhJLlJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICpcbiAqIEBtZXRob2QgY29udGFpbnNcbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZHMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICovXG5QSVhJLlJlY3RhbmdsZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4LCB5KVxue1xuICAgIGlmKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgeDEgPSB0aGlzLng7XG4gICAgaWYoeCA+PSB4MSAmJiB4IDw9IHgxICsgdGhpcy53aWR0aClcbiAgICB7XG4gICAgICAgIHZhciB5MSA9IHRoaXMueTtcblxuICAgICAgICBpZih5ID49IHkxICYmIHkgPD0geTEgKyB0aGlzLmhlaWdodClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5SZWN0YW5nbGU7XG5cblBJWEkuRW1wdHlSZWN0YW5nbGUgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwwLDAsMCk7XG4vKipcbiAqIEBhdXRob3IgQWRyaWVuIEJyYXVsdCA8YWRyaWVuLmJyYXVsdEBnbWFpbC5jb20+XG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gcG9pbnRzKiB7QXJyYXk8UG9pbnQ+fEFycmF5PE51bWJlcj58UG9pbnQuLi58TnVtYmVyLi4ufSBUaGlzIGNhbiBiZSBhbiBhcnJheSBvZiBQb2ludHMgdGhhdCBmb3JtIHRoZSBwb2x5Z29uLFxuICogICAgICBhIGZsYXQgYXJyYXkgb2YgbnVtYmVycyB0aGF0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgW3gseSwgeCx5LCAuLi5dLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmVcbiAqICAgICAgYWxsIHRoZSBwb2ludHMgb2YgdGhlIHBvbHlnb24gZS5nLiBgbmV3IFBJWEkuUG9seWdvbihuZXcgUElYSS5Qb2ludCgpLCBuZXcgUElYSS5Qb2ludCgpLCAuLi4pYCwgb3IgdGhlXG4gKiAgICAgIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGZsYXQgeCx5IHZhbHVlcyBlLmcuIGBuZXcgUElYSS5Qb2x5Z29uKHgseSwgeCx5LCB4LHksIC4uLilgIHdoZXJlIGB4YCBhbmQgYHlgIGFyZVxuICogICAgICBOdW1iZXJzLlxuICovXG5QSVhJLlBvbHlnb24gPSBmdW5jdGlvbihwb2ludHMpXG57XG4gICAgLy9pZiBwb2ludHMgaXNuJ3QgYW4gYXJyYXksIHVzZSBhcmd1bWVudHMgYXMgdGhlIGFycmF5XG4gICAgaWYoIShwb2ludHMgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICAgIHBvaW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAvL2lmIHRoaXMgaXMgYSBmbGF0IGFycmF5IG9mIG51bWJlcnMsIGNvbnZlcnQgaXQgdG8gcG9pbnRzXG4gICAgaWYodHlwZW9mIHBvaW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrPTIpIHtcbiAgICAgICAgICAgIHAucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgUElYSS5Qb2ludChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnRzID0gcDtcbiAgICB9XG5cbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9seWdvblxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge1BvbHlnb259IGEgY29weSBvZiB0aGUgcG9seWdvblxuICovXG5QSVhJLlBvbHlnb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2godGhpcy5wb2ludHNbaV0uY2xvbmUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQSVhJLlBvbHlnb24ocG9pbnRzKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gKlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gKi9cblBJWEkuUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4LCB5KVxue1xuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcblxuICAgIC8vIHVzZSBzb21lIHJheWNhc3RpbmcgdG8gdGVzdCBoaXRzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL3BvaW50LWluLXBvbHlnb24vYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgICBmb3IodmFyIGkgPSAwLCBqID0gdGhpcy5wb2ludHMubGVuZ3RoIC0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICB2YXIgeGkgPSB0aGlzLnBvaW50c1tpXS54LCB5aSA9IHRoaXMucG9pbnRzW2ldLnksXG4gICAgICAgICAgICB4aiA9IHRoaXMucG9pbnRzW2pdLngsIHlqID0gdGhpcy5wb2ludHNbal0ueSxcbiAgICAgICAgICAgIGludGVyc2VjdCA9ICgoeWkgPiB5KSAhPT0gKHlqID4geSkpICYmICh4IDwgKHhqIC0geGkpICogKHkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aSk7XG5cbiAgICAgICAgaWYoaW50ZXJzZWN0KSBpbnNpZGUgPSAhaW5zaWRlO1xuICAgIH1cblxuICAgIHJldHVybiBpbnNpZGU7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5Qb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuUG9seWdvbjtcblxuLyoqXG4gKiBAYXV0aG9yIENoYWQgRW5nbGVyIDxjaGFkQHBhbnRoZXJkZXYuY29tPlxuICovXG5cbi8qKlxuICogVGhlIENpcmNsZSBvYmplY3QgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGhpdCBhcmVhIGZvciBkaXNwbGF5T2JqZWN0c1xuICpcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoaXMgY2lyY2xlXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhpcyBjaXJjbGVcbiAqIEBwYXJhbSByYWRpdXMge051bWJlcn0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gKi9cblBJWEkuQ2lyY2xlID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzKVxue1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB4XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IHggfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB5XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7Q2lyY2xlfSBhIGNvcHkgb2YgdGhlIHBvbHlnb25cbiAqL1xuUElYSS5DaXJjbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiBuZXcgUElYSS5DaXJjbGUodGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHgsIGFuZCB5IGNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgY2lyY2xlXG4gKlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gKi9cblBJWEkuQ2lyY2xlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHkpXG57XG4gICAgaWYodGhpcy5yYWRpdXMgPD0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGR4ID0gKHRoaXMueCAtIHgpLFxuICAgICAgICBkeSA9ICh0aGlzLnkgLSB5KSxcbiAgICAgICAgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuXG4gICAgZHggKj0gZHg7XG4gICAgZHkgKj0gZHk7XG5cbiAgICByZXR1cm4gKGR4ICsgZHkgPD0gcjIpO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ2lyY2xlO1xuXG5cbi8qKlxuICogQGF1dGhvciBDaGFkIEVuZ2xlciA8Y2hhZEBwYW50aGVyZGV2LmNvbT5cbiAqL1xuXG4vKipcbiAqIFRoZSBFbGxpcHNlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgaGl0IGFyZWEgZm9yIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQGNsYXNzIEVsbGlwc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoaXMgZWxsaXBzZVxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoaXMgZWxsaXBzZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoaXMgZWxsaXBzZVxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSBUaGUgb3ZlcmFsbCBoZWlnaHQgb2YgdGhpcyBlbGxpcHNlXG4gKi9cblBJWEkuRWxsaXBzZSA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0geSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBFbGxpcHNlIGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7RWxsaXBzZX0gYSBjb3B5IG9mIHRoZSBlbGxpcHNlXG4gKi9cblBJWEkuRWxsaXBzZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIG5ldyBQSVhJLkVsbGlwc2UodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gKlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICovXG5QSVhJLkVsbGlwc2UucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSlcbntcbiAgICBpZih0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy9ub3JtYWxpemUgdGhlIGNvb3JkcyB0byBhbiBlbGxpcHNlIHdpdGggY2VudGVyIDAsMFxuICAgIHZhciBub3JteCA9ICgoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoKSxcbiAgICAgICAgbm9ybXkgPSAoKHkgLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHQpO1xuXG4gICAgbm9ybXggKj0gbm9ybXg7XG4gICAgbm9ybXkgKj0gbm9ybXk7XG5cbiAgICByZXR1cm4gKG5vcm14ICsgbm9ybXkgPD0gMSk7XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGVsbGlwc2UgYXMgYSBQSVhJLlJlY3RhbmdsZSBvYmplY3RcbipcbiogQG1ldGhvZCBnZXRCb3VuZHNcbiogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiovXG5QSVhJLkVsbGlwc2UucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKClcbntcbiAgICByZXR1cm4gbmV3IFBJWEkuUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5FbGxpcHNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuRWxsaXBzZTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLmRldGVybWluZU1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG59O1xuXG4vKlxuKiBAY2xhc3MgTWF0cml4MlxuKiBUaGUgTWF0cml4MiBjbGFzcyB3aWxsIGNob29zZSB0aGUgYmVzdCB0eXBlIG9mIGFycmF5IHRvIHVzZSBiZXR3ZWVuXG4qIGEgcmVndWxhciBqYXZhc2NyaXB0IEFycmF5IGFuZCBhIEZsb2F0MzJBcnJheSBpZiB0aGUgbGF0dGVyIGlzIGF2YWlsYWJsZVxuKlxuKi9cblBJWEkuTWF0cml4MiA9IFBJWEkuZGV0ZXJtaW5lTWF0cml4QXJyYXlUeXBlKCk7XG5cbi8qXG4qIEBjbGFzcyBNYXRyaXhcbiogVGhlIE1hdHJpeCBjbGFzcyBpcyBub3cgYW4gb2JqZWN0LCB3aGljaCBtYWtlcyBpdCBhIGxvdCBmYXN0ZXIsIFxuKiBoZXJlIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaXQgOiBcbiogfCBhIHwgYiB8IHR4fFxuKiB8IGMgfCBjIHwgdHl8XG4qIHwgMCB8IDAgfCAxIHxcbipcbiovXG5QSVhJLk1hdHJpeCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmEgPSAxO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5jID0gMDtcbiAgICB0aGlzLmQgPSAxO1xuICAgIHRoaXMudHggPSAwO1xuICAgIHRoaXMudHkgPSAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcGl4aSBtYXRyaXggb2JqZWN0IGJhc2VkIG9uIHRoZSBhcnJheSBnaXZlbiBhcyBhIHBhcmFtZXRlclxuICpcbiAqIEBtZXRob2QgZnJvbUFycmF5XG4gKiBAcGFyYW0gYXJyYXkge0FycmF5fSBUaGUgYXJyYXkgdGhhdCB0aGUgbWF0cml4IHdpbGwgYmUgZmlsbGVkIHdpdGhcbiAqL1xuUElYSS5NYXRyaXgucHJvdG90eXBlLmZyb21BcnJheSA9IGZ1bmN0aW9uKGFycmF5KVxue1xuICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xuICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgIHRoaXMudHggPSBhcnJheVsyXTtcbiAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgZnJvbSB0aGUgY3VycmVudCBNYXRyaXggb2JqZWN0XG4gKlxuICogQG1ldGhvZCB0b0FycmF5XG4gKiBAcGFyYW0gdHJhbnNwb3NlIHtCb29sZWFufSBXaGV0aGVyIHdlIG5lZWQgdG8gdHJhbnNwb3NlIHRoZSBtYXRyaXggb3Igbm90XG4gKiBAcmV0dXJuIGFycmF5IHtBcnJheX0gdGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIG1hdHJpeFxuICovXG5QSVhJLk1hdHJpeC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKHRyYW5zcG9zZSlcbntcbiAgICBpZighdGhpcy5hcnJheSkgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcblxuICAgIGlmKHRyYW5zcG9zZSlcbiAgICB7XG4gICAgICAgIHRoaXMuYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICAgIHRoaXMuYXJyYXlbMV0gPSB0aGlzLmM7XG4gICAgICAgIHRoaXMuYXJyYXlbMl0gPSAwO1xuICAgICAgICB0aGlzLmFycmF5WzNdID0gdGhpcy5iO1xuICAgICAgICB0aGlzLmFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgICB0aGlzLmFycmF5WzVdID0gMDtcbiAgICAgICAgdGhpcy5hcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICAgIHRoaXMuYXJyYXlbN10gPSB0aGlzLnR5O1xuICAgICAgICB0aGlzLmFycmF5WzhdID0gMTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5hcnJheVswXSA9IHRoaXMuYTtcbiAgICAgICAgdGhpcy5hcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgICAgdGhpcy5hcnJheVsyXSA9IHRoaXMudHg7XG4gICAgICAgIHRoaXMuYXJyYXlbM10gPSB0aGlzLmM7XG4gICAgICAgIHRoaXMuYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgIHRoaXMuYXJyYXlbNV0gPSB0aGlzLnR5O1xuICAgICAgICB0aGlzLmFycmF5WzZdID0gMDtcbiAgICAgICAgdGhpcy5hcnJheVs3XSA9IDA7XG4gICAgICAgIHRoaXMuYXJyYXlbOF0gPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTsvL1t0aGlzLmEsIHRoaXMuYiwgdGhpcy50eCwgdGhpcy5jLCB0aGlzLmQsIHRoaXMudHksIDAsIDAsIDFdO1xufTtcblxuUElYSS5pZGVudGl0eU1hdHJpeCA9IG5ldyBQSVhJLk1hdHJpeCgpO1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZCBvbiB0aGUgc2NyZWVuLlxuICpcbiAqIEBjbGFzcyBEaXNwbGF5T2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24oKVxue1xuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgUElYSS5Qb2ludCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIGZhY3RvciBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNjYWxlXG4gICAgICogQHR5cGUgUG9pbnRcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlID0gbmV3IFBJWEkuUG9pbnQoMSwxKTsvL3t4OjEsIHk6MX07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl2b3QgcG9pbnQgb2YgdGhlIGRpc3BsYXlPYmplY3QgdGhhdCBpdCByb3RhdGVzIGFyb3VuZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBpdm90XG4gICAgICogQHR5cGUgUG9pbnRcbiAgICAgKi9cbiAgICB0aGlzLnBpdm90ID0gbmV3IFBJWEkuUG9pbnQoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcm90YXRpb25cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYWxwaGFcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmFscGhhID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgZGVmaW5lZCBhcmVhIHRoYXQgd2lsbCBwaWNrIHVwIG1vdXNlIC8gdG91Y2ggZXZlbnRzLiBJdCBpcyBudWxsIGJ5IGRlZmF1bHQuXG4gICAgICogU2V0dGluZyBpdCBpcyBhIG5lYXQgd2F5IG9mIG9wdGltaXNpbmcgdGhlIGhpdFRlc3QgZnVuY3Rpb24gdGhhdCB0aGUgaW50ZXJhY3Rpb25NYW5hZ2VyIHdpbGwgdXNlIChhcyBpdCB3aWxsIG5vdCBuZWVkIHRvIGhpdCB0ZXN0IGFsbCB0aGUgY2hpbGRyZW4pXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaGl0QXJlYVxuICAgICAqIEB0eXBlIFJlY3RhbmdsZXxDaXJjbGV8RWxsaXBzZXxQb2x5Z29uXG4gICAgICovXG4gICAgdGhpcy5oaXRBcmVhID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBpbmRpY2F0ZSBpZiB0aGUgZGlzcGxheU9iamVjdCBzaG91bGQgZGlzcGxheSBhIG1vdXNlIGhhbmQgY3Vyc29yIG9uIHJvbGxvdmVyXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYnV0dG9uTW9kZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbk1vZGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENhbiB0aGlzIG9iamVjdCBiZSByZW5kZXJlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlcmFibGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgZGlzcGxheSBvYmplY3QgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhpcyBkaXNwbGF5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwYXJlbnRcbiAgICAgKiBAdHlwZSBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIHN0YWdlIHRoZSBkaXNwbGF5IG9iamVjdCBpcyBjb25uZWN0ZWQgdG8sIG9yIHVuZGVmaW5lZCBpZiBpdCBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBzdGFnZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzdGFnZVxuICAgICAqIEB0eXBlIFN0YWdlXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5zdGFnZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgbXVsdGlwbGllZCBhbHBoYSBvZiB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdvcmxkQWxwaGFcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLndvcmxkQWxwaGEgPSAxO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBpbnRlcmFjdGl2ZSwgZG8gbm90IHRvZ2dsZSBkaXJlY3RseSEgdXNlIHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX2ludGVyYWN0aXZlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faW50ZXJhY3RpdmUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGN1cnNvciB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIHRoZSBtb3VzZSBpcyBvdmVyIHRoaXMgb2JqZWN0LiBUbyBlbmFibGUgdGhpcyB0aGUgZWxlbWVudCBtdXN0IGhhdmUgaW50ZXJhY3Rpb24gPSB0cnVlIGFuZCBidXR0b25Nb2RlID0gdHJ1ZVxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0Q3Vyc29yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICpcbiAgICAqL1xuICAgIHRoaXMuZGVmYXVsdEN1cnNvciA9ICdwb2ludGVyJztcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9yc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdvcmxkVHJhbnNmb3JtXG4gICAgICogQHR5cGUgTWF0M1xuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBQSVhJLk1hdHJpeCgpO1xuXG4gICAgLyoqXG4gICAgICogW05ZSV0gVW5rbm93blxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbG9yXG4gICAgICogQHR5cGUgQXJyYXk8PlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb2xvciA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogW05ZSV0gSG9sZHMgd2hldGhlciBvciBub3QgdGhpcyBvYmplY3QgaXMgZHluYW1pYywgZm9yIHJlbmRlcmluZyBvcHRpbWl6YXRpb25cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkeW5hbWljXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5keW5hbWljID0gdHJ1ZTtcblxuICAgIC8vIGNhY2hlZCBzaW4gcm90YXRpb24gYW5kIGNvcyByb3RhdGlvblxuICAgIHRoaXMuX3NyID0gMDtcbiAgICB0aGlzLl9jciA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJlYSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQgdG8gbGlrZSB0aGUgaGl0QXJlYSB0aGlzIGlzIHVzZWQgYXMgbW9yZSBvZiBhbiBvcHRpbWlzYXRpb25cbiAgICAgKiByYXRoZXIgdGhhbiBmaWd1cmluZyBvdXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRpc3BsYXlPYmplY3QgZWFjaCBmcmFtZSB5b3UgY2FuIHNldCB0aGlzIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZpbHRlckFyZWFcbiAgICAgKiBAdHlwZSBSZWN0YW5nbGVcbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsOy8vbmV3IFBJWEkuUmVjdGFuZ2xlKDAsMCwxLDEpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsLCBjYWNoZWQgYm91bmRzIG9mIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfYm91bmRzXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgdXAtdG8tZGF0ZSBib3VuZHMgb2YgdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9jdXJyZW50Qm91bmRzXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZ2luYWwsIGNhY2hlZCBtYXNrIG9mIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfY3VycmVudEJvdW5kc1xuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWFzayA9IG51bGw7XG5cbiAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVJc0RpcnR5ID0gZmFsc2U7XG5cblxuICAgIC8qXG4gICAgICogTU9VU0UgQ2FsbGJhY2tzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VycyBjbGlja3Mgb24gdGhlIGRpc3BsYXlPYmplY3Qgd2l0aCB0aGVpciBtb3VzZVxuICAgICAqIEBtZXRob2QgY2xpY2tcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgbW91c2UgZG93biBvdmVyIHRoZSBzcHJpdGVcbiAgICAgKiBAbWV0aG9kIG1vdXNlZG93blxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIHRoYXQgd2FzIG92ZXIgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBmb3IgdGhpcyBjYWxsYmFjayB0byBiZSBmaXJlZCB0aGUgbW91c2UgbXVzdCBoYXZlIGJlZW4gcHJlc3NlZCBkb3duIG92ZXIgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBAbWV0aG9kIG1vdXNldXBcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSB0aGF0IHdhcyBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0IGJ1dCBpcyBubyBsb25nZXIgb3ZlciB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIGZvciB0aGlzIGNhbGxiYWNrIHRvIGJlIGZpcmVkLCBUaGUgdG91Y2ggbXVzdCBoYXZlIHN0YXJ0ZWQgb3ZlciB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIEBtZXRob2QgbW91c2V1cG91dHNpZGVcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VycyBtb3VzZSByb2xscyBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogQG1ldGhvZCBtb3VzZW92ZXJcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VycyBtb3VzZSBsZWF2ZXMgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBAbWV0aG9kIG1vdXNlb3V0XG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG5cbiAgICAvKlxuICAgICAqIFRPVUNIIENhbGxiYWNrc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlcnMgdGFwcyBvbiB0aGUgc3ByaXRlIHdpdGggdGhlaXIgZmluZ2VyXG4gICAgICogYmFzaWNhbGx5IGEgdG91Y2ggdmVyc2lvbiBvZiBjbGlja1xuICAgICAqIEBtZXRob2QgdGFwXG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgdXNlciB0b3VjaGVzIG92ZXIgdGhlIGRpc3BsYXlPYmplY3RcbiAgICAgKiBAbWV0aG9kIHRvdWNoc3RhcnRcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEgdG91Y2ggb3ZlciB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqIEBtZXRob2QgdG91Y2hlbmRcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3Rpb25EYXRhIHtJbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSB0b3VjaCB0aGF0IHdhcyBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICogZm9yIHRoaXMgY2FsbGJhY2sgdG8gYmUgZmlyZWQsIFRoZSB0b3VjaCBtdXN0IGhhdmUgc3RhcnRlZCBvdmVyIHRoZSBzcHJpdGVcbiAgICAgKiBAbWV0aG9kIHRvdWNoZW5kb3V0c2lkZVxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbkRhdGEge0ludGVyYWN0aW9uRGF0YX1cbiAgICAgKi9cbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5EaXNwbGF5T2JqZWN0O1xuXG4vKipcbiAqIFtEZXByZWNhdGVkXSBJbmRpY2F0ZXMgaWYgdGhlIHNwcml0ZSB3aWxsIGhhdmUgdG91Y2ggYW5kIG1vdXNlIGludGVyYWN0aXZpdHkuIEl0IGlzIGZhbHNlIGJ5IGRlZmF1bHRcbiAqIEluc3RlYWQgb2YgdXNpbmcgdGhpcyBmdW5jdGlvbiB5b3UgY2FuIG5vdyBzaW1wbHkgc2V0IHRoZSBpbnRlcmFjdGl2ZSBwcm9wZXJ0eSB0byB0cnVlIG9yIGZhbHNlXG4gKlxuICogQG1ldGhvZCBzZXRJbnRlcmFjdGl2ZVxuICogQHBhcmFtIGludGVyYWN0aXZlIHtCb29sZWFufVxuICogQGRlcHJlY2F0ZWQgU2ltcGx5IHNldCB0aGUgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBkaXJlY3RseVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnNldEludGVyYWN0aXZlID0gZnVuY3Rpb24oaW50ZXJhY3RpdmUpXG57XG4gICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGludGVyYWN0aXZlO1xufTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgdGhlIHNwcml0ZSB3aWxsIGhhdmUgdG91Y2ggYW5kIG1vdXNlIGludGVyYWN0aXZpdHkuIEl0IGlzIGZhbHNlIGJ5IGRlZmF1bHRcbiAqXG4gKiBAcHJvcGVydHkgaW50ZXJhY3RpdmVcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCAnaW50ZXJhY3RpdmUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aXZlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pbnRlcmFjdGl2ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIFRPRE8gbW9yZSB0byBiZSBkb25lIGhlcmUuLlxuICAgICAgICAvLyBuZWVkIHRvIHNvcnQgb3V0IGEgcmUtY3Jhd2whXG4gICAgICAgIGlmKHRoaXMuc3RhZ2UpdGhpcy5zdGFnZS5kaXJ0eSA9IHRydWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogW3JlYWQtb25seV0gSW5kaWNhdGVzIGlmIHRoZSBzcHJpdGUgaXMgZ2xvYmFseSB2aXNpYmxlLlxuICpcbiAqIEBwcm9wZXJ0eSB3b3JsZFZpc2libGVcbiAqIEB0eXBlIEJvb2xlYW5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsICd3b3JsZFZpc2libGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzO1xuXG4gICAgICAgIGRvXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKCFpdGVtLnZpc2libGUpcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKGl0ZW0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNldHMgYSBtYXNrIGZvciB0aGUgZGlzcGxheU9iamVjdC4gQSBtYXNrIGlzIGFuIG9iamVjdCB0aGF0IGxpbWl0cyB0aGUgdmlzaWJpbGl0eSBvZiBhbiBvYmplY3QgdG8gdGhlIHNoYXBlIG9mIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXQuXG4gKiBJbiBQSVhJIGEgcmVndWxhciBtYXNrIG11c3QgYmUgYSBQSVhJLkdyYXBoaWNzIG9iamVjdC4gVGhpcyBhbGxvd3MgZm9yIG11Y2ggZmFzdGVyIG1hc2tpbmcgaW4gY2FudmFzIGFzIGl0IHV0aWxpc2VzIHNoYXBlIGNsaXBwaW5nLlxuICogVG8gcmVtb3ZlIGEgbWFzaywgc2V0IHRoaXMgcHJvcGVydHkgdG8gbnVsbC5cbiAqXG4gKiBAcHJvcGVydHkgbWFza1xuICogQHR5cGUgR3JhcGhpY3NcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsICdtYXNrJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIGlmKHRoaXMuX21hc2spdGhpcy5fbWFzay5pc01hc2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgICAgICBpZih0aGlzLl9tYXNrKXRoaXMuX21hc2suaXNNYXNrID0gdHJ1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTZXRzIHRoZSBmaWx0ZXJzIGZvciB0aGUgZGlzcGxheU9iamVjdC5cbiAqICogSU1QT1JUQU5UOiBUaGlzIGlzIGEgd2ViR0wgb25seSBmZWF0dXJlIGFuZCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byAnbnVsbCdcbiAqIEBwcm9wZXJ0eSBmaWx0ZXJzXG4gKiBAdHlwZSBBcnJheSBBbiBhcnJheSBvZiBmaWx0ZXJzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCAnZmlsdGVycycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICBpZih2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gbm93IHB1dCBhbGwgdGhlIHBhc3NlcyBpbiBvbmUgcGxhY2UuLlxuICAgICAgICAgICAgdmFyIHBhc3NlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyUGFzc2VzID0gdmFsdWVbaV0ucGFzc2VzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsdGVyUGFzc2VzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFzc2VzLnB1c2goZmlsdGVyUGFzc2VzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE8gY2hhbmdlIHRoaXMgYXMgaXQgaXMgbGVnYWN5XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJCbG9jayA9IHt0YXJnZXQ6dGhpcywgZmlsdGVyUGFzc2VzOnBhc3Nlc307XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9maWx0ZXJzID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU2V0IHdlYXRoZXIgb3Igbm90IGEgdGhlIGRpc3BsYXkgb2JqZWN0cyBpcyBjYWNoZWQgYXMgYSBiaXRtYXAuXG4gKiBUaGlzIGJhc2ljYWxseSB0YWtlcyBhIHNuYXAgc2hvdCBvZiB0aGUgZGlzcGxheSBvYmplY3QgYXMgaXQgaXMgYXQgdGhhdCBtb21lbnQuIEl0IGNhbiBwcm92aWRlIGEgcGVyZm9ybWFuY2UgYmVuZWZpdCBmb3IgY29tcGxleCBzdGF0aWMgZGlzcGxheU9iamVjdHNcbiAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byAnbnVsbCdcbiAqIEBwcm9wZXJ0eSBjYWNoZUFzQml0bWFwXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCAnY2FjaGVBc0JpdG1hcCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIHRoaXMuX2NhY2hlQXNCaXRtYXA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgaWYodGhpcy5fY2FjaGVBc0JpdG1hcCA9PT0gdmFsdWUpcmV0dXJuO1xuXG4gICAgICAgIGlmKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL3RoaXMuX2NhY2hlSXNEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUNhY2hlZFNwcml0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKlxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIFRPRE8gT1BUSU1JWkUgVEhJUyEhIHdpdGggZGlydHlcbiAgICBpZih0aGlzLnJvdGF0aW9uICE9PSB0aGlzLnJvdGF0aW9uQ2FjaGUpXG4gICAge1xuXG4gICAgICAgIHRoaXMucm90YXRpb25DYWNoZSA9IHRoaXMucm90YXRpb247XG4gICAgICAgIHRoaXMuX3NyID0gIE1hdGguc2luKHRoaXMucm90YXRpb24pO1xuICAgICAgICB0aGlzLl9jciA9ICBNYXRoLmNvcyh0aGlzLnJvdGF0aW9uKTtcbiAgICB9XG5cbiAgIC8vIHZhciBsb2NhbFRyYW5zZm9ybSA9IHRoaXMubG9jYWxUcmFuc2Zvcm0vLy50b0FycmF5KCk7XG4gICAgdmFyIHBhcmVudFRyYW5zZm9ybSA9IHRoaXMucGFyZW50LndvcmxkVHJhbnNmb3JtOy8vLnRvQXJyYXkoKTtcbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtOy8vLnRvQXJyYXkoKTtcblxuICAgIHZhciBweCA9IHRoaXMucGl2b3QueDtcbiAgICB2YXIgcHkgPSB0aGlzLnBpdm90Lnk7XG5cbiAgICB2YXIgYTAwID0gdGhpcy5fY3IgKiB0aGlzLnNjYWxlLngsXG4gICAgICAgIGEwMSA9IC10aGlzLl9zciAqIHRoaXMuc2NhbGUueSxcbiAgICAgICAgYTEwID0gdGhpcy5fc3IgKiB0aGlzLnNjYWxlLngsXG4gICAgICAgIGExMSA9IHRoaXMuX2NyICogdGhpcy5zY2FsZS55LFxuICAgICAgICBhMDIgPSB0aGlzLnBvc2l0aW9uLnggLSBhMDAgKiBweCAtIHB5ICogYTAxLFxuICAgICAgICBhMTIgPSB0aGlzLnBvc2l0aW9uLnkgLSBhMTEgKiBweSAtIHB4ICogYTEwLFxuICAgICAgICBiMDAgPSBwYXJlbnRUcmFuc2Zvcm0uYSwgYjAxID0gcGFyZW50VHJhbnNmb3JtLmIsXG4gICAgICAgIGIxMCA9IHBhcmVudFRyYW5zZm9ybS5jLCBiMTEgPSBwYXJlbnRUcmFuc2Zvcm0uZDtcblxuICAgIHdvcmxkVHJhbnNmb3JtLmEgPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTA7XG4gICAgd29ybGRUcmFuc2Zvcm0uYiA9IGIwMCAqIGEwMSArIGIwMSAqIGExMTtcbiAgICB3b3JsZFRyYW5zZm9ybS50eCA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIHBhcmVudFRyYW5zZm9ybS50eDtcblxuICAgIHdvcmxkVHJhbnNmb3JtLmMgPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTA7XG4gICAgd29ybGRUcmFuc2Zvcm0uZCA9IGIxMCAqIGEwMSArIGIxMSAqIGExMTtcbiAgICB3b3JsZFRyYW5zZm9ybS50eSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIHBhcmVudFRyYW5zZm9ybS50eTtcblxuICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdCBhcyBhIHJlY3RhbmdsZSBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGdldEJvdW5kc1xuICogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCBtYXRyaXggKVxue1xuICAgIG1hdHJpeCA9IG1hdHJpeDsvL2p1c3QgdG8gZ2V0IHBhc3NlZCBqcyBoaW50aW5nIChhbmQgcHJlc2VydmUgaW5oZXJpdGFuY2UpXG4gICAgcmV0dXJuIFBJWEkuRW1wdHlSZWN0YW5nbGU7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICpcbiAqIEBtZXRob2QgZ2V0TG9jYWxCb3VuZHNcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uKClcbntcbiAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoUElYSS5pZGVudGl0eU1hdHJpeCk7Ly8vUElYSS5FbXB0eVJlY3RhbmdsZSgpO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIG9iamVjdCdzIHN0YWdlIHJlZmVyZW5jZSwgdGhlIHN0YWdlIHRoaXMgb2JqZWN0IGlzIGNvbm5lY3RlZCB0b1xuICpcbiAqIEBtZXRob2Qgc2V0U3RhZ2VSZWZlcmVuY2VcbiAqIEBwYXJhbSBzdGFnZSB7U3RhZ2V9IHRoZSBzdGFnZSB0aGF0IHRoZSBvYmplY3Qgd2lsbCBoYXZlIGFzIGl0cyBjdXJyZW50IHN0YWdlIHJlZmVyZW5jZVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnNldFN0YWdlUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhZ2UpXG57XG4gICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgIGlmKHRoaXMuX2ludGVyYWN0aXZlKXRoaXMuc3RhZ2UuZGlydHkgPSB0cnVlO1xufTtcblxuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZW5lcmF0ZVRleHR1cmUgPSBmdW5jdGlvbihyZW5kZXJlcilcbntcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBuZXcgUElYSS5SZW5kZXJUZXh0dXJlKGJvdW5kcy53aWR0aCB8IDAsIGJvdW5kcy5oZWlnaHQgfCAwLCByZW5kZXJlcik7XG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcywgbmV3IFBJWEkuUG9pbnQoLWJvdW5kcy54LCAtYm91bmRzLnkpICk7XG5cbiAgICByZXR1cm4gcmVuZGVyVGV4dHVyZTtcbn07XG5cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlQ2FjaGUgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUoKTtcbn07XG5cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhY2hlZFNwcml0ZSA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgaWYocmVuZGVyU2Vzc2lvbi5nbClcbiAgICB7XG4gICAgICAgIFBJWEkuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wuY2FsbCh0aGlzLl9jYWNoZWRTcHJpdGUsIHJlbmRlclNlc3Npb24pO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBQSVhJLlNwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcy5jYWxsKHRoaXMuX2NhY2hlZFNwcml0ZSwgcmVuZGVyU2Vzc2lvbik7XG4gICAgfVxufTtcblxuUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUgPSBmdW5jdGlvbigpLy9yZW5kZXJTZXNzaW9uKVxue1xuICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuICAgXG4gICAgaWYoIXRoaXMuX2NhY2hlZFNwcml0ZSlcbiAgICB7XG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gbmV3IFBJWEkuUmVuZGVyVGV4dHVyZShib3VuZHMud2lkdGggfCAwLCBib3VuZHMuaGVpZ2h0IHwgMCk7Ly8sIHJlbmRlclNlc3Npb24ucmVuZGVyZXIpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUudGV4dHVyZS5yZXNpemUoYm91bmRzLndpZHRoIHwgMCwgYm91bmRzLmhlaWdodCB8IDApO1xuICAgIH1cblxuICAgIC8vUkVNT1ZFIGZpbHRlciFcbiAgICB2YXIgdGVtcEZpbHRlcnMgPSB0aGlzLl9maWx0ZXJzO1xuICAgIHRoaXMuX2ZpbHRlcnMgPSBudWxsO1xuXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmZpbHRlcnMgPSB0ZW1wRmlsdGVycztcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUudGV4dHVyZS5yZW5kZXIodGhpcywgbmV3IFBJWEkuUG9pbnQoLWJvdW5kcy54LCAtYm91bmRzLnkpICk7XG5cbiAgICB0aGlzLl9maWx0ZXJzID0gdGVtcEZpbHRlcnM7XG5cbiAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gdHJ1ZTtcbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlcldlYkdMXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9kZXN0cm95Q2FjaGVkU3ByaXRlID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKCF0aGlzLl9jYWNoZWRTcHJpdGUpcmV0dXJuO1xuXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLnRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgLy8gIGNvbnNvbGUubG9nKFwiREVTVFJPWVwiKVxuICAgIC8vIGxldCB0aGUgZ2MgY29sbGVjdCB0aGUgdW51c2VkIHNwcml0ZVxuICAgIC8vIFRPRE8gY291bGQgYmUgb2JqZWN0IHBvb2xlZCFcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUgPSBudWxsO1xufTtcblxuXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gT1ZFUldSSVRFO1xuICAgIC8vIHRoaXMgbGluZSBpcyBqdXN0IGhlcmUgdG8gcGFzcyBqc2hpbnRpbmcgOilcbiAgICByZW5kZXJTZXNzaW9uID0gcmVuZGVyU2Vzc2lvbjtcbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJDYW52YXNcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gT1ZFUldSSVRFO1xuICAgIC8vIHRoaXMgbGluZSBpcyBqdXN0IGhlcmUgdG8gcGFzcyBqc2hpbnRpbmcgOilcbiAgICByZW5kZXJTZXNzaW9uID0gcmVuZGVyU2Vzc2lvbjtcbn07XG5cbi8qKlxuICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB4IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gKlxuICogQHByb3BlcnR5IHhcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwgJ3gnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICB0aGlzLnBvc2l0aW9uLng7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeSBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICpcbiAqIEBwcm9wZXJ0eSB5XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsICd5Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgdGhpcy5wb3NpdGlvbi55O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5cbi8qKlxuICogQSBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIHJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGRpc3BsYXkgb2JqZWN0cy5cbiAqIEl0IGlzIHRoZSBiYXNlIGNsYXNzIG9mIGFsbCBkaXNwbGF5IG9iamVjdHMgdGhhdCBhY3QgYXMgYSBjb250YWluZXIgZm9yIG90aGVyIG9iamVjdHMuXG4gKlxuICogQGNsYXNzIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0LmNhbGwoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBhcnJheSBvZiBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjaGlsZHJlblxuICAgICAqIEB0eXBlIEFycmF5PERpc3BsYXlPYmplY3Q+XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlICk7XG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyO1xuXG4vKipcbiAqIFRoZSB3aWR0aCBvZiB0aGUgZGlzcGxheU9iamVjdENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAqXG4gKiBAcHJvcGVydHkgd2lkdGhcbiAqIEB0eXBlIE51bWJlclxuICovXG5cbiAvKlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUsICd3aWR0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvICh0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGgvdGhpcy5zY2FsZS54KTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG59KTtcbiovXG5cbi8qKlxuICogVGhlIGhlaWdodCBvZiB0aGUgZGlzcGxheU9iamVjdENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAqXG4gKiBAcHJvcGVydHkgaGVpZ2h0XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuXG4vKlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUsICdoZWlnaHQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICB0aGlzLnNjYWxlLnkgKiB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvICh0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0L3RoaXMuc2NhbGUueSk7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuKi9cblxuLyoqXG4gKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAbWV0aG9kIGFkZENoaWxkXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIGFkZCB0byB0aGUgY29udGFpbmVyXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZClcbntcbiAgICB0aGlzLmFkZENoaWxkQXQoY2hpbGQsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGNoaWxkIHRvIHRoZSBjb250YWluZXIgYXQgYSBzcGVjaWZpZWQgaW5kZXguIElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKlxuICogQG1ldGhvZCBhZGRDaGlsZEF0XG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0byBhZGRcbiAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfSBUaGUgaW5kZXggdG8gcGxhY2UgdGhlIGNoaWxkIGluXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uKGNoaWxkLCBpbmRleClcbntcbiAgICBpZihpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgaWYoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIGlmKHRoaXMuc3RhZ2UpY2hpbGQuc2V0U3RhZ2VSZWZlcmVuY2UodGhpcy5zdGFnZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjaGlsZCArICcgVGhlIGluZGV4ICcrIGluZGV4ICsnIHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJyArIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFtOWUldIFN3YXBzIHRoZSBkZXB0aCBvZiAyIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQG1ldGhvZCBzd2FwQ2hpbGRyZW5cbiAqIEBwYXJhbSBjaGlsZCB7RGlzcGxheU9iamVjdH1cbiAqIEBwYXJhbSBjaGlsZDIge0Rpc3BsYXlPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnN3YXBDaGlsZHJlbiA9IGZ1bmN0aW9uKGNoaWxkLCBjaGlsZDIpXG57XG4gICAgaWYoY2hpbGQgPT09IGNoaWxkMikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluZGV4MSA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgdmFyIGluZGV4MiA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZDIpO1xuXG4gICAgaWYoaW5kZXgxIDwgMCB8fCBpbmRleDIgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3dhcENoaWxkcmVuOiBCb3RoIHRoZSBzdXBwbGllZCBEaXNwbGF5T2JqZWN0cyBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIGNhbGxlci4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4MV0gPSBjaGlsZDI7XG4gICAgdGhpcy5jaGlsZHJlbltpbmRleDJdID0gY2hpbGQ7XG4gICAgXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAqXG4gKiBAbWV0aG9kIGdldENoaWxkQXRcbiAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBmcm9tXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRBdCA9IGZ1bmN0aW9uKGluZGV4KVxue1xuICAgIGlmKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCBpbmRleCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2hpbGQgbGlzdCwgb3IgdGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSBjb250YWluZXIuXG4gKlxuICogQG1ldGhvZCByZW1vdmVDaGlsZFxuICogQHBhcmFtIGNoaWxkIHtEaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0byByZW1vdmVcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKVxue1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUNoaWxkQXQoIHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggY2hpbGQgKSApO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uIGluIHRoZSBjaGlsZCBsaXN0IG9mIHRoZSBjb250YWluZXIuXG4gKlxuICogQG1ldGhvZCByZW1vdmVDaGlsZEF0XG4gKiBAcGFyYW0gaW5kZXgge051bWJlcn0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkQXQgPSBmdW5jdGlvbihpbmRleClcbntcbiAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoIGluZGV4ICk7XG4gICAgaWYodGhpcy5zdGFnZSlcbiAgICAgICAgY2hpbGQucmVtb3ZlU3RhZ2VSZWZlcmVuY2UoKTtcblxuICAgIGNoaWxkLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICByZXR1cm4gY2hpbGQ7XG59O1xuXG4vKipcbiogUmVtb3ZlcyBhbGwgY2hpbGQgaW5zdGFuY2VzIGZyb20gdGhlIGNoaWxkIGxpc3Qgb2YgdGhlIGNvbnRhaW5lci5cbipcbiogQG1ldGhvZCByZW1vdmVDaGlsZHJlblxuKiBAcGFyYW0gYmVnaW5JbmRleCB7TnVtYmVyfSBUaGUgYmVnaW5uaW5nIHBvc2l0aW9uLiBQcmVkZWZpbmVkIHZhbHVlIGlzIDAuXG4qIEBwYXJhbSBlbmRJbmRleCB7TnVtYmVyfSBUaGUgZW5kaW5nIHBvc2l0aW9uLiBQcmVkZWZpbmVkIHZhbHVlIGlzIGNoaWxkcmVuJ3MgYXJyYXkgbGVuZ3RoLlxuKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbihiZWdpbkluZGV4LCBlbmRJbmRleClcbntcbiAgICB2YXIgYmVnaW4gPSBiZWdpbkluZGV4IHx8IDA7XG4gICAgdmFyIGVuZCA9IHR5cGVvZiBlbmRJbmRleCA9PT0gJ251bWJlcicgPyBlbmRJbmRleCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciByYW5nZSA9IGVuZCAtIGJlZ2luO1xuXG4gICAgaWYgKHJhbmdlID4gMCAmJiByYW5nZSA8PSBlbmQpXG4gICAge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGJlZ2luLCByYW5nZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gcmVtb3ZlZFtpXTtcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhZ2UpXG4gICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlU3RhZ2VSZWZlcmVuY2UoKTtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnUmFuZ2UgRXJyb3IsIG51bWVyaWMgdmFsdWVzIGFyZSBvdXRzaWRlIHRoZSBhY2NlcHRhYmxlIHJhbmdlJyApO1xuICAgIH1cbn07XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBjb250YWluZXIncyBjaGlsZHJlbnMgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbigpXG57XG4gICAgLy90aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcblxuICAgIGlmKCF0aGlzLnZpc2libGUpcmV0dXJuO1xuXG4gICAgUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbCggdGhpcyApO1xuXG4gICAgaWYodGhpcy5fY2FjaGVBc0JpdG1hcClyZXR1cm47XG5cbiAgICBmb3IodmFyIGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdENvbnRhaW5lciBhcyBhIHJlY3RhbmdsZSBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGdldEJvdW5kc1xuICogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKG1hdHJpeClcbntcbiAgICBpZih0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClyZXR1cm4gUElYSS5FbXB0eVJlY3RhbmdsZTtcblxuICAgIC8vIFRPRE8gdGhlIGJvdW5kcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxjdWxhdGVkIHRoaXMgcmVuZGVyIHNlc3Npb24gc28gcmV0dXJuIHdoYXQgd2UgaGF2ZVxuICAgIGlmKG1hdHJpeClcbiAgICB7XG4gICAgICAgIHZhciBtYXRyaXhDYWNoZSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBtYXRyaXg7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBtYXRyaXhDYWNoZTtcbiAgICB9XG5cbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG5cbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIHZhciBjaGlsZEJvdW5kcztcbiAgICB2YXIgY2hpbGRNYXhYO1xuICAgIHZhciBjaGlsZE1heFk7XG5cbiAgICB2YXIgY2hpbGRWaXNpYmxlID0gZmFsc2U7XG5cbiAgICBmb3IodmFyIGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIFxuICAgICAgICBpZighY2hpbGQudmlzaWJsZSljb250aW51ZTtcblxuICAgICAgICBjaGlsZFZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIGNoaWxkQm91bmRzID0gdGhpcy5jaGlsZHJlbltpXS5nZXRCb3VuZHMoIG1hdHJpeCApO1xuICAgICBcbiAgICAgICAgbWluWCA9IG1pblggPCBjaGlsZEJvdW5kcy54ID8gbWluWCA6IGNoaWxkQm91bmRzLng7XG4gICAgICAgIG1pblkgPSBtaW5ZIDwgY2hpbGRCb3VuZHMueSA/IG1pblkgOiBjaGlsZEJvdW5kcy55O1xuXG4gICAgICAgIGNoaWxkTWF4WCA9IGNoaWxkQm91bmRzLndpZHRoICsgY2hpbGRCb3VuZHMueDtcbiAgICAgICAgY2hpbGRNYXhZID0gY2hpbGRCb3VuZHMuaGVpZ2h0ICsgY2hpbGRCb3VuZHMueTtcblxuICAgICAgICBtYXhYID0gbWF4WCA+IGNoaWxkTWF4WCA/IG1heFggOiBjaGlsZE1heFg7XG4gICAgICAgIG1heFkgPSBtYXhZID4gY2hpbGRNYXhZID8gbWF4WSA6IGNoaWxkTWF4WTtcbiAgICB9XG5cbiAgICBpZighY2hpbGRWaXNpYmxlKVxuICAgICAgICByZXR1cm4gUElYSS5FbXB0eVJlY3RhbmdsZTtcblxuICAgIHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cbiAgICBib3VuZHMueCA9IG1pblg7XG4gICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIC8vIFRPRE86IHN0b3JlIGEgcmVmZXJlbmNlIHNvIHRoYXQgaWYgdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBhZ2FpbiBpbiB0aGUgcmVuZGVyIGN5Y2xlIHdlIGRvIG5vdCBoYXZlIHRvIHJlY2FsY3VsYXRlXG4gICAgLy90aGlzLl9jdXJyZW50Qm91bmRzID0gYm91bmRzO1xuICAgXG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIG1hdHJpeENhY2hlID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBQSVhJLmlkZW50aXR5TWF0cml4O1xuXG4gICAgZm9yKHZhciBpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG1hdHJpeENhY2hlO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29udGFpbmVyJ3Mgc3RhZ2UgcmVmZXJlbmNlLCB0aGUgc3RhZ2UgdGhpcyBvYmplY3QgaXMgY29ubmVjdGVkIHRvXG4gKlxuICogQG1ldGhvZCBzZXRTdGFnZVJlZmVyZW5jZVxuICogQHBhcmFtIHN0YWdlIHtTdGFnZX0gdGhlIHN0YWdlIHRoYXQgdGhlIGNvbnRhaW5lciB3aWxsIGhhdmUgYXMgaXRzIGN1cnJlbnQgc3RhZ2UgcmVmZXJlbmNlXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuc2V0U3RhZ2VSZWZlcmVuY2UgPSBmdW5jdGlvbihzdGFnZSlcbntcbiAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG4gICAgaWYodGhpcy5faW50ZXJhY3RpdmUpdGhpcy5zdGFnZS5kaXJ0eSA9IHRydWU7XG5cbiAgICBmb3IodmFyIGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGNoaWxkLnNldFN0YWdlUmVmZXJlbmNlKHN0YWdlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHJlbW92ZXMgdGhlIGN1cnJlbnQgc3RhZ2UgcmVmZXJlbmNlIG9mIHRoZSBjb250YWluZXJcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZVN0YWdlUmVmZXJlbmNlXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlU3RhZ2VSZWZlcmVuY2UgPSBmdW5jdGlvbigpXG57XG5cbiAgICBmb3IodmFyIGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGNoaWxkLnJlbW92ZVN0YWdlUmVmZXJlbmNlKCk7XG4gICAgfVxuXG4gICAgaWYodGhpcy5faW50ZXJhY3RpdmUpdGhpcy5zdGFnZS5kaXJ0eSA9IHRydWU7XG4gICAgXG4gICAgdGhpcy5zdGFnZSA9IG51bGw7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIGlmKCF0aGlzLnZpc2libGUgfHwgdGhpcy5hbHBoYSA8PSAwKXJldHVybjtcbiAgICBcbiAgICBpZih0aGlzLl9jYWNoZUFzQml0bWFwKVxuICAgIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2FjaGVkU3ByaXRlKHJlbmRlclNlc3Npb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciBpLGo7XG5cbiAgICBpZih0aGlzLl9tYXNrIHx8IHRoaXMuX2ZpbHRlcnMpXG4gICAge1xuICAgICAgICBpZih0aGlzLl9tYXNrKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuX2ZpbHRlcnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guZmx1c2goKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVyKHRoaXMuX2ZpbHRlckJsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgIGZvcihpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlcldlYkdMKHJlbmRlclNlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdG9wKCk7XG5cbiAgICAgICAgaWYodGhpcy5fZmlsdGVycylyZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG4gICAgICAgIGlmKHRoaXMuX21hc2spcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHJlbmRlclNlc3Npb24pO1xuICAgICAgICBcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdGFydCgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgICAgICBmb3IoaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJDYW52YXNcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgaWYodGhpcy52aXNpYmxlID09PSBmYWxzZSB8fCB0aGlzLmFscGhhID09PSAwKXJldHVybjtcblxuICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXApXG4gICAge1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckNhY2hlZFNwcml0ZShyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxuXG4gICAgZm9yKHZhciBpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBjaGlsZC5fcmVuZGVyQ2FudmFzKHJlbmRlclNlc3Npb24pO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnBvcE1hc2socmVuZGVyU2Vzc2lvbi5jb250ZXh0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIFNwcml0ZSBvYmplY3QgaXMgdGhlIGJhc2UgZm9yIGFsbCB0ZXh0dXJlZCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIHRvIHRoZSBzY3JlZW5cbiAqXG4gKiBAY2xhc3MgU3ByaXRlXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSBmb3IgdGhpcyBzcHJpdGVcbiAqIFxuICogQSBzcHJpdGUgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBhbiBpbWFnZSBsaWtlIHRoaXMgOiBcbiAqIHZhciBzcHJpdGUgPSBuZXggUElYSS5TcHJpdGUuRnJvbUltYWdlKCdhc3NldHMvaW1hZ2UucG5nJyk7XG4gKiB5b3VyU3RhZ2UuYWRkQ2hpbGQoc3ByaXRlKTtcbiAqIHRoZW4gb2J2aW91c2x5IGRvbid0IGZvcmdldCB0byBhZGQgaXQgdG8gdGhlIHN0YWdlIHlvdSBoYXZlIGFscmVhZHkgY3JlYXRlZFxuICovXG5QSVhJLlNwcml0ZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIDAsMCB0aGlzIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdFxuICAgICAqIFNldHRpbmcgdGhhbiBhbmNob3IgdG8gMC41LDAuNSBtZWFucyB0aGUgdGV4dHVyZXMgb3JpZ2luIGlzIGNlbnRyZWRcbiAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gMSwxIHdvdWxkIG1lYW4gdGhlIHRleHR1cmVzIG9yaWdpbiBwb2ludHMgd2lsbCBiZSB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFuY2hvclxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy5hbmNob3IgPSBuZXcgUElYSS5Qb2ludCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dHVyZVxuICAgICAqIEB0eXBlIFRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3dpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9oZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hlaWdodCA9IDA7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbnRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAqL1xuICAgIHRoaXMudGludCA9IDB4RkZGRkZGOy8vICogTWF0aC5yYW5kb20oKTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBibGVuZE1vZGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLmJsZW5kTW9kZXMuTk9STUFMO1xuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlID0gUElYSS5ibGVuZE1vZGVzLk5PUk1BTDtcblxuICAgIGlmKHRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5vblRleHR1cmVVcGRhdGUoKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5vblRleHR1cmVVcGRhdGVCaW5kID0gdGhpcy5vblRleHR1cmVVcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICd1cGRhdGUnLCB0aGlzLm9uVGV4dHVyZVVwZGF0ZUJpbmQgKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUgKTtcblBJWEkuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3ByaXRlO1xuXG4vKipcbiAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSB3aWR0aFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlNwcml0ZS5wcm90b3R5cGUsICd3aWR0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IGhlaWdodFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlNwcml0ZS5wcm90b3R5cGUsICdoZWlnaHQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICB0aGlzLnNjYWxlLnkgKiB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNldHMgdGhlIHRleHR1cmUgb2YgdGhlIHNwcml0ZVxuICpcbiAqIEBtZXRob2Qgc2V0VGV4dHVyZVxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSBQSVhJIHRleHR1cmUgdGhhdCBpcyBkaXNwbGF5ZWQgYnkgdGhlIHNwcml0ZVxuICovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgLy8gc3RvcCBjdXJyZW50IHRleHR1cmU7XG4gICAgaWYodGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlICE9PSB0ZXh0dXJlLmJhc2VUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB9XG5cbiAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcbiAgICB0aGlzLnVwZGF0ZUZyYW1lID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICpcbiAqIEBtZXRob2Qgb25UZXh0dXJlVXBkYXRlXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuU3ByaXRlLnByb3RvdHlwZS5vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbigpXG57XG4gICAgLy8gc28gaWYgX3dpZHRoIGlzIDAgdGhlbiB3aWR0aCB3YXMgbm90IHNldC4uXG4gICAgaWYodGhpcy5fd2lkdGgpdGhpcy5zY2FsZS54ID0gdGhpcy5fd2lkdGggLyB0aGlzLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgaWYodGhpcy5faGVpZ2h0KXRoaXMuc2NhbGUueSA9IHRoaXMuX2hlaWdodCAvIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG5cblxuICAgIHRoaXMudXBkYXRlRnJhbWUgPSB0cnVlO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBzcHJpdGUgYXMgYSBQSVhJLlJlY3RhbmdsZSBvYmplY3RcbipcbiogQG1ldGhvZCBnZXRCb3VuZHNcbiogQHBhcmFtIG1hdHJpeCB7TWF0cml4fSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBzcHJpdGVcbiogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4KVxue1xuXG4gICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuXG4gICAgdmFyIHcwID0gd2lkdGggKiAoMS10aGlzLmFuY2hvci54KTtcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC10aGlzLmFuY2hvci54O1xuXG4gICAgdmFyIGgwID0gaGVpZ2h0ICogKDEtdGhpcy5hbmNob3IueSk7XG4gICAgdmFyIGgxID0gaGVpZ2h0ICogLXRoaXMuYW5jaG9yLnk7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybSA7XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7XG5cbiAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2YXIgeTEgPSBkICogaDEgKyBiICogdzEgKyB0eTtcblxuICAgIHZhciB4MiA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgIHZhciB5MiA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgdmFyIHgzID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgdmFyIHkzID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG5cbiAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmFyIHk0ID0gIGQgKiBoMCArIGIgKiB3MSArIHR5O1xuXG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG5cbiAgICBtaW5YID0geDEgPCBtaW5YID8geDEgOiBtaW5YO1xuICAgIG1pblggPSB4MiA8IG1pblggPyB4MiA6IG1pblg7XG4gICAgbWluWCA9IHgzIDwgbWluWCA/IHgzIDogbWluWDtcbiAgICBtaW5YID0geDQgPCBtaW5YID8geDQgOiBtaW5YO1xuXG4gICAgbWluWSA9IHkxIDwgbWluWSA/IHkxIDogbWluWTtcbiAgICBtaW5ZID0geTIgPCBtaW5ZID8geTIgOiBtaW5ZO1xuICAgIG1pblkgPSB5MyA8IG1pblkgPyB5MyA6IG1pblk7XG4gICAgbWluWSA9IHk0IDwgbWluWSA/IHk0IDogbWluWTtcblxuICAgIG1heFggPSB4MSA+IG1heFggPyB4MSA6IG1heFg7XG4gICAgbWF4WCA9IHgyID4gbWF4WCA/IHgyIDogbWF4WDtcbiAgICBtYXhYID0geDMgPiBtYXhYID8geDMgOiBtYXhYO1xuICAgIG1heFggPSB4NCA+IG1heFggPyB4NCA6IG1heFg7XG5cbiAgICBtYXhZID0geTEgPiBtYXhZID8geTEgOiBtYXhZO1xuICAgIG1heFkgPSB5MiA+IG1heFkgPyB5MiA6IG1heFk7XG4gICAgbWF4WSA9IHkzID4gbWF4WSA/IHkzIDogbWF4WTtcbiAgICBtYXhZID0geTQgPiBtYXhZID8geTQgOiBtYXhZO1xuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICBib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcblxuICAgIGJvdW5kcy55ID0gbWluWTtcbiAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAvLyBzdG9yZSBhIHJlZmVyZW5jZSBzbyB0aGF0IGlmIHRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgYWdhaW4gaW4gdGhlIHJlbmRlciBjeWNsZSB3ZSBkbyBub3QgaGF2ZSB0byByZWNhbGN1bGF0ZVxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBib3VuZHM7XG5cbiAgICByZXR1cm4gYm91bmRzO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyV2ViR0xcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZighdGhpcy52aXNpYmxlIHx8IHRoaXMuYWxwaGEgPD0gMClyZXR1cm47XG4gICAgXG4gICAgdmFyIGksajtcblxuICAgIC8vIGRvIGEgcXVpY2sgY2hlY2sgdG8gc2VlIGlmIHRoaXMgZWxlbWVudCBoYXMgYSBtYXNrIG9yIGEgZmlsdGVyLlxuICAgIGlmKHRoaXMuX21hc2sgfHwgdGhpcy5fZmlsdGVycylcbiAgICB7XG4gICAgICAgIHZhciBzcHJpdGVCYXRjaCA9ICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoO1xuXG4gICAgICAgIGlmKHRoaXMuX21hc2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgICAgIHNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLl9maWx0ZXJzKVxuICAgICAgICB7XG4gICAgICAgICAgICBzcHJpdGVCYXRjaC5mbHVzaCgpO1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnB1c2hGaWx0ZXIodGhpcy5fZmlsdGVyQmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoaXMgc3ByaXRlIHRvIHRoZSBiYXRjaFxuICAgICAgICBzcHJpdGVCYXRjaC5yZW5kZXIodGhpcyk7XG5cbiAgICAgICAgLy8gbm93IGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gYW5kIG1ha2Ugc3VyZSB0aGV5IGdldCByZW5kZXJlZFxuICAgICAgICBmb3IoaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWUgdG8gc3RvcCB0aGUgc3ByaXRlIGJhdGNoIGFzIGVpdGhlciBhIG1hc2sgZWxlbWVudCBvciBhIGZpbHRlciBkcmF3IHdpbGwgaGFwcGVuIG5leHRcbiAgICAgICAgc3ByaXRlQmF0Y2guc3RvcCgpO1xuXG4gICAgICAgIGlmKHRoaXMuX2ZpbHRlcnMpcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xuICAgICAgICBpZih0aGlzLl9tYXNrKXJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgXG4gICAgICAgIHNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2gucmVuZGVyKHRoaXMpO1xuXG4gICAgICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgIGZvcihpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlcldlYkdMKHJlbmRlclNlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICBcbiAgICAvL1RPRE8gY2hlY2sgY3VsbGluZyAgXG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gaWYgdGhlIHNwcml0ZSBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgIGlmKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgfHwgdGhpcy5hbHBoYSA9PT0gMClyZXR1cm47XG4gICAgXG4gICAgdmFyIGZyYW1lID0gdGhpcy50ZXh0dXJlLmZyYW1lO1xuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyU2Vzc2lvbi5jb250ZXh0O1xuICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuXG4gICAgaWYodGhpcy5ibGVuZE1vZGUgIT09IHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tyZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxuXG4gICAgXG5cbiAgICAvL2lnbm9yZSBudWxsIHNvdXJjZXNcbiAgICBpZihmcmFtZSAmJiBmcmFtZS53aWR0aCAmJiBmcmFtZS5oZWlnaHQgJiYgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UpXG4gICAge1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgIC8vIGFsbG93IGZvciB0cmltbWluZ1xuICAgICAgICBpZiAocmVuZGVyU2Vzc2lvbi5yb3VuZFBpeGVscylcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmQsIHRyYW5zZm9ybS50eCB8IDAsIHRyYW5zZm9ybS50eSB8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uYiwgdHJhbnNmb3JtLmQsIHRyYW5zZm9ybS50eCwgdHJhbnNmb3JtLnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgc21vb3RoaW5nRW5hYmxlZCBpcyBzdXBwb3J0ZWQgYW5kIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBzbW9vdGhpbmcgcHJvcGVydHkgZm9yIHRoaXMgdGV4dHVyZVxuICAgICAgICBpZihyZW5kZXJTZXNzaW9uLnNtb290aFByb3BlcnR5ICYmIHJlbmRlclNlc3Npb24uc2NhbGVNb2RlICE9PSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuc2NhbGVNb2RlKSB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNjYWxlTW9kZSA9IHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGU7XG4gICAgICAgICAgICBjb250ZXh0W3JlbmRlclNlc3Npb24uc21vb3RoUHJvcGVydHldID0gKHJlbmRlclNlc3Npb24uc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMudGludCAhPT0gMHhGRkZGRkYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5jYWNoZWRUaW50ICE9PSB0aGlzLnRpbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gbm8gcG9pbnQgdGludGluZyBhbiBpbWFnZSB0aGF0IGhhcyBub3QgbG9hZGVkIHlldCFcbiAgICAgICAgICAgICAgICBpZighdGV4dHVyZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gdGhpcy50aW50O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vVE9ETyBjbGVhbiB1cCBjYWNoaW5nIC0gaG93IHRvIGNsZWFuIHVwIHRoZSBjYWNoZXM/XG4gICAgICAgICAgICAgICAgdGhpcy50aW50ZWRUZXh0dXJlID0gUElYSS5DYW52YXNUaW50ZXIuZ2V0VGludGVkVGV4dHVyZSh0aGlzLCB0aGlzLnRpbnQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLnRpbnRlZFRleHR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5hbmNob3IueCkgKiAtZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuYW5jaG9yLnkpICogLWZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuXG4gICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZih0ZXh0dXJlLnRyaW0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaW0gPSAgdGV4dHVyZS50cmltO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0ueCAtIHRoaXMuYW5jaG9yLnggKiB0cmltLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0ueSAtIHRoaXMuYW5jaG9yLnkgKiB0cmltLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmFuY2hvci54KSAqIC1mcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5hbmNob3IueSkgKiAtZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9WRVJXUklURVxuICAgIGZvcih2YXIgaT0wLGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgY2hpbGQuX3JlbmRlckNhbnZhcyhyZW5kZXJTZXNzaW9uKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxufTtcblxuXG4vLyBzb21lIGhlbHBlciBmdW5jdGlvbnMuLlxuXG4vKipcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc3ByaXRlIHRoYXQgd2lsbCBjb250YWluIGEgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlQ2FjaGUgYmFzZWQgb24gdGhlIGZyYW1lSWRcbiAqIFRoZSBmcmFtZSBpZHMgYXJlIGNyZWF0ZWQgd2hlbiBhIFRleHR1cmUgcGFja2VyIGZpbGUgaGFzIGJlZW4gbG9hZGVkXG4gKlxuICogQG1ldGhvZCBmcm9tRnJhbWVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBmcmFtZUlkIHtTdHJpbmd9IFRoZSBmcmFtZSBJZCBvZiB0aGUgdGV4dHVyZSBpbiB0aGUgY2FjaGVcbiAqIEByZXR1cm4ge1Nwcml0ZX0gQSBuZXcgU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBmcmFtZUlkXG4gKi9cblBJWEkuU3ByaXRlLmZyb21GcmFtZSA9IGZ1bmN0aW9uKGZyYW1lSWQpXG57XG4gICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmVDYWNoZVtmcmFtZUlkXTtcbiAgICBpZighdGV4dHVyZSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnJhbWVJZCBcIicgKyBmcmFtZUlkICsgJ1wiIGRvZXMgbm90IGV4aXN0IGluIHRoZSB0ZXh0dXJlIGNhY2hlJyArIHRoaXMpO1xuICAgIHJldHVybiBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG59O1xuXG4vKipcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc3ByaXRlIHRoYXQgd2lsbCBjb250YWluIGEgdGV4dHVyZSBiYXNlZCBvbiBhbiBpbWFnZSB1cmxcbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSBsb2FkZWRcbiAqXG4gKiBAbWV0aG9kIGZyb21JbWFnZVxuICogQHN0YXRpY1xuICogQHBhcmFtIGltYWdlSWQge1N0cmluZ30gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICogQHJldHVybiB7U3ByaXRlfSBBIG5ldyBTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGltYWdlIGlkXG4gKi9cblBJWEkuU3ByaXRlLmZyb21JbWFnZSA9IGZ1bmN0aW9uKGltYWdlSWQsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpXG57XG4gICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKGltYWdlSWQsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpO1xuICAgIHJldHVybiBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS9cbiAqL1xuXG4vKipcbiAqIFRoZSBTcHJpdGVCYXRjaCBjbGFzcyBpcyBhIHJlYWxseSBmYXN0IHZlcnNpb24gb2YgdGhlIERpc3BsYXlPYmplY3RDb250YWluZXIgXG4gKiBidWlsdCBzb2xlbHkgZm9yIHNwZWVkLCBzbyB1c2Ugd2hlbiB5b3UgbmVlZCBhIGxvdCBvZiBzcHJpdGVzIG9yIHBhcnRpY2xlcy5cbiAqIEFuZCBpdCdzIGV4dHJlbWVseSBlYXN5IHRvIHVzZSA6IFxuXG4gICAgdmFyIGNvbnRhaW5lciA9IG5ldyBQSVhJLlNwcml0ZUJhdGNoKCk7XG4gXG4gICAgc3RhZ2UuYWRkQ2hpbGQoY29udGFpbmVyKTtcbiBcbiAgICBmb3IodmFyIGkgID0gMDsgaSA8IDEwMDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoXCJteUltYWdlLnBuZ1wiKTtcbiAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHNwcml0ZSk7XG4gICAgfVxuICogQW5kIGhlcmUgeW91IGhhdmUgYSBodW5kcmVkIHNwcml0ZXMgdGhhdCB3aWxsIGJlIHJlbmRlcmVyIGF0IHRoZSBzcGVlZCBvZiBsaWdodFxuICpcbiAqIEBjbGFzcyBTcHJpdGVCYXRjaFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX1cbiAqL1xuUElYSS5TcHJpdGVCYXRjaCA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwoIHRoaXMpO1xuXG4gICAgdGhpcy50ZXh0dXJlVGhpbmcgPSB0ZXh0dXJlO1xuXG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xufTtcblxuUElYSS5TcHJpdGVCYXRjaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUpO1xuUElYSS5TcHJpdGVCYXRjaC5jb25zdHJ1Y3RvciA9IFBJWEkuU3ByaXRlQmF0Y2g7XG5cbi8qXG4gKiBJbml0aWFsaXNlcyB0aGUgc3ByaXRlQmF0Y2hcbiAqXG4gKiBAbWV0aG9kIGluaXRXZWJHTFxuICogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICovXG5QSVhJLlNwcml0ZUJhdGNoLnByb3RvdHlwZS5pbml0V2ViR0wgPSBmdW5jdGlvbihnbClcbntcbiAgICAvLyBUT0RPIG9ubHkgb25lIG5lZWRlZCBmb3IgdGhlIHdob2xlIGVuZ2luZSByZWFsbHk/XG4gICAgdGhpcy5mYXN0U3ByaXRlQmF0Y2ggPSBuZXcgUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaChnbCk7XG5cbiAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbn07XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5TcHJpdGVCYXRjaC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuICAgLy8gVE9ETyBkb250IG5lZWQgdG8hXG4gICAgUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbCggdGhpcyApO1xuICAvLyAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbCggdGhpcyApO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyV2ViR0xcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IFxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuU3ByaXRlQmF0Y2gucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgaWYoIXRoaXMudmlzaWJsZSB8fCB0aGlzLmFscGhhIDw9IDAgfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKXJldHVybjtcblxuICAgIGlmKCF0aGlzLnJlYWR5KXRoaXMuaW5pdFdlYkdMKCByZW5kZXJTZXNzaW9uLmdsICk7XG4gICAgXG4gICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdG9wKCk7XG4gICAgXG4gICAgcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmFjdGl2YXRlU2hhZGVyKHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5mYXN0U2hhZGVyKTtcbiAgICBcbiAgICB0aGlzLmZhc3RTcHJpdGVCYXRjaC5iZWdpbih0aGlzLCByZW5kZXJTZXNzaW9uKTtcbiAgICB0aGlzLmZhc3RTcHJpdGVCYXRjaC5yZW5kZXIodGhpcyk7XG5cbiAgICByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuYWN0aXZhdGVTaGFkZXIocmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXIpO1xuXG4gICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5zdGFydCgpO1xuIFxufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlckNhbnZhc1xuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5TcHJpdGVCYXRjaC5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJTZXNzaW9uLmNvbnRleHQ7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcblxuICAgIFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICAvLyBhbG93IGZvciB0cmltbWluZ1xuICAgICAgIFxuICAgIHZhciBpc1JvdGF0ZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYoIWNoaWxkLnZpc2libGUpY29udGludWU7XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSBjaGlsZC50ZXh0dXJlO1xuICAgICAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGEgKiBjaGlsZC5hbHBoYTtcblxuICAgICAgICBpZihjaGlsZC5yb3RhdGlvbiAlIChNYXRoLlBJICogMikgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKGlzUm90YXRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xuICAgICAgICAgICAgICAgIGlzUm90YXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBmYXN0ZXN0ICB3YXkgdG8gb3B0aW1pc2UhIC0gaWYgcm90YXRpb24gaXMgMCB0aGVuIHdlIGNhbiBhdm9pZCBhbnkga2luZCBvZiBzZXRUcmFuc2Zvcm0gY2FsbFxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjaGlsZC5hbmNob3IueCkgKiAoLWZyYW1lLndpZHRoICogY2hpbGQuc2NhbGUueCkgKyBjaGlsZC5wb3NpdGlvbi54ICArIDAuNSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjaGlsZC5hbmNob3IueSkgKiAoLWZyYW1lLmhlaWdodCAqIGNoaWxkLnNjYWxlLnkpICsgY2hpbGQucG9zaXRpb24ueSAgKyAwLjUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoICogY2hpbGQuc2NhbGUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCAqIGNoaWxkLnNjYWxlLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoIWlzUm90YXRlZClpc1JvdGF0ZWQgPSB0cnVlO1xuICAgIFxuICAgICAgICAgICAgUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0uY2FsbChjaGlsZCk7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNoaWxkVHJhbnNmb3JtID0gY2hpbGQud29ybGRUcmFuc2Zvcm07XG5cbiAgICAgICAgICAgIC8vIGFsbG93IGZvciB0cmltbWluZ1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyZW5kZXJTZXNzaW9uLnJvdW5kUGl4ZWxzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKGNoaWxkVHJhbnNmb3JtLmEsIGNoaWxkVHJhbnNmb3JtLmMsIGNoaWxkVHJhbnNmb3JtLmIsIGNoaWxkVHJhbnNmb3JtLmQsIGNoaWxkVHJhbnNmb3JtLnR4IHwgMCwgY2hpbGRUcmFuc2Zvcm0udHkgfCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShjaGlsZFRyYW5zZm9ybS5hLCBjaGlsZFRyYW5zZm9ybS5jLCBjaGlsZFRyYW5zZm9ybS5iLCBjaGlsZFRyYW5zZm9ybS5kLCBjaGlsZFRyYW5zZm9ybS50eCwgY2hpbGRUcmFuc2Zvcm0udHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGNoaWxkLmFuY2hvci54KSAqICgtZnJhbWUud2lkdGgpICsgMC41KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGNoaWxkLmFuY2hvci55KSAqICgtZnJhbWUuaGVpZ2h0KSArIDAuNSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQpO1xuICAgICAgICAgICBcblxuICAgICAgICB9XG5cbiAgICAgICAvLyBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG5cbi8vICAgIGNvbnRleHQucmVzdG9yZSgpO1xufTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogQSBNb3ZpZUNsaXAgaXMgYSBzaW1wbGUgd2F5IHRvIGRpc3BsYXkgYW4gYW5pbWF0aW9uIGRlcGljdGVkIGJ5IGEgbGlzdCBvZiB0ZXh0dXJlcy5cbiAqXG4gKiBAY2xhc3MgTW92aWVDbGlwXG4gKiBAZXh0ZW5kcyBTcHJpdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmVzIHtBcnJheTxUZXh0dXJlPn0gYW4gYXJyYXkgb2Yge1RleHR1cmV9IG9iamVjdHMgdGhhdCBtYWtlIHVwIHRoZSBhbmltYXRpb25cbiAqL1xuUElYSS5Nb3ZpZUNsaXAgPSBmdW5jdGlvbih0ZXh0dXJlcylcbntcbiAgICBQSVhJLlNwcml0ZS5jYWxsKHRoaXMsIHRleHR1cmVzWzBdKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiB0ZXh0dXJlcyB0aGF0IG1ha2UgdXAgdGhlIGFuaW1hdGlvblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHR1cmVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmVzID0gdGV4dHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BlZWQgdGhhdCB0aGUgTW92aWVDbGlwIHdpbGwgcGxheSBhdC4gSGlnaGVyIGlzIGZhc3RlciwgbG93ZXIgaXMgc2xvd2VyXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYW5pbWF0aW9uU3BlZWRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgbW92aWUgY2xpcCByZXBlYXRzIGFmdGVyIHBsYXlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbG9vcFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIE1vdmllQ2xpcCBmaW5pc2hlcyBwbGF5aW5nXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb25Db21wbGV0ZVxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBNb3ZpZUNsaXBzIGN1cnJlbnQgZnJhbWUgaW5kZXggKHRoaXMgbWF5IG5vdCBoYXZlIHRvIGJlIGEgd2hvbGUgbnVtYmVyKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRGcmFtZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBJbmRpY2F0ZXMgaWYgdGhlIE1vdmllQ2xpcCBpcyBjdXJyZW50bHkgcGxheWluZ1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsYXlpbmdcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5Nb3ZpZUNsaXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5TcHJpdGUucHJvdG90eXBlICk7XG5QSVhJLk1vdmllQ2xpcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLk1vdmllQ2xpcDtcblxuLyoqXG4qIFtyZWFkLW9ubHldIHRvdGFsRnJhbWVzIGlzIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBNb3ZpZUNsaXAuIFRoaXMgaXMgdGhlIHNhbWUgYXMgbnVtYmVyIG9mIHRleHR1cmVzXG4qIGFzc2lnbmVkIHRvIHRoZSBNb3ZpZUNsaXAuXG4qXG4qIEBwcm9wZXJ0eSB0b3RhbEZyYW1lc1xuKiBAdHlwZSBOdW1iZXJcbiogQGRlZmF1bHQgMFxuKiBAcmVhZE9ubHlcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoIFBJWEkuTW92aWVDbGlwLnByb3RvdHlwZSwgJ3RvdGFsRnJhbWVzJywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZXMubGVuZ3RoO1xuXHR9XG59KTtcblxuXG4vKipcbiAqIFN0b3BzIHRoZSBNb3ZpZUNsaXBcbiAqXG4gKiBAbWV0aG9kIHN0b3BcbiAqL1xuUElYSS5Nb3ZpZUNsaXAucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFBsYXlzIHRoZSBNb3ZpZUNsaXBcbiAqXG4gKiBAbWV0aG9kIHBsYXlcbiAqL1xuUElYSS5Nb3ZpZUNsaXAucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogU3RvcHMgdGhlIE1vdmllQ2xpcCBhbmQgZ29lcyB0byBhIHNwZWNpZmljIGZyYW1lXG4gKlxuICogQG1ldGhvZCBnb3RvQW5kU3RvcFxuICogQHBhcmFtIGZyYW1lTnVtYmVyIHtOdW1iZXJ9IGZyYW1lIGluZGV4IHRvIHN0b3AgYXRcbiAqL1xuUElYSS5Nb3ZpZUNsaXAucHJvdG90eXBlLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24oZnJhbWVOdW1iZXIpXG57XG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZU51bWJlcjtcbiAgICB2YXIgcm91bmQgPSAodGhpcy5jdXJyZW50RnJhbWUgKyAwLjUpIHwgMDtcbiAgICB0aGlzLnNldFRleHR1cmUodGhpcy50ZXh0dXJlc1tyb3VuZCAlIHRoaXMudGV4dHVyZXMubGVuZ3RoXSk7XG59O1xuXG4vKipcbiAqIEdvZXMgdG8gYSBzcGVjaWZpYyBmcmFtZSBhbmQgYmVnaW5zIHBsYXlpbmcgdGhlIE1vdmllQ2xpcFxuICpcbiAqIEBtZXRob2QgZ290b0FuZFBsYXlcbiAqIEBwYXJhbSBmcmFtZU51bWJlciB7TnVtYmVyfSBmcmFtZSBpbmRleCB0byBzdGFydCBhdFxuICovXG5QSVhJLk1vdmllQ2xpcC5wcm90b3R5cGUuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihmcmFtZU51bWJlcilcbntcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lTnVtYmVyO1xuICAgIHRoaXMucGxheWluZyA9IHRydWU7XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuTW92aWVDbGlwLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5TcHJpdGUucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuXG4gICAgaWYoIXRoaXMucGxheWluZylyZXR1cm47XG5cbiAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSB0aGlzLmFuaW1hdGlvblNwZWVkO1xuXG4gICAgdmFyIHJvdW5kID0gKHRoaXMuY3VycmVudEZyYW1lICsgMC41KSB8IDA7XG5cbiAgICBpZih0aGlzLmxvb3AgfHwgcm91bmQgPCB0aGlzLnRleHR1cmVzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0aGlzLnRleHR1cmVzW3JvdW5kICUgdGhpcy50ZXh0dXJlcy5sZW5ndGhdKTtcbiAgICB9XG4gICAgZWxzZSBpZihyb3VuZCA+PSB0aGlzLnRleHR1cmVzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHRoaXMuZ290b0FuZFN0b3AodGhpcy50ZXh0dXJlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYodGhpcy5vbkNvbXBsZXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuXG5QSVhJLkZpbHRlckJsb2NrID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKiAtIE1vZGlmaWVkIGJ5IFRvbSBTbGV6YWtvd3NraSBodHRwOi8vd3d3LnRvbXNsZXpha293c2tpLmNvbSBAVG9tU2xlemFrb3dza2kgKDI0LzAzLzIwMTQpIC0gQWRkZWQgZHJvcFNoYWRvd0NvbG9yLlxuICovXG5cbi8qKlxuICogQSBUZXh0IE9iamVjdCB3aWxsIGNyZWF0ZSBhIGxpbmUocykgb2YgdGV4dC4gVG8gc3BsaXQgYSBsaW5lIHlvdSBjYW4gdXNlICdcXG4nIFxuICogb3IgYWRkIGEgd29yZFdyYXAgcHJvcGVydHkgc2V0IHRvIHRydWUgYW5kIGFuZCB3b3JkV3JhcFdpZHRoIHByb3BlcnR5IHdpdGggYSB2YWx1ZVxuICogaW4gdGhlIHN0eWxlIG9iamVjdFxuICpcbiAqIEBjbGFzcyBUZXh0XG4gKiBAZXh0ZW5kcyBTcHJpdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHQge1N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKiBAcGFyYW0gW3N0eWxlXSB7T2JqZWN0fSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xuICogQHBhcmFtIFtzdHlsZS5mb250XSB7U3RyaW5nfSBkZWZhdWx0ICdib2xkIDIwcHggQXJpYWwnIFRoZSBzdHlsZSBhbmQgc2l6ZSBvZiB0aGUgZm9udFxuICogQHBhcmFtIFtzdHlsZS5maWxsPSdibGFjayddIHtTdHJpbmd8TnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZS5nICdyZWQnLCAnIzAwRkYwMCdcbiAqIEBwYXJhbSBbc3R5bGUuYWxpZ249J2xlZnQnXSB7U3RyaW5nfSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxuICogQHBhcmFtIFtzdHlsZS5zdHJva2VdIHtTdHJpbmd8TnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlIGUuZyAnYmx1ZScsICcjRkNGRjAwJ1xuICogQHBhcmFtIFtzdHlsZS5zdHJva2VUaGlja25lc3M9MF0ge051bWJlcn0gQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS4gRGVmYXVsdCBpcyAwIChubyBzdHJva2UpXG4gKiBAcGFyYW0gW3N0eWxlLndvcmRXcmFwPWZhbHNlXSB7Qm9vbGVhbn0gSW5kaWNhdGVzIGlmIHdvcmQgd3JhcCBzaG91bGQgYmUgdXNlZFxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcFdpZHRoPTEwMF0ge051bWJlcn0gVGhlIHdpZHRoIGF0IHdoaWNoIHRleHQgd2lsbCB3cmFwLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZVxuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93PWZhbHNlXSB7Qm9vbGVhbn0gU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0XG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dDb2xvcj0nIzAwMDAwMCddIHtTdHJpbmd9IEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBkcm9wc2hhZG93IGUuZyAncmVkJywgJyMwMEZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dBbmdsZT1NYXRoLlBJLzRdIHtOdW1iZXJ9IFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U9NV0ge051bWJlcn0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gKi9cblBJWEkuVGV4dCA9IGZ1bmN0aW9uKHRleHQsIHN0eWxlKVxue1xuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjYW52YXNcbiAgICAgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxuICAgICAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50IDJkIENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgUElYSS5TcHJpdGUuY2FsbCh0aGlzLCBQSVhJLlRleHR1cmUuZnJvbUNhbnZhcyh0aGlzLmNhbnZhcykpO1xuXG4gICAgdGhpcy5zZXRUZXh0KHRleHQpO1xuICAgIHRoaXMuc2V0U3R5bGUoc3R5bGUpO1xuXG4gICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuVGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuU3ByaXRlLnByb3RvdHlwZSk7XG5QSVhJLlRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5UZXh0O1xuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgb2YgdGhlIHRleHRcbiAqXG4gKiBAbWV0aG9kIHNldFN0eWxlXG4gKiBAcGFyYW0gW3N0eWxlXSB7T2JqZWN0fSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xuICogQHBhcmFtIFtzdHlsZS5mb250PSdib2xkIDIwcHQgQXJpYWwnXSB7U3RyaW5nfSBUaGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIGZvbnRcbiAqIEBwYXJhbSBbc3R5bGUuZmlsbD0nYmxhY2snXSB7T2JqZWN0fSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZWcgJ3JlZCcsICcjMDBGRjAwJ1xuICogQHBhcmFtIFtzdHlsZS5hbGlnbj0nbGVmdCddIHtTdHJpbmd9IEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0JyksIGRvZXMgbm90IGFmZmVjdCBzaW5nbGUgbGluZSB0ZXh0XG4gKiBAcGFyYW0gW3N0eWxlLnN0cm9rZT0nYmxhY2snXSB7U3RyaW5nfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlIGVnICdibHVlJywgJyNGQ0ZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLnN0cm9rZVRoaWNrbmVzcz0wXSB7TnVtYmVyfSBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlLiBEZWZhdWx0IGlzIDAgKG5vIHN0cm9rZSlcbiAqIEBwYXJhbSBbc3R5bGUud29yZFdyYXA9ZmFsc2VdIHtCb29sZWFufSBJbmRpY2F0ZXMgaWYgd29yZCB3cmFwIHNob3VsZCBiZSB1c2VkXG4gKiBAcGFyYW0gW3N0eWxlLndvcmRXcmFwV2lkdGg9MTAwXSB7TnVtYmVyfSBUaGUgd2lkdGggYXQgd2hpY2ggdGV4dCB3aWxsIHdyYXBcbiAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvdz1mYWxzZV0ge0Jvb2xlYW59IFNldCBhIGRyb3Agc2hhZG93IGZvciB0aGUgdGV4dFxuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93Q29sb3I9JyMwMDAwMDAnXSB7U3RyaW5nfSBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93QW5nbGU9TWF0aC5QSS80XSB7TnVtYmVyfSBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3dcbiAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlPTVdIHtOdW1iZXJ9IFNldCBhIGRpc3RhbmNlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICovXG5QSVhJLlRleHQucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpXG57XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICBzdHlsZS5mb250ID0gc3R5bGUuZm9udCB8fCAnYm9sZCAyMHB0IEFyaWFsJztcbiAgICBzdHlsZS5maWxsID0gc3R5bGUuZmlsbCB8fCAnYmxhY2snO1xuICAgIHN0eWxlLmFsaWduID0gc3R5bGUuYWxpZ24gfHwgJ2xlZnQnO1xuICAgIHN0eWxlLnN0cm9rZSA9IHN0eWxlLnN0cm9rZSB8fCAnYmxhY2snOyAvL3Byb3ZpZGUgYSBkZWZhdWx0LCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29kQm95RGlnaXRhbC9waXhpLmpzL2lzc3Vlcy8xMzZcbiAgICBzdHlsZS5zdHJva2VUaGlja25lc3MgPSBzdHlsZS5zdHJva2VUaGlja25lc3MgfHwgMDtcbiAgICBzdHlsZS53b3JkV3JhcCA9IHN0eWxlLndvcmRXcmFwIHx8IGZhbHNlO1xuICAgIHN0eWxlLndvcmRXcmFwV2lkdGggPSBzdHlsZS53b3JkV3JhcFdpZHRoIHx8IDEwMDtcbiAgICBzdHlsZS53b3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCB8fCAxMDA7XG4gICAgXG4gICAgc3R5bGUuZHJvcFNoYWRvdyA9IHN0eWxlLmRyb3BTaGFkb3cgfHwgZmFsc2U7XG4gICAgc3R5bGUuZHJvcFNoYWRvd0FuZ2xlID0gc3R5bGUuZHJvcFNoYWRvd0FuZ2xlIHx8IE1hdGguUEkgLyA2O1xuICAgIHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSB8fCA0O1xuICAgIHN0eWxlLmRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvciB8fCAnYmxhY2snO1xuXG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcHkgZm9yIHRoZSB0ZXh0IG9iamVjdC4gVG8gc3BsaXQgYSBsaW5lIHlvdSBjYW4gdXNlICdcXG4nXG4gKlxuICogQG1ldGhvZCBzZXRUZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgY29weSB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcbiAqL1xuUElYSS5UZXh0LnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24odGV4dClcbntcbiAgICB0aGlzLnRleHQgPSB0ZXh0LnRvU3RyaW5nKCkgfHwgJyAnO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGV4dCBhbmQgdXBkYXRlcyBpdCB3aGVuIG5lZWRlZFxuICpcbiAqIEBtZXRob2QgdXBkYXRlVGV4dFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5UZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuY29udGV4dC5mb250ID0gdGhpcy5zdHlsZS5mb250O1xuXG4gICAgdmFyIG91dHB1dFRleHQgPSB0aGlzLnRleHQ7XG5cbiAgICAvLyB3b3JkIHdyYXBcbiAgICAvLyBwcmVzZXJ2ZSBvcmlnaW5hbCB0ZXh0XG4gICAgaWYodGhpcy5zdHlsZS53b3JkV3JhcClvdXRwdXRUZXh0ID0gdGhpcy53b3JkV3JhcCh0aGlzLnRleHQpO1xuXG4gICAgLy9zcGxpdCB0ZXh0IGludG8gbGluZXNcbiAgICB2YXIgbGluZXMgPSBvdXRwdXRUZXh0LnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKTtcblxuICAgIC8vY2FsY3VsYXRlIHRleHQgd2lkdGhcbiAgICB2YXIgbGluZVdpZHRocyA9IFtdO1xuICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aDtcbiAgICAgICAgbGluZVdpZHRoc1tpXSA9IGxpbmVXaWR0aDtcbiAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGgpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IG1heExpbmVXaWR0aCArIHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIGlmKHRoaXMuc3R5bGUuZHJvcFNoYWRvdyl3aWR0aCArPSB0aGlzLnN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcblxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgLy9jYWxjdWxhdGUgdGV4dCBoZWlnaHRcbiAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZGV0ZXJtaW5lRm9udEhlaWdodCgnZm9udDogJyArIHRoaXMuc3R5bGUuZm9udCAgKyAnOycpICsgdGhpcy5zdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgXG4gICAgdmFyIGhlaWdodCA9IGxpbmVIZWlnaHQgKiBsaW5lcy5sZW5ndGg7XG4gICAgaWYodGhpcy5zdHlsZS5kcm9wU2hhZG93KWhlaWdodCArPSB0aGlzLnN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcblxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGlmKG5hdmlnYXRvci5pc0NvY29vbkpTKSB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsMCx0aGlzLmNhbnZhcy53aWR0aCx0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIHRoaXMuY29udGV4dC5mb250ID0gdGhpcy5zdHlsZS5mb250O1xuICAgIHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuc3R5bGUuc3Ryb2tlO1xuICAgIHRoaXMuY29udGV4dC5saW5lV2lkdGggPSB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICB0aGlzLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cbiAgICB2YXIgbGluZVBvc2l0aW9uWDtcbiAgICB2YXIgbGluZVBvc2l0aW9uWTtcblxuICAgIGlmKHRoaXMuc3R5bGUuZHJvcFNoYWRvdylcbiAgICB7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLnN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcblxuICAgICAgICB2YXIgeFNoYWRvd09mZnNldCA9IE1hdGguc2luKHRoaXMuc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHRoaXMuc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICB2YXIgeVNoYWRvd09mZnNldCA9IE1hdGguY29zKHRoaXMuc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHRoaXMuc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCA9IHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIgKyBpICogbGluZUhlaWdodDtcblxuICAgICAgICAgICAgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuc3R5bGUuYWxpZ24gPT09ICdjZW50ZXInKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5zdHlsZS5maWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHhTaGFkb3dPZmZzZXQsIGxpbmVQb3NpdGlvblkgKyB5U2hhZG93T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIC8vICBpZihkcm9wU2hhZG93KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9zZXQgY2FudmFzIHRleHQgc3R5bGVzXG4gICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuc3R5bGUuZmlsbDtcbiAgICBcbiAgICAvL2RyYXcgbGluZXMgbGluZSBieSBsaW5lXG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgbGluZVBvc2l0aW9uWCA9IHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IHRoaXMuc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMiArIGkgKiBsaW5lSGVpZ2h0O1xuXG4gICAgICAgIGlmKHRoaXMuc3R5bGUuYWxpZ24gPT09ICdyaWdodCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRoaXMuc3R5bGUuYWxpZ24gPT09ICdjZW50ZXInKVxuICAgICAgICB7XG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldKSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLnN0eWxlLnN0cm9rZSAmJiB0aGlzLnN0eWxlLnN0cm9rZVRoaWNrbmVzcylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5zdHlsZS5maWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkpO1xuICAgICAgICB9XG5cbiAgICAgIC8vICBpZihkcm9wU2hhZG93KVxuICAgIH1cblxuXG4gICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGV4dHVyZSBzaXplIGJhc2VkIG9uIGNhbnZhcyBzaXplXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUZXh0dXJlXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHQucHJvdG90eXBlLnVwZGF0ZVRleHR1cmUgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICB0aGlzLnRleHR1cmUuZnJhbWUud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG5cbiAgICB0aGlzLnJlcXVpcmVzVXBkYXRlID0gIHRydWU7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5UZXh0LnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIGlmKHRoaXMucmVxdWlyZXNVcGRhdGUpXG4gICAge1xuICAgICAgICB0aGlzLnJlcXVpcmVzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIFBJWEkudXBkYXRlV2ViR0xUZXh0dXJlKHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZSwgcmVuZGVyU2Vzc2lvbi5nbCk7XG4gICAgfVxuXG4gICAgUElYSS5TcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTC5jYWxsKHRoaXMsIHJlbmRlclNlc3Npb24pO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gb2YgdGhpcyBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5UZXh0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgUElYSS5TcHJpdGUucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKHRoaXMpO1xufTtcblxuLypcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8zNDQ0MS9lbGxpc2JiZW5cbiAqIGdyZWF0IHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtIVxuICogcmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiBmb250XG4gKlxuICogQG1ldGhvZCBkZXRlcm1pbmVGb250SGVpZ2h0XG4gKiBAcGFyYW0gZm9udFN0eWxlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHQucHJvdG90eXBlLmRldGVybWluZUZvbnRIZWlnaHQgPSBmdW5jdGlvbihmb250U3R5bGUpXG57XG4gICAgLy8gYnVpbGQgYSBsaXR0bGUgcmVmZXJlbmNlIGRpY3Rpb25hcnkgc28gaWYgdGhlIGZvbnQgc3R5bGUgaGFzIGJlZW4gdXNlZCByZXR1cm4gYVxuICAgIC8vIGNhY2hlZCB2ZXJzaW9uLi4uXG4gICAgdmFyIHJlc3VsdCA9IFBJWEkuVGV4dC5oZWlnaHRDYWNoZVtmb250U3R5bGVdO1xuXG4gICAgaWYoIXJlc3VsdClcbiAgICB7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICAgICAgdmFyIGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBkdW1teVRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnTScpO1xuICAgICAgICBkdW1teS5hcHBlbmRDaGlsZChkdW1teVRleHQpO1xuICAgICAgICBkdW1teS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgZm9udFN0eWxlICsgJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjAnKTtcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChkdW1teSk7XG5cbiAgICAgICAgcmVzdWx0ID0gZHVtbXkub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBQSVhJLlRleHQuaGVpZ2h0Q2FjaGVbZm9udFN0eWxlXSA9IHJlc3VsdDtcblxuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGR1bW15KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIG5ld2xpbmVzIHRvIGEgc3RyaW5nIHRvIGhhdmUgaXQgb3B0aW1hbGx5IGZpdCBpbnRvIHRoZSBob3Jpem9udGFsXG4gKiBib3VuZHMgc2V0IGJ5IHRoZSBUZXh0IG9iamVjdCdzIHdvcmRXcmFwV2lkdGggcHJvcGVydHkuXG4gKlxuICogQG1ldGhvZCB3b3JkV3JhcFxuICogQHBhcmFtIHRleHQge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuVGV4dC5wcm90b3R5cGUud29yZFdyYXAgPSBmdW5jdGlvbih0ZXh0KVxue1xuICAgIC8vIEdyZWVkeSB3cmFwcGluZyBhbGdvcml0aG0gdGhhdCB3aWxsIHdyYXAgd29yZHMgYXMgdGhlIGxpbmUgZ3Jvd3MgbG9uZ2VyXG4gICAgLy8gdGhhbiBpdHMgaG9yaXpvbnRhbCBib3VuZHMuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgc3BhY2VMZWZ0ID0gdGhpcy5zdHlsZS53b3JkV3JhcFdpZHRoO1xuICAgICAgICB2YXIgd29yZHMgPSBsaW5lc1tpXS5zcGxpdCgnICcpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHdvcmRzLmxlbmd0aDsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgd29yZFdpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmRzW2pdKS53aWR0aDtcbiAgICAgICAgICAgIHZhciB3b3JkV2lkdGhXaXRoU3BhY2UgPSB3b3JkV2lkdGggKyB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoJyAnKS53aWR0aDtcbiAgICAgICAgICAgIGlmKHdvcmRXaWR0aFdpdGhTcGFjZSA+IHNwYWNlTGVmdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHByaW50aW5nIHRoZSBuZXdsaW5lIGlmIGl0J3MgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGxpbmUgdGhhdCBpc1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgd29yZCB3cmFwIHdpZHRoLlxuICAgICAgICAgICAgICAgIGlmKGogPiAwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd29yZHNbal0gKyAnICc7XG4gICAgICAgICAgICAgICAgc3BhY2VMZWZ0ID0gdGhpcy5zdHlsZS53b3JkV3JhcFdpZHRoIC0gd29yZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNwYWNlTGVmdCAtPSB3b3JkV2lkdGhXaXRoU3BhY2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdvcmRzW2pdICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGgtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqIEBwYXJhbSBkZXN0cm95VGV4dHVyZSB7Qm9vbGVhbn1cbiAqL1xuUElYSS5UZXh0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZGVzdHJveVRleHR1cmUpXG57XG4gICAgaWYoZGVzdHJveVRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLnRleHR1cmUuZGVzdHJveSgpO1xuICAgIH1cblxufTtcblxuUElYSS5UZXh0LmhlaWdodENhY2hlID0ge307XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBBIFRleHQgT2JqZWN0IHdpbGwgY3JlYXRlIGEgbGluZShzKSBvZiB0ZXh0IHVzaW5nIGJpdG1hcCBmb250LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicsICdcXHInIG9yICdcXHJcXG4nXG4gKiBZb3UgY2FuIGdlbmVyYXRlIHRoZSBmbnQgZmlsZXMgdXNpbmdcbiAqIGh0dHA6Ly93d3cuYW5nZWxjb2RlLmNvbS9wcm9kdWN0cy9ibWZvbnQvIGZvciB3aW5kb3dzIG9yXG4gKiBodHRwOi8vd3d3LmJtZ2x5cGguY29tLyBmb3IgbWFjLlxuICpcbiAqIEBjbGFzcyBCaXRtYXBUZXh0XG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0IHtTdHJpbmd9IFRoZSBjb3B5IHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIHRleHQgdG8gZGlzcGxheVxuICogQHBhcmFtIHN0eWxlIHtPYmplY3R9IFRoZSBzdHlsZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gc3R5bGUuZm9udCB7U3RyaW5nfSBUaGUgc2l6ZSAob3B0aW9uYWwpIGFuZCBiaXRtYXAgZm9udCBpZCAocmVxdWlyZWQpIGVxICdBcmlhbCcgb3IgJzIwcHggQXJpYWwnIChtdXN0IGhhdmUgbG9hZGVkIHByZXZpb3VzbHkpXG4gKiBAcGFyYW0gW3N0eWxlLmFsaWduPSdsZWZ0J10ge1N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAqL1xuUElYSS5CaXRtYXBUZXh0ID0gZnVuY3Rpb24odGV4dCwgc3R5bGUpXG57XG4gICAgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9wb29sID0gW107XG5cbiAgICB0aGlzLnNldFRleHQodGV4dCk7XG4gICAgdGhpcy5zZXRTdHlsZShzdHlsZSk7XG4gICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuQml0bWFwVGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUpO1xuUElYSS5CaXRtYXBUZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQml0bWFwVGV4dDtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcHkgZm9yIHRoZSB0ZXh0IG9iamVjdFxuICpcbiAqIEBtZXRob2Qgc2V0VGV4dFxuICogQHBhcmFtIHRleHQge1N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKi9cblBJWEkuQml0bWFwVGV4dC5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpXG57XG4gICAgdGhpcy50ZXh0ID0gdGV4dCB8fCAnICc7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgb2YgdGhlIHRleHRcbiAqIHN0eWxlLmZvbnQge1N0cmluZ30gVGhlIHNpemUgKG9wdGlvbmFsKSBhbmQgYml0bWFwIGZvbnQgaWQgKHJlcXVpcmVkKSBlcSAnQXJpYWwnIG9yICcyMHB4IEFyaWFsJyAobXVzdCBoYXZlIGxvYWRlZCBwcmV2aW91c2x5KVxuICogW3N0eWxlLmFsaWduPSdsZWZ0J10ge1N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAqXG4gKiBAbWV0aG9kIHNldFN0eWxlXG4gKiBAcGFyYW0gc3R5bGUge09iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnMsIGNvbnRhaW5lZCBhcyBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuICovXG5QSVhJLkJpdG1hcFRleHQucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpXG57XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICBzdHlsZS5hbGlnbiA9IHN0eWxlLmFsaWduIHx8ICdsZWZ0JztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG5cbiAgICB2YXIgZm9udCA9IHN0eWxlLmZvbnQuc3BsaXQoJyAnKTtcbiAgICB0aGlzLmZvbnROYW1lID0gZm9udFtmb250Lmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuZm9udFNpemUgPSBmb250Lmxlbmd0aCA+PSAyID8gcGFyc2VJbnQoZm9udFtmb250Lmxlbmd0aCAtIDJdLCAxMCkgOiBQSVhJLkJpdG1hcFRleHQuZm9udHNbdGhpcy5mb250TmFtZV0uc2l6ZTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMudGludCA9IHN0eWxlLnRpbnQ7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGV4dCBhbmQgdXBkYXRlcyBpdCB3aGVuIG5lZWRlZFxuICpcbiAqIEBtZXRob2QgdXBkYXRlVGV4dFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5CaXRtYXBUZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBkYXRhID0gUElYSS5CaXRtYXBUZXh0LmZvbnRzW3RoaXMuZm9udE5hbWVdO1xuICAgIHZhciBwb3MgPSBuZXcgUElYSS5Qb2ludCgpO1xuICAgIHZhciBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgIHZhciBjaGFycyA9IFtdO1xuICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgIHZhciBsaW5lV2lkdGhzID0gW107XG4gICAgdmFyIGxpbmUgPSAwO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuZm9udFNpemUgLyBkYXRhLnNpemU7XG4gICAgXG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gdGhpcy50ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmKC8oPzpcXHJcXG58XFxyfFxcbikvLnRlc3QodGhpcy50ZXh0LmNoYXJBdChpKSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aHMucHVzaChwb3MueCk7XG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIHBvcy54KTtcbiAgICAgICAgICAgIGxpbmUrKztcblxuICAgICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgICAgcG9zLnkgKz0gZGF0YS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJEYXRhID0gZGF0YS5jaGFyc1tjaGFyQ29kZV07XG4gICAgICAgIGlmKCFjaGFyRGF0YSkgY29udGludWU7XG5cbiAgICAgICAgaWYocHJldkNoYXJDb2RlICYmIGNoYXJEYXRhW3ByZXZDaGFyQ29kZV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBvcy54ICs9IGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBjaGFycy5wdXNoKHt0ZXh0dXJlOmNoYXJEYXRhLnRleHR1cmUsIGxpbmU6IGxpbmUsIGNoYXJDb2RlOiBjaGFyQ29kZSwgcG9zaXRpb246IG5ldyBQSVhJLlBvaW50KHBvcy54ICsgY2hhckRhdGEueE9mZnNldCwgcG9zLnkgKyBjaGFyRGF0YS55T2Zmc2V0KX0pO1xuICAgICAgICBwb3MueCArPSBjaGFyRGF0YS54QWR2YW5jZTtcblxuICAgICAgICBwcmV2Q2hhckNvZGUgPSBjaGFyQ29kZTtcbiAgICB9XG5cbiAgICBsaW5lV2lkdGhzLnB1c2gocG9zLngpO1xuICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgcG9zLngpO1xuXG4gICAgdmFyIGxpbmVBbGlnbk9mZnNldHMgPSBbXTtcbiAgICBmb3IoaSA9IDA7IGkgPD0gbGluZTsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGFsaWduT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAge1xuICAgICAgICAgICAgYWxpZ25PZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy5zdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFsaWduT2Zmc2V0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBsaW5lQWxpZ25PZmZzZXRzLnB1c2goYWxpZ25PZmZzZXQpO1xuICAgIH1cblxuICAgIHZhciBsZW5DaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBsZW5DaGFycyA9IGNoYXJzLmxlbmd0aDtcbiAgICB2YXIgdGludCA9IHRoaXMudGludCB8fCAweEZGRkZGRjtcbiAgICBmb3IoaSA9IDA7IGkgPCBsZW5DaGFyczsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGMgPSBpIDwgbGVuQ2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuW2ldIDogdGhpcy5fcG9vbC5wb3AoKTsgLy8gZ2V0IG9sZCBjaGlsZCBpZiBoYXZlLiBpZiBub3QgLSB0YWtlIGZyb20gcG9vbC5cblxuICAgICAgICBpZiAoYykgYy5zZXRUZXh0dXJlKGNoYXJzW2ldLnRleHR1cmUpOyAvLyBjaGVjayBpZiBnb3Qgb25lIGJlZm9yZS5cbiAgICAgICAgZWxzZSBjID0gbmV3IFBJWEkuU3ByaXRlKGNoYXJzW2ldLnRleHR1cmUpOyAvLyBpZiBubyBjcmVhdGUgbmV3IG9uZS5cblxuICAgICAgICBjLnBvc2l0aW9uLnggPSAoY2hhcnNbaV0ucG9zaXRpb24ueCArIGxpbmVBbGlnbk9mZnNldHNbY2hhcnNbaV0ubGluZV0pICogc2NhbGU7XG4gICAgICAgIGMucG9zaXRpb24ueSA9IGNoYXJzW2ldLnBvc2l0aW9uLnkgKiBzY2FsZTtcbiAgICAgICAgYy5zY2FsZS54ID0gYy5zY2FsZS55ID0gc2NhbGU7XG4gICAgICAgIGMudGludCA9IHRpbnQ7XG4gICAgICAgIGlmICghYy5wYXJlbnQpIHRoaXMuYWRkQ2hpbGQoYyk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IGNoaWxkcmVuLlxuICAgIC8vIGFuZCBwdXQgdGhlaXIgaW50byB0aGUgcG9vbC5cbiAgICB3aGlsZSh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IGxlbkNoYXJzKVxuICAgIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuX3Bvb2wucHVzaChjaGlsZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIHdpZHRoIG9mIHRoZSBvdmVyYWxsIHRleHQsIGRpZmZlcmVudCBmcm9tIGZvbnRTaXplLFxuICAgICAqIHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIHN0eWxlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHRXaWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMudGV4dFdpZHRoID0gbWF4TGluZVdpZHRoICogc2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgaGVpZ2h0IG9mIHRoZSBvdmVyYWxsIHRleHQsIGRpZmZlcmVudCBmcm9tIGZvbnRTaXplLFxuICAgICAqIHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIHN0eWxlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHRIZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnRleHRIZWlnaHQgPSAocG9zLnkgKyBkYXRhLmxpbmVIZWlnaHQpICogc2NhbGU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvZiB0aGlzIG9iamVjdFxuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkJpdG1hcFRleHQucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKHRoaXMpO1xufTtcblxuUElYSS5CaXRtYXBUZXh0LmZvbnRzID0ge307XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cbiBcbi8qKlxuICogSG9sZHMgYWxsIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gYW4gSW50ZXJhY3Rpb24gZXZlbnRcbiAqXG4gKiBAY2xhc3MgSW50ZXJhY3Rpb25EYXRhXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5JbnRlcmFjdGlvbkRhdGEgPSBmdW5jdGlvbigpXG57XG4gICAgLyoqXG4gICAgICogVGhpcyBwb2ludCBzdG9yZXMgdGhlIGdsb2JhbCBjb29yZHMgb2Ygd2hlcmUgdGhlIHRvdWNoL21vdXNlIGV2ZW50IGhhcHBlbmVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ2xvYmFsXG4gICAgICogQHR5cGUgUG9pbnRcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbCA9IG5ldyBQSVhJLlBvaW50KCk7XG5cbiAgICAvLyB0aGlzIGlzIGhlcmUgZm9yIGxlZ2FjeS4uLiBidXQgd2lsbCByZW1vdmVcbiAgICB0aGlzLmxvY2FsID0gbmV3IFBJWEkuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgU3ByaXRlIHRoYXQgd2FzIGludGVyYWN0ZWQgd2l0aFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRhcmdldFxuICAgICAqIEB0eXBlIFNwcml0ZVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcGFzc2VkIHRvIGFuIGV2ZW50IGhhbmRsZXIsIHRoaXMgd2lsbCBiZSB0aGUgb3JpZ2luYWwgRE9NIEV2ZW50IHRoYXQgd2FzIGNhcHR1cmVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxuICAgICAqIEB0eXBlIEV2ZW50XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gbnVsbDtcbn07XG5cbi8qKlxuICogVGhpcyB3aWxsIHJldHVybiB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHNwZWNpZmllZCBkaXNwbGF5T2JqZWN0IGZvciB0aGlzIEludGVyYWN0aW9uRGF0YVxuICpcbiAqIEBtZXRob2QgZ2V0TG9jYWxQb3NpdGlvblxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIGxvY2FsIGNvb3JkcyBvZmZcbiAqIEByZXR1cm4ge1BvaW50fSBBIHBvaW50IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBJbnRlcmFjdGlvbkRhdGEgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIERpc3BsYXlPYmplY3RcbiAqL1xuUElYSS5JbnRlcmFjdGlvbkRhdGEucHJvdG90eXBlLmdldExvY2FsUG9zaXRpb24gPSBmdW5jdGlvbihkaXNwbGF5T2JqZWN0KVxue1xuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm07XG4gICAgdmFyIGdsb2JhbCA9IHRoaXMuZ2xvYmFsO1xuXG4gICAgLy8gZG8gYSBjaGVla3kgdHJhbnNmb3JtIHRvIGdldCB0aGUgbW91c2UgY29vcmRzO1xuICAgIHZhciBhMDAgPSB3b3JsZFRyYW5zZm9ybS5hLCBhMDEgPSB3b3JsZFRyYW5zZm9ybS5iLCBhMDIgPSB3b3JsZFRyYW5zZm9ybS50eCxcbiAgICAgICAgYTEwID0gd29ybGRUcmFuc2Zvcm0uYywgYTExID0gd29ybGRUcmFuc2Zvcm0uZCwgYTEyID0gd29ybGRUcmFuc2Zvcm0udHksXG4gICAgICAgIGlkID0gMSAvIChhMDAgKiBhMTEgKyBhMDEgKiAtYTEwKTtcbiAgICAvLyBzZXQgdGhlIG1vdXNlIGNvb3Jkcy4uLlxuICAgIHJldHVybiBuZXcgUElYSS5Qb2ludChhMTEgKiBpZCAqIGdsb2JhbC54ICsgLWEwMSAqIGlkICogZ2xvYmFsLnkgKyAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEwMCAqIGlkICogZ2xvYmFsLnkgKyAtYTEwICogaWQgKiBnbG9iYWwueCArICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGlkKTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkludGVyYWN0aW9uRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkludGVyYWN0aW9uRGF0YTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuIC8qKlxuICogVGhlIGludGVyYWN0aW9uIG1hbmFnZXIgZGVhbHMgd2l0aCBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzLiBBbnkgRGlzcGxheU9iamVjdCBjYW4gYmUgaW50ZXJhY3RpdmVcbiAqIGlmIGl0cyBpbnRlcmFjdGl2ZSBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWVcbiAqIFRoaXMgbWFuYWdlciBhbHNvIHN1cHBvcnRzIG11bHRpdG91Y2guXG4gKlxuICogQGNsYXNzIEludGVyYWN0aW9uTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gc3RhZ2Uge1N0YWdlfSBUaGUgc3RhZ2UgdG8gaGFuZGxlIGludGVyYWN0aW9uc1xuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKHN0YWdlKVxue1xuICAgIC8qKlxuICAgICAqIGEgcmVmZXJlbmNlIHRvIHRoZSBzdGFnZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHN0YWdlXG4gICAgICogQHR5cGUgU3RhZ2VcbiAgICAgKi9cbiAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgbW91c2UgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG1vdXNlXG4gICAgICogQHR5cGUgSW50ZXJhY3Rpb25EYXRhXG4gICAgICovXG4gICAgdGhpcy5tb3VzZSA9IG5ldyBQSVhJLkludGVyYWN0aW9uRGF0YSgpO1xuXG4gICAgLyoqXG4gICAgICogYW4gb2JqZWN0IHRoYXQgc3RvcmVzIGN1cnJlbnQgdG91Y2hlcyAoSW50ZXJhY3Rpb25EYXRhKSBieSBpZCByZWZlcmVuY2VcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0b3VjaHNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnRvdWNocyA9IHt9O1xuXG4gICAgLy8gaGVscGVyc1xuICAgIHRoaXMudGVtcFBvaW50ID0gbmV3IFBJWEkuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZW92ZXJFbmFibGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGhpcy5tb3VzZW92ZXJFbmFibGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIHRpbnkgbGl0dGxlIGludGVyYWN0aXZlRGF0YSBwb29sICFcbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgcG9vbFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy5wb29sID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgaXRlcmF0aXZlIGl0ZW1zIGZyb20gdGhlIG91ciBpbnRlcmFjdGl2ZSB0cmVlXG4gICAgICogQHByb3BlcnR5IGludGVyYWN0aXZlSXRlbXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLmludGVyYWN0aXZlSXRlbXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIE91ciBjYW52YXNcbiAgICAgKiBAcHJvcGVydHkgaW50ZXJhY3Rpb25ET01FbGVtZW50XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcblxuICAgIC8vdGhpcyB3aWxsIG1ha2UgaXQgc28gdGhhdCB5b3UgZG9udCBoYXZlIHRvIGNhbGwgYmluZCBhbGwgdGhlIHRpbWVcbiAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKCB0aGlzICk7XG4gICAgdGhpcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTW91c2VPdXQgPSB0aGlzLm9uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLm9uVG91Y2hTdGFydCA9IHRoaXMub25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblRvdWNoRW5kID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblRvdWNoTW92ZSA9IHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMubGFzdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3NzIHN0eWxlIG9mIHRoZSBjdXJzb3IgdGhhdCBpcyBiZWluZyB1c2VkXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRDdXJzb3JTdHlsZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgPSAnaW5oZXJpdCc7XG5cbiAgICAvKipcbiAgICAgKiBJcyBzZXQgdG8gdHJ1ZSB3aGVuIHRoZSBtb3VzZSBpcyBtb3ZlZCBvdXQgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwcm9wZXJ0eSBtb3VzZU91dFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMubW91c2VPdXQgPSBmYWxzZTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkludGVyYWN0aW9uTWFuYWdlcjtcblxuLyoqXG4gKiBDb2xsZWN0cyBhbiBpbnRlcmFjdGl2ZSBzcHJpdGUgcmVjdXJzaXZlbHkgdG8gaGF2ZSB0aGVpciBpbnRlcmFjdGlvbnMgbWFuYWdlZFxuICpcbiAqIEBtZXRob2QgY29sbGVjdEludGVyYWN0aXZlU3ByaXRlXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gdGhlIGRpc3BsYXlPYmplY3QgdG8gY29sbGVjdFxuICogQHBhcmFtIGlQYXJlbnQge0Rpc3BsYXlPYmplY3R9IHRoZSBkaXNwbGF5IG9iamVjdCdzIHBhcmVudFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbGxlY3RJbnRlcmFjdGl2ZVNwcml0ZSA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QsIGlQYXJlbnQpXG57XG4gICAgdmFyIGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcbiAgICB2YXIgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgLy8gbWFrZSBhbiBpbnRlcmFjdGlvbiB0cmVlLi4uIHtpdGVtLl9faW50ZXJhY3RpdmVQYXJlbnR9XG4gICAgZm9yICh2YXIgaSA9IGxlbmd0aC0xOyBpID49IDA7IGktLSlcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgIC8vIHB1c2ggYWxsIGludGVyYWN0aXZlIGJpdHNcbiAgICAgICAgaWYoY2hpbGQuX2ludGVyYWN0aXZlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpUGFyZW50LmludGVyYWN0aXZlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgLy9jaGlsZC5fX2lQYXJlbnQgPSBpUGFyZW50O1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICBpZihjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdEludGVyYWN0aXZlU3ByaXRlKGNoaWxkLCBjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5fX2lQYXJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZihjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdEludGVyYWN0aXZlU3ByaXRlKGNoaWxkLCBpUGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0YXJnZXQgZm9yIGV2ZW50IGRlbGVnYXRpb25cbiAqXG4gKiBAbWV0aG9kIHNldFRhcmdldFxuICogQHBhcmFtIHRhcmdldCB7V2ViR0xSZW5kZXJlcnxDYW52YXNSZW5kZXJlcn0gdGhlIHJlbmRlcmVyIHRvIGJpbmQgZXZlbnRzIHRvXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24odGFyZ2V0KVxue1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgLy9jaGVjayBpZiB0aGUgZG9tIGVsZW1lbnQgaGFzIGJlZW4gc2V0LiBJZiBpdCBoYXMgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiggdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPT09IG51bGwgKSB7XG5cbiAgICAgICAgdGhpcy5zZXRUYXJnZXREb21FbGVtZW50KCB0YXJnZXQudmlldyApO1xuICAgIH1cblxuICAgIFxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZS90b3VjaCBldmVudHMuIFRoaXMgaXMgdXNlZnVsIGZvciB3aGVuIHlvdSBoYXZlIG90aGVyIERPTVxuICogZWxlbWVudHMgb24gdG9wIG9mIHRoZSByZW5kZXJlcnMgQ2FudmFzIGVsZW1lbnQuIFdpdGggdGhpcyB5b3UnbGwgYmUgYWJsZSB0byBkZWxlZ2F0ZSBhbm90aGVyIERPTSBlbGVtZW50XG4gKiB0byByZWNlaXZlIHRob3NlIGV2ZW50c1xuICpcbiAqIEBtZXRob2Qgc2V0VGFyZ2V0RG9tRWxlbWVudFxuICogQHBhcmFtIGRvbUVsZW1lbnQge0RPTUVsZW1lbnR9IHRoZSBET00gZWxlbWVudCB3aGljaCB3aWxsIHJlY2VpdmUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRhcmdldERvbUVsZW1lbnQgPSBmdW5jdGlvbihkb21FbGVtZW50KVxue1xuXG4gICAgdGhpcy5yZW1vdmVFdmVudHMoKTtcblxuXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZClcbiAgICB7XG4gICAgICAgIC8vIHRpbWUgdG8gcmVtb3ZlIHNvbWUgb2YgdGhhdCB6b29tIGluIGphLi5cbiAgICAgICAgZG9tRWxlbWVudC5zdHlsZVsnLW1zLWNvbnRlbnQtem9vbWluZyddID0gJ25vbmUnO1xuICAgICAgICBkb21FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG5cbiAgICAgICAgLy8gRE8gc29tZSB3aW5kb3cgc3BlY2lmaWMgdG91Y2ghXG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAgdGhpcy5vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAgdGhpcy5vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsICAgdGhpcy5vbk1vdXNlT3V0LCB0cnVlKTtcblxuICAgIC8vIGFpbnQgbm8gbXVsdGkgdG91Y2gganVzdCB5ZXQhXG4gICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIHRydWUpO1xuICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIHRydWUpO1xuICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgdHJ1ZSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICB0aGlzLm9uTW91c2VVcCwgdHJ1ZSk7XG59O1xuXG5cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbigpXG57XG4gICAgaWYoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KXJldHVybjtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnJztcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLXRvdWNoLWFjdGlvbiddID0gJyc7XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAgdGhpcy5vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgIHRoaXMub25Nb3VzZURvd24sIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgICB0aGlzLm9uTW91c2VPdXQsIHRydWUpO1xuXG4gICAgLy8gYWludCBubyBtdWx0aSB0b3VjaCBqdXN0IHlldCFcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCB0cnVlKTtcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCB0cnVlKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgIHRoaXMub25Nb3VzZVVwLCB0cnVlKTtcbn07XG5cbi8qKlxuICogdXBkYXRlcyB0aGUgc3RhdGUgb2YgaW50ZXJhY3RpdmUgb2JqZWN0c1xuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKCF0aGlzLnRhcmdldClyZXR1cm47XG5cbiAgICAvLyBmcmVxdWVuY3kgb2YgMzBmcHM/P1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciBkaWZmID0gbm93IC0gdGhpcy5sYXN0O1xuICAgIGRpZmYgPSAoZGlmZiAqIFBJWEkuSU5URVJBQ1RJT05fRlJFUVVFTkNZICkgLyAxMDAwO1xuICAgIGlmKGRpZmYgPCAxKXJldHVybjtcbiAgICB0aGlzLmxhc3QgPSBub3c7XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICAvLyBvay4uIHNvIG1vdXNlIGV2ZW50cz8/XG4gICAgLy8geWVzIGZvciBub3cgOilcbiAgICAvLyBPUFRJTUlTRSAtIGhvdyBvZnRlbiB0byBjaGVjaz8/XG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICAgICAgICB2YXIgbGVuID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3RpdmVJdGVtc1tpXS5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludGVyYWN0aXZlSXRlbXMgPSBbXTtcblxuICAgICAgICBpZih0aGlzLnN0YWdlLmludGVyYWN0aXZlKXRoaXMuaW50ZXJhY3RpdmVJdGVtcy5wdXNoKHRoaXMuc3RhZ2UpO1xuICAgICAgICAvLyBnbyB0aHJvdWdoIGFuZCBjb2xsZWN0IGFsbCB0aGUgb2JqZWN0cyB0aGF0IGFyZSBpbnRlcmFjdGl2ZS4uXG4gICAgICAgIHRoaXMuY29sbGVjdEludGVyYWN0aXZlU3ByaXRlKHRoaXMuc3RhZ2UsIHRoaXMuc3RhZ2UpO1xuICAgIH1cblxuICAgIC8vIGxvb3AgdGhyb3VnaCBpbnRlcmFjdGl2ZSBvYmplY3RzIVxuICAgIHZhciBsZW5ndGggPSB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoO1xuICAgIHZhciBjdXJzb3IgPSAnaW5oZXJpdCc7XG4gICAgdmFyIG92ZXIgPSBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2ldO1xuXG4gICAgICAgIC8vIE9QVElNSVNBVElPTiAtIG9ubHkgY2FsY3VsYXRlIGV2ZXJ5IHRpbWUgaWYgdGhlIG1vdXNlbW92ZSBmdW5jdGlvbiBleGlzdHMuLlxuICAgICAgICAvLyBPSyBzby4uIGRvZXMgdGhlIG9iamVjdCBoYXZlIGFueSBvdGhlciBpbnRlcmFjdGl2ZSBmdW5jdGlvbnM/XG4gICAgICAgIC8vIGhpdC10ZXN0IHRoZSBjbGlwIVxuICAgICAgIC8vIGlmKGl0ZW0ubW91c2VvdmVyIHx8IGl0ZW0ubW91c2VvdXQgfHwgaXRlbS5idXR0b25Nb2RlKVxuICAgICAgIC8vIHtcbiAgICAgICAgLy8gb2sgc28gdGhlcmUgYXJlIHNvbWUgZnVuY3Rpb25zIHNvIGxldHMgaGl0IHRlc3QgaXQuLlxuICAgICAgICBpdGVtLl9faGl0ID0gdGhpcy5oaXRUZXN0KGl0ZW0sIHRoaXMubW91c2UpO1xuICAgICAgICB0aGlzLm1vdXNlLnRhcmdldCA9IGl0ZW07XG4gICAgICAgIC8vIG9rIHNvIGRlYWwgd2l0aCBpbnRlcmFjdGlvbnMuLlxuICAgICAgICAvLyBsb29rcyBsaWtlIHRoZXJlIHdhcyBhIGhpdCFcbiAgICAgICAgaWYoaXRlbS5fX2hpdCAmJiAhb3ZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoaXRlbS5idXR0b25Nb2RlKSBjdXJzb3IgPSBpdGVtLmRlZmF1bHRDdXJzb3I7XG5cbiAgICAgICAgICAgIGlmKCFpdGVtLmludGVyYWN0aXZlQ2hpbGRyZW4pb3ZlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKCFpdGVtLl9faXNPdmVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0ubW91c2VvdmVyKWl0ZW0ubW91c2VvdmVyKHRoaXMubW91c2UpO1xuICAgICAgICAgICAgICAgIGl0ZW0uX19pc092ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoaXRlbS5fX2lzT3ZlcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyByb2xsIG91dCFcbiAgICAgICAgICAgICAgICBpZihpdGVtLm1vdXNlb3V0KWl0ZW0ubW91c2VvdXQodGhpcy5tb3VzZSk7XG4gICAgICAgICAgICAgICAgaXRlbS5fX2lzT3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoIHRoaXMuY3VycmVudEN1cnNvclN0eWxlICE9PSBjdXJzb3IgKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgPSBjdXJzb3I7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG59O1xuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uTW91c2VNb3ZlXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIHRoZSBtb3VzZSBtb3ZpbmdcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KVxue1xuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDsgLy9JRSB1c2VzIHdpbmRvdy5ldmVudFxuICAgIC8vIFRPRE8gb3B0aW1pemUgYnkgbm90IGNoZWNrIEVWRVJZIFRJTUUhIG1heWJlIGhhbGYgYXMgb2Z0ZW4/IC8vXG4gICAgdmFyIHJlY3QgPSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHRoaXMubW91c2UuZ2xvYmFsLnggPSAoZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCkgKiAodGhpcy50YXJnZXQud2lkdGggLyByZWN0LndpZHRoKTtcbiAgICB0aGlzLm1vdXNlLmdsb2JhbC55ID0gKGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCkgKiAoIHRoaXMudGFyZ2V0LmhlaWdodCAvIHJlY3QuaGVpZ2h0KTtcblxuICAgIHZhciBsZW5ndGggPSB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2ldO1xuXG4gICAgICAgIGlmKGl0ZW0ubW91c2Vtb3ZlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL2NhbGwgdGhlIGZ1bmN0aW9uIVxuICAgICAgICAgICAgaXRlbS5tb3VzZW1vdmUodGhpcy5tb3VzZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCBkb3duIG9uIHRoZSByZW5kZXJlciBlbGVtZW50XG4gKlxuICogQG1ldGhvZCBvbk1vdXNlRG93blxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIG1vdXNlIGJ1dHRvbiBiZWluZyBwcmVzc2VkIGRvd25cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGV2ZW50KVxue1xuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDsgLy9JRSB1c2VzIHdpbmRvdy5ldmVudFxuXG4gICAgaWYoUElYSS5BVVRPX1BSRVZFTlRfREVGQVVMVCl0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBpbnRlcmFjdGlvbiB0cmVlLi4uXG4gICAgLy8gaGl0IHRlc3QgZWFjaCBpdGVtISAtPlxuICAgIC8vIGdldCBpbnRlcmFjdGl2ZSBpdGVtcyB1bmRlciBwb2ludD8/XG4gICAgLy9zdGFnZS5fX2lcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLmxlbmd0aDtcblxuICAgIC8vIHdoaWxlXG4gICAgLy8gaGl0IHRlc3RcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmludGVyYWN0aXZlSXRlbXNbaV07XG5cbiAgICAgICAgaWYoaXRlbS5tb3VzZWRvd24gfHwgaXRlbS5jbGljaylcbiAgICAgICAge1xuICAgICAgICAgICAgaXRlbS5fX21vdXNlSXNEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIGl0ZW0uX19oaXQgPSB0aGlzLmhpdFRlc3QoaXRlbSwgdGhpcy5tb3VzZSk7XG5cbiAgICAgICAgICAgIGlmKGl0ZW0uX19oaXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9jYWxsIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgICAgICBpZihpdGVtLm1vdXNlZG93bilpdGVtLm1vdXNlZG93bih0aGlzLm1vdXNlKTtcbiAgICAgICAgICAgICAgICBpdGVtLl9faXNEb3duID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGp1c3QgdGhlIG9uZSFcbiAgICAgICAgICAgICAgICBpZighaXRlbS5pbnRlcmFjdGl2ZUNoaWxkcmVuKWJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIG1vdmVkIG91dCBvZiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBtZXRob2Qgb25Nb3VzZU91dFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIG1vdXNlIGJ1dHRvbiBiZWluZyBtb3ZlZCBvdXRcbiAqIEBwcml2YXRlIFxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Nb3VzZU91dCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zLmxlbmd0aDtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9ICdpbmhlcml0JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtc1tpXTtcbiAgICAgICAgaWYoaXRlbS5fX2lzT3ZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tb3VzZS50YXJnZXQgPSBpdGVtO1xuICAgICAgICAgICAgaWYoaXRlbS5tb3VzZW91dClpdGVtLm1vdXNlb3V0KHRoaXMubW91c2UpO1xuICAgICAgICAgICAgaXRlbS5fX2lzT3ZlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZU91dCA9IHRydWU7XG5cbiAgICAvLyBtb3ZlIHRoZSBtb3VzZSB0byBhbiBpbXBvc3NpYmxlIHBvc2l0aW9uXG4gICAgdGhpcy5tb3VzZS5nbG9iYWwueCA9IC0xMDAwMDtcbiAgICB0aGlzLm1vdXNlLmdsb2JhbC55ID0gLTEwMDAwO1xufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHJlbGVhc2VkIG9uIHRoZSByZW5kZXJlciBlbGVtZW50XG4gKlxuICogQG1ldGhvZCBvbk1vdXNlVXBcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBidXR0b24gYmVpbmcgcmVsZWFzZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihldmVudClcbntcblxuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDsgLy9JRSB1c2VzIHdpbmRvdy5ldmVudFxuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG4gICAgdmFyIHVwID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmludGVyYWN0aXZlSXRlbXNbaV07XG5cbiAgICAgICAgaXRlbS5fX2hpdCA9IHRoaXMuaGl0VGVzdChpdGVtLCB0aGlzLm1vdXNlKTtcblxuICAgICAgICBpZihpdGVtLl9faGl0ICYmICF1cClcbiAgICAgICAge1xuICAgICAgICAgICAgLy9jYWxsIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGlmKGl0ZW0ubW91c2V1cClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpdGVtLm1vdXNldXAodGhpcy5tb3VzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihpdGVtLl9faXNEb3duKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0uY2xpY2spaXRlbS5jbGljayh0aGlzLm1vdXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWl0ZW0uaW50ZXJhY3RpdmVDaGlsZHJlbil1cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihpdGVtLl9faXNEb3duKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0ubW91c2V1cG91dHNpZGUpaXRlbS5tb3VzZXVwb3V0c2lkZSh0aGlzLm1vdXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0uX19pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgLy99XG4gICAgfVxufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgY3VycmVudCBtb3VzZSBjb29yZGluYXRlcyBoaXQgYSBzcHJpdGVcbiAqXG4gKiBAbWV0aG9kIGhpdFRlc3RcbiAqIEBwYXJhbSBpdGVtIHtEaXNwbGF5T2JqZWN0fSBUaGUgZGlzcGxheU9iamVjdCB0byB0ZXN0IGZvciBhIGhpdFxuICogQHBhcmFtIGludGVyYWN0aW9uRGF0YSB7SW50ZXJhY3Rpb25EYXRhfSBUaGUgaW50ZXJhY3Rpb25EYXRhIG9iamVjdCB0byB1cGRhdGUgaW4gdGhlIGNhc2UgdGhlcmUgaXMgYSBoaXRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24oaXRlbSwgaW50ZXJhY3Rpb25EYXRhKVxue1xuICAgIHZhciBnbG9iYWwgPSBpbnRlcmFjdGlvbkRhdGEuZ2xvYmFsO1xuXG4gICAgaWYoICFpdGVtLndvcmxkVmlzaWJsZSApcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gdGVtcCBmaXggZm9yIGlmIHRoZSBlbGVtZW50IGlzIGluIGEgbm9uIHZpc2libGVcbiAgIFxuICAgIHZhciBpc1Nwcml0ZSA9IChpdGVtIGluc3RhbmNlb2YgUElYSS5TcHJpdGUpLFxuICAgICAgICB3b3JsZFRyYW5zZm9ybSA9IGl0ZW0ud29ybGRUcmFuc2Zvcm0sXG4gICAgICAgIGEwMCA9IHdvcmxkVHJhbnNmb3JtLmEsIGEwMSA9IHdvcmxkVHJhbnNmb3JtLmIsIGEwMiA9IHdvcmxkVHJhbnNmb3JtLnR4LFxuICAgICAgICBhMTAgPSB3b3JsZFRyYW5zZm9ybS5jLCBhMTEgPSB3b3JsZFRyYW5zZm9ybS5kLCBhMTIgPSB3b3JsZFRyYW5zZm9ybS50eSxcbiAgICAgICAgaWQgPSAxIC8gKGEwMCAqIGExMSArIGEwMSAqIC1hMTApLFxuICAgICAgICB4ID0gYTExICogaWQgKiBnbG9iYWwueCArIC1hMDEgKiBpZCAqIGdsb2JhbC55ICsgKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBpZCxcbiAgICAgICAgeSA9IGEwMCAqIGlkICogZ2xvYmFsLnkgKyAtYTEwICogaWQgKiBnbG9iYWwueCArICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGlkO1xuXG4gICAgaW50ZXJhY3Rpb25EYXRhLnRhcmdldCA9IGl0ZW07XG5cbiAgICAvL2Egc3ByaXRlIG9yIGRpc3BsYXkgb2JqZWN0IHdpdGggYSBoaXQgYXJlYSBkZWZpbmVkXG4gICAgaWYoaXRlbS5oaXRBcmVhICYmIGl0ZW0uaGl0QXJlYS5jb250YWlucykge1xuICAgICAgICBpZihpdGVtLmhpdEFyZWEuY29udGFpbnMoeCwgeSkpIHtcbiAgICAgICAgICAgIC8vaWYoaXNTcHJpdGUpXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEudGFyZ2V0ID0gaXRlbTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGEgc3ByaXRlIHdpdGggbm8gaGl0YXJlYSBkZWZpbmVkXG4gICAgZWxzZSBpZihpc1Nwcml0ZSlcbiAgICB7XG4gICAgICAgIHZhciB3aWR0aCA9IGl0ZW0udGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGl0ZW0udGV4dHVyZS5mcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICB4MSA9IC13aWR0aCAqIGl0ZW0uYW5jaG9yLngsXG4gICAgICAgICAgICB5MTtcblxuICAgICAgICBpZih4ID4geDEgJiYgeCA8IHgxICsgd2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHkxID0gLWhlaWdodCAqIGl0ZW0uYW5jaG9yLnk7XG5cbiAgICAgICAgICAgIGlmKHkgPiB5MSAmJiB5IDwgeTEgKyBoZWlnaHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB0YXJnZXQgcHJvcGVydHkgaWYgYSBoaXQgaXMgdHJ1ZSFcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEudGFyZ2V0ID0gaXRlbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBpdGVtLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdGVtcEl0ZW0gPSBpdGVtLmNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgaGl0ID0gdGhpcy5oaXRUZXN0KHRlbXBJdGVtLCBpbnRlcmFjdGlvbkRhdGEpO1xuICAgICAgICBpZihoaXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGhtbS4uIFRPRE8gU0VUIENPUlJFQ1QgVEFSR0VUP1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhLnRhcmdldCA9IGl0ZW07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gYSB0b3VjaCBpcyBtb3ZlZCBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uVG91Y2hNb3ZlXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgdG91Y2ggbW92aW5nIGFjcm9zcyB0aGUgcmVuZGVyZXIgdmlld1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpXG57XG4gICAgdmFyIHJlY3QgPSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICB2YXIgdG91Y2hEYXRhO1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgIHRvdWNoRGF0YSA9IHRoaXMudG91Y2hzW3RvdWNoRXZlbnQuaWRlbnRpZmllcl07XG4gICAgICAgIHRvdWNoRGF0YS5vcmlnaW5hbEV2ZW50ID0gIGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvdWNoIHBvc2l0aW9uXG4gICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueCA9ICh0b3VjaEV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQpICogKHRoaXMudGFyZ2V0LndpZHRoIC8gcmVjdC53aWR0aCk7XG4gICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueSA9ICh0b3VjaEV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCkgICogKHRoaXMudGFyZ2V0LmhlaWdodCAvIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgaWYobmF2aWdhdG9yLmlzQ29jb29uSlMpIHtcbiAgICAgICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueCA9IHRvdWNoRXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueSA9IHRvdWNoRXZlbnQuY2xpZW50WTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSB0aGlzLmludGVyYWN0aXZlSXRlbXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2ldO1xuICAgICAgICBpZihpdGVtLnRvdWNobW92ZSlcbiAgICAgICAgICAgIGl0ZW0udG91Y2htb3ZlKHRvdWNoRGF0YSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiBhIHRvdWNoIGlzIHN0YXJ0ZWQgb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIG9uVG91Y2hTdGFydFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIHRvdWNoIHN0YXJ0aW5nIG9uIHRoZSByZW5kZXJlciB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpXG57XG4gICAgdmFyIHJlY3QgPSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmKFBJWEkuQVVUT19QUkVWRU5UX0RFRkFVTFQpZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBcbiAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gY2hhbmdlZFRvdWNoZXNbaV07XG5cbiAgICAgICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMucG9vbC5wb3AoKTtcbiAgICAgICAgaWYoIXRvdWNoRGF0YSl0b3VjaERhdGEgPSBuZXcgUElYSS5JbnRlcmFjdGlvbkRhdGEoKTtcblxuICAgICAgICB0b3VjaERhdGEub3JpZ2luYWxFdmVudCA9ICBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgdGhpcy50b3VjaHNbdG91Y2hFdmVudC5pZGVudGlmaWVyXSA9IHRvdWNoRGF0YTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gKHRvdWNoRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCkgKiAodGhpcy50YXJnZXQud2lkdGggLyByZWN0LndpZHRoKTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gKHRvdWNoRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAgKiAodGhpcy50YXJnZXQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xuICAgICAgICBpZihuYXZpZ2F0b3IuaXNDb2Nvb25KUykge1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gdG91Y2hFdmVudC5jbGllbnRYO1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gdG91Y2hFdmVudC5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGorKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmludGVyYWN0aXZlSXRlbXNbal07XG5cbiAgICAgICAgICAgIGlmKGl0ZW0udG91Y2hzdGFydCB8fCBpdGVtLnRhcClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpdGVtLl9faGl0ID0gdGhpcy5oaXRUZXN0KGl0ZW0sIHRvdWNoRGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZihpdGVtLl9faGl0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jYWxsIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS50b3VjaHN0YXJ0KWl0ZW0udG91Y2hzdGFydCh0b3VjaERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLl9faXNEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fX3RvdWNoRGF0YSA9IHRvdWNoRGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZighaXRlbS5pbnRlcmFjdGl2ZUNoaWxkcmVuKWJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gYSB0b3VjaCBpcyBlbmRlZCBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBtZXRob2Qgb25Ub3VjaEVuZFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIHRvdWNoIGVuZGluZyBvbiB0aGUgcmVuZGVyZXIgdmlld1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudClcbntcbiAgICAvL3RoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDsgLy9JRSB1c2VzIHdpbmRvdy5ldmVudFxuICAgIHZhciByZWN0ID0gdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgIHZhciB0b3VjaERhdGEgPSB0aGlzLnRvdWNoc1t0b3VjaEV2ZW50LmlkZW50aWZpZXJdO1xuICAgICAgICB2YXIgdXAgPSBmYWxzZTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gKHRvdWNoRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCkgKiAodGhpcy50YXJnZXQud2lkdGggLyByZWN0LndpZHRoKTtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gKHRvdWNoRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAgKiAodGhpcy50YXJnZXQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xuICAgICAgICBpZihuYXZpZ2F0b3IuaXNDb2Nvb25KUykge1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC54ID0gdG91Y2hFdmVudC5jbGllbnRYO1xuICAgICAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gdG91Y2hFdmVudC5jbGllbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaW50ZXJhY3RpdmVJdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5pbnRlcmFjdGl2ZUl0ZW1zW2pdO1xuICAgICAgICAgICAgdmFyIGl0ZW1Ub3VjaERhdGEgPSBpdGVtLl9fdG91Y2hEYXRhOyAvLyA8LS0gSGVyZSFcbiAgICAgICAgICAgIGl0ZW0uX19oaXQgPSB0aGlzLmhpdFRlc3QoaXRlbSwgdG91Y2hEYXRhKTtcblxuICAgICAgICAgICAgaWYoaXRlbVRvdWNoRGF0YSA9PT0gdG91Y2hEYXRhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHNvIHRoaXMgb25lIFdBUyBkb3duLi4uXG4gICAgICAgICAgICAgICAgdG91Y2hEYXRhLm9yaWdpbmFsRXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICAgICAgLy8gaGl0VGVzdD8/XG5cbiAgICAgICAgICAgICAgICBpZihpdGVtLnRvdWNoZW5kIHx8IGl0ZW0udGFwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5fX2hpdCAmJiAhdXApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0udG91Y2hlbmQpaXRlbS50b3VjaGVuZCh0b3VjaERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5fX2lzRG93bilcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLnRhcClpdGVtLnRhcCh0b3VjaERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighaXRlbS5pbnRlcmFjdGl2ZUNoaWxkcmVuKXVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uX19pc0Rvd24pXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS50b3VjaGVuZG91dHNpZGUpaXRlbS50b3VjaGVuZG91dHNpZGUodG91Y2hEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uX19pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtLl9fdG91Y2hEYXRhID0gbnVsbDtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgdGhlIHRvdWNoLi5cbiAgICAgICAgdGhpcy5wb29sLnB1c2godG91Y2hEYXRhKTtcbiAgICAgICAgdGhpcy50b3VjaHNbdG91Y2hFdmVudC5pZGVudGlmaWVyXSA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIEEgU3RhZ2UgcmVwcmVzZW50cyB0aGUgcm9vdCBvZiB0aGUgZGlzcGxheSB0cmVlLiBFdmVyeXRoaW5nIGNvbm5lY3RlZCB0byB0aGUgc3RhZ2UgaXMgcmVuZGVyZWRcbiAqXG4gKiBAY2xhc3MgU3RhZ2VcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGJhY2tncm91bmRDb2xvciB7TnVtYmVyfSB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgc3RhZ2UsIHlvdSBoYXZlIHRvIHBhc3MgdGhpcyBpbiBpcyBpbiBoZXggZm9ybWF0XG4gKiAgICAgIGxpa2U6IDB4RkZGRkZGIGZvciB3aGl0ZVxuICogXG4gKiBDcmVhdGluZyBhIHN0YWdlIGlzIGEgbWFuZGF0b3J5IHByb2Nlc3Mgd2hlbiB5b3UgdXNlIFBpeGksIHdoaWNoIGlzIGFzIHNpbXBsZSBhcyB0aGlzIDogXG4gKiB2YXIgc3RhZ2UgPSBuZXcgUElYSS5TdGFnZSgweEZGRkZGRik7XG4gKiB3aGVyZSB0aGUgcGFyYW1ldGVyIGdpdmVuIGlzIHRoZSBiYWNrZ3JvdW5kIGNvbG91ciBvZiB0aGUgc3RhZ2UsIGluIGhleFxuICogeW91IHdpbGwgdXNlIHRoaXMgc3RhZ2UgaW5zdGFuY2UgdG8gYWRkIHlvdXIgc3ByaXRlcyB0byBpdCBhbmQgdGhlcmVmb3JlIHRvIHRoZSByZW5kZXJlclxuICogSGVyZSBpcyBob3cgdG8gYWRkIGEgc3ByaXRlIHRvIHRoZSBzdGFnZSA6IFxuICogc3RhZ2UuYWRkQ2hpbGQoc3ByaXRlKTtcbiAqL1xuUElYSS5TdGFnZSA9IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvcilcbntcbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCggdGhpcyApO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gQ3VycmVudCB0cmFuc2Zvcm0gb2YgdGhlIG9iamVjdCBiYXNlZCBvbiB3b3JsZCAocGFyZW50KSBmYWN0b3JzXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd29ybGRUcmFuc2Zvcm1cbiAgICAgKiBAdHlwZSBNYXQzXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbmV3IFBJWEkuTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc3RhZ2UgaXMgaW50ZXJhY3RpdmVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpbnRlcmFjdGl2ZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcmFjdGlvbiBtYW5hZ2UgZm9yIHRoaXMgc3RhZ2UsIG1hbmFnZXMgYWxsIGludGVyYWN0aXZlIGFjdGl2aXR5IG9uIHRoZSBzdGFnZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGludGVyYWN0aXZlXG4gICAgICogQHR5cGUgSW50ZXJhY3Rpb25NYW5hZ2VyXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBuZXcgUElYSS5JbnRlcmFjdGlvbk1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzdGFnZSBpcyBkaXJ0eSBhbmQgbmVlZHMgdG8gaGF2ZSBpbnRlcmFjdGlvbnMgdXBkYXRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRpcnR5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAvL3RoZSBzdGFnZSBpcyBpdHMgb3duIHN0YWdlXG4gICAgdGhpcy5zdGFnZSA9IHRoaXM7XG5cbiAgICAvL29wdGltaXplIGhpdCBkZXRlY3Rpb24gYSBiaXRcbiAgICB0aGlzLnN0YWdlLmhpdEFyZWEgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwwLDEwMDAwMCwgMTAwMDAwKTtcblxuICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKGJhY2tncm91bmRDb2xvcik7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5TdGFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlICk7XG5QSVhJLlN0YWdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3RhZ2U7XG5cbi8qKlxuICogU2V0cyBhbm90aGVyIERPTSBlbGVtZW50IHdoaWNoIGNhbiByZWNlaXZlIG1vdXNlL3RvdWNoIGludGVyYWN0aW9ucyBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IENhbnZhcyBlbGVtZW50LlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHdoZW4geW91IGhhdmUgb3RoZXIgRE9NIGVsZW1lbnRzIG9uIHRvcCBvZiB0aGUgQ2FudmFzIGVsZW1lbnQuXG4gKlxuICogQG1ldGhvZCBzZXRJbnRlcmFjdGlvbkRlbGVnYXRlXG4gKiBAcGFyYW0gZG9tRWxlbWVudCB7RE9NRWxlbWVudH0gVGhpcyBuZXcgZG9tRWxlbWVudCB3aGljaCB3aWxsIHJlY2VpdmUgbW91c2UvdG91Y2ggZXZlbnRzXG4gKi9cblBJWEkuU3RhZ2UucHJvdG90eXBlLnNldEludGVyYWN0aW9uRGVsZWdhdGUgPSBmdW5jdGlvbihkb21FbGVtZW50KVxue1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLnNldFRhcmdldERvbUVsZW1lbnQoIGRvbUVsZW1lbnQgKTtcbn07XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5TdGFnZS5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG5cbiAgICBmb3IodmFyIGk9MCxqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgaWYodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgLy8gdXBkYXRlIGludGVyYWN0aXZlIVxuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYodGhpcy5pbnRlcmFjdGl2ZSl0aGlzLmludGVyYWN0aW9uTWFuYWdlci51cGRhdGUoKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYmFja2dyb3VuZCBjb2xvciBmb3IgdGhlIHN0YWdlXG4gKlxuICogQG1ldGhvZCBzZXRCYWNrZ3JvdW5kQ29sb3JcbiAqIEBwYXJhbSBiYWNrZ3JvdW5kQ29sb3Ige051bWJlcn0gdGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kLCBlYXNpZXN0IHdheSB0byBwYXNzIHRoaXMgaW4gaXMgaW4gaGV4IGZvcm1hdFxuICogICAgICBsaWtlOiAweEZGRkZGRiBmb3Igd2hpdGVcbiAqL1xuUElYSS5TdGFnZS5wcm90b3R5cGUuc2V0QmFja2dyb3VuZENvbG9yID0gZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yKVxue1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yIHx8IDB4MDAwMDAwO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yU3BsaXQgPSBQSVhJLmhleDJyZ2IodGhpcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHZhciBoZXggPSB0aGlzLmJhY2tncm91bmRDb2xvci50b1N0cmluZygxNik7XG4gICAgaGV4ID0gJzAwMDAwMCcuc3Vic3RyKDAsIDYgLSBoZXgubGVuZ3RoKSArIGhleDtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvclN0cmluZyA9ICcjJyArIGhleDtcbn07XG5cbi8qKlxuICogVGhpcyB3aWxsIHJldHVybiB0aGUgcG9pbnQgY29udGFpbmluZyBnbG9iYWwgY29vcmRzIG9mIHRoZSBtb3VzZS5cbiAqXG4gKiBAbWV0aG9kIGdldE1vdXNlUG9zaXRpb25cbiAqIEByZXR1cm4ge1BvaW50fSBUaGUgcG9pbnQgY29udGFpbmluZyB0aGUgY29vcmRzIG9mIHRoZSBnbG9iYWwgSW50ZXJhY3Rpb25EYXRhIHBvc2l0aW9uLlxuICovXG5QSVhJLlN0YWdlLnByb3RvdHlwZS5nZXRNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5tb3VzZS5nbG9iYWw7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG4gXG4vLyBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuLy8gaHR0cDovL215Lm9wZXJhLmNvbS9lbW9sbGVyL2Jsb2cvMjAxMS8xMi8yMC9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWVyLWFuaW1hdGluZ1xuXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLiBmaXhlcyBmcm9tIFBhdWwgSXJpc2ggYW5kIFRpbm8gWmlqZGVsXG5cbi8vIE1JVCBsaWNlbnNlXG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKiBZb3UgY2FuIGFjdHVhbGx5IHVzZSBib3RoIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhbmQgcmVxdWVzdEFuaW1GcmFtZSwgXG4gKiB5b3Ugd2lsbCBzdGlsbCBiZW5lZml0IGZyb20gdGhlIHBvbHlmaWxsXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqL1xuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBjYW5jZWxBbmltYXRpb25GcmFtZVxuICpcbiAqIEBtZXRob2QgY2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAqL1xudmFyIGxhc3RUaW1lID0gMDtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcbmZvcih2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHxcbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG59XG5cbmlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpOyB9LFxuICAgICAgICAgIHRpbWVUb0NhbGwpO1xuICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG59XG5cbmlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xufVxuXG53aW5kb3cucmVxdWVzdEFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgbnVtYmVyIHRvIGFuIFtSLCBHLCBCXSBhcnJheVxuICpcbiAqIEBtZXRob2QgaGV4MnJnYlxuICogQHBhcmFtIGhleCB7TnVtYmVyfVxuICovXG5QSVhJLmhleDJyZ2IgPSBmdW5jdGlvbihoZXgpIHtcbiAgICByZXR1cm4gWyhoZXggPj4gMTYgJiAweEZGKSAvIDI1NSwgKCBoZXggPj4gOCAmIDB4RkYpIC8gMjU1LCAoaGV4ICYgMHhGRikvIDI1NV07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3IgYXMgYW4gW1IsIEcsIEJdIGFycmF5IHRvIGEgaGV4IG51bWJlclxuICpcbiAqIEBtZXRob2QgcmdiMmhleFxuICogQHBhcmFtIHJnYiB7QXJyYXl9XG4gKi9cblBJWEkucmdiMmhleCA9IGZ1bmN0aW9uKHJnYikge1xuICAgIHJldHVybiAoKHJnYlswXSoyNTUgPDwgMTYpICsgKHJnYlsxXSoyNTUgPDwgOCkgKyByZ2JbMl0qMjU1KTtcbn07XG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAqXG4gKiBAbWV0aG9kIGJpbmRcbiAqL1xuaWYgKHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5hcHBseSh0aGlzIGluc3RhbmNlb2YgYm91bmQgPyB0aGlzIDogdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IChmdW5jdGlvbiBGKHByb3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3RvKSBGLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGKSkgcmV0dXJuIG5ldyBGKCk7XG4gICAgICAgICAgICB9KSh0YXJnZXQucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG59XG5cbi8qKlxuICogQSB3cmFwcGVyIGZvciBhamF4IHJlcXVlc3RzIHRvIGJlIGhhbmRsZWQgY3Jvc3MgYnJvd3NlclxuICpcbiAqIEBjbGFzcyBBamF4UmVxdWVzdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBJWEkuQWpheFJlcXVlc3QgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGFjdGl2ZXhtb2RlcyA9IFsnTXN4bWwyLlhNTEhUVFAuNi4wJywgJ01zeG1sMi5YTUxIVFRQLjMuMCcsICdNaWNyb3NvZnQuWE1MSFRUUCddOyAvL2FjdGl2ZVggdmVyc2lvbnMgdG8gY2hlY2sgZm9yIGluIElFXG5cbiAgICBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpXG4gICAgeyAvL1Rlc3QgZm9yIHN1cHBvcnQgZm9yIEFjdGl2ZVhPYmplY3QgaW4gSUUgZmlyc3QgKGFzIFhNTEh0dHBSZXF1ZXN0IGluIElFNyBpcyBicm9rZW4pXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxhY3RpdmV4bW9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KGFjdGl2ZXhtb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgLy9zdXBwcmVzcyBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkgLy8gaWYgTW96aWxsYSwgU2FmYXJpIGV0Y1xuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG4vKlxuUElYSS5wYWNrQ29sb3JSR0JBID0gZnVuY3Rpb24ociwgZywgYiwgYSkvL3IsIGcsIGIsIGEpXG57XG4gIC8vICBjb25zb2xlLmxvZyhyLCBiLCBjLCBkKVxuICByZXR1cm4gKE1hdGguZmxvb3IoKHIpKjYzKSA8PCAxOCkgfCAoTWF0aC5mbG9vcigoZykqNjMpIDw8IDEyKSB8IChNYXRoLmZsb29yKChiKSo2MykgPDwgNik7Ly8gfCAoTWF0aC5mbG9vcigoYSkqNjMpKVxuICAvLyAgaSA9IGkgfCAoTWF0aC5mbG9vcigoYSkqNjMpKTtcbiAgIC8vIHJldHVybiBpO1xuICAgLy8gdmFyIHIgPSAoaSAvIDI2MjE0NC4wICkgLyA2NDtcbiAgIC8vIHZhciBnID0gKGkgLyA0MDk2LjApJTY0IC8gNjQ7XG4gIC8vICB2YXIgYiA9IChpIC8gNjQuMCklNjQgLyA2NDtcbiAgLy8gIHZhciBhID0gKGkpJTY0IC8gNjQ7XG4gICAgIFxuICAvLyAgY29uc29sZS5sb2cociwgZywgYiwgYSk7XG4gIC8vICByZXR1cm4gaTtcblxufTtcbiovXG4vKlxuUElYSS5wYWNrQ29sb3JSR0IgPSBmdW5jdGlvbihyLCBnLCBiKS8vciwgZywgYiwgYSlcbntcbiAgICByZXR1cm4gKE1hdGguZmxvb3IoKHIpKjI1NSkgPDwgMTYpIHwgKE1hdGguZmxvb3IoKGcpKjI1NSkgPDwgOCkgfCAoTWF0aC5mbG9vcigoYikqMjU1KSk7XG59O1xuXG5QSVhJLnVucGFja0NvbG9yUkdCID0gZnVuY3Rpb24ociwgZywgYikvL3IsIGcsIGIsIGEpXG57XG4gICAgcmV0dXJuIChNYXRoLmZsb29yKChyKSoyNTUpIDw8IDE2KSB8IChNYXRoLmZsb29yKChnKSoyNTUpIDw8IDgpIHwgKE1hdGguZmxvb3IoKGIpKjI1NSkpO1xufTtcbiovXG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIENhbnZhcyBCbGVuZE1vZGVzIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3NlclxuICpcbiAqIEBtZXRob2QgY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2Rlc1xuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGV5IGFyZSBzdXBwb3J0ZWRcbiAqL1xuUElYSS5jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMCc7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLDAsMSwxKTtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2ZmZic7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLDAsMSwxKTtcbiAgICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwwLDEsMSkuZGF0YVswXSA9PT0gMDtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBudW1iZXIsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY2xvc2VzdCBudW1iZXIgdGhhdCBpcyBhIHBvd2VyIG9mIHR3b1xuICogdGhpcyBmdW5jdGlvbiBpcyB0YWtlbiBmcm9tIFN0YXJsaW5nIEZyYW1ld29yayBhcyBpdHMgcHJldHR5IG5lYXQgOylcbiAqXG4gKiBAbWV0aG9kIGdldE5leHRQb3dlck9mVHdvXG4gKiBAcGFyYW0gbnVtYmVyIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjbG9zZXN0IG51bWJlciB0aGF0IGlzIGEgcG93ZXIgb2YgdHdvXG4gKi9cblBJWEkuZ2V0TmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbihudW1iZXIpXG57XG4gICAgaWYgKG51bWJlciA+IDAgJiYgKG51bWJlciAmIChudW1iZXIgLSAxKSkgPT09IDApIC8vIHNlZTogaHR0cDovL2dvby5nbC9EOWtQalxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciByZXN1bHQgPSAxO1xuICAgICAgICB3aGlsZSAocmVzdWx0IDwgbnVtYmVyKSByZXN1bHQgPDw9IDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuIFxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50dGFyZ2V0LmpzL1xuICogVEhhbmtTIG1yIERPb2IhXG4gKi9cblxuLyoqXG4gKiBBZGRzIGV2ZW50IGVtaXR0ZXIgZnVuY3Rpb25hbGl0eSB0byBhIGNsYXNzXG4gKlxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XG4gKiBAZXhhbXBsZVxuICogICAgICBmdW5jdGlvbiBNeUVtaXR0ZXIoKSB7XG4gKiAgICAgICAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7IC8vbWl4ZXMgaW4gZXZlbnQgdGFyZ2V0IHN0dWZmXG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIHZhciBlbSA9IG5ldyBNeUVtaXR0ZXIoKTtcbiAqICAgICAgZW0uZW1pdCh7IHR5cGU6ICdldmVudE5hbWUnLCBkYXRhOiAnc29tZSBkYXRhJyB9KTtcbiAqL1xuUElYSS5FdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIGFsbCB0aGUgbGlzdGVuZXJzXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGlzdGVuZXJzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIGxpc3RlbmVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIGZvciBhIHNwZWNpZmljIGV2ZW50XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIge2Z1bmN0aW9ufSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gdGhlIGV2ZW50IG9jY3Vyc1xuICAgICAqL1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IHRoaXMub24gPSBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHRoZSBldmVudCwgaWUgcHJldGVuZHMgdGhhdCB0aGUgZXZlbnQgaGFzIGhhcHBlbmVkXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcbiAgICAgKiBAcGFyYW0gZXZlbnQge0V2ZW50fSB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50ID0gdGhpcy5lbWl0ID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgICAgICBpZiAoICFsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXSB8fCAhbGlzdGVuZXJzWyBldmVudC50eXBlIF0ubGVuZ3RoICkge1xuXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAgICAgbGlzdGVuZXJzWyBldmVudC50eXBlIF1bIGkgXSggZXZlbnQgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIHRoYXQgd2FzIGFzc2lnbmVkIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZVxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHdoaWNoIHdpbGwgaGF2ZSBpdHMgbGlzdGVuZXIgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciB7ZnVuY3Rpb259IFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdhcyBiZSBmaXJlZCB3aGVuIHRoZSBldmVudCBvY2N1cmVkXG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gdGhpcy5vZmYgPSBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICk7XG5cbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFjdGl2ZSBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHdoaWNoIHdpbGwgaGF2ZSBhbGwgaXRzIGxpc3RlbmVycyByZW1vdmVkXG4gICAgICovXG5cdHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHR2YXIgYSA9IGxpc3RlbmVyc1t0eXBlXTtcblx0XHRpZiAoYSlcblx0XHRcdGEubGVuZ3RoID0gMDtcblx0fTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHdoaWNoIHJlbmRlcmVyIHlvdSBzaG91bGQgYmUgdXNpbmcuXG4gKiBXZWJHTCBpcyB0aGUgcHJlZmVycmVkIHJlbmRlcmVyIGFzIGl0IGlzIGEgbG90IGZhc3Rlci4gSWYgd2ViR0wgaXMgbm90IHN1cHBvcnRlZCBieVxuICogdGhlIGJyb3dzZXIgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgY2FudmFzIHJlbmRlcmVyXG4gKiBAY2xhc3MgYXV0b0RldGVjdFJlbmRlcmVyXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gd2lkdGg9ODAwIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQ9NjAwIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlcmVycyB2aWV3XG4gKiBAcGFyYW0gW3ZpZXddIHtDYW52YXN9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWwgXG4gKiBAcGFyYW0gW3RyYW5zcGFyZW50PWZhbHNlXSB7Qm9vbGVhbn0gdGhlIHRyYW5zcGFyZW5jeSBvZiB0aGUgcmVuZGVyIHZpZXcsIGRlZmF1bHQgZmFsc2VcbiAqIEBwYXJhbSBbYW50aWFsaWFzPWZhbHNlXSB7Qm9vbGVhbn0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiB3ZWJHTCBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAqXG4gKi9cblBJWEkuYXV0b0RldGVjdFJlbmRlcmVyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdmlldywgdHJhbnNwYXJlbnQsIGFudGlhbGlhcylcbntcbiAgICBpZighd2lkdGgpd2lkdGggPSA4MDA7XG4gICAgaWYoIWhlaWdodCloZWlnaHQgPSA2MDA7XG5cbiAgICAvLyBCT1JST1dFRCBmcm9tIE1yIERvb2IgKG1yZG9vYi5jb20pXG4gICAgdmFyIHdlYmdsID0gKCBmdW5jdGlvbiAoKSB7IHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhISB3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmICggY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKSB8fCBjYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKCBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApKCk7XG5cblxuICAgIGlmKCB3ZWJnbCApXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFBJWEkuV2ViR0xSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudCwgYW50aWFsaWFzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIG5ldyBQSVhJLkNhbnZhc1JlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIHZpZXcsIHRyYW5zcGFyZW50KTtcbn07XG5cbi8qXG4gICAgUG9seUsgbGlicmFyeVxuICAgIHVybDogaHR0cDovL3BvbHlrLml2YW5rLm5ldFxuICAgIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbmNlLlxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDEyIEl2YW4gS3Vja2lyXG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgIGNvbmRpdGlvbnM6XG5cbiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuICAgIFRoaXMgaXMgYW4gYW1hemluZyBsaWIhXG5cbiAgICBzbGlnaHRseSBtb2RpZmllZCBieSBNYXQgR3JvdmVzIChtYXRncm92ZXMuY29tKTtcbiovXG5cbi8qKlxuICogQmFzZWQgb24gdGhlIFBvbHlrIGxpYnJhcnkgaHR0cDovL3BvbHlrLml2YW5rLm5ldCByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5jZS5cbiAqIFRoaXMgaXMgYW4gYW1hemluZyBsaWIhXG4gKiBzbGlnaHRseSBtb2RpZmllZCBieSBNYXQgR3JvdmVzIChtYXRncm92ZXMuY29tKTtcbiAqIEBjbGFzcyBQb2x5S1xuICpcbiAqL1xuUElYSS5Qb2x5SyA9IHt9O1xuXG4vKipcbiAqIFRyaWFuZ3VsYXRlcyBzaGFwZXMgZm9yIHdlYkdMIGdyYXBoaWMgZmlsbHNcbiAqXG4gKiBAbWV0aG9kIFRyaWFuZ3VsYXRlXG4gKiBcbiAqL1xuUElYSS5Qb2x5Sy5Ucmlhbmd1bGF0ZSA9IGZ1bmN0aW9uKHApXG57XG4gICAgdmFyIHNpZ24gPSB0cnVlO1xuXG4gICAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICAgIGlmKG4gPCAzKSByZXR1cm4gW107XG5cbiAgICB2YXIgdGdzID0gW107XG4gICAgdmFyIGF2bCA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGF2bC5wdXNoKGkpO1xuXG4gICAgaSA9IDA7XG4gICAgdmFyIGFsID0gbjtcbiAgICB3aGlsZShhbCA+IDMpXG4gICAge1xuICAgICAgICB2YXIgaTAgPSBhdmxbKGkrMCklYWxdO1xuICAgICAgICB2YXIgaTEgPSBhdmxbKGkrMSklYWxdO1xuICAgICAgICB2YXIgaTIgPSBhdmxbKGkrMiklYWxdO1xuXG4gICAgICAgIHZhciBheCA9IHBbMippMF0sICBheSA9IHBbMippMCsxXTtcbiAgICAgICAgdmFyIGJ4ID0gcFsyKmkxXSwgIGJ5ID0gcFsyKmkxKzFdO1xuICAgICAgICB2YXIgY3ggPSBwWzIqaTJdLCAgY3kgPSBwWzIqaTIrMV07XG5cbiAgICAgICAgdmFyIGVhckZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmKFBJWEkuUG9seUsuX2NvbnZleChheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBzaWduKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGFsOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHZpID0gYXZsW2pdO1xuICAgICAgICAgICAgICAgIGlmKHZpID09PSBpMCB8fCB2aSA9PT0gaTEgfHwgdmkgPT09IGkyKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmKFBJWEkuUG9seUsuX1BvaW50SW5UcmlhbmdsZShwWzIqdmldLCBwWzIqdmkrMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhckZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVhckZvdW5kKVxuICAgICAgICB7XG4gICAgICAgICAgICB0Z3MucHVzaChpMCwgaTEsIGkyKTtcbiAgICAgICAgICAgIGF2bC5zcGxpY2UoKGkrMSklYWwsIDEpO1xuICAgICAgICAgICAgYWwtLTtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoaSsrID4gMyphbClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gbmVlZCB0byBmbGlwIGZsaXAgcmV2ZXJzZSBpdCFcbiAgICAgICAgICAgIC8vIHJlc2V0IVxuICAgICAgICAgICAgaWYoc2lnbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0Z3MgPSBbXTtcbiAgICAgICAgICAgICAgICBhdmwgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspIGF2bC5wdXNoKGkpO1xuXG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBuO1xuXG4gICAgICAgICAgICAgICAgc2lnbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhcIlBJWEkgV2FybmluZzogc2hhcGUgdG9vIGNvbXBsZXggdG8gZmlsbFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0Z3MucHVzaChhdmxbMF0sIGF2bFsxXSwgYXZsWzJdKTtcbiAgICByZXR1cm4gdGdzO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHBvaW50IGlzIHdpdGhpbiBhIHRyaWFuZ2xlXG4gKlxuICogQG1ldGhvZCBfUG9pbnRJblRyaWFuZ2xlXG4gKiBAcGFyYW0gcHgge051bWJlcn0geCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0gcHkge051bWJlcn0geSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0gYXgge051bWJlcn0geCBjb29yZGluYXRlIG9mIHRoZSBhIHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIGF5IHtOdW1iZXJ9IHkgY29vcmRpbmF0ZSBvZiB0aGUgYSBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwYXJhbSBieCB7TnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgdGhlIGIgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0gYnkge051bWJlcn0geSBjb29yZGluYXRlIG9mIHRoZSBiIHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIGN4IHtOdW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgYyBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwYXJhbSBjeSB7TnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIGMgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlBvbHlLLl9Qb2ludEluVHJpYW5nbGUgPSBmdW5jdGlvbihweCwgcHksIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpXG57XG4gICAgdmFyIHYweCA9IGN4LWF4O1xuICAgIHZhciB2MHkgPSBjeS1heTtcbiAgICB2YXIgdjF4ID0gYngtYXg7XG4gICAgdmFyIHYxeSA9IGJ5LWF5O1xuICAgIHZhciB2MnggPSBweC1heDtcbiAgICB2YXIgdjJ5ID0gcHktYXk7XG5cbiAgICB2YXIgZG90MDAgPSB2MHgqdjB4K3YweSp2MHk7XG4gICAgdmFyIGRvdDAxID0gdjB4KnYxeCt2MHkqdjF5O1xuICAgIHZhciBkb3QwMiA9IHYweCp2MngrdjB5KnYyeTtcbiAgICB2YXIgZG90MTEgPSB2MXgqdjF4K3YxeSp2MXk7XG4gICAgdmFyIGRvdDEyID0gdjF4KnYyeCt2MXkqdjJ5O1xuXG4gICAgdmFyIGludkRlbm9tID0gMSAvIChkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSk7XG4gICAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgdmFyIHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207XG5cbiAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbiB0cmlhbmdsZVxuICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBzaGFwZSBpcyBjb252ZXhcbiAqXG4gKiBAbWV0aG9kIF9jb252ZXhcbiAqIFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Qb2x5Sy5fY29udmV4ID0gZnVuY3Rpb24oYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgc2lnbilcbntcbiAgICByZXR1cm4gKChheS1ieSkqKGN4LWJ4KSArIChieC1heCkqKGN5LWJ5KSA+PSAwKSA9PT0gc2lnbjtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLy8gVE9ETyBBbHZpbiBhbmQgTWF0XG4vLyBTaG91bGQgd2UgZXZlbnR1YWxseSBjcmVhdGUgYSBVdGlscyBjbGFzcyA/IFxuLy8gT3IganVzdCBtb3ZlIHRoaXMgZmlsZSB0byB0aGUgcGl4aS5qcyBmaWxlID9cblBJWEkuaW5pdERlZmF1bHRTaGFkZXJzID0gZnVuY3Rpb24oKVxue1xuICAgXG4gIC8vICBQSVhJLnN0cmlwU2hhZGVyID0gbmV3IFBJWEkuU3RyaXBTaGFkZXIoKTtcbi8vICAgIFBJWEkuc3RyaXBTaGFkZXIuaW5pdCgpO1xuXG59O1xuXG5QSVhJLkNvbXBpbGVWZXJ0ZXhTaGFkZXIgPSBmdW5jdGlvbihnbCwgc2hhZGVyU3JjKVxue1xuICAgIHJldHVybiBQSVhJLl9Db21waWxlU2hhZGVyKGdsLCBzaGFkZXJTcmMsIGdsLlZFUlRFWF9TSEFERVIpO1xufTtcblxuUElYSS5Db21waWxlRnJhZ21lbnRTaGFkZXIgPSBmdW5jdGlvbihnbCwgc2hhZGVyU3JjKVxue1xuICAgIHJldHVybiBQSVhJLl9Db21waWxlU2hhZGVyKGdsLCBzaGFkZXJTcmMsIGdsLkZSQUdNRU5UX1NIQURFUik7XG59O1xuXG5QSVhJLl9Db21waWxlU2hhZGVyID0gZnVuY3Rpb24oZ2wsIHNoYWRlclNyYywgc2hhZGVyVHlwZSlcbntcbiAgICB2YXIgc3JjID0gc2hhZGVyU3JjLmpvaW4oXCJcXG5cIik7XG4gICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxuUElYSS5jb21waWxlUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKVxue1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IFBJWEkuQ29tcGlsZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNyYyk7XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IFBJWEkuQ29tcGlsZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U3JjKTtcblxuICAgIHZhciBzaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcblxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihzaGFkZXJQcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKFwiQ291bGQgbm90IGluaXRpYWxpc2Ugc2hhZGVyc1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyUHJvZ3JhbTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKiBAYXV0aG9yIFJpY2hhcmQgRGF2ZXkgaHR0cDovL3d3dy5waG90b25zdG9ybS5jb20gQHBob3RvbnN0b3JtXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBQaXhpU2hhZGVyXG4qIEBjb25zdHJ1Y3RvclxuKi9cblBJWEkuUGl4aVNoYWRlciA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBnbFxuICAgICAqIEB0eXBlIFdlYkdMQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHthbnl9IHByb2dyYW0gLSBUaGUgV2ViR0wgcHJvZ3JhbS5cbiAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGZyYWdtZW50U3JjIC0gVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAqL1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yIDsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gdGV4dHVyZUNvdW50IC0gQSBsb2NhbCB0ZXh0dXJlIGNvdW50ZXIgZm9yIG11bHRpLXRleHR1cmUgc2hhZGVycy5cbiAgICAqL1xuICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMDtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGluaXRcbipcbiovXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHZhciBwcm9ncmFtID0gUElYSS5jb21waWxlUHJvZ3JhbShnbCwgdGhpcy52ZXJ0ZXhTcmMgfHwgUElYSS5QaXhpU2hhZGVyLmRlZmF1bHRWZXJ0ZXhTcmMsIHRoaXMuZnJhZ21lbnRTcmMpO1xuICAgIFxuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSB1bmlmb3JtcyBmb3IgdGhlIHNoYWRlclxuICAgIHRoaXMudVNhbXBsZXIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTYW1wbGVyJyk7XG4gICAgdGhpcy5wcm9qZWN0aW9uVmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdwcm9qZWN0aW9uVmVjdG9yJyk7XG4gICAgdGhpcy5vZmZzZXRWZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ29mZnNldFZlY3RvcicpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnZGltZW5zaW9ucycpO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgYXR0cmlidXRlc1xuICAgIHRoaXMuYVZlcnRleFBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgIHRoaXMuYVRleHR1cmVDb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVGV4dHVyZUNvb3JkJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcblxuXG4gICAgLy8gQmVnaW4gd29yc3QgaGFjayBldmEgLy9cblxuICAgIC8vIFdIWT8/PyBPTkxZIG9uIG15IGNocm9tZSBwaXhlbCB0aGUgbGluZSBhYm92ZSByZXR1cm5zIC0xIHdoZW4gdXNpbmcgZmlsdGVycz9cbiAgICAvLyBtYXliZSBpdHMgc29tZXRoaW5nIHRvIGRvIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGdsIGNvbnRleHQuXG4gICAgLy8gSW0gY29udmluY2VkIHRoaXMgaXMgYSBidWcgaW4gdGhlIGNocm9tZSBicm93c2VyIGFzIHRoZXJlIGlzIE5PIHJlYXNvbiB3aHkgdGhpcyBzaG91bGQgYmUgcmV0dXJuaW5nIC0xIGVzcGVjaWFsbHkgYXMgaXQgb25seSBtYW5pZmVzdHMgb24gbXkgY2hyb21lIHBpeGVsXG4gICAgLy8gSWYgdGhlcmVzIGFueSB3ZWJHTCBwZW9wbGUgdGhhdCBrbm93IHdoeSBjb3VsZCBoYXBwZW4gcGxlYXNlIGhlbHAgOilcbiAgICBpZih0aGlzLmNvbG9yQXR0cmlidXRlID09PSAtMSlcbiAgICB7XG4gICAgICAgIHRoaXMuY29sb3JBdHRyaWJ1dGUgPSAyO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFt0aGlzLmFWZXJ0ZXhQb3NpdGlvbiwgdGhpcy5hVGV4dHVyZUNvb3JkLCB0aGlzLmNvbG9yQXR0cmlidXRlXTtcblxuICAgIC8vIEVuZCB3b3JzdCBoYWNrIGV2YSAvL1xuXG4gICAgLy8gYWRkIHRob3NlIGN1c3RvbSBzaGFkZXJzIVxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnVuaWZvcm1zKVxuICAgIHtcbiAgICAgICAgLy8gZ2V0IHRoZSB1bmlmb3JtIGxvY2F0aW9ucy4uXG4gICAgICAgIHRoaXMudW5pZm9ybXNba2V5XS51bmlmb3JtTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwga2V5KTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRVbmlmb3JtcygpO1xuXG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyIHVuaWZvcm0gdmFsdWVzLlxuKiBVbmlmb3JtcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBHTFNMX0VTIFNwZWNpZmljYXRpb246IGh0dHA6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvbGF0ZXN0LzEuMC9cbiogaHR0cDovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS9nbGVzL3NwZWNzLzIuMC9HTFNMX0VTX1NwZWNpZmljYXRpb25fMS4wLjE3LnBkZlxuKlxuKiBAbWV0aG9kIGluaXRVbmlmb3Jtc1xuKi9cblBJWEkuUGl4aVNoYWRlci5wcm90b3R5cGUuaW5pdFVuaWZvcm1zID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMTtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciB1bmlmb3JtO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMudW5pZm9ybXMpXG4gICAge1xuICAgICAgICB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1trZXldO1xuXG4gICAgICAgIHZhciB0eXBlID0gdW5pZm9ybS50eXBlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc2FtcGxlcjJEJylcbiAgICAgICAge1xuICAgICAgICAgICAgdW5pZm9ybS5faW5pdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodW5pZm9ybS52YWx1ZSAhPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTYW1wbGVyMkQodW5pZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ21hdDInIHx8IHR5cGUgPT09ICdtYXQzJyB8fCB0eXBlID09PSAnbWF0NCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBUaGVzZSByZXF1aXJlIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgICAgIHVuaWZvcm0uZ2xNYXRyaXggPSB0cnVlO1xuICAgICAgICAgICAgdW5pZm9ybS5nbFZhbHVlTGVuZ3RoID0gMTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtYXQyJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsRnVuYyA9IGdsLnVuaWZvcm1NYXRyaXgyZnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbWF0MycpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMgPSBnbC51bmlmb3JtTWF0cml4M2Z2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ21hdDQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jID0gZ2wudW5pZm9ybU1hdHJpeDRmdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBHTCBmdW5jdGlvbiByZWZlcmVuY2VcbiAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jID0gZ2xbJ3VuaWZvcm0nICsgdHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnMmYnIHx8IHR5cGUgPT09ICcyaScpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbFZhbHVlTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICczZicgfHwgdHlwZSA9PT0gJzNpJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsVmFsdWVMZW5ndGggPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJzRmJyB8fCB0eXBlID09PSAnNGknKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbFZhbHVlTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4qIEluaXRpYWxpc2VzIGEgU2FtcGxlcjJEIHVuaWZvcm0gKHdoaWNoIG1heSBvbmx5IGJlIGF2YWlsYWJsZSBsYXRlciBvbiBhZnRlciBpbml0VW5pZm9ybXMgb25jZSB0aGUgdGV4dHVyZSBoYXMgbG9hZGVkKVxuKlxuKiBAbWV0aG9kIGluaXRTYW1wbGVyMkRcbiovXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLmluaXRTYW1wbGVyMkQgPSBmdW5jdGlvbih1bmlmb3JtKVxue1xuICAgIGlmICghdW5pZm9ybS52YWx1ZSB8fCAhdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZSB8fCAhdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbJ1RFWFRVUkUnICsgdGhpcy50ZXh0dXJlQ291bnRdKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSk7XG5cbiAgICAvLyAgRXh0ZW5kZWQgdGV4dHVyZSBkYXRhXG4gICAgaWYgKHVuaWZvcm0udGV4dHVyZURhdGEpXG4gICAge1xuICAgICAgICB2YXIgZGF0YSA9IHVuaWZvcm0udGV4dHVyZURhdGE7XG5cbiAgICAgICAgLy8gR0xUZXh0dXJlID0gbWFnIGxpbmVhciwgbWluIGxpbmVhcl9taXBtYXBfbGluZWFyLCB3cmFwIHJlcGVhdCArIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgICAgICAvLyBHTFRleHR1cmVMaW5lYXIgPSBtYWcvbWluIGxpbmVhciwgd3JhcCBjbGFtcFxuICAgICAgICAvLyBHTFRleHR1cmVOZWFyZXN0UmVwZWF0ID0gbWFnL21pbiBORUFSRVNULCB3cmFwIHJlcGVhdFxuICAgICAgICAvLyBHTFRleHR1cmVOZWFyZXN0ID0gbWFnL21pbiBuZWFyZXN0LCB3cmFwIGNsYW1wXG4gICAgICAgIC8vIEF1ZGlvVGV4dHVyZSA9IHdoYXRldmVyICsgbHVtaW5hbmNlICsgd2lkdGggNTEyLCBoZWlnaHQgMiwgYm9yZGVyIDBcbiAgICAgICAgLy8gS2V5VGV4dHVyZSA9IHdoYXRldmVyICsgbHVtaW5hbmNlICsgd2lkdGggMjU2LCBoZWlnaHQgMiwgYm9yZGVyIDBcblxuICAgICAgICAvLyAgbWFnRmlsdGVyIGNhbiBiZTogZ2wuTElORUFSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiBvciBnbC5ORUFSRVNUXG4gICAgICAgIC8vICB3cmFwUy9UIGNhbiBiZTogZ2wuQ0xBTVBfVE9fRURHRSBvciBnbC5SRVBFQVRcblxuICAgICAgICB2YXIgbWFnRmlsdGVyID0gKGRhdGEubWFnRmlsdGVyKSA/IGRhdGEubWFnRmlsdGVyIDogZ2wuTElORUFSO1xuICAgICAgICB2YXIgbWluRmlsdGVyID0gKGRhdGEubWluRmlsdGVyKSA/IGRhdGEubWluRmlsdGVyIDogZ2wuTElORUFSO1xuICAgICAgICB2YXIgd3JhcFMgPSAoZGF0YS53cmFwUykgPyBkYXRhLndyYXBTIDogZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgICAgdmFyIHdyYXBUID0gKGRhdGEud3JhcFQpID8gZGF0YS53cmFwVCA6IGdsLkNMQU1QX1RPX0VER0U7XG4gICAgICAgIHZhciBmb3JtYXQgPSAoZGF0YS5sdW1pbmFuY2UpID8gZ2wuTFVNSU5BTkNFIDogZ2wuUkdCQTtcblxuICAgICAgICBpZiAoZGF0YS5yZXBlYXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdyYXBTID0gZ2wuUkVQRUFUO1xuICAgICAgICAgICAgd3JhcFQgPSBnbC5SRVBFQVQ7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCAhIWRhdGEuZmxpcFkpO1xuXG4gICAgICAgIGlmIChkYXRhLndpZHRoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSAoZGF0YS53aWR0aCkgPyBkYXRhLndpZHRoIDogNTEyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IChkYXRhLmhlaWdodCkgPyBkYXRhLmhlaWdodCA6IDI7XG4gICAgICAgICAgICB2YXIgYm9yZGVyID0gKGRhdGEuYm9yZGVyKSA/IGRhdGEuYm9yZGVyIDogMDtcblxuICAgICAgICAgICAgLy8gdm9pZCB0ZXhJbWFnZTJEKEdMZW51bSB0YXJnZXQsIEdMaW50IGxldmVsLCBHTGVudW0gaW50ZXJuYWxmb3JtYXQsIEdMc2l6ZWkgd2lkdGgsIEdMc2l6ZWkgaGVpZ2h0LCBHTGludCBib3JkZXIsIEdMZW51bSBmb3JtYXQsIEdMZW51bSB0eXBlLCBBcnJheUJ1ZmZlclZpZXc/IHBpeGVscyk7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgYm9yZGVyLCBmb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gIHZvaWQgdGV4SW1hZ2UyRChHTGVudW0gdGFyZ2V0LCBHTGludCBsZXZlbCwgR0xlbnVtIGludGVybmFsZm9ybWF0LCBHTGVudW0gZm9ybWF0LCBHTGVudW0gdHlwZSwgSW1hZ2VEYXRhPyBwaXhlbHMpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBtYWdGaWx0ZXIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbWluRmlsdGVyKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgd3JhcFMpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB3cmFwVCk7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybTFpKHVuaWZvcm0udW5pZm9ybUxvY2F0aW9uLCB0aGlzLnRleHR1cmVDb3VudCk7XG5cbiAgICB1bmlmb3JtLl9pbml0ID0gdHJ1ZTtcblxuICAgIHRoaXMudGV4dHVyZUNvdW50Kys7XG5cbn07XG5cbi8qKlxuKiBVcGRhdGVzIHRoZSBzaGFkZXIgdW5pZm9ybSB2YWx1ZXMuXG4qXG4qIEBtZXRob2Qgc3luY1VuaWZvcm1zXG4qL1xuUElYSS5QaXhpU2hhZGVyLnByb3RvdHlwZS5zeW5jVW5pZm9ybXMgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy50ZXh0dXJlQ291bnQgPSAxO1xuICAgIHZhciB1bmlmb3JtO1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyAgVGhpcyB3b3VsZCBwcm9iYWJseSBiZSBmYXN0ZXIgaW4gYW4gYXJyYXkgYW5kIGl0IHdvdWxkIGd1YXJhbnRlZSBrZXkgb3JkZXJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy51bmlmb3JtcylcbiAgICB7XG4gICAgICAgIHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW2tleV07XG5cbiAgICAgICAgaWYgKHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0uZ2xNYXRyaXggPT09IHRydWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMuY2FsbChnbCwgdW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0udHJhbnNwb3NlLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsRnVuYy5jYWxsKGdsLCB1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pZm9ybS5nbFZhbHVlTGVuZ3RoID09PSAyKVxuICAgICAgICB7XG4gICAgICAgICAgICB1bmlmb3JtLmdsRnVuYy5jYWxsKGdsLCB1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdW5pZm9ybS52YWx1ZS54LCB1bmlmb3JtLnZhbHVlLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9PT0gMylcbiAgICAgICAge1xuICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMuY2FsbChnbCwgdW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0udmFsdWUueCwgdW5pZm9ybS52YWx1ZS55LCB1bmlmb3JtLnZhbHVlLnopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9PT0gNClcbiAgICAgICAge1xuICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMuY2FsbChnbCwgdW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0udmFsdWUueCwgdW5pZm9ybS52YWx1ZS55LCB1bmlmb3JtLnZhbHVlLnosIHVuaWZvcm0udmFsdWUudyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pZm9ybS50eXBlID09PSAnc2FtcGxlcjJEJylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0uX2luaXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFsnVEVYVFVSRScgKyB0aGlzLnRleHR1cmVDb3VudF0pO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdIHx8IFBJWEkuY3JlYXRlV2ViR0xUZXh0dXJlKCB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlLCBnbCkpO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdGhpcy50ZXh0dXJlQ291bnQpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U2FtcGxlcjJEKHVuaWZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKCB0aGlzLnByb2dyYW0gKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG59O1xuXG4vKipcbiogVGhlIERlZmF1bHQgVmVydGV4IHNoYWRlciBzb3VyY2VcbiogQHByb3BlcnR5IGRlZmF1bHRWZXJ0ZXhTcmNcbiogQHR5cGUgU3RyaW5nXG4qL1xuUElYSS5QaXhpU2hhZGVyLmRlZmF1bHRWZXJ0ZXhTcmMgPSBbXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFDb2xvcjsnLFxuXG4gICAgJ3VuaWZvcm0gdmVjMiBwcm9qZWN0aW9uVmVjdG9yOycsXG4gICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXRWZWN0b3I7JyxcblxuICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAnY29uc3QgdmVjMiBjZW50ZXIgPSB2ZWMyKC0xLjAsIDEuMCk7JyxcblxuICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCggKChhVmVydGV4UG9zaXRpb24gKyBvZmZzZXRWZWN0b3IpIC8gcHJvamVjdGlvblZlY3RvcikgKyBjZW50ZXIgLCAwLjAsIDEuMCk7JyxcbiAgICAnICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7JyxcbiAgICAnICAgdmVjMyBjb2xvciA9IG1vZCh2ZWMzKGFDb2xvci55LzY1NTM2LjAsIGFDb2xvci55LzI1Ni4wLCBhQ29sb3IueSksIDI1Ni4wKSAvIDI1Ni4wOycsXG4gICAgJyAgIHZDb2xvciA9IHZlYzQoY29sb3IgKiBhQ29sb3IueCwgYUNvbG9yLngpOycsXG4gICAgJ30nXG5dO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICogQGF1dGhvciBSaWNoYXJkIERhdmV5IGh0dHA6Ly93d3cucGhvdG9uc3Rvcm0uY29tIEBwaG90b25zdG9ybVxuICovXG5cbi8qKlxuKiBAY2xhc3MgUGl4aUZhc3RTaGFkZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLlBpeGlGYXN0U2hhZGVyID0gZnVuY3Rpb24oZ2wpXG57XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FueX0gcHJvZ3JhbSAtIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBmcmFnbWVudFNyYyAtIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyBmbG9hdCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yIDsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2FycmF5fSB2ZXJ0ZXhTcmMgLSBUaGUgdmVydGV4IHNoYWRlclxuICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTcmMgPSBbXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbkNvb3JkOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhU2NhbGU7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhUm90YXRpb247JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhQ29sb3I7JyxcblxuICAgICAgICAndW5pZm9ybSB2ZWMyIHByb2plY3Rpb25WZWN0b3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXRWZWN0b3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0MyB1TWF0cml4OycsXG5cbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuXG4gICAgICAgICdjb25zdCB2ZWMyIGNlbnRlciA9IHZlYzIoLTEuMCwgMS4wKTsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWMyIHY7JyxcbiAgICAgICAgJyAgIHZlYzIgc3YgPSBhVmVydGV4UG9zaXRpb24gKiBhU2NhbGU7JyxcbiAgICAgICAgJyAgIHYueCA9IChzdi54KSAqIGNvcyhhUm90YXRpb24pIC0gKHN2LnkpICogc2luKGFSb3RhdGlvbik7JyxcbiAgICAgICAgJyAgIHYueSA9IChzdi54KSAqIHNpbihhUm90YXRpb24pICsgKHN2LnkpICogY29zKGFSb3RhdGlvbik7JyxcbiAgICAgICAgJyAgIHYgPSAoIHVNYXRyaXggKiB2ZWMzKHYgKyBhUG9zaXRpb25Db29yZCAsIDEuMCkgKS54eSA7JyxcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCggKCB2IC8gcHJvamVjdGlvblZlY3RvcikgKyBjZW50ZXIgLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAvLyAgJyAgIHZlYzMgY29sb3IgPSBtb2QodmVjMyhhQ29sb3IueS82NTUzNi4wLCBhQ29sb3IueS8yNTYuMCwgYUNvbG9yLnkpLCAyNTYuMCkgLyAyNTYuMDsnLFxuICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRleHR1cmVDb3VudCAtIEEgbG9jYWwgdGV4dHVyZSBjb3VudGVyIGZvciBtdWx0aS10ZXh0dXJlIHNoYWRlcnMuXG4gICAgKi9cbiAgICB0aGlzLnRleHR1cmVDb3VudCA9IDA7XG5cbiAgICBcbiAgICB0aGlzLmluaXQoKTtcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgaW5pdFxuKlxuKi9cblBJWEkuUGl4aUZhc3RTaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpXG57XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIHByb2dyYW0gPSBQSVhJLmNvbXBpbGVQcm9ncmFtKGdsLCB0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyk7XG4gICAgXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIHVuaWZvcm1zIGZvciB0aGUgc2hhZGVyXG4gICAgdGhpcy51U2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhbXBsZXInKTtcblxuICAgIHRoaXMucHJvamVjdGlvblZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAncHJvamVjdGlvblZlY3RvcicpO1xuICAgIHRoaXMub2Zmc2V0VmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdvZmZzZXRWZWN0b3InKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2RpbWVuc2lvbnMnKTtcbiAgICB0aGlzLnVNYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VNYXRyaXgnKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLmFWZXJ0ZXhQb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVmVydGV4UG9zaXRpb24nKTtcbiAgICB0aGlzLmFQb3NpdGlvbkNvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FQb3NpdGlvbkNvb3JkJyk7XG5cbiAgICB0aGlzLmFTY2FsZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhU2NhbGUnKTtcbiAgICB0aGlzLmFSb3RhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUm90YXRpb24nKTtcblxuICAgIHRoaXMuYVRleHR1cmVDb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVGV4dHVyZUNvb3JkJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcbiAgIFxuXG4gICBcbiAgICAvLyBCZWdpbiB3b3JzdCBoYWNrIGV2YSAvL1xuXG4gICAgLy8gV0hZPz8/IE9OTFkgb24gbXkgY2hyb21lIHBpeGVsIHRoZSBsaW5lIGFib3ZlIHJldHVybnMgLTEgd2hlbiB1c2luZyBmaWx0ZXJzP1xuICAgIC8vIG1heWJlIGl0cyBzb210aGluZyB0byBkbyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnbCBjb250ZXh0LlxuICAgIC8vIEltIGNvbnZpbmNlZCB0aGlzIGlzIGEgYnVnIGluIHRoZSBjaHJvbWUgYnJvd3NlciBhcyB0aGVyZSBpcyBOTyByZWFzb24gd2h5IHRoaXMgc2hvdWxkIGJlIHJldHVybmluZyAtMSBlc3BlY2lhbGx5IGFzIGl0IG9ubHkgbWFuaWZlc3RzIG9uIG15IGNocm9tZSBwaXhlbFxuICAgIC8vIElmIHRoZXJlcyBhbnkgd2ViR0wgcGVvcGxlIHRoYXQga25vdyB3aHkgY291bGQgaGFwcGVuIHBsZWFzZSBoZWxwIDopXG4gICAgaWYodGhpcy5jb2xvckF0dHJpYnV0ZSA9PT0gLTEpXG4gICAge1xuICAgICAgICB0aGlzLmNvbG9yQXR0cmlidXRlID0gMjtcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbdGhpcy5hVmVydGV4UG9zaXRpb24sIHRoaXMuYVBvc2l0aW9uQ29vcmQsICB0aGlzLmFTY2FsZSwgdGhpcy5hUm90YXRpb24sIHRoaXMuYVRleHR1cmVDb29yZCwgdGhpcy5jb2xvckF0dHJpYnV0ZV07XG4gICAgXG4gICAgLy8gRW5kIHdvcnN0IGhhY2sgZXZhIC8vXG5cblxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGRlc3Ryb3lcbipcbiovXG5QSVhJLlBpeGlGYXN0U2hhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggdGhpcy5wcm9ncmFtICk7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5cblBJWEkuU3RyaXBTaGFkZXIgPSBmdW5jdGlvbigpXG57XG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2FueX0gcHJvZ3JhbSAtIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGZyYWdtZW50U3JjIC0gVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55KSk7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIGFscGhhOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGZyYWdtZW50U3JjIC0gVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAqL1xuICAgIHRoaXMudmVydGV4U3JjID0gW1xuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYUNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBwcm9qZWN0aW9uVmVjdG9yOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldFZlY3RvcjsnLFxuICAgICAgICAndmFyeWluZyBmbG9hdCB2Q29sb3I7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMyB2ID0gdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTsnLFxuICAgICAgICAnICAgdiAtPSBvZmZzZXRWZWN0b3IueHl4OycsXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoIHYueCAvIHByb2plY3Rpb25WZWN0b3IueCAtMS4wLCB2LnkgLyBwcm9qZWN0aW9uVmVjdG9yLnkgKyAxLjAgLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICcgICB2Q29sb3IgPSBhQ29sb3I7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgaW5pdFxuKlxuKi9cblBJWEkuU3RyaXBTaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpXG57XG5cbiAgICB2YXIgZ2wgPSBQSVhJLmdsO1xuXG4gICAgdmFyIHByb2dyYW0gPSBQSVhJLmNvbXBpbGVQcm9ncmFtKGdsLCB0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIHVuaWZvcm1zIGZvciB0aGUgc2hhZGVyXG4gICAgdGhpcy51U2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhbXBsZXInKTtcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcbiAgICAvL3RoaXMuZGltZW5zaW9ucyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdkaW1lbnNpb25zJyk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hVmVydGV4UG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyk7XG4gICAgdGhpcy5hVGV4dHVyZUNvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FUZXh0dXJlQ29vcmQnKTtcblxuICAgIHRoaXMudHJhbnNsYXRpb25NYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3RyYW5zbGF0aW9uTWF0cml4Jyk7XG4gICAgdGhpcy5hbHBoYSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnYWxwaGEnKTtcblxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAY2xhc3MgUHJpbWl0aXZlU2hhZGVyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5QcmltaXRpdmVTaGFkZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBwcm9ncmFtIC0gVGhlIFdlYkdMIHByb2dyYW0uXG4gICAgKi9cbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGZyYWdtZW50U3JjXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgdmVydGV4U3JjXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleFNyYyAgPSBbXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcHJvamVjdGlvblZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldFZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMzIHRpbnQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMyB2ID0gdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHYgLT0gb2Zmc2V0VmVjdG9yLnh5eDsnLFxuICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KCB2LnggLyBwcm9qZWN0aW9uVmVjdG9yLnggLTEuMCwgdi55IC8gLXByb2plY3Rpb25WZWN0b3IueSArIDEuMCAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yICogdmVjNCh0aW50ICogYWxwaGEsIGFscGhhKTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIHNoYWRlclxuKiBAbWV0aG9kIGluaXRcbipcbiovXG5QSVhJLlByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcbntcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgdW5pZm9ybXMgZm9yIHRoZSBzaGFkZXJcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy50aW50Q29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3RpbnQnKTtcblxuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgYXR0cmlidXRlc1xuICAgIHRoaXMuYVZlcnRleFBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgIHRoaXMuY29sb3JBdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUNvbG9yJyk7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbdGhpcy5hVmVydGV4UG9zaXRpb24sIHRoaXMuY29sb3JBdHRyaWJ1dGVdO1xuXG4gICAgdGhpcy50cmFuc2xhdGlvbk1hdHJpeCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndHJhbnNsYXRpb25NYXRyaXgnKTtcbiAgICB0aGlzLmFscGhhID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdhbHBoYScpO1xuXG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgc2hhZGVyXG4qIEBtZXRob2QgZGVzdHJveVxuKlxuKi9cblBJWEkuUHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggdGhpcy5wcm9ncmFtICk7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogQSBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIHdlYkdMIHJlbmRlcmVyIHRvIGRyYXcgdGhlIHByaW1pdGl2ZSBncmFwaGljcyBkYXRhXG4gKlxuICogQGNsYXNzIFdlYkdMR3JhcGhpY3NcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcyA9IGZ1bmN0aW9uKClcbntcblxufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBncmFwaGljcyBvYmplY3RcbiAqXG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCByZW5kZXJHcmFwaGljc1xuICogQHBhcmFtIGdyYXBoaWNzIHtHcmFwaGljc31cbiAqIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtPYmplY3R9XG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcy5yZW5kZXJHcmFwaGljcyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCByZW5kZXJTZXNzaW9uKS8vcHJvamVjdGlvbiwgb2Zmc2V0KVxue1xuICAgIHZhciBnbCA9IHJlbmRlclNlc3Npb24uZ2w7XG4gICAgdmFyIHByb2plY3Rpb24gPSByZW5kZXJTZXNzaW9uLnByb2plY3Rpb24sXG4gICAgICAgIG9mZnNldCA9IHJlbmRlclNlc3Npb24ub2Zmc2V0LFxuICAgICAgICBzaGFkZXIgPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIucHJpbWl0aXZlU2hhZGVyO1xuXG4gICAgaWYoIWdyYXBoaWNzLl93ZWJHTFtnbC5pZF0pZ3JhcGhpY3MuX3dlYkdMW2dsLmlkXSA9IHtwb2ludHM6W10sIGluZGljZXM6W10sIGxhc3RJbmRleDowLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjpnbC5jcmVhdGVCdWZmZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ1ZmZlcjpnbC5jcmVhdGVCdWZmZXIoKX07XG5cbiAgICB2YXIgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbZ2wuaWRdO1xuXG4gICAgaWYoZ3JhcGhpY3MuZGlydHkpXG4gICAge1xuICAgICAgICBncmFwaGljcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIGlmKGdyYXBoaWNzLmNsZWFyRGlydHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdyYXBoaWNzLmNsZWFyRGlydHkgPSBmYWxzZTtcblxuICAgICAgICAgICAgd2ViR0wubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIHdlYkdMLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgd2ViR0wuaW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MudXBkYXRlR3JhcGhpY3MoZ3JhcGhpY3MsIGdsKTtcbiAgICB9XG5cbiAgICByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuYWN0aXZhdGVQcmltaXRpdmVTaGFkZXIoKTtcblxuICAgIC8vIFRoaXMgIGNvdWxkIGJlIHNwZWVkZWQgdXAgZm9yIHN1cmUhXG5cbiAgICAvLyBzZXQgdGhlIG1hdHJpeCB0cmFuc2Zvcm1cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnRyYW5zbGF0aW9uTWF0cml4LCBmYWxzZSwgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKSk7XG5cbiAgICBnbC51bmlmb3JtMmYoc2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIHByb2plY3Rpb24ueCwgLXByb2plY3Rpb24ueSk7XG4gICAgZ2wudW5pZm9ybTJmKHNoYWRlci5vZmZzZXRWZWN0b3IsIC1vZmZzZXQueCwgLW9mZnNldC55KTtcblxuICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnRpbnRDb2xvciwgUElYSS5oZXgycmdiKGdyYXBoaWNzLnRpbnQpKTtcblxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIuYWxwaGEsIGdyYXBoaWNzLndvcmxkQWxwaGEpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB3ZWJHTC5idWZmZXIpO1xuXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiA2LCAwKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5jb2xvckF0dHJpYnV0ZSwgNCwgZ2wuRkxPQVQsIGZhbHNlLDQgKiA2LCAyICogNCk7XG5cbiAgICAvLyBzZXQgdGhlIGluZGV4IGJ1ZmZlciFcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTC5pbmRleEJ1ZmZlcik7XG5cbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfU1RSSVAsICB3ZWJHTC5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgIHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5kZWFjdGl2YXRlUHJpbWl0aXZlU2hhZGVyKCk7XG5cbiAgICAvLyByZXR1cm4gdG8gZGVmYXVsdCBzaGFkZXIuLi5cbi8vICBQSVhJLmFjdGl2YXRlU2hhZGVyKFBJWEkuZGVmYXVsdFNoYWRlcik7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGdyYXBoaWNzIG9iamVjdFxuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHVwZGF0ZUdyYXBoaWNzXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtHcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCB0byB1cGRhdGVcbiAqIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAqL1xuUElYSS5XZWJHTEdyYXBoaWNzLnVwZGF0ZUdyYXBoaWNzID0gZnVuY3Rpb24oZ3JhcGhpY3MsIGdsKVxue1xuICAgIHZhciB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFtnbC5pZF07XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IHdlYkdMLmxhc3RJbmRleDsgaSA8IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuXG4gICAgICAgIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5QT0xZKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihkYXRhLmZpbGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5wb2ludHMubGVuZ3RoPjMpXG4gICAgICAgICAgICAgICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5idWlsZFBvbHkoZGF0YSwgd2ViR0wpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkYXRhLmxpbmVXaWR0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkTGluZShkYXRhLCB3ZWJHTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuUkVDVClcbiAgICAgICAge1xuICAgICAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkUmVjdGFuZ2xlKGRhdGEsIHdlYkdMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5DSVJDIHx8IGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5FTElQKVxuICAgICAgICB7XG4gICAgICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRDaXJjbGUoZGF0YSwgd2ViR0wpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2ViR0wubGFzdEluZGV4ID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDtcblxuICAgXG5cbiAgICB3ZWJHTC5nbFBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkod2ViR0wucG9pbnRzKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB3ZWJHTC5idWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB3ZWJHTC5nbFBvaW50cywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgd2ViR0wuZ2xJbmRpY2llcyA9IG5ldyBVaW50MTZBcnJheSh3ZWJHTC5pbmRpY2VzKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHdlYkdMLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTC5nbEluZGljaWVzLCBnbC5TVEFUSUNfRFJBVyk7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHJlY3RhbmdsZSB0byBkcmF3XG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgYnVpbGRSZWN0YW5nbGVcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHdlYkdMRGF0YSB7T2JqZWN0fVxuICovXG5QSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRSZWN0YW5nbGUgPSBmdW5jdGlvbihncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcbiAgICAvLyAtLS0gLy9cbiAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcbiAgICAvL1xuICAgIHZhciByZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgdmFyIHggPSByZWN0RGF0YVswXTtcbiAgICB2YXIgeSA9IHJlY3REYXRhWzFdO1xuICAgIHZhciB3aWR0aCA9IHJlY3REYXRhWzJdO1xuICAgIHZhciBoZWlnaHQgPSByZWN0RGF0YVszXTtcblxuXG4gICAgaWYoZ3JhcGhpY3NEYXRhLmZpbGwpXG4gICAge1xuICAgICAgICB2YXIgY29sb3IgPSBQSVhJLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgdmVydHMucHVzaCh4LCB5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHggLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAvLyBpbnNlcnQgMiBkZWFkIHRyaWFuZ2xlcy4uXG4gICAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zLCB2ZXJ0UG9zKzEsIHZlcnRQb3MrMiwgdmVydFBvcyszLCB2ZXJ0UG9zKzMpO1xuICAgIH1cblxuICAgIGlmKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpXG4gICAge1xuICAgICAgICB2YXIgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IFt4LCB5LFxuICAgICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5LFxuICAgICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgeCwgeSArIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHgsIHldO1xuXG5cbiAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBjaXJjbGUgdG8gZHJhd1xuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIGJ1aWxkQ2lyY2xlXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtHcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCB0byBkcmF3XG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtPYmplY3R9XG4gKi9cblBJWEkuV2ViR0xHcmFwaGljcy5idWlsZENpcmNsZSA9IGZ1bmN0aW9uKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIFxuICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxuICAgIHZhciByZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgdmFyIHggPSByZWN0RGF0YVswXTtcbiAgICB2YXIgeSA9IHJlY3REYXRhWzFdO1xuICAgIHZhciB3aWR0aCA9IHJlY3REYXRhWzJdO1xuICAgIHZhciBoZWlnaHQgPSByZWN0RGF0YVszXTtcblxuICAgIHZhciB0b3RhbFNlZ3MgPSA0MDtcbiAgICB2YXIgc2VnID0gKE1hdGguUEkgKiAyKSAvIHRvdGFsU2VncyA7XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZihncmFwaGljc0RhdGEuZmlsbClcbiAgICB7XG4gICAgICAgIHZhciBjb2xvciA9IFBJWEkuaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcbiAgICAgICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcblxuICAgICAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHZlY1BvcyA9IHZlcnRzLmxlbmd0aC82O1xuXG4gICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbFNlZ3MgKyAxIDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHgseSwgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHggKyBNYXRoLnNpbihzZWcgKiBpKSAqIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICB5ICsgTWF0aC5jb3Moc2VnICogaSkgKiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1BvcysrLCB2ZWNQb3MrKyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRpY2VzLnB1c2godmVjUG9zLTEpO1xuICAgIH1cblxuICAgIGlmKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpXG4gICAge1xuICAgICAgICB2YXIgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbFNlZ3MgKyAxOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMucHVzaCh4ICsgTWF0aC5zaW4oc2VnICogaSkgKiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICsgTWF0aC5jb3Moc2VnICogaSkgKiBoZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgUElYSS5XZWJHTEdyYXBoaWNzLmJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBsaW5lIHRvIGRyYXdcbiAqXG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBidWlsZExpbmVcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHdlYkdMRGF0YSB7T2JqZWN0fVxuICovXG5QSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRMaW5lID0gZnVuY3Rpb24oZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgLy8gVE9ETyBPUFRJTUlTRSFcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBpZihwb2ludHMubGVuZ3RoID09PSAwKXJldHVybjtcblxuICAgIC8vIGlmIHRoZSBsaW5lIHdpZHRoIGlzIGFuIG9kZCBudW1iZXIgYWRkIDAuNSB0byBhbGlnbiB0byBhIHdob2xlIHBpeGVsXG4gICAgaWYoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCUyKVxuICAgIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzW2ldICs9IDAuNTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldCBmaXJzdCBhbmQgbGFzdCBwb2ludC4uIGZpZ3VyZSBvdXQgdGhlIG1pZGRsZSFcbiAgICB2YXIgZmlyc3RQb2ludCA9IG5ldyBQSVhJLlBvaW50KCBwb2ludHNbMF0sIHBvaW50c1sxXSApO1xuICAgIHZhciBsYXN0UG9pbnQgPSBuZXcgUElYSS5Qb2ludCggcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSApO1xuXG4gICAgLy8gaWYgdGhlIGZpcnN0IHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IC0gZ29ubmEgaGF2ZSBpc3N1ZXMgOilcbiAgICBpZihmaXJzdFBvaW50LnggPT09IGxhc3RQb2ludC54ICYmIGZpcnN0UG9pbnQueSA9PT0gbGFzdFBvaW50LnkpXG4gICAge1xuICAgICAgICBwb2ludHMucG9wKCk7XG4gICAgICAgIHBvaW50cy5wb3AoKTtcblxuICAgICAgICBsYXN0UG9pbnQgPSBuZXcgUElYSS5Qb2ludCggcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSApO1xuXG4gICAgICAgIHZhciBtaWRQb2ludFggPSBsYXN0UG9pbnQueCArIChmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgKjAuNTtcbiAgICAgICAgdmFyIG1pZFBvaW50WSA9IGxhc3RQb2ludC55ICsgKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSAqMC41O1xuXG4gICAgICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICAgICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgdmFyIGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBpbmRleFN0YXJ0ID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAvLyBEUkFXIHRoZSBMaW5lXG4gICAgdmFyIHdpZHRoID0gZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCAvIDI7XG5cbiAgICAvLyBzb3J0IGNvbG9yXG4gICAgdmFyIGNvbG9yID0gUElYSS5oZXgycmdiKGdyYXBoaWNzRGF0YS5saW5lQ29sb3IpO1xuICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5saW5lQWxwaGE7XG4gICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICB2YXIgcHgsIHB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5O1xuICAgIHZhciBwZXJweCwgcGVycHksIHBlcnAyeCwgcGVycDJ5LCBwZXJwM3gsIHBlcnAzeTtcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMjtcbiAgICB2YXIgZGVub20sIHBkaXN0LCBkaXN0O1xuXG4gICAgcDF4ID0gcG9pbnRzWzBdO1xuICAgIHAxeSA9IHBvaW50c1sxXTtcblxuICAgIHAyeCA9IHBvaW50c1syXTtcbiAgICBwMnkgPSBwb2ludHNbM107XG5cbiAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICBwZXJweSA9ICBwMXggLSBwMng7XG5cbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4KnBlcnB4ICsgcGVycHkqcGVycHkpO1xuXG4gICAgcGVycHggLz0gZGlzdDtcbiAgICBwZXJweSAvPSBkaXN0O1xuICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgIHBlcnB5ICo9IHdpZHRoO1xuXG4gICAgLy8gc3RhcnRcbiAgICB2ZXJ0cy5wdXNoKHAxeCAtIHBlcnB4ICwgcDF5IC0gcGVycHksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgdmVydHMucHVzaChwMXggKyBwZXJweCAsIHAxeSArIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGgtMTsgaSsrKVxuICAgIHtcbiAgICAgICAgcDF4ID0gcG9pbnRzWyhpLTEpKjJdO1xuICAgICAgICBwMXkgPSBwb2ludHNbKGktMSkqMiArIDFdO1xuXG4gICAgICAgIHAyeCA9IHBvaW50c1soaSkqMl07XG4gICAgICAgIHAyeSA9IHBvaW50c1soaSkqMiArIDFdO1xuXG4gICAgICAgIHAzeCA9IHBvaW50c1soaSsxKSoyXTtcbiAgICAgICAgcDN5ID0gcG9pbnRzWyhpKzEpKjIgKyAxXTtcblxuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJweCpwZXJweCArIHBlcnB5KnBlcnB5KTtcbiAgICAgICAgcGVycHggLz0gZGlzdDtcbiAgICAgICAgcGVycHkgLz0gZGlzdDtcbiAgICAgICAgcGVycHggKj0gd2lkdGg7XG4gICAgICAgIHBlcnB5ICo9IHdpZHRoO1xuXG4gICAgICAgIHBlcnAyeCA9IC0ocDJ5IC0gcDN5KTtcbiAgICAgICAgcGVycDJ5ID0gcDJ4IC0gcDN4O1xuXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycDJ4KnBlcnAyeCArIHBlcnAyeSpwZXJwMnkpO1xuICAgICAgICBwZXJwMnggLz0gZGlzdDtcbiAgICAgICAgcGVycDJ5IC89IGRpc3Q7XG4gICAgICAgIHBlcnAyeCAqPSB3aWR0aDtcbiAgICAgICAgcGVycDJ5ICo9IHdpZHRoO1xuXG4gICAgICAgIGExID0gKC1wZXJweSArIHAxeSkgLSAoLXBlcnB5ICsgcDJ5KTtcbiAgICAgICAgYjEgPSAoLXBlcnB4ICsgcDJ4KSAtICgtcGVycHggKyBwMXgpO1xuICAgICAgICBjMSA9ICgtcGVycHggKyBwMXgpICogKC1wZXJweSArIHAyeSkgLSAoLXBlcnB4ICsgcDJ4KSAqICgtcGVycHkgKyBwMXkpO1xuICAgICAgICBhMiA9ICgtcGVycDJ5ICsgcDN5KSAtICgtcGVycDJ5ICsgcDJ5KTtcbiAgICAgICAgYjIgPSAoLXBlcnAyeCArIHAyeCkgLSAoLXBlcnAyeCArIHAzeCk7XG4gICAgICAgIGMyID0gKC1wZXJwMnggKyBwM3gpICogKC1wZXJwMnkgKyBwMnkpIC0gKC1wZXJwMnggKyBwMngpICogKC1wZXJwMnkgKyBwM3kpO1xuXG4gICAgICAgIGRlbm9tID0gYTEqYjIgLSBhMipiMTtcblxuICAgICAgICBpZihNYXRoLmFicyhkZW5vbSkgPCAwLjEgKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGRlbm9tKz0xMC4xO1xuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSBwZXJweCAsIHAyeSAtIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyBwZXJweCAsIHAyeSArIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBweCA9IChiMSpjMiAtIGIyKmMxKS9kZW5vbTtcbiAgICAgICAgcHkgPSAoYTIqYzEgLSBhMSpjMikvZGVub207XG5cblxuICAgICAgICBwZGlzdCA9IChweCAtcDJ4KSAqIChweCAtcDJ4KSArIChweSAtcDJ5KSArIChweSAtcDJ5KTtcblxuXG4gICAgICAgIGlmKHBkaXN0ID4gMTQwICogMTQwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwZXJwM3ggPSBwZXJweCAtIHBlcnAyeDtcbiAgICAgICAgICAgIHBlcnAzeSA9IHBlcnB5IC0gcGVycDJ5O1xuXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAzeCpwZXJwM3ggKyBwZXJwM3kqcGVycDN5KTtcbiAgICAgICAgICAgIHBlcnAzeCAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycDN5IC89IGRpc3Q7XG4gICAgICAgICAgICBwZXJwM3ggKj0gd2lkdGg7XG4gICAgICAgICAgICBwZXJwM3kgKj0gd2lkdGg7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycDN4LCBwMnkgLXBlcnAzeSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyBwZXJwM3gsIHAyeSArcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC1wZXJwM3kpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIGluZGV4Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcblxuICAgICAgICAgICAgdmVydHMucHVzaChweCAsIHB5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChweC1wMngpLCBwMnkgLSAocHkgLSBwMnkpKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcDF4ID0gcG9pbnRzWyhsZW5ndGgtMikqMl07XG4gICAgcDF5ID0gcG9pbnRzWyhsZW5ndGgtMikqMiArIDFdO1xuXG4gICAgcDJ4ID0gcG9pbnRzWyhsZW5ndGgtMSkqMl07XG4gICAgcDJ5ID0gcG9pbnRzWyhsZW5ndGgtMSkqMiArIDFdO1xuXG4gICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XG4gICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4KnBlcnB4ICsgcGVycHkqcGVycHkpO1xuICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgcGVycHkgLz0gZGlzdDtcbiAgICBwZXJweCAqPSB3aWR0aDtcbiAgICBwZXJweSAqPSB3aWR0aDtcblxuICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycHggLCBwMnkgLSBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4ICwgcDJ5ICsgcGVycHkpO1xuICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGluZGV4Q291bnQ7IGkrKylcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0KyspO1xuICAgIH1cblxuICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0LTEpO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBwb2x5Z29uIHRvIGRyYXdcbiAqXG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBidWlsZFBvbHlcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHdlYkdMRGF0YSB7T2JqZWN0fVxuICovXG5QSVhJLldlYkdMR3JhcGhpY3MuYnVpbGRQb2x5ID0gZnVuY3Rpb24oZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA8IDYpcmV0dXJuO1xuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcblxuICAgIC8vIHNvcnQgY29sb3JcbiAgICB2YXIgY29sb3IgPSBQSVhJLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcbiAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgIHZhciB0cmlhbmdsZXMgPSBQSVhJLlBvbHlLLlRyaWFuZ3VsYXRlKHBvaW50cyk7XG5cbiAgICB2YXIgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSs9MylcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlcnRQb3MpO1xuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICt2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICsgdmVydFBvcyk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmVydHMucHVzaChwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSxcbiAgICAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLmdsQ29udGV4dHMgPSBbXTsgLy8gdGhpcyBpcyB3aGVyZSB3ZSBzdG9yZSB0aGUgd2ViR0wgY29udGV4dHMgZm9yIGVhc3kgYWNjZXNzLlxuXG4vKipcbiAqIHRoZSBXZWJHTFJlbmRlcmVyIGRyYXdzIHRoZSBzdGFnZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSB3ZWJHTCBlbmFibGVkIGNhbnZhcy4gVGhpcyByZW5kZXJlclxuICogc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB3ZWJHTC4gVGhpcyBSZW5kZXIgd29ya3MgYnkgYXV0b21hdGljYWxseSBtYW5hZ2luZyB3ZWJHTEJhdGNoJ3MuXG4gKiBTbyBubyBuZWVkIGZvciBTcHJpdGUgQmF0Y2gncyBvciBTcHJpdGUgQ2xvdWQnc1xuICogRG9udCBmb3JnZXQgdG8gYWRkIHRoZSB2aWV3IHRvIHlvdXIgRE9NIG9yIHlvdSB3aWxsIG5vdCBzZWUgYW55dGhpbmcgOilcbiAqXG4gKiBAY2xhc3MgV2ViR0xSZW5kZXJlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gd2lkdGg9MCB7TnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gaGVpZ2h0PTAge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSB2aWV3IHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICogQHBhcmFtIHRyYW5zcGFyZW50PWZhbHNlIHtCb29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnQsIGRlZmF1bHQgZmFsc2VcbiAqIEBwYXJhbSBhbnRpYWxpYXM9ZmFsc2Uge0Jvb2xlYW59IHNldHMgYW50aWFsaWFzIChvbmx5IGFwcGxpY2FibGUgaW4gY2hyb21lIGF0IHRoZSBtb21lbnQpXG4gKlxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudCwgYW50aWFsaWFzKVxue1xuICAgIGlmKCFQSVhJLmRlZmF1bHRSZW5kZXJlcilQSVhJLmRlZmF1bHRSZW5kZXJlciA9IHRoaXM7XG5cbiAgICB0aGlzLnR5cGUgPSBQSVhJLldFQkdMX1JFTkRFUkVSO1xuXG4gICAgLy8gZG8gYSBjYXRjaC4uIG9ubHkgMSB3ZWJHTCByZW5kZXJlci4uXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0cmFuc3BhcmVudFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gISF0cmFuc3BhcmVudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDgwMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCA4MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDYwMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDYwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2aWV3XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSB2aWV3IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAvLyBkZWFsIHdpdGggbG9zaW5nIGNvbnRleHQuLlxuICAgIHRoaXMuY29udGV4dExvc3QgPSB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5jb250ZXh0UmVzdG9yZWRMb3N0ID0gdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQuYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuY29udGV4dExvc3QsIGZhbHNlKTtcbiAgICB0aGlzLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmNvbnRleHRSZXN0b3JlZExvc3QsIGZhbHNlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgIGFudGlhbGlhczohIWFudGlhbGlhcywgLy8gU1BFRUQgVVA/P1xuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6ISF0cmFuc3BhcmVudCxcbiAgICAgICAgc3RlbmNpbDp0cnVlXG4gICAgfTtcblxuICAgIC8vdHJ5ICdleHBlcmltZW50YWwtd2ViZ2wnXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5nbCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCAgdGhpcy5vcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vdHJ5ICd3ZWJnbCdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnd2ViZ2wnLCAgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIFRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicgKyB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdGhpcy5nbENvbnRleHRJZCA9IGdsLmlkID0gUElYSS5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkICsrO1xuXG4gICAgUElYSS5nbENvbnRleHRzW3RoaXMuZ2xDb250ZXh0SWRdID0gZ2w7XG5cbiAgICBpZighUElYSS5ibGVuZE1vZGVzV2ViR0wpXG4gICAge1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTCA9IFtdO1xuXG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5OT1JNQUxdICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuQUREXSAgICAgICAgICAgPSBbZ2wuU1JDX0FMUEhBLCBnbC5EU1RfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuTVVMVElQTFldICAgICAgPSBbZ2wuRFNUX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLlNDUkVFTl0gICAgICAgID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLk9WRVJMQVldICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5EQVJLRU5dICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuTElHSFRFTl0gICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkNPTE9SX0RPREdFXSAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl9CVVJOXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuSEFSRF9MSUdIVF0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLlNPRlRfTElHSFRdICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5ESUZGRVJFTkNFXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuRVhDTFVTSU9OXSAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkhVRV0gICAgICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIFBJWEkuYmxlbmRNb2Rlc1dlYkdMW1BJWEkuYmxlbmRNb2Rlcy5TQVRVUkFUSU9OXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTFtQSVhJLmJsZW5kTW9kZXMuQ09MT1JdICAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgUElYSS5ibGVuZE1vZGVzV2ViR0xbUElYSS5ibGVuZE1vZGVzLkxVTUlOT1NJVFldICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgfVxuXG5cblxuXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gbmV3IFBJWEkuUG9pbnQoKTtcbiAgICB0aGlzLnByb2plY3Rpb24ueCA9ICB0aGlzLndpZHRoLzI7XG4gICAgdGhpcy5wcm9qZWN0aW9uLnkgPSAgLXRoaXMuaGVpZ2h0LzI7XG5cbiAgICB0aGlzLm9mZnNldCA9IG5ldyBQSVhJLlBvaW50KDAsIDApO1xuXG4gICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHRoaXMuY29udGV4dExvc3QgPSBmYWxzZTtcblxuICAgIC8vIHRpbWUgdG8gY3JlYXRlIHRoZSByZW5kZXIgbWFuYWdlcnMhIGVhY2ggb25lIGZvY3VzZXMgb24gbWFuYWdpbmUgYSBzdGF0ZSBpbiB3ZWJHTFxuICAgIHRoaXMuc2hhZGVyTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMU2hhZGVyTWFuYWdlcihnbCk7ICAgICAgICAgICAgICAgICAgIC8vIGRlYWxzIHdpdGggbWFuYWdpbmcgdGhlIHNoYWRlciBwcm9ncmFtcyBhbmQgdGhlaXIgYXR0cmlic1xuICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSBuZXcgUElYSS5XZWJHTFNwcml0ZUJhdGNoKGdsKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbmFnZXMgdGhlIHJlbmRlcmluZyBvZiBzcHJpdGVzXG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMTWFza01hbmFnZXIoZ2wpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFuYWdlcyB0aGUgbWFza3MgdXNpbmcgdGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gbmV3IFBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyKGdsLCB0aGlzLnRyYW5zcGFyZW50KTsgLy8gbWFuYWdlcyB0aGUgZmlsdGVyc1xuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0ge307XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmdsID0gdGhpcy5nbDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZHJhd0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlciA9IHRoaXMuc2hhZGVyTWFuYWdlcjtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24ubWFza01hbmFnZXIgPSB0aGlzLm1hc2tNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyID0gdGhpcy5maWx0ZXJNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaCA9IHRoaXMuc3ByaXRlQmF0Y2g7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnJlbmRlcmVyID0gdGhpcztcblxuICAgIGdsLnVzZVByb2dyYW0odGhpcy5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXIucHJvZ3JhbSk7XG5cbiAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcblxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRoaXMudHJhbnNwYXJlbnQpO1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLldlYkdMUmVuZGVyZXI7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgc3RhZ2UgdG8gaXRzIHdlYkdMIHZpZXdcbiAqXG4gKiBAbWV0aG9kIHJlbmRlclxuICogQHBhcmFtIHN0YWdlIHtTdGFnZX0gdGhlIFN0YWdlIGVsZW1lbnQgdG8gYmUgcmVuZGVyZWRcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzdGFnZSlcbntcbiAgICBpZih0aGlzLmNvbnRleHRMb3N0KXJldHVybjtcblxuXG4gICAgLy8gaWYgcmVuZGVyaW5nIGEgbmV3IHN0YWdlIGNsZWFyIHRoZSBiYXRjaGVzLi5cbiAgICBpZih0aGlzLl9fc3RhZ2UgIT09IHN0YWdlKVxuICAgIHtcbiAgICAgICAgaWYoc3RhZ2UuaW50ZXJhY3RpdmUpc3RhZ2UuaW50ZXJhY3Rpb25NYW5hZ2VyLnJlbW92ZUV2ZW50cygpO1xuXG4gICAgICAgIC8vIFRPRE8gbWFrZSB0aGlzIHdvcmtcbiAgICAgICAgLy8gZG9udCB0aGluayB0aGlzIGlzIG5lZWRlZCBhbnkgbW9yZT9cbiAgICAgICAgdGhpcy5fX3N0YWdlID0gc3RhZ2U7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGFueSB0ZXh0dXJlcyB0aGlzIGluY2x1ZGVzIHV2cyBhbmQgdXBsb2FkaW5nIHRoZW0gdG8gdGhlIGdwdVxuICAgIFBJWEkuV2ViR0xSZW5kZXJlci51cGRhdGVUZXh0dXJlcygpO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzY2VuZSBncmFwaFxuICAgIHN0YWdlLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG5cbiAgICAvLyBpbnRlcmFjdGlvblxuICAgIGlmKHN0YWdlLl9pbnRlcmFjdGl2ZSlcbiAgICB7XG4gICAgICAgIC8vbmVlZCB0byBhZGQgc29tZSBldmVudHMhXG4gICAgICAgIGlmKCFzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhZ2UuX2ludGVyYWN0aXZlRXZlbnRzQWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RhZ2UuaW50ZXJhY3Rpb25NYW5hZ2VyLnNldFRhcmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gLS0gRG9lcyB0aGlzIG5lZWQgdG8gYmUgc2V0IGV2ZXJ5IGZyYW1lPyAtLSAvL1xuICAgIC8vZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRoaXMudHJhbnNwYXJlbnQpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgYm91bmQgdG8gdGhlIG1haW4gZnJhbWUgYnVmZmVyXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgIGlmKHRoaXMudHJhbnNwYXJlbnQpXG4gICAge1xuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnbC5jbGVhckNvbG9yKHN0YWdlLmJhY2tncm91bmRDb2xvclNwbGl0WzBdLHN0YWdlLmJhY2tncm91bmRDb2xvclNwbGl0WzFdLHN0YWdlLmJhY2tncm91bmRDb2xvclNwbGl0WzJdLCAxKTtcbiAgICB9XG5cblxuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXG4gICAgdGhpcy5yZW5kZXJEaXNwbGF5T2JqZWN0KCBzdGFnZSwgdGhpcy5wcm9qZWN0aW9uICk7XG5cbiAgICAvLyBpbnRlcmFjdGlvblxuICAgIGlmKHN0YWdlLmludGVyYWN0aXZlKVxuICAgIHtcbiAgICAgICAgLy9uZWVkIHRvIGFkZCBzb21lIGV2ZW50cyFcbiAgICAgICAgaWYoIXN0YWdlLl9pbnRlcmFjdGl2ZUV2ZW50c0FkZGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgICBzdGFnZS5pbnRlcmFjdGlvbk1hbmFnZXIuc2V0VGFyZ2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmKHN0YWdlLl9pbnRlcmFjdGl2ZUV2ZW50c0FkZGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhZ2UuaW50ZXJhY3Rpb25NYW5hZ2VyLnNldFRhcmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgLy9jYW4gc2ltdWxhdGUgY29udGV4dCBsb3NzIGluIENocm9tZSBsaWtlIHNvOlxuICAgICB0aGlzLnZpZXcub25tb3VzZWRvd24gPSBmdW5jdGlvbihldikge1xuICAgICBjb25zb2xlLmRpcih0aGlzLmdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKSk7XG4gICAgICAgIHZhciBleHQgPSAoXG4gICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9zY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIilcbiAgICAgICAvLyBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSB8fFxuICAgICAgIC8vIGdsLmdldEV4dGVuc2lvbihcIk1PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSB8fFxuICAgICAgIC8vIGdsLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKVxuICAgICApO1xuICAgICBjb25zb2xlLmRpcihleHQpO1xuICAgICB2YXIgbG9zZUN0eCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuICAgICAgY29uc29sZS5sb2coXCJraWxsaW5nIGNvbnRleHRcIik7XG4gICAgICBsb3NlQ3R4Lmxvc2VDb250ZXh0KCk7XG4gICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJyZXN0b3JpbmcgY29udGV4dC4uLlwiKTtcbiAgICAgICAgICBsb3NlQ3R4LnJlc3RvcmVDb250ZXh0KCk7XG4gICAgICB9LmJpbmQodGhpcyksIDEwMDApO1xuICAgICB9LmJpbmQodGhpcyk7XG4gICAgICovXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBkaXNwbGF5IE9iamVjdFxuICpcbiAqIEBtZXRob2QgcmVuZGVyRElzcGxheU9iamVjdFxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIHJlbmRlclxuICogQHBhcmFtIHByb2plY3Rpb24ge1BvaW50fSBUaGUgcHJvamVjdGlvblxuICogQHBhcmFtIGJ1ZmZlciB7QXJyYXl9IGEgc3RhbmRhcmQgV2ViR0wgYnVmZmVyIFxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckRpc3BsYXlPYmplY3QgPSBmdW5jdGlvbihkaXNwbGF5T2JqZWN0LCBwcm9qZWN0aW9uLCBidWZmZXIpXG57XG4gICAgLy8gcmVzZXQgdGhlIHJlbmRlciBzZXNzaW9uIGRhdGEuLlxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5kcmF3Q291bnQgPSAwO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5jdXJyZW50QmxlbmRNb2RlID0gOTk5OTtcblxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24ub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG5cbiAgICAvLyBzdGFydCB0aGUgc3ByaXRlIGJhdGNoXG4gICAgdGhpcy5zcHJpdGVCYXRjaC5iZWdpbih0aGlzLnJlbmRlclNlc3Npb24pO1xuXG4gICAgLy8gc3RhcnQgdGhlIGZpbHRlciBtYW5hZ2VyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLmJlZ2luKHRoaXMucmVuZGVyU2Vzc2lvbiwgYnVmZmVyKTtcblxuICAgIC8vIHJlbmRlciB0aGUgc2NlbmUhXG4gICAgZGlzcGxheU9iamVjdC5fcmVuZGVyV2ViR0wodGhpcy5yZW5kZXJTZXNzaW9uKTtcblxuICAgIC8vIGZpbmlzaCB0aGUgc3ByaXRlIGJhdGNoXG4gICAgdGhpcy5zcHJpdGVCYXRjaC5lbmQoKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdGV4dHVyZXMgbG9hZGVkIGludG8gdGhpcyB3ZWJnbCByZW5kZXJlclxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgdXBkYXRlVGV4dHVyZXNcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci51cGRhdGVUZXh0dXJlcyA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgaSA9IDA7XG5cbiAgICAvL1RPRE8gYnJlYWsgdGhpcyBvdXQgaW50byBhIHRleHR1cmUgbWFuYWdlci4uLlxuICAgIC8vZm9yIChpID0gMDsgaSA8IFBJWEkudGV4dHVyZXNUb1VwZGF0ZS5sZW5ndGg7IGkrKylcbiAgICAvLyAgICBQSVhJLldlYkdMUmVuZGVyZXIudXBkYXRlVGV4dHVyZShQSVhJLnRleHR1cmVzVG9VcGRhdGVbaV0pO1xuXG5cbiAgICBmb3IgKGk9MDsgaSA8IFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIFBJWEkuV2ViR0xSZW5kZXJlci51cGRhdGVUZXh0dXJlRnJhbWUoUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlc1tpXSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgUElYSS50ZXh0dXJlc1RvRGVzdHJveS5sZW5ndGg7IGkrKylcbiAgICAgICAgUElYSS5XZWJHTFJlbmRlcmVyLmRlc3Ryb3lUZXh0dXJlKFBJWEkudGV4dHVyZXNUb0Rlc3Ryb3lbaV0pO1xuXG4gICAgUElYSS50ZXh0dXJlc1RvVXBkYXRlLmxlbmd0aCA9IDA7XG4gICAgUElYSS50ZXh0dXJlc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuICAgIFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgYSBsb2FkZWQgd2ViZ2wgdGV4dHVyZVxuICpcbiAqIEBtZXRob2QgZGVzdHJveVRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSB0byB1cGRhdGVcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5kZXN0cm95VGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgLy9UT0RPIGJyZWFrIHRoaXMgb3V0IGludG8gYSB0ZXh0dXJlIG1hbmFnZXIuLi5cblxuICAgIGZvciAodmFyIGkgPSB0ZXh0dXJlLl9nbFRleHR1cmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIHtcbiAgICAgICAgdmFyIGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbaV07XG4gICAgICAgIHZhciBnbCA9IFBJWEkuZ2xDb250ZXh0c1tpXTtcblxuICAgICAgICBpZihnbCAmJiBnbFRleHR1cmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoZ2xUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHR1cmUuX2dsVGV4dHVyZXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICpcbiAqIEBtZXRob2QgdXBkYXRlVGV4dHVyZUZyYW1lXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIHRleHR1cmUgdG8gdXBkYXRlIHRoZSBmcmFtZSBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIudXBkYXRlVGV4dHVyZUZyYW1lID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICB0ZXh0dXJlLnVwZGF0ZUZyYW1lID0gZmFsc2U7XG5cbiAgICAvLyBub3cgc2V0IHRoZSB1dnMuIEZpZ3VyZWQgdGhhdCB0aGUgdXYgZGF0YSBzaXRzIHdpdGggYSB0ZXh0dXJlIHJhdGhlciB0aGFuIGEgc3ByaXRlLlxuICAgIC8vIHNvIHV2IGRhdGEgaXMgc3RvcmVkIG9uIHRoZSB0ZXh0dXJlIGl0c2VsZlxuICAgIHRleHR1cmUuX3VwZGF0ZVdlYkdMdXZzKCk7XG59O1xuXG4vKipcbiAqIHJlc2l6ZXMgdGhlIHdlYkdMIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gKlxuICogQG1ldGhvZCByZXNpemVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSB3ZWJHTCB2aWV3XG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB3ZWJHTCB2aWV3XG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICB0aGlzLnByb2plY3Rpb24ueCA9ICB0aGlzLndpZHRoLzI7XG4gICAgdGhpcy5wcm9qZWN0aW9uLnkgPSAgLXRoaXMuaGVpZ2h0LzI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBXZWJHTCB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCBjcmVhdGVXZWJHTFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0byByZW5kZXJcbiAqIEBwYXJhbSBnbCB7d2ViZ2xDb250ZXh0fSB0aGUgV2ViR0wgY29udGV4dFxuICogQHN0YXRpY1xuICovXG5QSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUsIGdsKVxue1xuXG5cbiAgICBpZih0ZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcblxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRleHR1cmUuc291cmNlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gUElYSS5zY2FsZU1vZGVzLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuXG4gICAgICAgIC8vIHJlZ3VsZXIuLi5cblxuICAgICAgICBpZighdGV4dHVyZS5fcG93ZXJPZjIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiAgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF07XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBXZWJHTCB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCB1cGRhdGVXZWJHTFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB1cGRhdGVcbiAqIEBwYXJhbSBnbCB7d2ViZ2xDb250ZXh0fSB0aGUgV2ViR0wgY29udGV4dFxuICogQHByaXZhdGVcbiAqL1xuUElYSS51cGRhdGVXZWJHTFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlLCBnbClcbntcbiAgICBpZiggdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0gKVxuICAgIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5zb3VyY2UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG5cbiAgICAgICAgLy8gcmVndWxlci4uLlxuXG4gICAgICAgIGlmKCF0ZXh0dXJlLl9wb3dlck9mMilcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgfVxuICAgIFxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgbG9zdCB3ZWJnbCBjb250ZXh0XG4gKlxuICogQG1ldGhvZCBoYW5kbGVDb250ZXh0TG9zdFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlQ29udGV4dExvc3QgPSBmdW5jdGlvbihldmVudClcbntcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY29udGV4dExvc3QgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcmVzdG9yZWQgd2ViZ2wgY29udGV4dFxuICpcbiAqIEBtZXRob2QgaGFuZGxlQ29udGV4dFJlc3RvcmVkXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSBmdW5jdGlvbigpXG57XG5cbiAgICAvL3RyeSAnZXhwZXJpbWVudGFsLXdlYmdsJ1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgIHRoaXMub3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvL3RyeSAnd2ViZ2wnXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gdGhpcy52aWV3LmdldENvbnRleHQoJ3dlYmdsJywgIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAvLyBmYWlsLCBub3QgYWJsZSB0byBnZXQgYSBjb250ZXh0XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyBUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3ZWJHTC4gVHJ5IHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXInICsgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmlkID0gUElYSS5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkICsrO1xuXG5cblxuICAgIC8vIG5lZWQgdG8gc2V0IHRoZSBjb250ZXh0Li4uXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyLnNldENvbnRleHQoZ2wpO1xuICAgIHRoaXMuc3ByaXRlQmF0Y2guc2V0Q29udGV4dChnbCk7XG4gICAgdGhpcy5tYXNrTWFuYWdlci5zZXRDb250ZXh0KGdsKTtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIuc2V0Q29udGV4dChnbCk7XG5cblxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5nbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcblxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRoaXMudHJhbnNwYXJlbnQpO1xuXG4gICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICBmb3IodmFyIGtleSBpbiBQSVhJLlRleHR1cmVDYWNoZSlcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlQ2FjaGVba2V5XS5iYXNlVGV4dHVyZTtcbiAgICAgICAgdGV4dHVyZS5fZ2xUZXh0dXJlcyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNvbnRleHQgd2FzIGxvc3QgXG4gICAgICogQHByb3BlcnR5IGNvbnRleHRMb3N0XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dExvc3QgPSBmYWxzZTtcblxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgKGV2ZW50IGxpc3RlbmVycywgc3ByaXRlYmF0Y2gsIGV0Yy4uLilcbiAqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuXG4gICAgLy8gZGVhbCB3aXRoIGxvc2luZyBjb250ZXh0Li5cbiAgICBcbiAgICAvLyByZW1vdmUgbGlzdGVuZXJzXG4gICAgdGhpcy52aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmNvbnRleHRMb3N0KTtcbiAgICB0aGlzLnZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmNvbnRleHRSZXN0b3JlZExvc3QpO1xuXG4gICAgUElYSS5nbENvbnRleHRzW3RoaXMuZ2xDb250ZXh0SWRdID0gbnVsbDtcblxuICAgIHRoaXMucHJvamVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5vZmZzZXQgPSBudWxsO1xuXG4gICAgLy8gdGltZSB0byBjcmVhdGUgdGhlIHJlbmRlciBtYW5hZ2VycyEgZWFjaCBvbmUgZm9jdXNlcyBvbiBtYW5hZ2luZSBhIHN0YXRlIGluIHdlYkdMXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnNwcml0ZUJhdGNoLmRlc3Ryb3koKTtcbiAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLnNwcml0ZUJhdGNoID0gbnVsbDtcbiAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBudWxsO1xuICAgIFxuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIC8vXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0gbnVsbDtcbn07XG5cblxuUElYSS5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkID0gMDtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuIFxuXG4vKipcbiogQGNsYXNzIFdlYkdMTWFza01hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHByaXZhdGVcbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLm1hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMubWFza1Bvc2l0aW9uID0gMDtcblxuICAgIHRoaXMuc2V0Q29udGV4dChnbCk7XG59O1xuXG4vKipcbiogU2V0cyB0aGUgZHJhd2luZyBjb250ZXh0IHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXG4qIEBtZXRob2Qgc2V0Q29udGV4dCBcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKi9cblBJWEkuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcbn07XG5cbi8qKlxuKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFja1xuKiBAbWV0aG9kIHB1c2hNYXNrXG4qIEBwYXJhbSBtYXNrRGF0YSB7QXJyYXl9XG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufVxuKi9cblBJWEkuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaE1hc2sgPSBmdW5jdGlvbihtYXNrRGF0YSwgcmVuZGVyU2Vzc2lvbilcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgaWYodGhpcy5tYXNrU3RhY2subGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywxLDEpO1xuICAgIH1cbiAgICBcbiAgLy8gIG1hc2tEYXRhLnZpc2libGUgPSBmYWxzZTtcblxuICAgIHRoaXMubWFza1N0YWNrLnB1c2gobWFza0RhdGEpO1xuICAgIFxuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuXG4gICAgUElYSS5XZWJHTEdyYXBoaWNzLnJlbmRlckdyYXBoaWNzKG1hc2tEYXRhLCByZW5kZXJTZXNzaW9uKTtcblxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwwLCB0aGlzLm1hc2tTdGFjay5sZW5ndGgpO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuS0VFUCk7XG59O1xuXG4vKipcbiogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdFxuKiBAbWV0aG9kIHBvcE1hc2tcbipcbiogQHBhcmFtIHJlbmRlclNlc3Npb24ge1JlbmRlclNlc3Npb259IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgdXNlZnVsIHBhcmFtZXRlcnNcbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnBvcE1hc2sgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFjay5wb3AoKTtcblxuICAgIGlmKG1hc2tEYXRhKVxuICAgIHtcbiAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAvL2dsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywxLDEpO1xuICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xuXG4gICAgICAgIFBJWEkuV2ViR0xHcmFwaGljcy5yZW5kZXJHcmFwaGljcyhtYXNrRGF0YSwgcmVuZGVyU2Vzc2lvbik7XG5cbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5OT1RFUVVBTCwwLHRoaXMubWFza1N0YWNrLmxlbmd0aCk7XG4gICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuS0VFUCk7XG4gICAgfVxuICAgXG4gICAgaWYodGhpcy5tYXNrU3RhY2subGVuZ3RoID09PSAwKWdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgbWFzayBzdGFja1xuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5tYXNrU3RhY2sgPSBudWxsO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xufTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBXZWJHTFNoYWRlck1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHByaXZhdGVcbiovXG5QSVhJLldlYkdMU2hhZGVyTWFuYWdlciA9IGZ1bmN0aW9uKGdsKVxue1xuXG4gICAgdGhpcy5tYXhBdHRpYnMgPSAxMDtcbiAgICB0aGlzLmF0dHJpYlN0YXRlID0gW107XG4gICAgdGhpcy50ZW1wQXR0cmliU3RhdGUgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXhBdHRpYnM7IGkrKykge1xuICAgICAgICB0aGlzLmF0dHJpYlN0YXRlW2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRDb250ZXh0KGdsKTtcbiAgICAvLyB0aGUgZmluYWwgb25lIGlzIHVzZWQgZm9yIHRoZSByZW5kZXJpbmcgc3RyaXBzXG4gICAgLy90aGlzLnN0cmlwU2hhZGVyID0gbmV3IFBJWEkuU3RyaXBTaGFkZXIoZ2wpO1xufTtcblxuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIGNvbnRleHQgYW5kIHRoZSBwcm9wZXJ0aWVzXG4qIEBtZXRob2Qgc2V0Q29udGV4dCBcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcGFyYW0gdHJhbnNwYXJlbnQge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBkcmF3aW5nIGNvbnRleHQgc2hvdWxkIGJlIHRyYW5zcGFyZW50XG4qL1xuUElYSS5XZWJHTFNoYWRlck1hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgXG4gICAgLy8gdGhlIG5leHQgb25lIGlzIHVzZWQgZm9yIHJlbmRlcmluZyBwcmltYXRpdmVzXG4gICAgdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBuZXcgUElYSS5QcmltaXRpdmVTaGFkZXIoZ2wpO1xuXG4gICAgLy8gdGhpcyBzaGFkZXIgaXMgdXNlZCBmb3IgdGhlIGRlZmF1bHQgc3ByaXRlIHJlbmRlcmluZ1xuICAgIHRoaXMuZGVmYXVsdFNoYWRlciA9IG5ldyBQSVhJLlBpeGlTaGFkZXIoZ2wpO1xuXG4gICAgLy8gdGhpcyBzaGFkZXIgaXMgdXNlZCBmb3IgdGhlIGZhc3Qgc3ByaXRlIHJlbmRlcmluZ1xuICAgIHRoaXMuZmFzdFNoYWRlciA9IG5ldyBQSVhJLlBpeGlGYXN0U2hhZGVyKGdsKTtcblxuXG4gICAgdGhpcy5hY3RpdmF0ZVNoYWRlcih0aGlzLmRlZmF1bHRTaGFkZXIpO1xufTtcblxuXG4vKipcbiogVGFrZXMgdGhlIGF0dHJpYnV0ZXMgZ2l2ZW4gaW4gcGFyYW1ldGVycyBcbiogQG1ldGhvZCBzZXRBdHRyaWJzXG4qIEBwYXJhbSBhdHRyaWJzIHtBcnJheX0gYXR0cmlicyBcbiovXG5QSVhJLldlYkdMU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuc2V0QXR0cmlicyA9IGZ1bmN0aW9uKGF0dHJpYnMpXG57XG4gICAgLy8gcmVzZXQgdGVtcCBzdGF0ZVxuXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50ZW1wQXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbmV3IGF0dHJpYnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWJJZCA9IGF0dHJpYnNbaV07XG4gICAgICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlW2F0dHJpYklkXSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKVxuICAgIHtcblxuICAgICAgICBpZih0aGlzLmF0dHJpYlN0YXRlW2ldICE9PSB0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZVtpXSA9IHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldO1xuXG4gICAgICAgICAgICBpZih0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiogU2V0cy11cCB0aGUgZ2l2ZW4gc2hhZGVyIFxuKlxuKiBAbWV0aG9kIGFjdGl2YXRlU2hhZGVyXG4qIEBwYXJhbSBzaGFkZXIge09iamVjdH0gdGhlIHNoYWRlciB0aGF0IGlzIGdvaW5nIHRvIGJlIGFjdGl2YXRlZFxuKi9cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZVNoYWRlciA9IGZ1bmN0aW9uKHNoYWRlcilcbntcbiAgICAvL2lmKHRoaXMuY3VycmVudFNoYWRlciA9PSBzaGFkZXIpcmV0dXJuO1xuXG4gICAgdGhpcy5jdXJyZW50U2hhZGVyID0gc2hhZGVyO1xuXG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcbiAgICB0aGlzLnNldEF0dHJpYnMoc2hhZGVyLmF0dHJpYnV0ZXMpO1xuICBcbn07XG5cbi8qKlxuKiBUcmlnZ2VycyB0aGUgcHJpbWl0aXZlIHNoYWRlclxuKiBAbWV0aG9kIGFjdGl2YXRlUHJpbWl0aXZlU2hhZGVyXG4qL1xuUElYSS5XZWJHTFNoYWRlck1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlUHJpbWl0aXZlU2hhZGVyID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJpbWl0aXZlU2hhZGVyLnByb2dyYW0pO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJzKHRoaXMucHJpbWl0aXZlU2hhZGVyLmF0dHJpYnV0ZXMpO1xuICAgIFxufTtcblxuLyoqXG4qIERpc2FibGUgdGhlIHByaW1pdGl2ZSBzaGFkZXJcbiogQG1ldGhvZCBkZWFjdGl2YXRlUHJpbWl0aXZlU2hhZGVyXG4qL1xuUElYSS5XZWJHTFNoYWRlck1hbmFnZXIucHJvdG90eXBlLmRlYWN0aXZhdGVQcmltaXRpdmVTaGFkZXIgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGdsLnVzZVByb2dyYW0odGhpcy5kZWZhdWx0U2hhZGVyLnByb2dyYW0pO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJzKHRoaXMuZGVmYXVsdFNoYWRlci5hdHRyaWJ1dGVzKTtcbn07XG5cbi8qKlxuKiBEZXN0cm95c1xuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLldlYkdMU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmF0dHJpYlN0YXRlID0gbnVsbDtcblxuICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlID0gbnVsbDtcblxuICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuZGVmYXVsdFNoYWRlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmZhc3RTaGFkZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5nbCA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKiBcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIFdlYkdMU3ByaXRlQmF0Y2g6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbGliZ2R4L2xpYmdkeC9ibG9iL21hc3Rlci9nZHgvc3JjL2NvbS9iYWRsb2dpYy9nZHgvZ3JhcGhpY3MvZzJkL1dlYkdMU3ByaXRlQmF0Y2guamF2YVxuICovXG5cbiAvKipcbiAqXG4gKiBAY2xhc3MgV2ViR0xTcHJpdGVCYXRjaFxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICpcbiAqL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoID0gZnVuY3Rpb24oZ2wpXG57XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0U2l6ZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMudmVydFNpemUgPSA2O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgaW4gdGhlIFNwcml0ZUJhdGNoIGJlZm9yZSBpdCBmbHVzaGVzXG4gICAgICogQHByb3BlcnR5IHNpemVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnNpemUgPSAyMDAwOy8vTWF0aC5wb3coMiwgMTYpIC8gIHRoaXMudmVydFNpemU7XG5cbiAgICAvL3RoZSB0b3RhbCBudW1iZXIgb2YgZmxvYXRzIGluIG91ciBiYXRjaFxuICAgIHZhciBudW1WZXJ0cyA9IHRoaXMuc2l6ZSAqIDQgKiAgdGhpcy52ZXJ0U2l6ZTtcbiAgICAvL3RoZSB0b3RhbCBudW1iZXIgb2YgaW5kaWNlcyBpbiBvdXIgYmF0Y2hcbiAgICB2YXIgbnVtSW5kaWNlcyA9IHRoaXMuc2l6ZSAqIDY7XG5cbiAgICAvL3ZlcnRleCBkYXRhXG5cbiAgICAvKipcbiAgICAqIEhvbGRzIHRoZSB2ZXJ0aWNlc1xuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICogQHR5cGUgRmxvYXQzMkFycmF5XG4gICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0cyk7XG5cbiAgICAvL2luZGV4IGRhdGFcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgaW5kaWNlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGluZGljZXNcbiAgICAgKiBAdHlwZSBVaW50MTZBcnJheVxuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcbiAgICBcbiAgICB0aGlzLmxhc3RJbmRleENvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGk9MCwgaj0wOyBpIDwgbnVtSW5kaWNlczsgaSArPSA2LCBqICs9IDQpXG4gICAge1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDBdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDNdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgIH1cblxuXG4gICAgdGhpcy5kcmF3aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcbiAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgXG4gICAgdGhpcy5zZXRDb250ZXh0KGdsKTtcbn07XG5cbi8qKlxuKiBcbiogQG1ldGhvZCBzZXRDb250ZXh0XG4qXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvLyBjcmVhdGUgYSBjb3VwbGUgb2YgYnVmZmVyc1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLy8gNjU1MzUgaXMgbWF4IGluZGV4LCBzbyA2NTUzNSAvIDYgPSAxMDkyMi5cblxuXG4gICAgLy91cGxvYWQgdGhlIGluZGV4IGRhdGFcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSA5OTk5OTtcbn07XG5cbi8qKlxuKiBcbiogQG1ldGhvZCBiZWdpblxuKlxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gdGhlIFJlbmRlclNlc3Npb25cbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSByZW5kZXJTZXNzaW9uO1xuICAgIHRoaXMuc2hhZGVyID0gdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuZGVmYXVsdFNoYWRlcjtcblxuICAgIHRoaXMuc3RhcnQoKTtcbn07XG5cbi8qKlxuKiBcbiogQG1ldGhvZCBlbmRcbipcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2QgcmVuZGVyXG4qIFxuKiBAcGFyYW0gc3ByaXRlIHtTcHJpdGV9IHRoZSBzcHJpdGUgdG8gcmVuZGVyIHdoZW4gdXNpbmcgdGhpcyBzcHJpdGViYXRjaFxuKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc3ByaXRlKVxue1xuICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLnRleHR1cmU7XG5cbiAgICAvLyBjaGVjayB0ZXh0dXJlLi5cbiAgICBpZih0ZXh0dXJlLmJhc2VUZXh0dXJlICE9PSB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSB8fCB0aGlzLmN1cnJlbnRCYXRjaFNpemUgPj0gdGhpcy5zaXplKVxuICAgIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgfVxuXG5cbiAgICAvLyBjaGVjayBibGVuZCBtb2RlXG4gICAgaWYoc3ByaXRlLmJsZW5kTW9kZSAhPT0gdGhpcy5jdXJyZW50QmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoc3ByaXRlLmJsZW5kTW9kZSk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB1dnMgZm9yIHRoZSB0ZXh0dXJlXG4gICAgdmFyIHV2cyA9IHNwcml0ZS5fdXZzIHx8IHNwcml0ZS50ZXh0dXJlLl91dnM7XG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgIGlmKCF1dnMpcmV0dXJuO1xuXG4gICAgLy8gZ2V0IHRoZSBzcHJpdGVzIGN1cnJlbnQgYWxwaGFcbiAgICB2YXIgYWxwaGEgPSBzcHJpdGUud29ybGRBbHBoYTtcbiAgICB2YXIgdGludCA9IHNwcml0ZS50aW50O1xuXG4gICAgdmFyIHZlcnRpY2llcyA9IHRoaXMudmVydGljZXM7XG5cblxuICAgIC8vIFRPRE8gdHJpbT8/XG4gICAgdmFyIGFYID0gc3ByaXRlLmFuY2hvci54O1xuICAgIHZhciBhWSA9IHNwcml0ZS5hbmNob3IueTtcblxuICAgIHZhciB3MCwgdzEsIGgwLCBoMTtcbiAgICAgICAgXG4gICAgaWYgKHNwcml0ZS50ZXh0dXJlLnRyaW0pXG4gICAge1xuICAgICAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc3ByaXRlIGNvb3Jkcy4uXG4gICAgICAgIHZhciB0cmltID0gc3ByaXRlLnRleHR1cmUudHJpbTtcblxuICAgICAgICB3MSA9IHRyaW0ueCAtIGFYICogdHJpbS53aWR0aDtcbiAgICAgICAgdzAgPSB3MSArIHRleHR1cmUuZnJhbWUud2lkdGg7XG5cbiAgICAgICAgaDEgPSB0cmltLnkgLSBhWSAqIHRyaW0uaGVpZ2h0O1xuICAgICAgICBoMCA9IGgxICsgdGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdzAgPSAodGV4dHVyZS5mcmFtZS53aWR0aCApICogKDEtYVgpO1xuICAgICAgICB3MSA9ICh0ZXh0dXJlLmZyYW1lLndpZHRoICkgKiAtYVg7XG5cbiAgICAgICAgaDAgPSB0ZXh0dXJlLmZyYW1lLmhlaWdodCAqICgxLWFZKTtcbiAgICAgICAgaDEgPSB0ZXh0dXJlLmZyYW1lLmhlaWdodCAqIC1hWTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiA0ICogdGhpcy52ZXJ0U2l6ZTtcblxuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHNwcml0ZS53b3JsZFRyYW5zZm9ybTsvLy50b0FycmF5KCk7XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7Ly9bMF07XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5jOy8vWzNdO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYjsvL1sxXTtcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7Ly9bNF07XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7Ly9bMl07XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7Ly8vWzVdO1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDEgKyBiICogdzEgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTA7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDEgKyBiICogdzAgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTE7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDAgKyBiICogdzAgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MjtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTI7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDAgKyBiICogdzEgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MztcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTM7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuICAgIFxuICAgIC8vIGluY3JlbWVudCB0aGUgYmF0Y2hzaXplXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplKys7XG5cblxufTtcblxuLyoqXG4qIFJlbmRlcnMgYSB0aWxpbmdTcHJpdGUgdXNpbmcgdGhlIHNwcml0ZUJhdGNoXG4qIEBtZXRob2QgcmVuZGVyVGlsaW5nU3ByaXRlXG4qIFxuKiBAcGFyYW0gc3ByaXRlIHtUaWxpbmdTcHJpdGV9IHRoZSB0aWxpbmdTcHJpdGUgdG8gcmVuZGVyXG4qL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5yZW5kZXJUaWxpbmdTcHJpdGUgPSBmdW5jdGlvbih0aWxpbmdTcHJpdGUpXG57XG4gICAgdmFyIHRleHR1cmUgPSB0aWxpbmdTcHJpdGUudGlsaW5nVGV4dHVyZTtcblxuICAgIGlmKHRleHR1cmUuYmFzZVRleHR1cmUgIT09IHRoaXMuY3VycmVudEJhc2VUZXh0dXJlIHx8IHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLnNpemUpXG4gICAge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICAgLy8gY2hlY2sgYmxlbmQgbW9kZVxuICAgIGlmKHRpbGluZ1Nwcml0ZS5ibGVuZE1vZGUgIT09IHRoaXMuY3VycmVudEJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKHRpbGluZ1Nwcml0ZS5ibGVuZE1vZGUpO1xuICAgIH1cblxuICAgICAvLyBzZXQgdGhlIHRleHR1cmVzIHV2cyB0ZW1wb3JhcmlseVxuICAgIC8vIFRPRE8gY3JlYXRlIGEgc2VwYXJhdGUgdGV4dHVyZSBzbyB0aGF0IHdlIGNhbiB0aWxlIHBhcnQgb2YgYSB0ZXh0dXJlXG5cbiAgICBpZighdGlsaW5nU3ByaXRlLl91dnMpdGlsaW5nU3ByaXRlLl91dnMgPSBuZXcgUElYSS5UZXh0dXJlVXZzKCk7XG5cbiAgICB2YXIgdXZzID0gdGlsaW5nU3ByaXRlLl91dnM7XG5cbiAgICB0aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLnggJT0gdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCAqIHRpbGluZ1Nwcml0ZS50aWxlU2NhbGVPZmZzZXQueDtcbiAgICB0aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLnkgJT0gdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQgKiB0aWxpbmdTcHJpdGUudGlsZVNjYWxlT2Zmc2V0Lnk7XG5cbiAgICB2YXIgb2Zmc2V0WCA9ICB0aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLngvKHRleHR1cmUuYmFzZVRleHR1cmUud2lkdGgqdGlsaW5nU3ByaXRlLnRpbGVTY2FsZU9mZnNldC54KTtcbiAgICB2YXIgb2Zmc2V0WSA9ICB0aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLnkvKHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0KnRpbGluZ1Nwcml0ZS50aWxlU2NhbGVPZmZzZXQueSk7XG5cbiAgICB2YXIgc2NhbGVYID0gICh0aWxpbmdTcHJpdGUud2lkdGggLyB0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoKSAgLyAodGlsaW5nU3ByaXRlLnRpbGVTY2FsZS54ICogdGlsaW5nU3ByaXRlLnRpbGVTY2FsZU9mZnNldC54KTtcbiAgICB2YXIgc2NhbGVZID0gICh0aWxpbmdTcHJpdGUuaGVpZ2h0IC8gdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQpIC8gKHRpbGluZ1Nwcml0ZS50aWxlU2NhbGUueSAqIHRpbGluZ1Nwcml0ZS50aWxlU2NhbGVPZmZzZXQueSk7XG5cbiAgICB1dnMueDAgPSAwIC0gb2Zmc2V0WDtcbiAgICB1dnMueTAgPSAwIC0gb2Zmc2V0WTtcblxuICAgIHV2cy54MSA9ICgxICogc2NhbGVYKSAtIG9mZnNldFg7XG4gICAgdXZzLnkxID0gMCAtIG9mZnNldFk7XG5cbiAgICB1dnMueDIgPSAoMSAqIHNjYWxlWCkgLSBvZmZzZXRYO1xuICAgIHV2cy55MiA9ICgxICogc2NhbGVZKSAtIG9mZnNldFk7XG5cbiAgICB1dnMueDMgPSAwIC0gb2Zmc2V0WDtcbiAgICB1dnMueTMgPSAoMSAqc2NhbGVZKSAtIG9mZnNldFk7XG5cbiAgICAvLyBnZXQgdGhlIHRpbGluZ1Nwcml0ZXMgY3VycmVudCBhbHBoYVxuICAgIHZhciBhbHBoYSA9IHRpbGluZ1Nwcml0ZS53b3JsZEFscGhhO1xuICAgIHZhciB0aW50ID0gdGlsaW5nU3ByaXRlLnRpbnQ7XG5cbiAgICB2YXIgIHZlcnRpY2llcyA9IHRoaXMudmVydGljZXM7XG5cbiAgICB2YXIgd2lkdGggPSB0aWxpbmdTcHJpdGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRpbGluZ1Nwcml0ZS5oZWlnaHQ7XG5cbiAgICAvLyBUT0RPIHRyaW0/P1xuICAgIHZhciBhWCA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueDsgLy8gLSB0aWxpbmdTcHJpdGUudGV4dHVyZS50cmltLnhcbiAgICB2YXIgYVkgPSB0aWxpbmdTcHJpdGUuYW5jaG9yLnk7IC8vLSB0aWxpbmdTcHJpdGUudGV4dHVyZS50cmltLnlcbiAgICB2YXIgdzAgPSB3aWR0aCAqICgxLWFYKTtcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC1hWDtcblxuICAgIHZhciBoMCA9IGhlaWdodCAqICgxLWFZKTtcbiAgICB2YXIgaDEgPSBoZWlnaHQgKiAtYVk7XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiA0ICogdGhpcy52ZXJ0U2l6ZTtcblxuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHRpbGluZ1Nwcml0ZS53b3JsZFRyYW5zZm9ybTtcblxuICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTsvL1swXTtcbiAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmM7Ly9bM107XG4gICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5iOy8vWzFdO1xuICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDsvL1s0XTtcbiAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDsvL1syXTtcbiAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTsvLy9bNV07XG5cbiAgICAvLyB4eVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuICAgIC8vIHV2XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLngwO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy55MDtcbiAgICAvLyBjb2xvclxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGFscGhhO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHRpbnQ7XG5cbiAgICAvLyB4eVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuICAgIC8vIHV2XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLngxO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy55MTtcbiAgICAvLyBjb2xvclxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGFscGhhO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHRpbnQ7XG4gICAgXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDAgKyBiICogdzAgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MjtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTI7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBkICogaDAgKyBiICogdzEgKyB0eTtcbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MztcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTM7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBhbHBoYTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB0aW50O1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBiYXRjaHNcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUrKztcbn07XG5cblxuLyoqXG4qIFJlbmRlcnMgdGhlIGNvbnRlbnQgYW5kIGVtcHRpZXMgdGhlIGN1cnJlbnQgYmF0Y2hcbipcbiogQG1ldGhvZCBmbHVzaFxuKiBcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIElmIHRoZSBiYXRjaCBpcyBsZW5ndGggMCB0aGVuIHJldHVybiBhcyB0aGVyZSBpcyBub3RoaW5nIHRvIGRyYXdcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplPT09MClyZXR1cm47XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIFxuICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSB8fCBQSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSh0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSwgZ2wpKTtcblxuICAgIC8vIHVwbG9hZCB0aGUgdmVydHMgdG8gdGhlIGJ1ZmZlclxuICAgIFxuICAgIGlmKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+ICggdGhpcy5zaXplICogMC41ICkgKVxuICAgIHtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGljZXMpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmVydGljZXMuc3ViYXJyYXkoMCwgdGhpcy5jdXJyZW50QmF0Y2hTaXplICogNCAqIHRoaXMudmVydFNpemUpO1xuXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2aWV3KTtcbiAgICB9XG5cbiAgIC8vIHZhciB2aWV3ID0gdGhpcy52ZXJ0aWNlcy5zdWJhcnJheSgwLCB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiA0ICogdGhpcy52ZXJ0U2l6ZSk7XG4gICAgLy9nbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmlldyk7XG4gICAgXG4gICAgLy8gbm93IGRyYXcgdGhvc2Ugc3Vja2FzIVxuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgIFxuICAgIC8vIHRoZW4gcmVzZXQgdGhlIGJhdGNoIVxuICAgIHRoaXMuY3VycmVudEJhdGNoU2l6ZSA9IDA7XG5cbiAgICAvLyBpbmNyZW1lbnQgdGhlIGRyYXcgY291bnRcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZHJhd0NvdW50Kys7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2Qgc3RvcFxuKlxuKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2Qgc3RhcnRcbipcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyBiaW5kIHRoZSBtYWluIHRleHR1cmVcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgIC8vIGJpbmQgdGhlIGJ1ZmZlcnNcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgLy8gc2V0IHRoZSBwcm9qZWN0aW9uXG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbjtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5zaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCBwcm9qZWN0aW9uLnkpO1xuXG4gICAgLy8gc2V0IHRoZSBwb2ludGVyc1xuICAgIHZhciBzdHJpZGUgPSAgdGhpcy52ZXJ0U2l6ZSAqIDQ7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAwKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAyICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5jb2xvckF0dHJpYnV0ZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDQgKiA0KTtcblxuICAgIC8vIHNldCB0aGUgYmxlbmQgbW9kZS4uXG4gICAgaWYodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSBQSVhJLmJsZW5kTW9kZXMuTk9STUFMKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoUElYSS5ibGVuZE1vZGVzLk5PUk1BTCk7XG4gICAgfVxufTtcblxuLyoqXG4qIFNldHMtdXAgdGhlIGdpdmVuIGJsZW5kTW9kZSBmcm9tIFdlYkdMJ3MgcG9pbnQgb2Ygdmlld1xuKiBAbWV0aG9kIHNldEJsZW5kTW9kZSBcbipcbiogQHBhcmFtIGJsZW5kTW9kZSB7TnVtYmVyfSB0aGUgYmxlbmRNb2RlLCBzaG91bGQgYmUgYSBQaXhpIGNvbnN0LCBzdWNoIGFzIFBJWEkuQmxlbmRNb2Rlcy5BRERcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnNldEJsZW5kTW9kZSA9IGZ1bmN0aW9uKGJsZW5kTW9kZSlcbntcbiAgICB0aGlzLmZsdXNoKCk7XG5cbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSBibGVuZE1vZGU7XG4gICAgXG4gICAgdmFyIGJsZW5kTW9kZVdlYkdMID0gUElYSS5ibGVuZE1vZGVzV2ViR0xbdGhpcy5jdXJyZW50QmxlbmRNb2RlXTtcbiAgICB0aGlzLmdsLmJsZW5kRnVuYyhibGVuZE1vZGVXZWJHTFswXSwgYmxlbmRNb2RlV2ViR0xbMV0pO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBTcHJpdGVCYXRjaFxuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG5cbiAgICB0aGlzLnZlcnRpY2VzID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuICAgIFxuICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKCB0aGlzLnZlcnRleEJ1ZmZlciApO1xuICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKCB0aGlzLmluZGV4QnVmZmVyICk7XG4gICAgXG4gICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBudWxsO1xuICAgIFxuICAgIHRoaXMuZ2wgPSBudWxsO1xufTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICogXG4gKiBCaWcgdGhhbmtzIHRvIHRoZSB2ZXJ5IGNsZXZlciBNYXR0IERlc0xhdXJpZXJzIDxtYXR0ZGVzbD4gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL1xuICogZm9yIGNyZWF0aW5nIHRoZSBvcmlnaW5hbCBwaXhpIHZlcnNpb24hXG4gKlxuICogSGVhdmlseSBpbnNwaXJlZCBieSBMaWJHRFgncyBXZWJHTFNwcml0ZUJhdGNoOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9XZWJHTFNwcml0ZUJhdGNoLmphdmFcbiAqL1xuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoID0gZnVuY3Rpb24oZ2wpXG57XG4gICBcblxuICAgIHRoaXMudmVydFNpemUgPSAxMDtcbiAgICB0aGlzLm1heFNpemUgPSA2MDAwOy8vTWF0aC5wb3coMiwgMTYpIC8gIHRoaXMudmVydFNpemU7XG4gICAgdGhpcy5zaXplID0gdGhpcy5tYXhTaXplO1xuXG4gICAgLy90aGUgdG90YWwgbnVtYmVyIG9mIGZsb2F0cyBpbiBvdXIgYmF0Y2hcbiAgICB2YXIgbnVtVmVydHMgPSB0aGlzLnNpemUgKiA0ICogIHRoaXMudmVydFNpemU7XG4gICAgLy90aGUgdG90YWwgbnVtYmVyIG9mIGluZGljZXMgaW4gb3VyIGJhdGNoXG4gICAgdmFyIG51bUluZGljZXMgPSB0aGlzLm1heFNpemUgKiA2O1xuXG4gICAgIC8vdmVydGV4IGRhdGFcbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0cyk7XG4gICAgLy9pbmRleCBkYXRhXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xuICAgIFxuICAgIHRoaXMudmVydGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcblxuICAgIHRoaXMubGFzdEluZGV4Q291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaT0wLCBqPTA7IGkgPCBudW1JbmRpY2VzOyBpICs9IDYsIGogKz0gNClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMF0gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDJdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgM10gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDVdID0gaiArIDM7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcbiAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGw7XG4gICBcbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSAwO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IG51bGw7XG4gICAgXG5cbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG5cbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG5cbiAgICB0aGlzLnNldENvbnRleHQoZ2wpO1xufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vIGNyZWF0ZSBhIGNvdXBsZSBvZiBidWZmZXJzXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyA2NTUzNSBpcyBtYXggaW5kZXgsIHNvIDY1NTM1IC8gNiA9IDEwOTIyLlxuXG5cbiAgICAvL3VwbG9hZCB0aGUgaW5kZXggZGF0YVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0aWNlcywgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDk5OTk5O1xufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihzcHJpdGVCYXRjaCwgcmVuZGVyU2Vzc2lvbilcbntcbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSByZW5kZXJTZXNzaW9uO1xuICAgIHRoaXMuc2hhZGVyID0gdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuZmFzdFNoYWRlcjtcblxuICAgIHRoaXMubWF0cml4ID0gc3ByaXRlQmF0Y2gud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKTtcblxuICAgIHRoaXMuc3RhcnQoKTtcbn07XG5cblBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2gucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmZsdXNoKCk7XG59O1xuXG5cblBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNwcml0ZUJhdGNoKVxue1xuXG4gICAgdmFyIGNoaWxkcmVuID0gc3ByaXRlQmF0Y2guY2hpbGRyZW47XG4gICAgdmFyIHNwcml0ZSA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgIFxuICAgIC8vIGNoZWNrIHRleHR1cmUuXG4gICAgaWYoIXNwcml0ZS50ZXh0dXJlLl91dnMpcmV0dXJuO1xuICAgXG4gICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBzcHJpdGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAvLyBjaGVjayBibGVuZCBtb2RlXG4gICAgaWYoc3ByaXRlLmJsZW5kTW9kZSAhPT0gdGhpcy5jdXJyZW50QmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoc3ByaXRlLmJsZW5kTW9kZSk7XG4gICAgfVxuICAgIFxuICAgIGZvcih2YXIgaT0wLGo9IGNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLnJlbmRlclNwcml0ZShjaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaCgpO1xufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUucmVuZGVyU3ByaXRlID0gZnVuY3Rpb24oc3ByaXRlKVxue1xuICAgIC8vc3ByaXRlID0gY2hpbGRyZW5baV07XG4gICAgaWYoIXNwcml0ZS52aXNpYmxlKXJldHVybjtcbiAgICBcbiAgICAvLyBUT0RPIHRyaW0/P1xuICAgIGlmKHNwcml0ZS50ZXh0dXJlLmJhc2VUZXh0dXJlICE9PSB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBzcHJpdGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgXG4gICAgICAgIGlmKCFzcHJpdGUudGV4dHVyZS5fdXZzKXJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXZzLCB2ZXJ0aWNpZXMgPSB0aGlzLnZlcnRpY2VzLCB3aWR0aCwgaGVpZ2h0LCB3MCwgdzEsIGgwLCBoMSwgaW5kZXg7XG5cbiAgICB1dnMgPSBzcHJpdGUudGV4dHVyZS5fdXZzO1xuXG5cbiAgICB3aWR0aCA9IHNwcml0ZS50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIGhlaWdodCA9IHNwcml0ZS50ZXh0dXJlLmZyYW1lLmhlaWdodDtcblxuICAgIGlmIChzcHJpdGUudGV4dHVyZS50cmltKVxuICAgIHtcbiAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlIGV4dHJhIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuLlxuICAgICAgICB2YXIgdHJpbSA9IHNwcml0ZS50ZXh0dXJlLnRyaW07XG5cbiAgICAgICAgdzEgPSB0cmltLnggLSBzcHJpdGUuYW5jaG9yLnggKiB0cmltLndpZHRoO1xuICAgICAgICB3MCA9IHcxICsgc3ByaXRlLnRleHR1cmUuZnJhbWUud2lkdGg7XG5cbiAgICAgICAgaDEgPSB0cmltLnkgLSBzcHJpdGUuYW5jaG9yLnkgKiB0cmltLmhlaWdodDtcbiAgICAgICAgaDAgPSBoMSArIHNwcml0ZS50ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdzAgPSAoc3ByaXRlLnRleHR1cmUuZnJhbWUud2lkdGggKSAqICgxLXNwcml0ZS5hbmNob3IueCk7XG4gICAgICAgIHcxID0gKHNwcml0ZS50ZXh0dXJlLmZyYW1lLndpZHRoICkgKiAtc3ByaXRlLmFuY2hvci54O1xuXG4gICAgICAgIGgwID0gc3ByaXRlLnRleHR1cmUuZnJhbWUuaGVpZ2h0ICogKDEtc3ByaXRlLmFuY2hvci55KTtcbiAgICAgICAgaDEgPSBzcHJpdGUudGV4dHVyZS5mcmFtZS5oZWlnaHQgKiAtc3ByaXRlLmFuY2hvci55O1xuICAgIH1cblxuICAgIGluZGV4ID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplICogNCAqIHRoaXMudmVydFNpemU7XG5cbiAgICAvLyB4eVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHcxO1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IGgxO1xuXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnBvc2l0aW9uLng7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnBvc2l0aW9uLnk7XG5cbiAgICAvL3NjYWxlXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnNjYWxlLng7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnNjYWxlLnk7XG5cbiAgICAvL3JvdGF0aW9uXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLnJvdGF0aW9uO1xuXG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueDA7XG4gICAgdmVydGljaWVzW2luZGV4KytdID0gdXZzLnkxO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljaWVzW2luZGV4KytdID0gc3ByaXRlLmFscGhhO1xuIFxuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB3MDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBoMTtcblxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS55O1xuXG4gICAgIC8vcm90YXRpb25cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucm90YXRpb247XG5cbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTE7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuYWxwaGE7XG4gIFxuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB3MDtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBoMDtcblxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS55O1xuXG4gICAgIC8vcm90YXRpb25cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucm90YXRpb247XG5cbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MjtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTI7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuYWxwaGE7XG4gXG5cblxuXG4gICAgLy8geHlcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB3MTtcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBoMDtcblxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS54O1xuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS55O1xuXG4gICAgIC8vcm90YXRpb25cbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUucm90YXRpb247XG5cbiAgICAvLyB1dlxuICAgIHZlcnRpY2llc1tpbmRleCsrXSA9IHV2cy54MztcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSB1dnMueTM7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNpZXNbaW5kZXgrK10gPSBzcHJpdGUuYWxwaGE7XG5cbiAgICAvLyBpbmNyZW1lbnQgdGhlIGJhdGNoc1xuICAgIHRoaXMuY3VycmVudEJhdGNoU2l6ZSsrO1xuXG4gICAgaWYodGhpcy5jdXJyZW50QmF0Y2hTaXplID49IHRoaXMuc2l6ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG59O1xuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKClcbntcblxuICAgIC8vIElmIHRoZSBiYXRjaCBpcyBsZW5ndGggMCB0aGVuIHJldHVybiBhcyB0aGVyZSBpcyBub3RoaW5nIHRvIGRyYXdcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplPT09MClyZXR1cm47XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIFxuICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxuXG4gICAgaWYoIXRoaXMuY3VycmVudEJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSlQSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSh0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSwgZ2wpO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTsvLyB8fCBQSVhJLmNyZWF0ZVdlYkdMVGV4dHVyZSh0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSwgZ2wpKTtcblxuICAgIC8vIHVwbG9hZCB0aGUgdmVydHMgdG8gdGhlIGJ1ZmZlclxuXG4gICBcbiAgICBpZih0aGlzLmN1cnJlbnRCYXRjaFNpemUgPiAoIHRoaXMuc2l6ZSAqIDAuNSApIClcbiAgICB7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnZlcnRpY2VzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZlcnRpY2VzLnN1YmFycmF5KDAsIHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDQgKiB0aGlzLnZlcnRTaXplKTtcblxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmlldyk7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIC8vIG5vdyBkcmF3IHRob3NlIHN1Y2thcyFcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICBcbiAgICAvLyB0aGVuIHJlc2V0IHRoZSBiYXRjaCFcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUgPSAwO1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBkcmF3IGNvdW50XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCsrO1xufTtcblxuXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZmx1c2goKTtcbn07XG5cblBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2gucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyBiaW5kIHRoZSBtYWluIHRleHR1cmVcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgIC8vIGJpbmQgdGhlIGJ1ZmZlcnNcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgLy8gc2V0IHRoZSBwcm9qZWN0aW9uXG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbjtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5zaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCBwcm9qZWN0aW9uLnkpO1xuXG4gICAgLy8gc2V0IHRoZSBtYXRyaXhcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuc2hhZGVyLnVNYXRyaXgsIGZhbHNlLCB0aGlzLm1hdHJpeCk7XG5cbiAgICAvLyBzZXQgdGhlIHBvaW50ZXJzXG4gICAgdmFyIHN0cmlkZSA9ICB0aGlzLnZlcnRTaXplICogNDtcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hUG9zaXRpb25Db29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDIgKiA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFTY2FsZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDQgKiA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFSb3RhdGlvbiwgMSwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDYgKiA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA3ICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5jb2xvckF0dHJpYnV0ZSwgMSwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDkgKiA0KTtcblxuICAgIC8vIHNldCB0aGUgYmxlbmQgbW9kZS4uXG4gICAgaWYodGhpcy5jdXJyZW50QmxlbmRNb2RlICE9PSBQSVhJLmJsZW5kTW9kZXMuTk9STUFMKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoUElYSS5ibGVuZE1vZGVzLk5PUk1BTCk7XG4gICAgfVxufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUuc2V0QmxlbmRNb2RlID0gZnVuY3Rpb24oYmxlbmRNb2RlKVxue1xuICAgIHRoaXMuZmx1c2goKTtcblxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgICBcbiAgICB2YXIgYmxlbmRNb2RlV2ViR0wgPSBQSVhJLmJsZW5kTW9kZXNXZWJHTFt0aGlzLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgIHRoaXMuZ2wuYmxlbmRGdW5jKGJsZW5kTW9kZVdlYkdMWzBdLCBibGVuZE1vZGVXZWJHTFsxXSk7XG59O1xuXG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiogQGNsYXNzIFdlYkdMRmlsdGVyTWFuYWdlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcGFyYW0gdHJhbnNwYXJlbnQge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBkcmF3aW5nIGNvbnRleHQgc2hvdWxkIGJlIHRyYW5zcGFyZW50XG4qIEBwcml2YXRlXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIgPSBmdW5jdGlvbihnbCwgdHJhbnNwYXJlbnQpXG57XG4gICAgdGhpcy50cmFuc3BhcmVudCA9IHRyYW5zcGFyZW50O1xuXG4gICAgdGhpcy5maWx0ZXJTdGFjayA9IFtdO1xuICAgIFxuICAgIHRoaXMub2Zmc2V0WCA9IDA7XG4gICAgdGhpcy5vZmZzZXRZID0gMDtcblxuICAgIHRoaXMuc2V0Q29udGV4dChnbCk7XG59O1xuXG4vLyBBUElcbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgY29udGV4dCBhbmQgdGhlIHByb3BlcnRpZXNcbiogQG1ldGhvZCBzZXRDb250ZXh0IFxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy50ZXh0dXJlUG9vbCA9IFtdO1xuXG4gICAgdGhpcy5pbml0U2hhZGVyQnVmZmVycygpO1xufTtcblxuLyoqXG4qIFxuKiBAbWV0aG9kIGJlZ2luXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHBhcmFtIGJ1ZmZlciB7QXJyYXlCdWZmZXJ9IFxuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24sIGJ1ZmZlcilcbntcbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSByZW5kZXJTZXNzaW9uO1xuICAgIHRoaXMuZGVmYXVsdFNoYWRlciA9IHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5kZWZhdWx0U2hhZGVyO1xuXG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbjtcbiAgIC8vIGNvbnNvbGUubG9nKHRoaXMud2lkdGgpXG4gICAgdGhpcy53aWR0aCA9IHByb2plY3Rpb24ueCAqIDI7XG4gICAgdGhpcy5oZWlnaHQgPSAtcHJvamVjdGlvbi55ICogMjtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbn07XG5cbi8qKlxuKiBBcHBsaWVzIHRoZSBmaWx0ZXIgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrXG4qIEBtZXRob2QgcHVzaEZpbHRlclxuKiBAcGFyYW0gZmlsdGVyQmxvY2sge09iamVjdH0gdGhlIGZpbHRlciB0aGF0IHdpbGwgYmUgcHVzaGVkIHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFja1xuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5wdXNoRmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyQmxvY2spXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb247XG4gICAgdmFyIG9mZnNldCA9IHRoaXMucmVuZGVyU2Vzc2lvbi5vZmZzZXQ7XG5cbiAgICBmaWx0ZXJCbG9jay5fZmlsdGVyQXJlYSA9IGZpbHRlckJsb2NrLnRhcmdldC5maWx0ZXJBcmVhIHx8IGZpbHRlckJsb2NrLnRhcmdldC5nZXRCb3VuZHMoKTtcblxuXG4gICAgLy8gZmlsdGVyIHByb2dyYW1cbiAgICAvLyBPUFRJTUlTQVRJT04gLSB0aGUgZmlyc3QgZmlsdGVyIGlzIGZyZWUgaWYgaXRzIGEgc2ltcGxlIGNvbG9yIGNoYW5nZT9cbiAgICB0aGlzLmZpbHRlclN0YWNrLnB1c2goZmlsdGVyQmxvY2spO1xuXG4gICAgdmFyIGZpbHRlciA9IGZpbHRlckJsb2NrLmZpbHRlclBhc3Nlc1swXTtcblxuICAgIHRoaXMub2Zmc2V0WCArPSBmaWx0ZXJCbG9jay5fZmlsdGVyQXJlYS54O1xuICAgIHRoaXMub2Zmc2V0WSArPSBmaWx0ZXJCbG9jay5fZmlsdGVyQXJlYS55O1xuXG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLnRleHR1cmVQb29sLnBvcCgpO1xuICAgIGlmKCF0ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGV4dHVyZSA9IG5ldyBQSVhJLkZpbHRlclRleHR1cmUodGhpcy5nbCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0ZXh0dXJlLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgIHRleHR1cmUudGV4dHVyZSk7XG5cbiAgICB2YXIgZmlsdGVyQXJlYSA9IGZpbHRlckJsb2NrLl9maWx0ZXJBcmVhOy8vIGZpbHRlckJsb2NrLnRhcmdldC5nZXRCb3VuZHMoKTsvLy9maWx0ZXJCbG9jay50YXJnZXQuZmlsdGVyQXJlYTtcblxuICAgIHZhciBwYWRpZG5nID0gZmlsdGVyLnBhZGRpbmc7XG4gICAgZmlsdGVyQXJlYS54IC09IHBhZGlkbmc7XG4gICAgZmlsdGVyQXJlYS55IC09IHBhZGlkbmc7XG4gICAgZmlsdGVyQXJlYS53aWR0aCArPSBwYWRpZG5nICogMjtcbiAgICBmaWx0ZXJBcmVhLmhlaWdodCArPSBwYWRpZG5nICogMjtcblxuICAgIC8vIGNhcCBmaWx0ZXIgdG8gc2NyZWVuIHNpemUuLlxuICAgIGlmKGZpbHRlckFyZWEueCA8IDApZmlsdGVyQXJlYS54ID0gMDtcbiAgICBpZihmaWx0ZXJBcmVhLndpZHRoID4gdGhpcy53aWR0aClmaWx0ZXJBcmVhLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICBpZihmaWx0ZXJBcmVhLnkgPCAwKWZpbHRlckFyZWEueSA9IDA7XG4gICAgaWYoZmlsdGVyQXJlYS5oZWlnaHQgPiB0aGlzLmhlaWdodClmaWx0ZXJBcmVhLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsICBmaWx0ZXJBcmVhLndpZHRoLCBmaWx0ZXJBcmVhLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0ZXh0dXJlLmZyYW1lQnVmZmVyKTtcblxuICAgIC8vIHNldCB2aWV3IHBvcnRcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBmaWx0ZXJBcmVhLndpZHRoLCBmaWx0ZXJBcmVhLmhlaWdodCk7XG5cbiAgICBwcm9qZWN0aW9uLnggPSBmaWx0ZXJBcmVhLndpZHRoLzI7XG4gICAgcHJvamVjdGlvbi55ID0gLWZpbHRlckFyZWEuaGVpZ2h0LzI7XG5cbiAgICBvZmZzZXQueCA9IC1maWx0ZXJBcmVhLng7XG4gICAgb2Zmc2V0LnkgPSAtZmlsdGVyQXJlYS55O1xuXG4gICAgLy8gdXBkYXRlIHByb2plY3Rpb25cbiAgICBnbC51bmlmb3JtMmYodGhpcy5kZWZhdWx0U2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIGZpbHRlckFyZWEud2lkdGgvMiwgLWZpbHRlckFyZWEuaGVpZ2h0LzIpO1xuICAgIGdsLnVuaWZvcm0yZih0aGlzLmRlZmF1bHRTaGFkZXIub2Zmc2V0VmVjdG9yLCAtZmlsdGVyQXJlYS54LCAtZmlsdGVyQXJlYS55KTtcblxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBnbC5jbGVhckNvbG9yKDAsMCwwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgIGZpbHRlckJsb2NrLl9nbEZpbHRlclRleHR1cmUgPSB0ZXh0dXJlO1xuXG59O1xuXG5cbi8qKlxuKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0XG4qIEBtZXRob2QgcG9wRmlsdGVyXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnBvcEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBmaWx0ZXJCbG9jayA9IHRoaXMuZmlsdGVyU3RhY2sucG9wKCk7XG4gICAgdmFyIGZpbHRlckFyZWEgPSBmaWx0ZXJCbG9jay5fZmlsdGVyQXJlYTtcbiAgICB2YXIgdGV4dHVyZSA9IGZpbHRlckJsb2NrLl9nbEZpbHRlclRleHR1cmU7XG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbjtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZW5kZXJTZXNzaW9uLm9mZnNldDtcblxuICAgIGlmKGZpbHRlckJsb2NrLmZpbHRlclBhc3Nlcy5sZW5ndGggPiAxKVxuICAgIHtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZmlsdGVyQXJlYS53aWR0aCwgZmlsdGVyQXJlYS5oZWlnaHQpO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVswXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbMV0gPSBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzJdID0gZmlsdGVyQXJlYS53aWR0aDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVszXSA9IGZpbHRlckFyZWEuaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbNF0gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzVdID0gMDtcblxuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzZdID0gZmlsdGVyQXJlYS53aWR0aDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVs3XSA9IDA7XG5cbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGV4QXJyYXkpO1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnV2QnVmZmVyKTtcbiAgICAgICAgLy8gbm93IHNldCB0aGUgdXZzLi5cbiAgICAgICAgdGhpcy51dkFycmF5WzJdID0gZmlsdGVyQXJlYS53aWR0aC90aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnV2QXJyYXlbNV0gPSBmaWx0ZXJBcmVhLmhlaWdodC90aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy51dkFycmF5WzZdID0gZmlsdGVyQXJlYS53aWR0aC90aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnV2QXJyYXlbN10gPSBmaWx0ZXJBcmVhLmhlaWdodC90aGlzLmhlaWdodDtcblxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy51dkFycmF5KTtcblxuICAgICAgICB2YXIgaW5wdXRUZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgdmFyIG91dHB1dFRleHR1cmUgPSB0aGlzLnRleHR1cmVQb29sLnBvcCgpO1xuICAgICAgICBpZighb3V0cHV0VGV4dHVyZSlvdXRwdXRUZXh0dXJlID0gbmV3IFBJWEkuRmlsdGVyVGV4dHVyZSh0aGlzLmdsLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIG91dHB1dFRleHR1cmUucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBuZWVkIHRvIGNsZWFyIHRoaXMgRkJPIGFzIGl0IG1heSBoYXZlIHNvbWUgbGVmdCBvdmVyIGVsZW1lbnRzIGZyb20gYSBwcmV2aW91cyBmaWx0ZXIuXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgb3V0cHV0VGV4dHVyZS5mcmFtZUJ1ZmZlciApO1xuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlckJsb2NrLmZpbHRlclBhc3Nlcy5sZW5ndGgtMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyUGFzcyA9IGZpbHRlckJsb2NrLmZpbHRlclBhc3Nlc1tpXTtcblxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBvdXRwdXRUZXh0dXJlLmZyYW1lQnVmZmVyICk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcblxuICAgICAgICAgICAgLy8gZHJhdyB0ZXh0dXJlLi5cbiAgICAgICAgICAgIC8vZmlsdGVyUGFzcy5hcHBseUZpbHRlclBhc3MoZmlsdGVyQXJlYS53aWR0aCwgZmlsdGVyQXJlYS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5hcHBseUZpbHRlclBhc3MoZmlsdGVyUGFzcywgZmlsdGVyQXJlYSwgZmlsdGVyQXJlYS53aWR0aCwgZmlsdGVyQXJlYS5oZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBzd2FwIHRoZSB0ZXh0dXJlcy4uXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGlucHV0VGV4dHVyZTtcbiAgICAgICAgICAgIGlucHV0VGV4dHVyZSA9IG91dHB1dFRleHR1cmU7XG4gICAgICAgICAgICBvdXRwdXRUZXh0dXJlID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG5cbiAgICAgICAgdGV4dHVyZSA9IGlucHV0VGV4dHVyZTtcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbC5wdXNoKG91dHB1dFRleHR1cmUpO1xuICAgIH1cblxuICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXNbZmlsdGVyQmxvY2suZmlsdGVyUGFzc2VzLmxlbmd0aC0xXTtcblxuICAgIHRoaXMub2Zmc2V0WCAtPSBmaWx0ZXJBcmVhLng7XG4gICAgdGhpcy5vZmZzZXRZIC09IGZpbHRlckFyZWEueTtcblxuXG4gICAgdmFyIHNpemVYID0gdGhpcy53aWR0aDtcbiAgICB2YXIgc2l6ZVkgPSB0aGlzLmhlaWdodDtcblxuICAgIHZhciBvZmZzZXRYID0gMDtcbiAgICB2YXIgb2Zmc2V0WSA9IDA7XG5cbiAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cbiAgICAvLyB0aW1lIHRvIHJlbmRlciB0aGUgZmlsdGVycyB0ZXh0dXJlIHRvIHRoZSBwcmV2aW91cyBzY2VuZVxuICAgIGlmKHRoaXMuZmlsdGVyU3RhY2subGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpOy8vdGhpcy50cmFuc3BhcmVudCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBjdXJyZW50RmlsdGVyID0gdGhpcy5maWx0ZXJTdGFja1t0aGlzLmZpbHRlclN0YWNrLmxlbmd0aC0xXTtcbiAgICAgICAgZmlsdGVyQXJlYSA9IGN1cnJlbnRGaWx0ZXIuX2ZpbHRlckFyZWE7XG5cbiAgICAgICAgc2l6ZVggPSBmaWx0ZXJBcmVhLndpZHRoO1xuICAgICAgICBzaXplWSA9IGZpbHRlckFyZWEuaGVpZ2h0O1xuXG4gICAgICAgIG9mZnNldFggPSBmaWx0ZXJBcmVhLng7XG4gICAgICAgIG9mZnNldFkgPSBmaWx0ZXJBcmVhLnk7XG5cbiAgICAgICAgYnVmZmVyID0gIGN1cnJlbnRGaWx0ZXIuX2dsRmlsdGVyVGV4dHVyZS5mcmFtZUJ1ZmZlcjtcbiAgICB9XG5cblxuXG4gICAgLy8gVE9ETyBuZWVkIHRvcmVtb3ZlIHRoZWFzZSBnbG9iYWwgZWxlbWVudHMuLlxuICAgIHByb2plY3Rpb24ueCA9IHNpemVYLzI7XG4gICAgcHJvamVjdGlvbi55ID0gLXNpemVZLzI7XG5cbiAgICBvZmZzZXQueCA9IG9mZnNldFg7XG4gICAgb2Zmc2V0LnkgPSBvZmZzZXRZO1xuXG4gICAgZmlsdGVyQXJlYSA9IGZpbHRlckJsb2NrLl9maWx0ZXJBcmVhO1xuXG4gICAgdmFyIHggPSBmaWx0ZXJBcmVhLngtb2Zmc2V0WDtcbiAgICB2YXIgeSA9IGZpbHRlckFyZWEueS1vZmZzZXRZO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXJzLi5cbiAgICAvLyBtYWtlIHN1cmUgdG8gZmxpcCB0aGUgeSFcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuXG4gICAgdGhpcy52ZXJ0ZXhBcnJheVswXSA9IHg7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheVsxXSA9IHkgKyBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgIHRoaXMudmVydGV4QXJyYXlbMl0gPSB4ICsgZmlsdGVyQXJlYS53aWR0aDtcbiAgICB0aGlzLnZlcnRleEFycmF5WzNdID0geSArIGZpbHRlckFyZWEuaGVpZ2h0O1xuXG4gICAgdGhpcy52ZXJ0ZXhBcnJheVs0XSA9IHg7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheVs1XSA9IHk7XG5cbiAgICB0aGlzLnZlcnRleEFycmF5WzZdID0geCArIGZpbHRlckFyZWEud2lkdGg7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheVs3XSA9IHk7XG5cbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy52ZXJ0ZXhBcnJheSk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy51dkJ1ZmZlcik7XG5cbiAgICB0aGlzLnV2QXJyYXlbMl0gPSBmaWx0ZXJBcmVhLndpZHRoL3RoaXMud2lkdGg7XG4gICAgdGhpcy51dkFycmF5WzVdID0gZmlsdGVyQXJlYS5oZWlnaHQvdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy51dkFycmF5WzZdID0gZmlsdGVyQXJlYS53aWR0aC90aGlzLndpZHRoO1xuICAgIHRoaXMudXZBcnJheVs3XSA9IGZpbHRlckFyZWEuaGVpZ2h0L3RoaXMuaGVpZ2h0O1xuXG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudXZBcnJheSk7XG5cbiAgIC8vY29uc29sZS5sb2codGhpcy52ZXJ0ZXhBcnJheSlcbiAgIC8vY29uc29sZS5sb2codGhpcy51dkFycmF5KVxuICAgIC8vY29uc29sZS5sb2coc2l6ZVggKyBcIiA6IFwiICsgc2l6ZVkpXG5cbiAgICBnbC52aWV3cG9ydCgwLCAwLCBzaXplWCwgc2l6ZVkpO1xuXG4gICAgLy8gYmluZCB0aGUgYnVmZmVyXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBidWZmZXIgKTtcblxuICAgIC8vIHNldCB0aGUgYmxlbmQgbW9kZSEgXG4gICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKVxuXG4gICAgLy8gc2V0IHRleHR1cmVcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLnRleHR1cmUpO1xuXG4gICAgLy8gYXBwbHkhXG4gICAgdGhpcy5hcHBseUZpbHRlclBhc3MoZmlsdGVyLCBmaWx0ZXJBcmVhLCBzaXplWCwgc2l6ZVkpO1xuXG4gICAgLy8gbm93IHJlc3RvcmUgdGhlIHJlZ3VsYXIgc2hhZGVyLi5cbiAgICBnbC51c2VQcm9ncmFtKHRoaXMuZGVmYXVsdFNoYWRlci5wcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5kZWZhdWx0U2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIHNpemVYLzIsIC1zaXplWS8yKTtcbiAgICBnbC51bmlmb3JtMmYodGhpcy5kZWZhdWx0U2hhZGVyLm9mZnNldFZlY3RvciwgLW9mZnNldFgsIC1vZmZzZXRZKTtcblxuICAgIC8vIHJldHVybiB0aGUgdGV4dHVyZSB0byB0aGUgcG9vbFxuICAgIHRoaXMudGV4dHVyZVBvb2wucHVzaCh0ZXh0dXJlKTtcbiAgICBmaWx0ZXJCbG9jay5fZ2xGaWx0ZXJUZXh0dXJlID0gbnVsbDtcbn07XG5cblxuLyoqXG4qIEFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgc3BlY2lmaWVkIGFyZWFcbiogQG1ldGhvZCBhcHBseUZpbHRlclBhc3NcbiogQHBhcmFtIGZpbHRlciB7QWJzdHJhY3RGaWx0ZXJ9IHRoZSBmaWx0ZXIgdGhhdCBuZWVkcyB0byBiZSBhcHBsaWVkXG4qIEBwYXJhbSBmaWx0ZXJBcmVhIHt0ZXh0dXJlfSBUT0RPIC0gbWlnaHQgbmVlZCBhbiB1cGRhdGVcbiogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBob3Jpem9udGFsIHJhbmdlIG9mIHRoZSBmaWx0ZXJcbiogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgdmVydGljYWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5hcHBseUZpbHRlclBhc3MgPSBmdW5jdGlvbihmaWx0ZXIsIGZpbHRlckFyZWEsIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgLy8gdXNlIHByb2dyYW1cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBzaGFkZXIgPSBmaWx0ZXIuc2hhZGVyc1tnbC5pZF07XG5cbiAgICBpZighc2hhZGVyKVxuICAgIHtcbiAgICAgICAgc2hhZGVyID0gbmV3IFBJWEkuUGl4aVNoYWRlcihnbCk7XG5cbiAgICAgICAgc2hhZGVyLmZyYWdtZW50U3JjID0gZmlsdGVyLmZyYWdtZW50U3JjO1xuICAgICAgICBzaGFkZXIudW5pZm9ybXMgPSBmaWx0ZXIudW5pZm9ybXM7XG4gICAgICAgIHNoYWRlci5pbml0KCk7XG5cbiAgICAgICAgZmlsdGVyLnNoYWRlcnNbZ2wuaWRdID0gc2hhZGVyO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgc2hhZGVyXG4gICAgZ2wudXNlUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG5cbiAgICBnbC51bmlmb3JtMmYoc2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIHdpZHRoLzIsIC1oZWlnaHQvMik7XG4gICAgZ2wudW5pZm9ybTJmKHNoYWRlci5vZmZzZXRWZWN0b3IsIDAsMCk7XG5cbiAgICBpZihmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucylcbiAgICB7XG4gICAgICAgIGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzBdID0gdGhpcy53aWR0aDsvL3dpZHRoO1xuICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVsxXSA9IHRoaXMuaGVpZ2h0Oy8vaGVpZ2h0O1xuICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVsyXSA9IHRoaXMudmVydGV4QXJyYXlbMF07XG4gICAgICAgIGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzNdID0gdGhpcy52ZXJ0ZXhBcnJheVs1XTsvL2ZpbHRlckFyZWEuaGVpZ2h0O1xuICAgIH1cblxuICAvLyAgY29uc29sZS5sb2codGhpcy51dkFycmF5IClcbiAgICBzaGFkZXIuc3luY1VuaWZvcm1zKCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnV2QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuY29sb3JCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmNvbG9yQXR0cmlidXRlLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG5cbiAgICAvLyBkcmF3IHRoZSBmaWx0ZXIuLi5cbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCsrO1xufTtcblxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBzaGFkZXIgYnVmZmVyc1xuKiBAbWV0aG9kIGluaXRTaGFkZXJCdWZmZXJzXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmluaXRTaGFkZXJCdWZmZXJzID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyBjcmVhdGUgc29tZSBidWZmZXJzXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLnV2QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5jb2xvckJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXG4gICAgLy8gYmluZCBhbmQgdXBsb2FkIHRoZSB2ZXJ0ZXhzLi5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB2ZXJ0ZXhGbG9hdERhdGEuLlxuICAgIHRoaXMudmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFswLjAsIDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMCwgMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDEuMF0pO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKFxuICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICB0aGlzLnZlcnRleEFycmF5LFxuICAgIGdsLlNUQVRJQ19EUkFXKTtcblxuXG4gICAgLy8gYmluZCBhbmQgdXBsb2FkIHRoZSB1diBidWZmZXJcbiAgICB0aGlzLnV2QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFswLjAsIDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsIDEuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDEuMF0pO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudXZCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgZ2wuQVJSQVlfQlVGRkVSLFxuICAgIHRoaXMudXZBcnJheSxcbiAgICBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICB0aGlzLmNvbG9yQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFsxLjAsIDB4RkZGRkZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCwgMHhGRkZGRkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAweEZGRkZGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDB4RkZGRkZGXSk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5jb2xvckJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShcbiAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgdGhpcy5jb2xvckFycmF5LFxuICAgIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIC8vIGJpbmQgYW5kIHVwbG9hZCB0aGUgaW5kZXhcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKFxuICAgIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxuICAgIG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMSwgMywgMl0pLFxuICAgIGdsLlNUQVRJQ19EUkFXKTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgZmlsdGVyIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGZpbHRlciBzdGFja1xuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5maWx0ZXJTdGFjayA9IG51bGw7XG4gICAgXG4gICAgdGhpcy5vZmZzZXRYID0gMDtcbiAgICB0aGlzLm9mZnNldFkgPSAwO1xuXG4gICAgLy8gZGVzdHJveSB0ZXh0dXJlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXh0dXJlUG9vbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnRleHR1cmVQb29sLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy50ZXh0dXJlUG9vbCA9IG51bGw7XG5cbiAgICAvL2Rlc3Ryb3kgYnVmZmVycy4uXG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy51dkJ1ZmZlcik7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuY29sb3JCdWZmZXIpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyKTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBGaWx0ZXJUZXh0dXJlXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgaG9yaXpvbnRhbCByYW5nZSBvZiB0aGUgZmlsdGVyXG4qIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIHZlcnRpY2FsIHJhbmdlIG9mIHRoZSBmaWx0ZXJcbiogQHByaXZhdGVcbiovXG5QSVhJLkZpbHRlclRleHR1cmUgPSBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodClcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvLyBuZXh0IHRpbWUgdG8gY3JlYXRlIGEgZnJhbWUgYnVmZmVyIGFuZCB0ZXh0dXJlXG4gICAgdGhpcy5mcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyICk7XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIgKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSwgMCk7XG5cbiAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbn07XG5cblxuLyoqXG4qIENsZWFycyB0aGUgZmlsdGVyIHRleHR1cmVcbiogQG1ldGhvZCBjbGVhclxuKi9cblBJWEkuRmlsdGVyVGV4dHVyZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBcbiAgICBnbC5jbGVhckNvbG9yKDAsMCwwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgdGV4dHVyZSB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAqXG4gKiBAbWV0aG9kIHJlc2l6ZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAqL1xuUElYSS5GaWx0ZXJUZXh0dXJlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIGlmKHRoaXMud2lkdGggPT09IHdpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBoZWlnaHQpIHJldHVybjtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCAgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsICB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBmaWx0ZXIgdGV4dHVyZVxuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLkZpbHRlclRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlciggdGhpcy5mcmFtZUJ1ZmZlciApO1xuICAgIGdsLmRlbGV0ZVRleHR1cmUoIHRoaXMudGV4dHVyZSApO1xuXG4gICAgdGhpcy5mcmFtZUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKiBcbiAqIFxuICovXG4vKipcbiAqIEEgc2V0IG9mIGZ1bmN0aW9ucyB1c2VkIHRvIGhhbmRsZSBtYXNraW5nXG4gKlxuICogQGNsYXNzIENhbnZhc01hc2tNYW5hZ2VyXG4gKi9cblBJWEkuQ2FudmFzTWFza01hbmFnZXIgPSBmdW5jdGlvbigpXG57XG4gICAgXG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgc3RhY2sgb2YgbWFza3NcbiAqXG4gKiBAbWV0aG9kIHB1c2hNYXNrXG4gKiBAcGFyYW0gbWFza0RhdGEgdGhlIG1hc2tEYXRhIHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0MkR9IHRoZSAyZCBkcmF3aW5nIG1ldGhvZCBvZiB0aGUgY2FudmFzXG4gKi9cblBJWEkuQ2FudmFzTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hNYXNrID0gZnVuY3Rpb24obWFza0RhdGEsIGNvbnRleHQpXG57XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgXG4gICAgdmFyIGNhY2hlQWxwaGEgPSBtYXNrRGF0YS5hbHBoYTtcbiAgICB2YXIgdHJhbnNmb3JtID0gbWFza0RhdGEud29ybGRUcmFuc2Zvcm07XG5cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xuXG4gICAgUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljc01hc2sobWFza0RhdGEsIGNvbnRleHQpO1xuXG4gICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICBtYXNrRGF0YS53b3JsZEFscGhhID0gY2FjaGVBbHBoYTtcbn07XG5cbi8qKlxuICogUmVzdG9yZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBjb250ZXh0IHRvIHRoZSBzdGF0ZSBpdCB3YXMgYmVmb3JlIHRoZSBtYXNrIHdhcyBhcHBsaWVkXG4gKlxuICogQG1ldGhvZCBwb3BNYXNrXG4gKiBAcGFyYW0gY29udGV4dCB7Q29udGV4dDJEfSB0aGUgMmQgZHJhd2luZyBtZXRob2Qgb2YgdGhlIGNhbnZhc1xuICovXG5QSVhJLkNhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BNYXNrID0gZnVuY3Rpb24oY29udGV4dClcbntcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKiBcbiAqIFxuICovXG5cbi8qKlxuICogQGNsYXNzIENhbnZhc1RpbnRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RhdGljXG4gKi9cblBJWEkuQ2FudmFzVGludGVyID0gZnVuY3Rpb24oKVxue1xuICAgIC8vLyB0aGlzLnRleHR1cmVDYWNoXG59O1xuXG4vL1BJWEkuQ2FudmFzVGludGVyLmNhY2hUaW50ID0gdHJ1ZTtcbiAgICBcblxuLyoqXG4gKiBCYXNpY2FsbHkgdGhpcyBtZXRob2QganVzdCBuZWVkcyBhIHNwcml0ZSBhbmQgYSBjb2xvciBhbmQgdGludHMgdGhlIHNwcml0ZSBcbiAqIHdpdGggdGhlIGdpdmVuIGNvbG9yXG4gKiBcbiAqIEBtZXRob2QgZ2V0VGludGVkVGV4dHVyZSBcbiAqIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHNwcml0ZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige051bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICovXG5QSVhJLkNhbnZhc1RpbnRlci5nZXRUaW50ZWRUZXh0dXJlID0gZnVuY3Rpb24oc3ByaXRlLCBjb2xvcilcbntcblxuICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLnRleHR1cmU7XG5cbiAgICBjb2xvciA9IFBJWEkuQ2FudmFzVGludGVyLnJvdW5kQ29sb3IoY29sb3IpO1xuXG4gICAgdmFyIHN0cmluZ0NvbG9yID0gXCIjXCIgKyAoXCIwMDAwMFwiICsgKCBjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgIFxuICAgIHRleHR1cmUudGludENhY2hlID0gdGV4dHVyZS50aW50Q2FjaGUgfHwge307XG5cbiAgICBpZih0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0pIHJldHVybiB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl07XG5cbiAgICAgLy8gY2xvbmUgdGV4dHVyZS4uXG4gICAgdmFyIGNhbnZhcyA9IFBJWEkuQ2FudmFzVGludGVyLmNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIFxuICAgIC8vUElYSS5DYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbCh0ZXh0dXJlLCBzdHJpbmdDb2xvciwgY2FudmFzKTtcblxuICAgIFxuICAgIFBJWEkuQ2FudmFzVGludGVyLnRpbnRNZXRob2QodGV4dHVyZSwgY29sb3IsIGNhbnZhcyk7XG5cbiAgICBpZihQSVhJLkNhbnZhc1RpbnRlci5jb252ZXJ0VGludFRvSW1hZ2UpXG4gICAge1xuICAgICAgICAvLyBpcyB0aGlzIGJldHRlcj9cbiAgICAgICAgdmFyIHRpbnRJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0aW50SW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuXG4gICAgICAgIHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSA9IHRpbnRJbWFnZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgIFxuICAgICAgICB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0gPSBjYW52YXM7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3QgY29udmVydGluZyB0aGUgdGV4dHVyZSB0byBhbiBpbWFnZSB0aGVuIHdlIG5lZWQgdG8gbG9zZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXNcbiAgICAgICAgUElYSS5DYW52YXNUaW50ZXIuY2FudmFzID0gbnVsbDtcblxuICAgIH1cblxuICAgIHJldHVybiBjYW52YXM7XG59O1xuXG4vKipcbiAqIFRpbnQgYSB0ZXh0dXJlIHVzaW5nIHRoZSBcIm11bHRpcGx5XCIgb3BlcmF0aW9uXG4gKiBAbWV0aG9kIHRpbnRXaXRoTXVsdGlwbHlcbiAqIEBwYXJhbSB0ZXh0dXJlIHt0ZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige051bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICogQHBhcmFtIGNhbnZhcyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjdXJyZW50IGNhbnZhc1xuICovXG5QSVhJLkNhbnZhc1RpbnRlci50aW50V2l0aE11bHRpcGx5ID0gZnVuY3Rpb24odGV4dHVyZSwgY29sb3IsIGNhbnZhcylcbntcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcblxuICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG5cbiAgICBjYW52YXMud2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNcIiArIChcIjAwMDAwXCIgKyAoIGNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgIFxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcIm11bHRpcGx5XCI7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0KTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgXG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG59O1xuXG4vKipcbiAqIFRpbnQgYSB0ZXh0dXJlIHVzaW5nIHRoZSBcIm92ZXJsYXlcIiBvcGVyYXRpb25cbiAqIEBtZXRob2QgdGludFdpdGhPdmVybGF5XG4gKiBAcGFyYW0gdGV4dHVyZSB7dGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdGludFxuICogQHBhcmFtIGNvbG9yIHtOdW1iZXJ9IHRoZSBjb2xvciB0byB1c2UgdG8gdGludCB0aGUgc3ByaXRlIHdpdGhcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY3VycmVudCBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNUaW50ZXIudGludFdpdGhPdmVybGF5ID0gZnVuY3Rpb24odGV4dHVyZSwgY29sb3IsIGNhbnZhcylcbntcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcblxuICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG5cbiAgICBjYW52YXMud2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuXG4gICAgXG4gICAgXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImNvcHlcIjtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI1wiICsgKFwiMDAwMDBcIiArICggY29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG5cbiAgICBcbiAgICAvL2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG5cbn07XG5cbi8qKlxuICogVGludCBhIHRleHR1cmUgcGl4ZWwgcGVyIHBpeGVsXG4gKiBAbWV0aG9kIHRpbnRQZXJQaXhlbFxuICogQHBhcmFtIHRleHR1cmUge3RleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7TnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGN1cnJlbnQgY2FudmFzXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLnRpbnRXaXRoUGVyUGl4ZWwgPSBmdW5jdGlvbih0ZXh0dXJlLCBjb2xvciwgY2FudmFzKVxue1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoIFwiMmRcIiApO1xuXG4gICAgdmFyIGZyYW1lID0gdGV4dHVyZS5mcmFtZTtcblxuICAgIGNhbnZhcy53aWR0aCA9IGZyYW1lLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG4gIFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCk7XG5cbiAgICB2YXIgcmdiVmFsdWVzID0gUElYSS5oZXgycmdiKGNvbG9yKTtcbiAgICB2YXIgciA9IHJnYlZhbHVlc1swXSwgZyA9IHJnYlZhbHVlc1sxXSwgYiA9IHJnYlZhbHVlc1syXTtcblxuICAgIHZhciBwaXhlbERhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcblxuICAgIHZhciBwaXhlbHMgPSBwaXhlbERhdGEuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGl4ZWxzLmxlbmd0aDsgaSArPSA0KVxuICAgIHtcbiAgICAgICAgcGl4ZWxzW2krMF0gKj0gcjtcbiAgICAgICAgcGl4ZWxzW2krMV0gKj0gZztcbiAgICAgICAgcGl4ZWxzW2krMl0gKj0gYjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShwaXhlbERhdGEsIDAsIDApO1xufTtcblxuLyoqXG4gKiBSb3VuZHMgdGhlIHNwZWNpZmllZCBjb2xvciBhY2NvcmRpbmcgdG8gdGhlIFBJWEkuQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWxcbiAqIEBtZXRob2Qgcm91bmRDb2xvclxuICogQHBhcmFtIGNvbG9yIHtudW1iZXJ9IHRoZSBjb2xvciB0byByb3VuZCwgc2hvdWxkIGJlIGEgaGV4IGNvbG9yXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLnJvdW5kQ29sb3IgPSBmdW5jdGlvbihjb2xvcilcbntcbiAgICB2YXIgc3RlcCA9IFBJWEkuQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWw7XG5cbiAgICB2YXIgcmdiVmFsdWVzID0gUElYSS5oZXgycmdiKGNvbG9yKTtcblxuICAgIHJnYlZhbHVlc1swXSA9IE1hdGgubWluKDI1NSwgKHJnYlZhbHVlc1swXSAvIHN0ZXApICogc3RlcCk7XG4gICAgcmdiVmFsdWVzWzFdID0gTWF0aC5taW4oMjU1LCAocmdiVmFsdWVzWzFdIC8gc3RlcCkgKiBzdGVwKTtcbiAgICByZ2JWYWx1ZXNbMl0gPSBNYXRoLm1pbigyNTUsIChyZ2JWYWx1ZXNbMl0gLyBzdGVwKSAqIHN0ZXApO1xuXG4gICAgcmV0dXJuIFBJWEkucmdiMmhleChyZ2JWYWx1ZXMpO1xufTtcblxuLyoqXG4gKiBcbiAqIE51bWJlciBvZiBzdGVwcyB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBjYXAgd2hlbiByb3VuZGluZyBjb2xvcnNcbiAqXG4gKiBAcHJvcGVydHkgY2FjaGVTdGVwc1BlckNvbG9yQ2hhbm5lbFxuICogQHR5cGUgTnVtYmVyXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWwgPSA4O1xuLyoqXG4gKiBcbiAqIE51bWJlciBvZiBzdGVwcyB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBjYXAgd2hlbiByb3VuZGluZyBjb2xvcnNcbiAqXG4gKiBAcHJvcGVydHkgY29udmVydFRpbnRUb0ltYWdlXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLmNvbnZlcnRUaW50VG9JbWFnZSA9IGZhbHNlO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXMgQmxlbmRNb2RlcyBhcmUgc3VwcG9ydGVkLCBjb25zZXF1ZW50bHkgdGhlIGFiaWxpdHkgdG8gdGludCB1c2luZyB0aGUgbXVsdGlwbHkgbWV0aG9kXG4gKlxuICogQHByb3BlcnR5IGNhblVzZU11bHRpcGx5XG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cblBJWEkuQ2FudmFzVGludGVyLmNhblVzZU11bHRpcGx5ID0gUElYSS5jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzKCk7XG5cblBJWEkuQ2FudmFzVGludGVyLnRpbnRNZXRob2QgPSBQSVhJLkNhbnZhc1RpbnRlci5jYW5Vc2VNdWx0aXBseSA/IFBJWEkuQ2FudmFzVGludGVyLnRpbnRXaXRoTXVsdGlwbHkgOiAgUElYSS5DYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbDtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogdGhlIENhbnZhc1JlbmRlcmVyIGRyYXdzIHRoZSBzdGFnZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSAyZCBjYW52YXMuIFRoaXMgcmVuZGVyZXIgc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgd2ViR0wuXG4gKiBEb250IGZvcmdldCB0byBhZGQgdGhlIHZpZXcgdG8geW91ciBET00gb3IgeW91IHdpbGwgbm90IHNlZSBhbnl0aGluZyA6KVxuICpcbiAqIEBjbGFzcyBDYW52YXNSZW5kZXJlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gd2lkdGg9ODAwIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQ9NjAwIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gW3ZpZXddIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICogQHBhcmFtIFt0cmFuc3BhcmVudD1mYWxzZV0ge0Jvb2xlYW59IHRoZSB0cmFuc3BhcmVuY3kgb2YgdGhlIHJlbmRlciB2aWV3LCBkZWZhdWx0IGZhbHNlXG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCB2aWV3LCB0cmFuc3BhcmVudClcbntcbiAgICBQSVhJLmRlZmF1bHRSZW5kZXJlciA9IFBJWEkuZGVmYXVsdFJlbmRlcmVyIHx8IHRoaXM7XG5cbiAgICB0aGlzLnR5cGUgPSBQSVhJLkNBTlZBU19SRU5ERVJFUjtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgc2V0cyBpZiB0aGUgQ2FudmFzUmVuZGVyZXIgd2lsbCBjbGVhciB0aGUgY2FudmFzIG9yIG5vdCBiZWZvcmUgdGhlIG5ldyByZW5kZXIgcGFzcy5cbiAgICAgKiBJZiB0aGUgU3RhZ2UgaXMgTk9UIHRyYW5zcGFyZW50IFBpeGkgd2lsbCB1c2UgYSBjYW52YXMgc2l6ZWQgZmlsbFJlY3Qgb3BlcmF0aW9uIGV2ZXJ5IGZyYW1lIHRvIHNldCB0aGUgY2FudmFzIGJhY2tncm91bmQgY29sb3IuXG4gICAgICogSWYgdGhlIFN0YWdlIGlzIHRyYW5zcGFyZW50IFBpeGkgd2lsbCB1c2UgY2xlYXJSZWN0IHRvIGNsZWFyIHRoZSBjYW52YXMgZXZlcnkgZnJhbWUuXG4gICAgICogRGlzYWJsZSB0aGlzIGJ5IHNldHRpbmcgdGhpcyB0byBmYWxzZS4gRm9yIGV4YW1wbGUgaWYgeW91ciBnYW1lIGhhcyBhIGNhbnZhcyBmaWxsaW5nIGJhY2tncm91bmQgaW1hZ2UgeW91IG9mdGVuIGRvbid0IG5lZWQgdGhpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY2xlYXJCZWZvcmVSZW5kZXJcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUgUGl4aSB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAqIEhhbmR5IGZvciBjcmlzcCBwaXhlbCBhcnQgYW5kIHNwZWVkIG9uIGxlZ2FjeSBkZXZpY2VzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJvdW5kUGl4ZWxzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0cmFuc3BhcmVudFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gISF0cmFuc3BhcmVudDtcblxuICAgIGlmKCFQSVhJLmJsZW5kTW9kZXNDYW52YXMpXG4gICAge1xuICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGlmKFBJWEkuY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlcygpKVxuICAgICAgICB7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLk5PUk1BTF0gICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQUREXSAgICAgID0gXCJsaWdodGVyXCI7IC8vSVMgVEhJUyBPSz8/P1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5NVUxUSVBMWV0gPSBcIm11bHRpcGx5XCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNDUkVFTl0gICA9IFwic2NyZWVuXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLk9WRVJMQVldICA9IFwib3ZlcmxheVwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5EQVJLRU5dICAgPSBcImRhcmtlblwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5MSUdIVEVOXSAgPSBcImxpZ2h0ZW5cIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQ09MT1JfRE9ER0VdID0gXCJjb2xvci1kb2RnZVwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl9CVVJOXSA9IFwiY29sb3ItYnVyblwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5IQVJEX0xJR0hUXSA9IFwiaGFyZC1saWdodFwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5TT0ZUX0xJR0hUXSA9IFwic29mdC1saWdodFwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5ESUZGRVJFTkNFXSA9IFwiZGlmZmVyZW5jZVwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5FWENMVVNJT05dID0gXCJleGNsdXNpb25cIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuSFVFXSAgICAgICA9IFwiaHVlXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNBVFVSQVRJT05dID0gXCJzYXR1cmF0aW9uXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkNPTE9SXSAgICAgID0gXCJjb2xvclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5MVU1JTk9TSVRZXSA9IFwibHVtaW5vc2l0eVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIGNvb2wgbmV3IGJsZW5kIG1vZGVzIGluIGNhbnZhcyBcImNvdWdoXCIgaWUgXCJjb3VnaFwiXG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLk5PUk1BTF0gICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQUREXSAgICAgID0gXCJsaWdodGVyXCI7IC8vSVMgVEhJUyBPSz8/P1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5NVUxUSVBMWV0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNDUkVFTl0gICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuT1ZFUkxBWV0gID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5EQVJLRU5dICAgPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkxJR0hURU5dICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuQ09MT1JfRE9ER0VdID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5DT0xPUl9CVVJOXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuSEFSRF9MSUdIVF0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLlNPRlRfTElHSFRdID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5ESUZGRVJFTkNFXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuRVhDTFVTSU9OXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuSFVFXSAgICAgICA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgICAgIFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tQSVhJLmJsZW5kTW9kZXMuU0FUVVJBVElPTl0gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgICAgICBQSVhJLmJsZW5kTW9kZXNDYW52YXNbUElYSS5ibGVuZE1vZGVzLkNPTE9SXSAgICAgID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzW1BJWEkuYmxlbmRNb2Rlcy5MVU1JTk9TSVRZXSA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDgwMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCA4MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDYwMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDYwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2aWV3XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSB2aWV3IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiY2FudmFzXCIgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgMmQgY29udGV4dCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gd2l0aFxuICAgICAqIEBwcm9wZXJ0eSBjb250ZXh0XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnQgMmQgQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCBcIjJkXCIsIHsgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQgfSApO1xuXG4gICAgdGhpcy5yZWZyZXNoID0gdHJ1ZTtcbiAgICAvLyBoYWNrIHRvIGVuYWJsZSBzb21lIGhhcmR3YXJlIGFjY2VsZXJhdGlvbiFcbiAgICAvL3RoaXMudmlldy5zdHlsZVtcInRyYW5zZm9ybVwiXSA9IFwidHJhbnNsYXRleigwKVwiO1xuXG4gICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5jb3VudCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZSBvZiBhIFBJWEkuQ2FudmFzTWFza01hbmFnZXIsIGhhbmRsZXMgbWFza2luZyB3aGVuIHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXJcbiAgICAgKiBAcHJvcGVydHkgQ2FudmFzTWFza01hbmFnZXJcbiAgICAgKiBAdHlwZSBDYW52YXNNYXNrTWFuYWdlclxuICAgICAqL1xuICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgUElYSS5DYW52YXNNYXNrTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbmRlciBzZXNzaW9uIGlzIGp1c3QgYSBidW5jaCBvZiBwYXJhbWV0ZXIgdXNlZCBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByb3BlcnR5IHJlbmRlclNlc3Npb25cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSB7XG4gICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgbWFza01hbmFnZXI6IHRoaXMubWFza01hbmFnZXIsXG4gICAgICAgIHNjYWxlTW9kZTogbnVsbCxcbiAgICAgICAgc21vb3RoUHJvcGVydHk6IG51bGxcbiAgICB9O1xuXG4gICAgaWYoXCJpbWFnZVNtb290aGluZ0VuYWJsZWRcIiBpbiB0aGlzLmNvbnRleHQpXG4gICAgICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zbW9vdGhQcm9wZXJ0eSA9IFwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkXCI7XG4gICAgZWxzZSBpZihcIndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZFwiIGluIHRoaXMuY29udGV4dClcbiAgICAgICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNtb290aFByb3BlcnR5ID0gXCJ3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWRcIjtcbiAgICBlbHNlIGlmKFwibW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIgaW4gdGhpcy5jb250ZXh0KVxuICAgICAgICB0aGlzLnJlbmRlclNlc3Npb24uc21vb3RoUHJvcGVydHkgPSBcIm1vekltYWdlU21vb3RoaW5nRW5hYmxlZFwiO1xuICAgIGVsc2UgaWYoXCJvSW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIgaW4gdGhpcy5jb250ZXh0KVxuICAgICAgICB0aGlzLnJlbmRlclNlc3Npb24uc21vb3RoUHJvcGVydHkgPSBcIm9JbWFnZVNtb290aGluZ0VuYWJsZWRcIjtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ2FudmFzUmVuZGVyZXI7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgc3RhZ2UgdG8gaXRzIGNhbnZhcyB2aWV3XG4gKlxuICogQG1ldGhvZCByZW5kZXJcbiAqIEBwYXJhbSBzdGFnZSB7U3RhZ2V9IHRoZSBTdGFnZSBlbGVtZW50IHRvIGJlIHJlbmRlcmVkXG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHN0YWdlKVxue1xuICAgIC8vIHVwZGF0ZSB0ZXh0dXJlcyBpZiBuZWVkIGJlXG4gICAgUElYSS50ZXh0dXJlc1RvVXBkYXRlLmxlbmd0aCA9IDA7XG4gICAgUElYSS50ZXh0dXJlc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuXG4gICAgc3RhZ2UudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcbiAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgaWYgKCF0aGlzLnRyYW5zcGFyZW50ICYmIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gc3RhZ2UuYmFja2dyb3VuZENvbG9yU3RyaW5nO1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnRyYW5zcGFyZW50ICYmIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckRpc3BsYXlPYmplY3Qoc3RhZ2UpO1xuXG4gICAgLy8gcnVuIGludGVyYWN0aW9uIVxuICAgIGlmKHN0YWdlLmludGVyYWN0aXZlKVxuICAgIHtcbiAgICAgICAgLy9uZWVkIHRvIGFkZCBzb21lIGV2ZW50cyFcbiAgICAgICAgaWYoIXN0YWdlLl9pbnRlcmFjdGl2ZUV2ZW50c0FkZGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdGFnZS5faW50ZXJhY3RpdmVFdmVudHNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgICBzdGFnZS5pbnRlcmFjdGlvbk1hbmFnZXIuc2V0VGFyZ2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGZyYW1lIHVwZGF0ZXMuLlxuICAgIGlmKFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMubGVuZ3RoID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIGNhbnZhcyB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICpcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcbn07XG5cbi8qKlxuICogUmVuZGVycyBhIGRpc3BsYXkgb2JqZWN0XG4gKlxuICogQG1ldGhvZCByZW5kZXJEaXNwbGF5T2JqZWN0XG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXlPYmplY3QgdG8gcmVuZGVyXG4gKiBAcGFyYW0gY29udGV4dCB7Q29udGV4dDJEfSB0aGUgY29udGV4dCAyZCBtZXRob2Qgb2YgdGhlIGNhbnZhc1xuICogQHByaXZhdGVcbiAqL1xuUElYSS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QsIGNvbnRleHQpXG57XG4gICAgLy8gbm8gbG9uZ2VyIHJlY3Vyc2l2ZSFcbiAgICAvL3ZhciB0cmFuc2Zvcm07XG4gICAgLy92YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmNvbnRleHQ7XG4gICAgZGlzcGxheU9iamVjdC5fcmVuZGVyQ2FudmFzKHRoaXMucmVuZGVyU2Vzc2lvbik7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBmbGF0IHN0cmlwXG4gKlxuICogQG1ldGhvZCByZW5kZXJTdHJpcEZsYXRcbiAqIEBwYXJhbSBzdHJpcCB7U3RyaXB9IFRoZSBTdHJpcCB0byByZW5kZXJcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclN0cmlwRmxhdCA9IGZ1bmN0aW9uKHN0cmlwKVxue1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHZhciB2ZXJ0aWNpZXMgPSBzdHJpcC52ZXJ0aWNpZXM7XG5cbiAgICB2YXIgbGVuZ3RoID0gdmVydGljaWVzLmxlbmd0aC8yO1xuICAgIHRoaXMuY291bnQrKztcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZm9yICh2YXIgaT0xOyBpIDwgbGVuZ3RoLTI7IGkrKylcbiAgICB7XG4gICAgICAgIC8vIGRyYXcgc29tZSB0cmlhbmdsZXMhXG4gICAgICAgIHZhciBpbmRleCA9IGkqMjtcblxuICAgICAgICB2YXIgeDAgPSB2ZXJ0aWNpZXNbaW5kZXhdLCAgIHgxID0gdmVydGljaWVzW2luZGV4KzJdLCB4MiA9IHZlcnRpY2llc1tpbmRleCs0XTtcbiAgICAgICAgdmFyIHkwID0gdmVydGljaWVzW2luZGV4KzFdLCB5MSA9IHZlcnRpY2llc1tpbmRleCszXSwgeTIgPSB2ZXJ0aWNpZXNbaW5kZXgrNV07XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI0ZGMDAwMFwiO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBzdHJpcFxuICpcbiAqIEBtZXRob2QgcmVuZGVyU3RyaXBcbiAqIEBwYXJhbSBzdHJpcCB7U3RyaXB9IFRoZSBTdHJpcCB0byByZW5kZXJcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclN0cmlwID0gZnVuY3Rpb24oc3RyaXApXG57XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAvLyBkcmF3IHRyaWFuZ2xlcyEhXG4gICAgdmFyIHZlcnRpY2llcyA9IHN0cmlwLnZlcnRpY2llcztcbiAgICB2YXIgdXZzID0gc3RyaXAudXZzO1xuXG4gICAgdmFyIGxlbmd0aCA9IHZlcnRpY2llcy5sZW5ndGgvMjtcbiAgICB0aGlzLmNvdW50Kys7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aC0yOyBpKyspXG4gICAge1xuICAgICAgICAvLyBkcmF3IHNvbWUgdHJpYW5nbGVzIVxuICAgICAgICB2YXIgaW5kZXggPSBpKjI7XG5cbiAgICAgICAgdmFyIHgwID0gdmVydGljaWVzW2luZGV4XSwgICB4MSA9IHZlcnRpY2llc1tpbmRleCsyXSwgeDIgPSB2ZXJ0aWNpZXNbaW5kZXgrNF07XG4gICAgICAgIHZhciB5MCA9IHZlcnRpY2llc1tpbmRleCsxXSwgeTEgPSB2ZXJ0aWNpZXNbaW5kZXgrM10sIHkyID0gdmVydGljaWVzW2luZGV4KzVdO1xuXG4gICAgICAgIHZhciB1MCA9IHV2c1tpbmRleF0gKiBzdHJpcC50ZXh0dXJlLndpZHRoLCAgIHUxID0gdXZzW2luZGV4KzJdICogc3RyaXAudGV4dHVyZS53aWR0aCwgdTIgPSB1dnNbaW5kZXgrNF0qIHN0cmlwLnRleHR1cmUud2lkdGg7XG4gICAgICAgIHZhciB2MCA9IHV2c1tpbmRleCsxXSogc3RyaXAudGV4dHVyZS5oZWlnaHQsIHYxID0gdXZzW2luZGV4KzNdICogc3RyaXAudGV4dHVyZS5oZWlnaHQsIHYyID0gdXZzW2luZGV4KzVdKiBzdHJpcC50ZXh0dXJlLmhlaWdodDtcblxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgICAgICAvLyBDb21wdXRlIG1hdHJpeCB0cmFuc2Zvcm1cbiAgICAgICAgdmFyIGRlbHRhID0gdTAqdjEgKyB2MCp1MiArIHUxKnYyIC0gdjEqdTIgLSB2MCp1MSAtIHUwKnYyO1xuICAgICAgICB2YXIgZGVsdGFBID0geDAqdjEgKyB2MCp4MiArIHgxKnYyIC0gdjEqeDIgLSB2MCp4MSAtIHgwKnYyO1xuICAgICAgICB2YXIgZGVsdGFCID0gdTAqeDEgKyB4MCp1MiArIHUxKngyIC0geDEqdTIgLSB4MCp1MSAtIHUwKngyO1xuICAgICAgICB2YXIgZGVsdGFDID0gdTAqdjEqeDIgKyB2MCp4MSp1MiArIHgwKnUxKnYyIC0geDAqdjEqdTIgLSB2MCp1MSp4MiAtIHUwKngxKnYyO1xuICAgICAgICB2YXIgZGVsdGFEID0geTAqdjEgKyB2MCp5MiArIHkxKnYyIC0gdjEqeTIgLSB2MCp5MSAtIHkwKnYyO1xuICAgICAgICB2YXIgZGVsdGFFID0gdTAqeTEgKyB5MCp1MiArIHUxKnkyIC0geTEqdTIgLSB5MCp1MSAtIHUwKnkyO1xuICAgICAgICB2YXIgZGVsdGFGID0gdTAqdjEqeTIgKyB2MCp5MSp1MiArIHkwKnUxKnYyIC0geTAqdjEqdTIgLSB2MCp1MSp5MiAtIHUwKnkxKnYyO1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKGRlbHRhQSAvIGRlbHRhLCBkZWx0YUQgLyBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YUIgLyBkZWx0YSwgZGVsdGFFIC8gZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFDIC8gZGVsdGEsIGRlbHRhRiAvIGRlbHRhKTtcblxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShzdHJpcC50ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSwgMCwgMCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENhbnZhcyBlbGVtZW50IG9mIHRoZSBnaXZlbiBzaXplXG4gKlxuICogQG1ldGhvZCBDYW52YXNCdWZmZXJcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgd2lkdGggZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNhbnZhc1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgaGVpZ2h0IGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjYW52YXNcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuQ2FudmFzQnVmZmVyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiY2FudmFzXCIgKTtcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcblxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGNhbnZhcyB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBDYW52YXNCdWZmZXIgY2xhc3NcbiAqXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkNhbnZhc0J1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgY2FudmFzIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIENhbnZhc0J1ZmZlciBjbGFzcyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAqXG4gKiBAbWV0aG9kIHJlc2l6ZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIGNhbnZhc1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgY2FudmFzXG4gKiBAcHJpdmF0ZVxuICovXG5cblBJWEkuQ2FudmFzQnVmZmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblxuLyoqXG4gKiBBIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBieSB0aGUgY2FudmFzIHJlbmRlcmVyIHRvIGRyYXcgdGhlIHByaW1pdGl2ZSBncmFwaGljcyBkYXRhXG4gKlxuICogQGNsYXNzIENhbnZhc0dyYXBoaWNzXG4gKi9cblBJWEkuQ2FudmFzR3JhcGhpY3MgPSBmdW5jdGlvbigpXG57XG5cbn07XG5cblxuLypcbiAqIFJlbmRlcnMgdGhlIGdyYXBoaWNzIG9iamVjdFxuICpcbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHJlbmRlckdyYXBoaWNzXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge0dyYXBoaWNzfSB0aGUgYWN0dWFsIGdyYXBoaWNzIG9iamVjdCB0byByZW5kZXJcbiAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0MkR9IHRoZSAyZCBkcmF3aW5nIG1ldGhvZCBvZiB0aGUgY2FudmFzXG4gKi9cblBJWEkuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3MgPSBmdW5jdGlvbihncmFwaGljcywgY29udGV4dClcbntcbiAgICB2YXIgd29ybGRBbHBoYSA9IGdyYXBoaWNzLndvcmxkQWxwaGE7XG4gICAgdmFyIGNvbG9yID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICB2YXIgcG9pbnRzID0gZGF0YS5wb2ludHM7XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoIGRhdGEubGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZGF0YS5saW5lV2lkdGg7XG5cbiAgICAgICAgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlBPTFkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaj0xOyBqIDwgcG9pbnRzLmxlbmd0aC8yOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ogKiAyXSwgcG9pbnRzW2ogKiAyICsgMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcbiAgICAgICAgICAgIGlmKHBvaW50c1swXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl0gJiYgcG9pbnRzWzFdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkYXRhLmZpbGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoIGRhdGEuZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5saW5lV2lkdGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLlJFQ1QpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgaWYoZGF0YS5maWxsQ29sb3IgfHwgZGF0YS5maWxsQ29sb3IgPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoIGRhdGEuZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5saW5lV2lkdGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLkNJUkMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLDAsMipNYXRoLlBJKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgIGlmKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggZGF0YS5maWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuRUxJUClcbiAgICAgICAge1xuXG4gICAgICAgICAgICAvLyBlbGxpcHNlIGNvZGUgdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG5cbiAgICAgICAgICAgIHZhciBlbGxpcHNlRGF0YSA9ICBkYXRhLnBvaW50cztcblxuICAgICAgICAgICAgdmFyIHcgPSBlbGxpcHNlRGF0YVsyXSAqIDI7XG4gICAgICAgICAgICB2YXIgaCA9IGVsbGlwc2VEYXRhWzNdICogMjtcblxuICAgICAgICAgICAgdmFyIHggPSBlbGxpcHNlRGF0YVswXSAtIHcvMjtcbiAgICAgICAgICAgIHZhciB5ID0gZWxsaXBzZURhdGFbMV0gLSBoLzI7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICAgICAgICAgICAgICBveCA9ICh3IC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgIG95ID0gKGggLyAyKSAqIGthcHBhLCAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgIHhlID0geCArIHcsICAgICAgICAgICAvLyB4LWVuZFxuICAgICAgICAgICAgICAgIHllID0geSArIGgsICAgICAgICAgICAvLyB5LWVuZFxuICAgICAgICAgICAgICAgIHhtID0geCArIHcgLyAyLCAgICAgICAvLyB4LW1pZGRsZVxuICAgICAgICAgICAgICAgIHltID0geSArIGggLyAyOyAgICAgICAvLyB5LW1pZGRsZVxuXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5bSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICBpZihkYXRhLmZpbGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yID0gJyMnICsgKCcwMDAwMCcgKyAoIGRhdGEuZmlsbENvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5saW5lV2lkdGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiAqIFJlbmRlcnMgYSBncmFwaGljcyBtYXNrXG4gKlxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqIEBtZXRob2QgcmVuZGVyR3JhcGhpY3NNYXNrXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge0dyYXBoaWNzfSB0aGUgZ3JhcGhpY3Mgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgbWFza1xuICogQHBhcmFtIGNvbnRleHQge0NvbnRleHQyRH0gdGhlIGNvbnRleHQgMmQgbWV0aG9kIG9mIHRoZSBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljc01hc2sgPSBmdW5jdGlvbihncmFwaGljcywgY29udGV4dClcbntcbiAgICB2YXIgbGVuID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDtcblxuICAgIGlmKGxlbiA9PT0gMCkgcmV0dXJuO1xuXG4gICAgaWYobGVuID4gMSlcbiAgICB7XG4gICAgICAgIGxlbiA9IDE7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnUGl4aS5qcyB3YXJuaW5nOiBtYXNrcyBpbiBjYW52YXMgY2FuIG9ubHkgbWFzayB1c2luZyB0aGUgZmlyc3QgcGF0aCBpbiB0aGUgZ3JhcGhpY3Mgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgZGF0YSA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YVtpXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IGRhdGEucG9pbnRzO1xuXG4gICAgICAgIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5QT0xZKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTE7IGogPCBwb2ludHMubGVuZ3RoLzI7IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaiAqIDJdLCBwb2ludHNbaiAqIDIgKyAxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludCBhcmUgdGhlIHNhbWUgY2xvc2UgdGhlIHBhdGggLSBtdWNoIG5lYXRlciA6KVxuICAgICAgICAgICAgaWYocG9pbnRzWzBdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXSAmJiBwb2ludHNbMV0gPT09IHBvaW50c1twb2ludHMubGVuZ3RoLTFdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGRhdGEudHlwZSA9PT0gUElYSS5HcmFwaGljcy5SRUNUKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZGF0YS50eXBlID09PSBQSVhJLkdyYXBoaWNzLkNJUkMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLDAsMipNYXRoLlBJKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkYXRhLnR5cGUgPT09IFBJWEkuR3JhcGhpY3MuRUxJUClcbiAgICAgICAge1xuXG4gICAgICAgICAgICAvLyBlbGxpcHNlIGNvZGUgdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG4gICAgICAgICAgICB2YXIgZWxsaXBzZURhdGEgPSAgZGF0YS5wb2ludHM7XG5cbiAgICAgICAgICAgIHZhciB3ID0gZWxsaXBzZURhdGFbMl0gKiAyO1xuICAgICAgICAgICAgdmFyIGggPSBlbGxpcHNlRGF0YVszXSAqIDI7XG5cbiAgICAgICAgICAgIHZhciB4ID0gZWxsaXBzZURhdGFbMF0gLSB3LzI7XG4gICAgICAgICAgICB2YXIgeSA9IGVsbGlwc2VEYXRhWzFdIC0gaC8yO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICAgICAgICAgICAgb3ggPSAodyAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgICAgICAgICAgICBveSA9IChoIC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICAgICAgICAgICAgICB4ZSA9IHggKyB3LCAgICAgICAgICAgLy8geC1lbmRcbiAgICAgICAgICAgICAgICB5ZSA9IHkgKyBoLCAgICAgICAgICAgLy8geS1lbmRcbiAgICAgICAgICAgICAgICB4bSA9IHggKyB3IC8gMiwgICAgICAgLy8geC1taWRkbGVcbiAgICAgICAgICAgICAgICB5bSA9IHkgKyBoIC8gMjsgICAgICAgLy8geS1taWRkbGVcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblxuLyoqXG4gKiBUaGUgR3JhcGhpY3MgY2xhc3MgY29udGFpbnMgYSBzZXQgb2YgbWV0aG9kcyB0aGF0IHlvdSBjYW4gdXNlIHRvIGNyZWF0ZSBwcmltaXRpdmUgc2hhcGVzIGFuZCBsaW5lcy5cbiAqIEl0IGlzIGltcG9ydGFudCB0byBrbm93IHRoYXQgd2l0aCB0aGUgd2ViR0wgcmVuZGVyZXIgb25seSBzaW1wbGUgcG9seWdvbnMgY2FuIGJlIGZpbGxlZCBhdCB0aGlzIHN0YWdlXG4gKiBDb21wbGV4IHBvbHlnb25zIHdpbGwgbm90IGJlIGZpbGxlZC4gSGVyZXMgYW4gZXhhbXBsZSBvZiBhIGNvbXBsZXggcG9seWdvbjogaHR0cDovL3d3dy5nb29kYm95ZGlnaXRhbC5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTMvMDYvY29tcGxleFBvbHlnb24ucG5nXG4gKlxuICogQGNsYXNzIEdyYXBoaWNzXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUElYSS5HcmFwaGljcyA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbHBoYSBvZiB0aGUgZmlsbCBvZiB0aGlzIGdyYXBoaWNzIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZpbGxBbHBoYVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBhbnkgbGluZXMgZHJhd25cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsaW5lV2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sb3Igb2YgYW55IGxpbmVzIGRyYXduXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGluZUNvbG9yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy5saW5lQ29sb3IgPSBcImJsYWNrXCI7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaGljcyBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3JhcGhpY3NEYXRhXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFRoaXMgaXMgYSBoZXggdmFsdWVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW50XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjsvLyAqIE1hdGgucmFuZG9tKCk7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJsZW5kTW9kZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IFBJWEkuYmxlbmRNb2Rlcy5OT1JNQUw7XG4gICAgICovXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBQSVhJLmJsZW5kTW9kZXMuTk9STUFMO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcGF0aFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRQYXRoXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0ge3BvaW50czpbXX07XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBjb250YWluaW5nIHNvbWUgV2ViR0wtcmVsYXRlZCBwcm9wZXJ0aWVzIHVzZWQgYnkgdGhlIFdlYkdMIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX3dlYkdMXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3dlYkdMID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2hhcGUgaXMgYmVpbmcgdXNlZCBhcyBhIG1hc2tcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc01hc2tcbiAgICAgKiBAdHlwZSBpc01hc2tcbiAgICAgKi9cbiAgICB0aGlzLmlzTWFzayA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZSBhcyByZWN0YW5nbGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5ib3VuZHMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogdGhlIGJvdW5kcycgcGFkZGluZyB1c2VkIGZvciBib3VuZHMgY2FsY3VsYXRpb25cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib3VuZHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kc1BhZGRpbmcgPSAxMDtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUgKTtcblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5HcmFwaGljcztcblxuLyoqXG4gKiBJZiBjYWNoZUFzQml0bWFwIGlzIHRydWUgdGhlIGdyYXBoaWNzIG9iamVjdCB3aWxsIHRoZW4gYmUgcmVuZGVyZWQgYXMgaWYgaXQgd2FzIGEgc3ByaXRlLlxuICogVGhpcyBpcyB1c2VmdWwgaWYgeW91ciBncmFwaGljcyBlbGVtZW50IGRvZXMgbm90IGNoYW5nZSBvZnRlbiBhcyBpdCB3aWxsIHNwZWVkIHVwIHRoZSByZW5kZXJpbmcgb2YgdGhlIG9iamVjdFxuICogSXQgaXMgYWxzbyB1c2Z1bCBhcyB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHdpbGwgYWx3YXlzIGJlIGFudGlhbGlhc2VkIGJlY2F1c2UgaXQgd2lsbCBiZSByZW5kZXJlZCB1c2luZyBjYW52YXNcbiAqIE5vdCByZWNvbW1lbmRlZCBpZiB5b3UgYXJlIGNvbnN0YW5seSByZWRyYXdpbmcgdGhlIGdyYXBoaWNzIGVsZW1lbnQuXG4gKlxuICogQHByb3BlcnR5IGNhY2hlQXNCaXRtYXBcbiAqIEBkZWZhdWx0IGZhbHNlXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAcHJpdmF0ZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5HcmFwaGljcy5wcm90b3R5cGUsIFwiY2FjaGVBc0JpdG1hcFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICB0aGlzLl9jYWNoZUFzQml0bWFwO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gdmFsdWU7XG5cbiAgICAgICAgaWYodGhpcy5fY2FjaGVBc0JpdG1hcClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUNhY2hlZFNwcml0ZSgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbn0pO1xuXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBsaW5lIHN0eWxlIHVzZWQgZm9yIHN1YnNlcXVlbnQgY2FsbHMgdG8gR3JhcGhpY3MgbWV0aG9kcyBzdWNoIGFzIHRoZSBsaW5lVG8oKSBtZXRob2Qgb3IgdGhlIGRyYXdDaXJjbGUoKSBtZXRob2QuXG4gKlxuICogQG1ldGhvZCBsaW5lU3R5bGVcbiAqIEBwYXJhbSBsaW5lV2lkdGgge051bWJlcn0gd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdCdzIHN0b3JlZCBzdHlsZVxuICogQHBhcmFtIGNvbG9yIHtOdW1iZXJ9IGNvbG9yIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3QncyBzdG9yZWQgc3R5bGVcbiAqIEBwYXJhbSBhbHBoYSB7TnVtYmVyfSBhbHBoYSBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0J3Mgc3RvcmVkIHN0eWxlXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmxpbmVTdHlsZSA9IGZ1bmN0aW9uKGxpbmVXaWR0aCwgY29sb3IsIGFscGhhKVxue1xuICAgIGlmICghdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoKSB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcblxuICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDA7XG4gICAgdGhpcy5saW5lQ29sb3IgPSBjb2xvciB8fCAwO1xuICAgIHRoaXMubGluZUFscGhhID0gKGFyZ3VtZW50cy5sZW5ndGggPCAzKSA/IDEgOiBhbHBoYTtcblxuICAgIHRoaXMuY3VycmVudFBhdGggPSB7bGluZVdpZHRoOnRoaXMubGluZVdpZHRoLCBsaW5lQ29sb3I6dGhpcy5saW5lQ29sb3IsIGxpbmVBbHBoYTp0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvciwgZmlsbEFscGhhOnRoaXMuZmlsbEFscGhhLCBmaWxsOnRoaXMuZmlsbGluZywgcG9pbnRzOltdLCB0eXBlOlBJWEkuR3JhcGhpY3MuUE9MWX07XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuY3VycmVudFBhdGgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1vdmVzIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8gKHgsIHkpLlxuICpcbiAqIEBtZXRob2QgbW92ZVRvXG4gKiBAcGFyYW0geCB7TnVtYmVyfSB0aGUgWCBjb29yZGluYXRlIHRvIG1vdmUgdG9cbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IHRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KVxue1xuICAgIGlmICghdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoKSB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcblxuICAgIHRoaXMuY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoID0ge2xpbmVXaWR0aDp0aGlzLmxpbmVXaWR0aCwgbGluZUNvbG9yOnRoaXMubGluZUNvbG9yLCBsaW5lQWxwaGE6dGhpcy5saW5lQWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3IsIGZpbGxBbHBoYTp0aGlzLmZpbGxBbHBoYSwgZmlsbDp0aGlzLmZpbGxpbmcsIHBvaW50czpbXSwgdHlwZTpQSVhJLkdyYXBoaWNzLlBPTFl9O1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMucHVzaCh4LCB5KTtcblxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRHJhd3MgYSBsaW5lIHVzaW5nIHRoZSBjdXJyZW50IGxpbmUgc3R5bGUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvICh4LCB5KTtcbiAqIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gaXMgdGhlbiBzZXQgdG8gKHgsIHkpLlxuICpcbiAqIEBtZXRob2QgbGluZVRvXG4gKiBAcGFyYW0geCB7TnVtYmVyfSB0aGUgWCBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IHRoZSBZIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbih4LCB5KVxue1xuICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLnB1c2goeCwgeSk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgc2ltcGxlIG9uZS1jb2xvciBmaWxsIHRoYXQgc3Vic2VxdWVudCBjYWxscyB0byBvdGhlciBHcmFwaGljcyBtZXRob2RzXG4gKiAoc3VjaCBhcyBsaW5lVG8oKSBvciBkcmF3Q2lyY2xlKCkpIHVzZSB3aGVuIGRyYXdpbmcuXG4gKlxuICogQG1ldGhvZCBiZWdpbkZpbGxcbiAqIEBwYXJhbSBjb2xvciB7TnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcbiAqIEBwYXJhbSBhbHBoYSB7TnVtYmVyfSB0aGUgYWxwaGEgb2YgdGhlIGZpbGxcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuYmVnaW5GaWxsID0gZnVuY3Rpb24oY29sb3IsIGFscGhhKVxue1xuXG4gICAgdGhpcy5maWxsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGxDb2xvciA9IGNvbG9yIHx8IDA7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAoYXJndW1lbnRzLmxlbmd0aCA8IDIpID8gMSA6IGFscGhhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBmaWxsIHRvIHRoZSBsaW5lcyBhbmQgc2hhcGVzIHRoYXQgd2VyZSBhZGRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBiZWdpbkZpbGwoKSBtZXRob2QuXG4gKlxuICogQG1ldGhvZCBlbmRGaWxsXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmVuZEZpbGwgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5maWxsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5maWxsQ29sb3IgPSBudWxsO1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRyYXdSZWN0XG4gKlxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIFggY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdSZWN0ID0gZnVuY3Rpb24oIHgsIHksIHdpZHRoLCBoZWlnaHQgKVxue1xuICAgIGlmICghdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoKSB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcblxuICAgIHRoaXMuY3VycmVudFBhdGggPSB7bGluZVdpZHRoOnRoaXMubGluZVdpZHRoLCBsaW5lQ29sb3I6dGhpcy5saW5lQ29sb3IsIGxpbmVBbHBoYTp0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvciwgZmlsbEFscGhhOnRoaXMuZmlsbEFscGhhLCBmaWxsOnRoaXMuZmlsbGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czpbeCwgeSwgd2lkdGgsIGhlaWdodF0sIHR5cGU6UElYSS5HcmFwaGljcy5SRUNUfTtcblxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRHJhd3MgYSBjaXJjbGUuXG4gKlxuICogQG1ldGhvZCBkcmF3Q2lyY2xlXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSByYWRpdXMge051bWJlcn0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdDaXJjbGUgPSBmdW5jdGlvbiggeCwgeSwgcmFkaXVzKVxue1xuXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGgpIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHtsaW5lV2lkdGg6dGhpcy5saW5lV2lkdGgsIGxpbmVDb2xvcjp0aGlzLmxpbmVDb2xvciwgbGluZUFscGhhOnRoaXMubGluZUFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOnRoaXMuZmlsbENvbG9yLCBmaWxsQWxwaGE6dGhpcy5maWxsQWxwaGEsIGZpbGw6dGhpcy5maWxsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOlt4LCB5LCByYWRpdXMsIHJhZGl1c10sIHR5cGU6UElYSS5HcmFwaGljcy5DSVJDfTtcblxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRHJhd3MgYW4gZWxsaXBzZS5cbiAqXG4gKiBAbWV0aG9kIGRyYXdFbGxpcHNlXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhpcyBlbGxpcHNlXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhpcyBlbGxpcHNlXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIGVsbGlwc2VcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZHJhd0VsbGlwc2UgPSBmdW5jdGlvbiggeCwgeSwgd2lkdGgsIGhlaWdodClcbntcblxuICAgIGlmICghdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoKSB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcblxuICAgIHRoaXMuY3VycmVudFBhdGggPSB7bGluZVdpZHRoOnRoaXMubGluZVdpZHRoLCBsaW5lQ29sb3I6dGhpcy5saW5lQ29sb3IsIGxpbmVBbHBoYTp0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvciwgZmlsbEFscGhhOnRoaXMuZmlsbEFscGhhLCBmaWxsOnRoaXMuZmlsbGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czpbeCwgeSwgd2lkdGgsIGhlaWdodF0sIHR5cGU6UElYSS5HcmFwaGljcy5FTElQfTtcblxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBncmFwaGljcyB0aGF0IHdlcmUgZHJhd24gdG8gdGhpcyBHcmFwaGljcyBvYmplY3QsIGFuZCByZXNldHMgZmlsbCBhbmQgbGluZSBzdHlsZSBzZXR0aW5ncy5cbiAqXG4gKiBAbWV0aG9kIGNsZWFyXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMubGluZVdpZHRoID0gMDtcbiAgICB0aGlzLmZpbGxpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuY2xlYXJEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5ncmFwaGljc0RhdGEgPSBbXTtcblxuICAgIHRoaXMuYm91bmRzID0gbnVsbDsgLy9uZXcgUElYSS5SZWN0YW5nbGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVc2VmdWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBvZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHRoYXQgY2FuIHRoZW4gYmUgdXNlZCB0byBjcmVhdGUgc3ByaXRlc1xuICogVGhpcyBjYW4gYmUgcXVpdGUgdXNlZnVsIGlmIHlvdXIgZ2VvbWV0cnkgaXMgY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBAbWV0aG9kIGdlbmVyYXRlVGV4dHVyZVxuICogQHJldHVybiB7VGV4dHVyZX0gYSB0ZXh0dXJlIG9mIHRoZSBncmFwaGljcyBvYmplY3RcbiAqL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuZ2VuZXJhdGVUZXh0dXJlID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXG4gICAgdmFyIGNhbnZhc0J1ZmZlciA9IG5ldyBQSVhJLkNhbnZhc0J1ZmZlcihib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21DYW52YXMoY2FudmFzQnVmZmVyLmNhbnZhcyk7XG5cbiAgICBjYW52YXNCdWZmZXIuY29udGV4dC50cmFuc2xhdGUoLWJvdW5kcy54LC1ib3VuZHMueSk7XG4gICAgXG4gICAgUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljcyh0aGlzLCBjYW52YXNCdWZmZXIuY29udGV4dCk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlcldlYkdMXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uKVxue1xuICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZih0aGlzLnZpc2libGUgPT09IGZhbHNlIHx8IHRoaXMuYWxwaGEgPT09IDAgfHwgdGhpcy5pc01hc2sgPT09IHRydWUpcmV0dXJuO1xuICAgIFxuICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXApXG4gICAge1xuICAgICAgIFxuICAgICAgICBpZih0aGlzLmRpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSgpO1xuICAgICAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSB0ZXh0dXJlIG9uIHRoZSBncHUgdG9vIVxuICAgICAgICAgICAgUElYSS51cGRhdGVXZWJHTFRleHR1cmUodGhpcy5fY2FjaGVkU3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUsIHJlbmRlclNlc3Npb24uZ2wpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFscGhhID0gdGhpcy5hbHBoYTtcbiAgICAgICAgUElYSS5TcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTC5jYWxsKHRoaXMuX2NhY2hlZFNwcml0ZSwgcmVuZGVyU2Vzc2lvbik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcblxuICAgICAgICBpZih0aGlzLl9tYXNrKXJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgaWYodGhpcy5fZmlsdGVycylyZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0aGlzLl9maWx0ZXJCbG9jayk7XG4gICAgICBcbiAgICAgICAgLy8gY2hlY2sgYmxlbmQgbW9kZVxuICAgICAgICBpZih0aGlzLmJsZW5kTW9kZSAhPT0gcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5jdXJyZW50QmxlbmRNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLmN1cnJlbnRCbGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICAgICAgICAgIHZhciBibGVuZE1vZGVXZWJHTCA9IFBJWEkuYmxlbmRNb2Rlc1dlYkdMW3JlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guY3VycmVudEJsZW5kTW9kZV07XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLmdsLmJsZW5kRnVuYyhibGVuZE1vZGVXZWJHTFswXSwgYmxlbmRNb2RlV2ViR0xbMV0pO1xuICAgICAgICB9XG4gICAgIFxuICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MucmVuZGVyR3JhcGhpY3ModGhpcywgcmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBvbmx5IHJlbmRlciBpZiBpdCBoYXMgY2hpbGRyZW4hXG4gICAgICAgIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG5cbiAgICAgICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgICAgICAgICAgZm9yKHZhciBpPTAsIGo9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8ajsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlcldlYkdMKHJlbmRlclNlc3Npb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuX2ZpbHRlcnMpcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xuICAgICAgICBpZih0aGlzLl9tYXNrKXJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgICBcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5kcmF3Q291bnQrKztcblxuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgfVxufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlckNhbnZhc1xuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5HcmFwaGljcy5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgLy8gaWYgdGhlIHNwcml0ZSBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgIGlmKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgfHwgdGhpcy5hbHBoYSA9PT0gMCB8fCB0aGlzLmlzTWFzayA9PT0gdHJ1ZSlyZXR1cm47XG4gICAgXG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJTZXNzaW9uLmNvbnRleHQ7XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgXG4gICAgaWYodGhpcy5ibGVuZE1vZGUgIT09IHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFBJWEkuYmxlbmRNb2Rlc0NhbnZhc1tyZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hLCB0cmFuc2Zvcm0uYywgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5kLCB0cmFuc2Zvcm0udHgsIHRyYW5zZm9ybS50eSk7XG4gICAgUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljcyh0aGlzLCBjb250ZXh0KTtcblxuICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgIGZvcih2YXIgaT0wLCBqPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0uX3JlbmRlckNhbnZhcyhyZW5kZXJTZXNzaW9uKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBncmFwaGljIHNoYXBlIGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICpcbiAqIEBtZXRob2QgZ2V0Qm91bmRzXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCBtYXRyaXggKVxue1xuICAgIGlmKCF0aGlzLmJvdW5kcyl0aGlzLnVwZGF0ZUJvdW5kcygpO1xuXG4gICAgdmFyIHcwID0gdGhpcy5ib3VuZHMueDtcbiAgICB2YXIgdzEgPSB0aGlzLmJvdW5kcy53aWR0aCArIHRoaXMuYm91bmRzLng7XG5cbiAgICB2YXIgaDAgPSB0aGlzLmJvdW5kcy55O1xuICAgIHZhciBoMSA9IHRoaXMuYm91bmRzLmhlaWdodCArIHRoaXMuYm91bmRzLnk7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTtcbiAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmM7XG4gICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5iO1xuICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDtcbiAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDtcbiAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcblxuICAgIHZhciB4MSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgIHZhciB5MSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuXG4gICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgdmFyIHkyID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICB2YXIgeDMgPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2YXIgeTMgPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgIHZhciB4NCA9ICBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2YXIgeTQgPSAgZCAqIGgwICsgYiAqIHcxICsgdHk7XG5cbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcblxuICAgIG1pblggPSB4MSA8IG1pblggPyB4MSA6IG1pblg7XG4gICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xuICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XG5cbiAgICBtaW5ZID0geTEgPCBtaW5ZID8geTEgOiBtaW5ZO1xuICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XG4gICAgbWluWSA9IHkzIDwgbWluWSA/IHkzIDogbWluWTtcbiAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xuXG4gICAgbWF4WCA9IHgxID4gbWF4WCA/IHgxIDogbWF4WDtcbiAgICBtYXhYID0geDIgPiBtYXhYID8geDIgOiBtYXhYO1xuICAgIG1heFggPSB4MyA+IG1heFggPyB4MyA6IG1heFg7XG4gICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgIG1heFkgPSB5MSA+IG1heFkgPyB5MSA6IG1heFk7XG4gICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xuICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgYm91bmRzLnggPSBtaW5YO1xuICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIHJldHVybiBib3VuZHM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kc1xuICovXG5QSVhJLkdyYXBoaWNzLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbigpXG57XG4gICAgXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgcG9pbnRzLCB4LCB5LCB3LCBoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGRhdGEubGluZVdpZHRoO1xuXG4gICAgICAgIHBvaW50cyA9IGRhdGEucG9pbnRzO1xuXG4gICAgICAgIGlmKHR5cGUgPT09IFBJWEkuR3JhcGhpY3MuUkVDVClcbiAgICAgICAge1xuICAgICAgICAgICAgeCA9IHBvaW50c1swXSAtIGxpbmVXaWR0aC8yO1xuICAgICAgICAgICAgeSA9IHBvaW50c1sxXSAtIGxpbmVXaWR0aC8yO1xuICAgICAgICAgICAgdyA9IHBvaW50c1syXSArIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIGggPSBwb2ludHNbM10gKyBsaW5lV2lkdGg7XG5cbiAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geCA6IG1pblk7XG4gICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodHlwZSA9PT0gUElYSS5HcmFwaGljcy5DSVJDIHx8IHR5cGUgPT09IFBJWEkuR3JhcGhpY3MuRUxJUClcbiAgICAgICAge1xuICAgICAgICAgICAgeCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICB3ID0gcG9pbnRzWzJdICsgbGluZVdpZHRoLzI7XG4gICAgICAgICAgICBoID0gcG9pbnRzWzNdICsgbGluZVdpZHRoLzI7XG5cbiAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XG4gICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xuXG4gICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xuICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBPTFlcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgais9MilcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal07XG4gICAgICAgICAgICAgICAgeSA9IHBvaW50c1tqKzFdO1xuICAgICAgICAgICAgICAgIG1pblggPSB4LWxpbmVXaWR0aCA8IG1pblggPyB4LWxpbmVXaWR0aCA6IG1pblg7XG4gICAgICAgICAgICAgICAgbWF4WCA9IHgrbGluZVdpZHRoID4gbWF4WCA/IHgrbGluZVdpZHRoIDogbWF4WDtcblxuICAgICAgICAgICAgICAgIG1pblkgPSB5LWxpbmVXaWR0aCA8IG1pblkgPyB5LWxpbmVXaWR0aCA6IG1pblk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IHkrbGluZVdpZHRoID4gbWF4WSA/IHkrbGluZVdpZHRoIDogbWF4WTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYWRkaW5nID0gdGhpcy5ib3VuZHNQYWRkaW5nO1xuICAgIHRoaXMuYm91bmRzID0gbmV3IFBJWEkuUmVjdGFuZ2xlKG1pblggLSBwYWRkaW5nLCBtaW5ZIC0gcGFkZGluZywgKG1heFggLSBtaW5YKSArIHBhZGRpbmcgKiAyLCAobWF4WSAtIG1pblkpICsgcGFkZGluZyAqIDIpO1xufTtcblxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgY2FjaGVkIHNwcml0ZSB3aGVuIHRoZSBzcHJpdGUgaGFzIGNhY2hlQXNCaXRtYXAgPSB0cnVlXG4gKlxuICogQG1ldGhvZCBfZ2VuZXJhdGVDYWNoZWRTcHJpdGVcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgaWYoIXRoaXMuX2NhY2hlZFNwcml0ZSlcbiAgICB7XG4gICAgICAgIHZhciBjYW52YXNCdWZmZXIgPSBuZXcgUElYSS5DYW52YXNCdWZmZXIoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXNCdWZmZXIuY2FudmFzKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlciA9IGNhbnZhc0J1ZmZlcjtcblxuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLnJlc2l6ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIGxldmVyYWdlIHRoZSBhbmNob3IgdG8gYWNjb3VudCBmb3IgdGhlIG9mZnNldCBvZiB0aGUgZWxlbWVudFxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oIGJvdW5kcy54IC8gYm91bmRzLndpZHRoICk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLSggYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0ICk7XG5cbiAgIC8vIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIuY29udGV4dC5zYXZlKCk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5jb250ZXh0LnRyYW5zbGF0ZSgtYm91bmRzLngsLWJvdW5kcy55KTtcbiAgICBcbiAgICBQSVhJLkNhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzKHRoaXMsIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIuY29udGV4dCk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFscGhhID0gdGhpcy5hbHBoYTtcblxuICAgLy8gdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5jb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cblBJWEkuR3JhcGhpY3MucHJvdG90eXBlLmRlc3Ryb3lDYWNoZWRTcHJpdGUgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLnRleHR1cmUuZGVzdHJveSh0cnVlKTtcblxuICAgIC8vIGxldCB0aGUgZ2MgY29sbGVjdCB0aGUgdW51c2VkIHNwcml0ZVxuICAgIC8vIFRPRE8gY291bGQgYmUgb2JqZWN0IHBvb2xlZCFcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUgPSBudWxsO1xufTtcblxuXG4vLyBTT01FIFRZUEVTOlxuUElYSS5HcmFwaGljcy5QT0xZID0gMDtcblBJWEkuR3JhcGhpY3MuUkVDVCA9IDE7XG5QSVhJLkdyYXBoaWNzLkNJUkMgPSAyO1xuUElYSS5HcmFwaGljcy5FTElQID0gMztcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vXG4gKi9cblxuIC8qKlxuICogXG4gKiBAY2xhc3MgU3RyaXBcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHRvIHVzZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSB3aWR0aCBcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIGhlaWdodFxuICogXG4gKi9cblBJWEkuU3RyaXAgPSBmdW5jdGlvbih0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5jYWxsKCB0aGlzICk7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IFBJWEkuYmxlbmRNb2Rlcy5OT1JNQUw7XG5cbiAgICB0cnlcbiAgICB7XG4gICAgICAgIHRoaXMudXZzID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMSxcbiAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgIDEsIDAsIDAsMV0pO1xuXG4gICAgICAgIHRoaXMudmVydGljaWVzID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDBdKTtcblxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKTtcblxuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDNdKTtcbiAgICB9XG4gICAgY2F0Y2goZXJyb3IpXG4gICAge1xuICAgICAgICB0aGlzLnV2cyA9IFswLCAxLFxuICAgICAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAgICAgMSwgMCwgMCwxXTtcblxuICAgICAgICB0aGlzLnZlcnRpY2llcyA9IFswLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMF07XG5cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBbMSwgMSwgMSwgMV07XG5cbiAgICAgICAgdGhpcy5pbmRpY2VzID0gWzAsIDEsIDIsIDNdO1xuICAgIH1cblxuXG4gICAgLypcbiAgICB0aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoKVxuICAgIHRoaXMudmVydGljaWVzID0gbmV3IEZsb2F0MzJBcnJheSgpXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KClcbiAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoKVxuICAgICovXG4gICAgXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLy8gbG9hZCB0aGUgdGV4dHVyZSFcbiAgICBpZih0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHRoaXMud2lkdGggICA9IHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgID0gdGhpcy50ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGVGcmFtZSA9IHRydWU7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMub25UZXh0dXJlVXBkYXRlQmluZCA9IHRoaXMub25UZXh0dXJlVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAndXBkYXRlJywgdGhpcy5vblRleHR1cmVVcGRhdGVCaW5kICk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlN0cmlwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZSk7XG5QSVhJLlN0cmlwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuU3RyaXA7XG5cbi8qXG4gKiBTZXRzIHRoZSB0ZXh0dXJlIHRoYXQgdGhlIFN0cmlwIHdpbGwgdXNlIFxuICpcbiAqIEBtZXRob2Qgc2V0VGV4dHVyZVxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IHRoZSB0ZXh0dXJlIHRoYXQgd2lsbCBiZSB1c2VkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlN0cmlwLnByb3RvdHlwZS5zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICAvL1RPRE8gU0VUIFRIRSBURVhUVVJFU1xuICAgIC8vVE9ETyBWSVNJQklMSVRZXG5cbiAgICAvLyBzdG9wIGN1cnJlbnQgdGV4dHVyZVxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy53aWR0aCAgID0gdGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCAgPSB0ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgICB0aGlzLnVwZGF0ZUZyYW1lID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICpcbiAqIEBtZXRob2Qgb25UZXh0dXJlVXBkYXRlXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuU3RyaXAucHJvdG90eXBlLm9uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnVwZGF0ZUZyYW1lID0gdHJ1ZTtcbn07XG4vKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFxuICogQGNsYXNzIFJvcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHRvIHVzZVxuICogQHBhcmFtIHBvaW50cyB7QXJyYXl9XG4gKiBcbiAqL1xuUElYSS5Sb3BlID0gZnVuY3Rpb24odGV4dHVyZSwgcG9pbnRzKVxue1xuICAgIFBJWEkuU3RyaXAuY2FsbCggdGhpcywgdGV4dHVyZSApO1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICB0aGlzLnZlcnRpY2llcyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgICB0aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgIH1cbiAgICBjYXRjaChlcnJvcilcbiAgICB7XG4gICAgICAgIHRoaXMudmVydGljaWVzID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcbiAgICAgICAgdGhpcy51dnMgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG59O1xuXG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlJvcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5TdHJpcC5wcm90b3R5cGUgKTtcblBJWEkuUm9wZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlJvcGU7XG5cbi8qXG4gKiBSZWZyZXNoZXMgXG4gKlxuICogQG1ldGhvZCByZWZyZXNoXG4gKi9cblBJWEkuUm9wZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA8IDEpIHJldHVybjtcblxuICAgIHZhciB1dnMgPSB0aGlzLnV2cztcblxuICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzO1xuXG4gICAgdGhpcy5jb3VudC09MC4yO1xuXG5cbiAgICB1dnNbMF0gPSAwO1xuICAgIHV2c1sxXSA9IDE7XG4gICAgdXZzWzJdID0gMDtcbiAgICB1dnNbM10gPSAxO1xuXG4gICAgY29sb3JzWzBdID0gMTtcbiAgICBjb2xvcnNbMV0gPSAxO1xuXG4gICAgaW5kaWNlc1swXSA9IDA7XG4gICAgaW5kaWNlc1sxXSA9IDE7XG5cbiAgICB2YXIgdG90YWwgPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBwb2ludCwgaW5kZXgsIGFtb3VudDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdG90YWw7IGkrKylcbiAgICB7XG5cbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIGluZGV4ID0gaSAqIDQ7XG4gICAgICAgIC8vIHRpbWUgdG8gZG8gc29tZSBzbWFydCBkcmF3aW5nIVxuICAgICAgICBhbW91bnQgPSBpIC8gKHRvdGFsLTEpO1xuXG4gICAgICAgIGlmKGklMilcbiAgICAgICAge1xuICAgICAgICAgICAgdXZzW2luZGV4XSA9IGFtb3VudDtcbiAgICAgICAgICAgIHV2c1tpbmRleCsxXSA9IDA7XG5cbiAgICAgICAgICAgIHV2c1tpbmRleCsyXSA9IGFtb3VudDtcbiAgICAgICAgICAgIHV2c1tpbmRleCszXSA9IDE7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHV2c1tpbmRleF0gPSBhbW91bnQ7XG4gICAgICAgICAgICB1dnNbaW5kZXgrMV0gPSAwO1xuXG4gICAgICAgICAgICB1dnNbaW5kZXgrMl0gPSBhbW91bnQ7XG4gICAgICAgICAgICB1dnNbaW5kZXgrM10gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBpICogMjtcbiAgICAgICAgY29sb3JzW2luZGV4XSA9IDE7XG4gICAgICAgIGNvbG9yc1tpbmRleCsxXSA9IDE7XG5cbiAgICAgICAgaW5kZXggPSBpICogMjtcbiAgICAgICAgaW5kaWNlc1tpbmRleF0gPSBpbmRleDtcbiAgICAgICAgaW5kaWNlc1tpbmRleCArIDFdID0gaW5kZXggKyAxO1xuXG4gICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgIH1cbn07XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyYW5zZm9ybVxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Sb3BlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbigpXG57XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYocG9pbnRzLmxlbmd0aCA8IDEpcmV0dXJuO1xuXG4gICAgdmFyIGxhc3RQb2ludCA9IHBvaW50c1swXTtcbiAgICB2YXIgbmV4dFBvaW50O1xuICAgIHZhciBwZXJwID0ge3g6MCwgeTowfTtcblxuICAgIHRoaXMuY291bnQtPTAuMjtcblxuICAgIHZhciB2ZXJ0aWNpZXMgPSB0aGlzLnZlcnRpY2llcztcbiAgICB2ZXJ0aWNpZXNbMF0gPSBsYXN0UG9pbnQueCArIHBlcnAueDtcbiAgICB2ZXJ0aWNpZXNbMV0gPSBsYXN0UG9pbnQueSArIHBlcnAueTsgLy8rIDIwMFxuICAgIHZlcnRpY2llc1syXSA9IGxhc3RQb2ludC54IC0gcGVycC54O1xuICAgIHZlcnRpY2llc1szXSA9IGxhc3RQb2ludC55IC0gcGVycC55Oy8vKzIwMFxuICAgIC8vIHRpbWUgdG8gZG8gc29tZSBzbWFydCBkcmF3aW5nIVxuXG4gICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgcG9pbnQsIGluZGV4LCByYXRpbywgcGVycExlbmd0aCwgbnVtO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0b3RhbDsgaSsrKVxuICAgIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIGluZGV4ID0gaSAqIDQ7XG5cbiAgICAgICAgaWYoaSA8IHBvaW50cy5sZW5ndGgtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2krMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBlcnAueSA9IC0obmV4dFBvaW50LnggLSBsYXN0UG9pbnQueCk7XG4gICAgICAgIHBlcnAueCA9IG5leHRQb2ludC55IC0gbGFzdFBvaW50Lnk7XG5cbiAgICAgICAgcmF0aW8gPSAoMSAtIChpIC8gKHRvdGFsLTEpKSkgKiAxMDtcblxuICAgICAgICBpZihyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KHBlcnAueCAqIHBlcnAueCArIHBlcnAueSAqIHBlcnAueSk7XG4gICAgICAgIG51bSA9IHRoaXMudGV4dHVyZS5oZWlnaHQgLyAyOyAvLygyMCArIE1hdGguYWJzKE1hdGguc2luKChpICsgdGhpcy5jb3VudCkgKiAwLjMpICogNTApICkqIHJhdGlvO1xuICAgICAgICBwZXJwLnggLz0gcGVycExlbmd0aDtcbiAgICAgICAgcGVycC55IC89IHBlcnBMZW5ndGg7XG5cbiAgICAgICAgcGVycC54ICo9IG51bTtcbiAgICAgICAgcGVycC55ICo9IG51bTtcblxuICAgICAgICB2ZXJ0aWNpZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnAueDtcbiAgICAgICAgdmVydGljaWVzW2luZGV4KzFdID0gcG9pbnQueSArIHBlcnAueTtcbiAgICAgICAgdmVydGljaWVzW2luZGV4KzJdID0gcG9pbnQueCAtIHBlcnAueDtcbiAgICAgICAgdmVydGljaWVzW2luZGV4KzNdID0gcG9pbnQueSAtIHBlcnAueTtcblxuICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgICB9XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG59O1xuLypcbiAqIFNldHMgdGhlIHRleHR1cmUgdGhhdCB0aGUgUm9wZSB3aWxsIHVzZSBcbiAqXG4gKiBAbWV0aG9kIHNldFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0aGF0IHdpbGwgYmUgdXNlZFxuICovXG5QSVhJLlJvcGUucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIC8vIHN0b3AgY3VycmVudCB0ZXh0dXJlXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLnVwZGF0ZUZyYW1lID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tL1xuICovXG5cbi8qKlxuICogQSB0aWxpbmcgc3ByaXRlIGlzIGEgZmFzdCB3YXkgb2YgcmVuZGVyaW5nIGEgdGlsaW5nIGltYWdlXG4gKlxuICogQGNsYXNzIFRpbGluZ1Nwcml0ZVxuICogQGV4dGVuZHMgU3ByaXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9ICB0aGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICovXG5QSVhJLlRpbGluZ1Nwcml0ZSA9IGZ1bmN0aW9uKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgUElYSS5TcHJpdGUuY2FsbCggdGhpcywgdGV4dHVyZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2l0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDEwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGluZyBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbGVTY2FsZVxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy50aWxlU2NhbGUgPSBuZXcgUElYSS5Qb2ludCgxLDEpO1xuXG4gICAgLyoqXG4gICAgICogQSBwb2ludCB0aGF0IHJlcHJlc2VudHMgdGhlIHNjYWxlIG9mIHRoZSB0ZXh0dXJlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbGVTY2FsZU9mZnNldFxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy50aWxlU2NhbGVPZmZzZXQgPSBuZXcgUElYSS5Qb2ludCgxLDEpO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGltYWdlIHRoYXQgaXMgYmVpbmcgdGlsZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aWxlUG9zaXRpb25cbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMudGlsZVBvc2l0aW9uID0gbmV3IFBJWEkuUG9pbnQoMCwwKTtcblxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIHNwcml0ZSBpcyByZW5kZXJhYmxlIG9yIG5vdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlcmFibGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW50XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBibGVuZE1vZGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLmJsZW5kTW9kZXMuTk9STUFMO1xuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlID0gUElYSS5ibGVuZE1vZGVzLk5PUk1BTDtcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuU3ByaXRlLnByb3RvdHlwZSk7XG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlRpbGluZ1Nwcml0ZTtcblxuXG4vKipcbiAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICpcbiAqIEBwcm9wZXJ0eSB3aWR0aFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUsICd3aWR0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBoZWlnaHQgb2YgdGhlIFRpbGluZ1Nwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAqXG4gKiBAcHJvcGVydHkgaGVpZ2h0XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZSwgJ2hlaWdodCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIHRoaXMuX2hlaWdodDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgYmUgZmlyZWQgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcbiAqXG4gKiBAbWV0aG9kIG9uVGV4dHVyZVVwZGF0ZVxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUub25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudXBkYXRlRnJhbWUgPSB0cnVlO1xufTtcblxuUElYSS5UaWxpbmdTcHJpdGUucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIGlmKHRoaXMudGV4dHVyZSA9PT0gdGV4dHVyZSlyZXR1cm47XG5cbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgdGhpcy5yZWZyZXNoVGV4dHVyZSA9IHRydWU7XG4gICAgLypcbiAgICBpZih0aGlzLnRpbGluZ1RleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLmdlbmVyYXRlVGlsaW5nVGV4dHVyZSh0cnVlKTtcbiAgICB9XG4qL1xuXG4gICAgLypcbiAgICAvLyBzdG9wIGN1cnJlbnQgdGV4dHVyZTtcbiAgICBpZih0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUgIT09IHRleHR1cmUuYmFzZVRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLnRleHR1cmVDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRnJhbWUgPSB0cnVlOyovXG4gICAgdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5UaWxpbmdTcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG5cbiAgICBpZih0aGlzLnZpc2libGUgPT09IGZhbHNlIHx8IHRoaXMuYWxwaGEgPT09IDApcmV0dXJuO1xuICAgIFxuICAgIHZhciBpLGo7XG5cbiAgICBpZih0aGlzLm1hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLm1hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgaWYodGhpcy5maWx0ZXJzKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5mbHVzaCgpO1xuICAgICAgICByZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0aGlzLl9maWx0ZXJCbG9jayk7XG4gICAgfVxuXG5cbiAgICBpZighdGhpcy50aWxpbmdUZXh0dXJlIHx8IHRoaXMucmVmcmVzaFRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLmdlbmVyYXRlVGlsaW5nVGV4dHVyZSh0cnVlKTtcbiAgICAgICAgaWYodGhpcy50aWxpbmdUZXh0dXJlICYmIHRoaXMudGlsaW5nVGV4dHVyZS5uZWVkc1VwZGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy9UT0RPIC0gdHdlYWtpbmdcbiAgICAgICAgICAgIFBJWEkudXBkYXRlV2ViR0xUZXh0dXJlKHRoaXMudGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZSwgcmVuZGVyU2Vzc2lvbi5nbCk7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgLy8gdGhpcy50aWxpbmdUZXh0dXJlLl91dnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgcmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaC5yZW5kZXJUaWxpbmdTcHJpdGUodGhpcyk7XG4gICAgXG5cbiAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgIGZvcihpPTAsaj10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICB9XG5cbiAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcblxuICAgIGlmKHRoaXMuZmlsdGVycylyZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG4gICAgaWYodGhpcy5tYXNrKXJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJTZXNzaW9uKTtcbiAgICBcbiAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufSBcbiogQHByaXZhdGVcbiovXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlclNlc3Npb24pXG57XG4gICAgaWYodGhpcy52aXNpYmxlID09PSBmYWxzZSB8fCB0aGlzLmFscGhhID09PSAwKXJldHVybjtcbiAgICBcbiAgICB2YXIgY29udGV4dCA9IHJlbmRlclNlc3Npb24uY29udGV4dDtcblxuICAgIGlmKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICBcbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIC8vIGFsbG93IGZvciB0cmltbWluZ1xuLy8odGhpcy5hbmNob3IueCkgKiAtZnJhbWUud2lkdGgsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5hbmNob3IueSkgKiAtZnJhbWUuaGVpZ2h0LFxuXG4gICAgICAgICBcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmMsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4ICwgdHJhbnNmb3JtLnR5KTtcblxuXG4gICAgaWYoIXRoaXMuX190aWxlUGF0dGVybiB8fCAgdGhpcy5yZWZyZXNoVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVUaWxpbmdUZXh0dXJlKGZhbHNlKTtcbiAgICBcbiAgICAgICAgaWYodGhpcy50aWxpbmdUZXh0dXJlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9fdGlsZVBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4odGhpcy50aWxpbmdUZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSwgJ3JlcGVhdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgYmxlbmQgbW9kZVxuICAgIGlmKHRoaXMuYmxlbmRNb2RlICE9PSByZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGUpXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLmN1cnJlbnRCbGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBQSVhJLmJsZW5kTW9kZXNDYW52YXNbcmVuZGVyU2Vzc2lvbi5jdXJyZW50QmxlbmRNb2RlXTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgdmFyIHRpbGVQb3NpdGlvbiA9IHRoaXMudGlsZVBvc2l0aW9uO1xuICAgIHZhciB0aWxlU2NhbGUgPSB0aGlzLnRpbGVTY2FsZTtcblxuICAgIHRpbGVQb3NpdGlvbi54ICU9IHRoaXMudGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aDtcbiAgICB0aWxlUG9zaXRpb24ueSAlPSB0aGlzLnRpbGluZ1RleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgLy8gb2Zmc2V0XG4gICAgY29udGV4dC5zY2FsZSh0aWxlU2NhbGUueCx0aWxlU2NhbGUueSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUodGlsZVBvc2l0aW9uLngsIHRpbGVQb3NpdGlvbi55KTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fX3RpbGVQYXR0ZXJuO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRvIGFjY291bnQgZm9yIHRoZSBhbmNob3IgcG9pbnQuLlxuICAgIGNvbnRleHQuZmlsbFJlY3QoLXRpbGVQb3NpdGlvbi54ICsgKHRoaXMuYW5jaG9yLnggKiAtdGhpcy5fd2lkdGgpLC10aWxlUG9zaXRpb24ueSArICh0aGlzLmFuY2hvci55ICogLXRoaXMuX2hlaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCAvIHRpbGVTY2FsZS54LCB0aGlzLl9oZWlnaHQgLyB0aWxlU2NhbGUueSk7XG5cbiAgICBjb250ZXh0LnNjYWxlKDEvdGlsZVNjYWxlLngsIDEvdGlsZVNjYWxlLnkpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC10aWxlUG9zaXRpb24ueCwgLXRpbGVQb3NpdGlvbi55KTtcblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZih0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHJlbmRlclNlc3Npb24uY29udGV4dCk7XG4gICAgfVxufTtcblxuXG4vKipcbiogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIHNwcml0ZSBhcyBhIFBJWEkuUmVjdGFuZ2xlIG9iamVjdFxuKlxuKiBAbWV0aG9kIGdldEJvdW5kc1xuKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuKi9cblBJWEkuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbigpXG57XG5cbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gICAgdmFyIHcwID0gd2lkdGggKiAoMS10aGlzLmFuY2hvci54KTtcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC10aGlzLmFuY2hvci54O1xuXG4gICAgdmFyIGgwID0gaGVpZ2h0ICogKDEtdGhpcy5hbmNob3IueSk7XG4gICAgdmFyIGgxID0gaGVpZ2h0ICogLXRoaXMuYW5jaG9yLnk7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hO1xuICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYztcbiAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmI7XG4gICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kO1xuICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xuICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xuICAgIFxuICAgIHZhciB4MSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgIHZhciB5MSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuXG4gICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgdmFyIHkyID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICB2YXIgeDMgPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICB2YXIgeTMgPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgIHZhciB4NCA9ICBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2YXIgeTQgPSAgZCAqIGgwICsgYiAqIHcxICsgdHk7XG5cbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcblxuICAgIG1pblggPSB4MSA8IG1pblggPyB4MSA6IG1pblg7XG4gICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xuICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XG5cbiAgICBtaW5ZID0geTEgPCBtaW5ZID8geTEgOiBtaW5ZO1xuICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XG4gICAgbWluWSA9IHkzIDwgbWluWSA/IHkzIDogbWluWTtcbiAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xuXG4gICAgbWF4WCA9IHgxID4gbWF4WCA/IHgxIDogbWF4WDtcbiAgICBtYXhYID0geDIgPiBtYXhYID8geDIgOiBtYXhYO1xuICAgIG1heFggPSB4MyA+IG1heFggPyB4MyA6IG1heFg7XG4gICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgIG1heFkgPSB5MSA+IG1heFkgPyB5MSA6IG1heFk7XG4gICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xuICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgYm91bmRzLnggPSBtaW5YO1xuICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHNvIHRoYXQgaWYgdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBhZ2FpbiBpbiB0aGUgcmVuZGVyIGN5Y2xlIHdlIGRvIG5vdCBoYXZlIHRvIHJlY2FsY3VsYXRlXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcblxuICAgIHJldHVybiBib3VuZHM7XG59O1xuXG4vKipcbiogXG4qIEBtZXRob2QgZ2VuZXJhdGVUaWxpbmdUZXh0dXJlXG4qIFxuKiBAcGFyYW0gZm9yY2VQb3dlck9mVHdvIHtCb29sZWFufSBXaGV0aGVyIHdlIHdhbnQgdG8gZm9yY2UgdGhlIHRleHR1cmUgdG8gYmUgYSBwb3dlciBvZiB0d29cbiovXG5QSVhJLlRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWxpbmdUZXh0dXJlID0gZnVuY3Rpb24oZm9yY2VQb3dlck9mVHdvKVxue1xuICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuXG4gICAgaWYoIXRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKXJldHVybjtcblxuICAgIHZhciBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdmFyIGZyYW1lID0gdGV4dHVyZS5mcmFtZTtcblxuICAgIHZhciB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0O1xuXG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgZnJhbWUgaXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgYmFzZSB0ZXh0dXJlLlxuICAgIHZhciBpc0ZyYW1lID0gZnJhbWUud2lkdGggIT09IGJhc2VUZXh0dXJlLndpZHRoIHx8IGZyYW1lLmhlaWdodCAhPT0gYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgdmFyIG5ld1RleHR1cmVSZXF1aXJlZCA9IGZhbHNlO1xuXG4gICAgaWYoIWZvcmNlUG93ZXJPZlR3bylcbiAgICB7XG4gICAgICAgIGlmKGlzRnJhbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldFdpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgICAgICAgICB0YXJnZXRIZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgbmV3VGV4dHVyZVJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRhcmdldFdpZHRoID0gUElYSS5nZXROZXh0UG93ZXJPZlR3byhmcmFtZS53aWR0aCk7XG4gICAgICAgIHRhcmdldEhlaWdodCA9IFBJWEkuZ2V0TmV4dFBvd2VyT2ZUd28oZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgaWYoZnJhbWUud2lkdGggIT09IHRhcmdldFdpZHRoICYmIGZyYW1lLmhlaWdodCAhPT0gdGFyZ2V0SGVpZ2h0KW5ld1RleHR1cmVSZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYobmV3VGV4dHVyZVJlcXVpcmVkKVxuICAgIHtcbiAgICAgICAgdmFyIGNhbnZhc0J1ZmZlcjtcblxuICAgICAgICBpZih0aGlzLnRpbGluZ1RleHR1cmUgJiYgdGhpcy50aWxpbmdUZXh0dXJlLmlzVGlsaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYW52YXNCdWZmZXIgPSB0aGlzLnRpbGluZ1RleHR1cmUuY2FudmFzQnVmZmVyO1xuICAgICAgICAgICAgY2FudmFzQnVmZmVyLnJlc2l6ZSh0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCA9IHRhcmdldFdpZHRoO1xuICAgICAgICAgICAgdGhpcy50aWxpbmdUZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjYW52YXNCdWZmZXIgPSBuZXcgUElYSS5DYW52YXNCdWZmZXIodGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMudGlsaW5nVGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tQ2FudmFzKGNhbnZhc0J1ZmZlci5jYW52YXMpO1xuICAgICAgICAgICAgdGhpcy50aWxpbmdUZXh0dXJlLmNhbnZhc0J1ZmZlciA9IGNhbnZhc0J1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nVGV4dHVyZS5pc1RpbGluZyA9IHRydWU7XG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2FudmFzQnVmZmVyLmNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCk7XG5cbiAgICAgICAgdGhpcy50aWxlU2NhbGVPZmZzZXQueCA9IGZyYW1lLndpZHRoIC8gdGFyZ2V0V2lkdGg7XG4gICAgICAgIHRoaXMudGlsZVNjYWxlT2Zmc2V0LnkgPSBmcmFtZS5oZWlnaHQgLyB0YXJnZXRIZWlnaHQ7XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy9UT0RPIC0gc3dpdGNoaW5nP1xuICAgICAgICBpZih0aGlzLnRpbGluZ1RleHR1cmUgJiYgdGhpcy50aWxpbmdUZXh0dXJlLmlzVGlsaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBkZXN0cm95IHRoZSB0aWxpbmcgdGV4dHVyZSFcbiAgICAgICAgICAgIC8vIFRPRE8gY291bGQgc3RvcmUgdGhpcyBzb21ld2hlcmU/XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1RleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGlsZVNjYWxlT2Zmc2V0LnggPSAxO1xuICAgICAgICB0aGlzLnRpbGVTY2FsZU9mZnNldC55ID0gMTtcbiAgICAgICAgdGhpcy50aWxpbmdUZXh0dXJlID0gdGV4dHVyZTtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoVGV4dHVyZSA9IGZhbHNlO1xuICAgIHRoaXMudGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZS5fcG93ZXJPZjIgPSB0cnVlO1xufTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKiBiYXNlZCBvbiBwaXhpIGltcGFjdCBzcGluZSBpbXBsZW1lbnRhdGlvbiBtYWRlIGJ5IEVlbWVsaSBLZWxva29ycGkgKEBla2Vsb2tvcnBpKSBodHRwczovL2dpdGh1Yi5jb20vZWtlbG9rb3JwaVxuICpcbiAqIEF3ZXNvbWUgSlMgcnVuIHRpbWUgcHJvdmlkZWQgYnkgRXNvdGVyaWNTb2Z0d2FyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL0Vzb3RlcmljU29mdHdhcmUvc3BpbmUtcnVudGltZXNcbiAqXG4gKi9cblxuLypcbiAqIEF3ZXNvbWUgSlMgcnVuIHRpbWUgcHJvdmlkZWQgYnkgRXNvdGVyaWNTb2Z0d2FyZVxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc290ZXJpY1NvZnR3YXJlL3NwaW5lLXJ1bnRpbWVzXG4gKlxuICovXG5cblxuXG52YXIgc3BpbmUgPSB7fTtcblxuc3BpbmUuQm9uZURhdGEgPSBmdW5jdGlvbiAobmFtZSwgcGFyZW50KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn07XG5zcGluZS5Cb25lRGF0YS5wcm90b3R5cGUgPSB7XG4gICAgbGVuZ3RoOiAwLFxuICAgIHg6IDAsIHk6IDAsXG4gICAgcm90YXRpb246IDAsXG4gICAgc2NhbGVYOiAxLCBzY2FsZVk6IDFcbn07XG5cbnNwaW5lLlNsb3REYXRhID0gZnVuY3Rpb24gKG5hbWUsIGJvbmVEYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmJvbmVEYXRhID0gYm9uZURhdGE7XG59O1xuc3BpbmUuU2xvdERhdGEucHJvdG90eXBlID0ge1xuICAgIHI6IDEsIGc6IDEsIGI6IDEsIGE6IDEsXG4gICAgYXR0YWNobWVudE5hbWU6IG51bGxcbn07XG5cbnNwaW5lLkJvbmUgPSBmdW5jdGlvbiAoYm9uZURhdGEsIHBhcmVudCkge1xuICAgIHRoaXMuZGF0YSA9IGJvbmVEYXRhO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc2V0VG9TZXR1cFBvc2UoKTtcbn07XG5zcGluZS5Cb25lLnlEb3duID0gZmFsc2U7XG5zcGluZS5Cb25lLnByb3RvdHlwZSA9IHtcbiAgICB4OiAwLCB5OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNjYWxlWDogMSwgc2NhbGVZOiAxLFxuICAgIG0wMDogMCwgbTAxOiAwLCB3b3JsZFg6IDAsIC8vIGEgYiB4XG4gICAgbTEwOiAwLCBtMTE6IDAsIHdvcmxkWTogMCwgLy8gYyBkIHlcbiAgICB3b3JsZFJvdGF0aW9uOiAwLFxuICAgIHdvcmxkU2NhbGVYOiAxLCB3b3JsZFNjYWxlWTogMSxcbiAgICB1cGRhdGVXb3JsZFRyYW5zZm9ybTogZnVuY3Rpb24gKGZsaXBYLCBmbGlwWSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy53b3JsZFggPSB0aGlzLnggKiBwYXJlbnQubTAwICsgdGhpcy55ICogcGFyZW50Lm0wMSArIHBhcmVudC53b3JsZFg7XG4gICAgICAgICAgICB0aGlzLndvcmxkWSA9IHRoaXMueCAqIHBhcmVudC5tMTAgKyB0aGlzLnkgKiBwYXJlbnQubTExICsgcGFyZW50LndvcmxkWTtcbiAgICAgICAgICAgIHRoaXMud29ybGRTY2FsZVggPSBwYXJlbnQud29ybGRTY2FsZVggKiB0aGlzLnNjYWxlWDtcbiAgICAgICAgICAgIHRoaXMud29ybGRTY2FsZVkgPSBwYXJlbnQud29ybGRTY2FsZVkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgICAgIHRoaXMud29ybGRSb3RhdGlvbiA9IHBhcmVudC53b3JsZFJvdGF0aW9uICsgdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud29ybGRYID0gdGhpcy54O1xuICAgICAgICAgICAgdGhpcy53b3JsZFkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGVYID0gdGhpcy5zY2FsZVg7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGVZID0gdGhpcy5zY2FsZVk7XG4gICAgICAgICAgICB0aGlzLndvcmxkUm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYWRpYW5zID0gdGhpcy53b3JsZFJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgICAgIHRoaXMubTAwID0gY29zICogdGhpcy53b3JsZFNjYWxlWDtcbiAgICAgICAgdGhpcy5tMTAgPSBzaW4gKiB0aGlzLndvcmxkU2NhbGVYO1xuICAgICAgICB0aGlzLm0wMSA9IC1zaW4gKiB0aGlzLndvcmxkU2NhbGVZO1xuICAgICAgICB0aGlzLm0xMSA9IGNvcyAqIHRoaXMud29ybGRTY2FsZVk7XG4gICAgICAgIGlmIChmbGlwWCkge1xuICAgICAgICAgICAgdGhpcy5tMDAgPSAtdGhpcy5tMDA7XG4gICAgICAgICAgICB0aGlzLm0wMSA9IC10aGlzLm0wMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxpcFkpIHtcbiAgICAgICAgICAgIHRoaXMubTEwID0gLXRoaXMubTEwO1xuICAgICAgICAgICAgdGhpcy5tMTEgPSAtdGhpcy5tMTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwaW5lLkJvbmUueURvd24pIHtcbiAgICAgICAgICAgIHRoaXMubTEwID0gLXRoaXMubTEwO1xuICAgICAgICAgICAgdGhpcy5tMTEgPSAtdGhpcy5tMTE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldFRvU2V0dXBQb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLnggPSBkYXRhLng7XG4gICAgICAgIHRoaXMueSA9IGRhdGEueTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG4gICAgICAgIHRoaXMuc2NhbGVYID0gZGF0YS5zY2FsZVg7XG4gICAgICAgIHRoaXMuc2NhbGVZID0gZGF0YS5zY2FsZVk7XG4gICAgfVxufTtcblxuc3BpbmUuU2xvdCA9IGZ1bmN0aW9uIChzbG90RGF0YSwgc2tlbGV0b24sIGJvbmUpIHtcbiAgICB0aGlzLmRhdGEgPSBzbG90RGF0YTtcbiAgICB0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XG4gICAgdGhpcy5ib25lID0gYm9uZTtcbiAgICB0aGlzLnNldFRvU2V0dXBQb3NlKCk7XG59O1xuc3BpbmUuU2xvdC5wcm90b3R5cGUgPSB7XG4gICAgcjogMSwgZzogMSwgYjogMSwgYTogMSxcbiAgICBfYXR0YWNobWVudFRpbWU6IDAsXG4gICAgYXR0YWNobWVudDogbnVsbCxcbiAgICBzZXRBdHRhY2htZW50OiBmdW5jdGlvbiAoYXR0YWNobWVudCkge1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuICAgICAgICB0aGlzLl9hdHRhY2htZW50VGltZSA9IHRoaXMuc2tlbGV0b24udGltZTtcbiAgICB9LFxuICAgIHNldEF0dGFjaG1lbnRUaW1lOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB0aGlzLl9hdHRhY2htZW50VGltZSA9IHRoaXMuc2tlbGV0b24udGltZSAtIHRpbWU7XG4gICAgfSxcbiAgICBnZXRBdHRhY2htZW50VGltZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5za2VsZXRvbi50aW1lIC0gdGhpcy5fYXR0YWNobWVudFRpbWU7XG4gICAgfSxcbiAgICBzZXRUb1NldHVwUG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy5yID0gZGF0YS5yO1xuICAgICAgICB0aGlzLmcgPSBkYXRhLmc7XG4gICAgICAgIHRoaXMuYiA9IGRhdGEuYjtcbiAgICAgICAgdGhpcy5hID0gZGF0YS5hO1xuXG4gICAgICAgIHZhciBzbG90RGF0YXMgPSB0aGlzLnNrZWxldG9uLmRhdGEuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdERhdGFzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHNsb3REYXRhc1tpXSA9PSBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRhY2htZW50KCFkYXRhLmF0dGFjaG1lbnROYW1lID8gbnVsbCA6IHRoaXMuc2tlbGV0b24uZ2V0QXR0YWNobWVudEJ5U2xvdEluZGV4KGksIGRhdGEuYXR0YWNobWVudE5hbWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnNwaW5lLlNraW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5hdHRhY2htZW50cyA9IHt9O1xufTtcbnNwaW5lLlNraW4ucHJvdG90eXBlID0ge1xuICAgIGFkZEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChzbG90SW5kZXgsIG5hbWUsIGF0dGFjaG1lbnQpIHtcbiAgICAgICAgdGhpcy5hdHRhY2htZW50c1tzbG90SW5kZXggKyBcIjpcIiArIG5hbWVdID0gYXR0YWNobWVudDtcbiAgICB9LFxuICAgIGdldEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChzbG90SW5kZXgsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNobWVudHNbc2xvdEluZGV4ICsgXCI6XCIgKyBuYW1lXTtcbiAgICB9LFxuICAgIF9hdHRhY2hBbGw6IGZ1bmN0aW9uIChza2VsZXRvbiwgb2xkU2tpbikge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2xkU2tpbi5hdHRhY2htZW50cykge1xuICAgICAgICAgICAgdmFyIGNvbG9uID0ga2V5LmluZGV4T2YoXCI6XCIpO1xuICAgICAgICAgICAgdmFyIHNsb3RJbmRleCA9IHBhcnNlSW50KGtleS5zdWJzdHJpbmcoMCwgY29sb24pLCAxMCk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGtleS5zdWJzdHJpbmcoY29sb24gKyAxKTtcbiAgICAgICAgICAgIHZhciBzbG90ID0gc2tlbGV0b24uc2xvdHNbc2xvdEluZGV4XTtcbiAgICAgICAgICAgIGlmIChzbG90LmF0dGFjaG1lbnQgJiYgc2xvdC5hdHRhY2htZW50Lm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gdGhpcy5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQpIHNsb3Quc2V0QXR0YWNobWVudChhdHRhY2htZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnNwaW5lLkFuaW1hdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB0aW1lbGluZXMsIGR1cmF0aW9uKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnRpbWVsaW5lcyA9IHRpbWVsaW5lcztcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG59O1xuc3BpbmUuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCB0aW1lLCBsb29wKSB7XG4gICAgICAgIGlmIChsb29wICYmIHRoaXMuZHVyYXRpb24pIHRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgdmFyIHRpbWVsaW5lcyA9IHRoaXMudGltZWxpbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRpbWVsaW5lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICB0aW1lbGluZXNbaV0uYXBwbHkoc2tlbGV0b24sIHRpbWUsIDEpO1xuICAgIH0sXG4gICAgbWl4OiBmdW5jdGlvbiAoc2tlbGV0b24sIHRpbWUsIGxvb3AsIGFscGhhKSB7XG4gICAgICAgIGlmIChsb29wICYmIHRoaXMuZHVyYXRpb24pIHRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgdmFyIHRpbWVsaW5lcyA9IHRoaXMudGltZWxpbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRpbWVsaW5lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICB0aW1lbGluZXNbaV0uYXBwbHkoc2tlbGV0b24sIHRpbWUsIGFscGhhKTtcbiAgICB9XG59O1xuXG5zcGluZS5iaW5hcnlTZWFyY2ggPSBmdW5jdGlvbiAodmFsdWVzLCB0YXJnZXQsIHN0ZXApIHtcbiAgICB2YXIgbG93ID0gMDtcbiAgICB2YXIgaGlnaCA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIHN0ZXApIC0gMjtcbiAgICBpZiAoIWhpZ2gpIHJldHVybiBzdGVwO1xuICAgIHZhciBjdXJyZW50ID0gaGlnaCA+Pj4gMTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodmFsdWVzWyhjdXJyZW50ICsgMSkgKiBzdGVwXSA8PSB0YXJnZXQpXG4gICAgICAgICAgICBsb3cgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaGlnaCA9IGN1cnJlbnQ7XG4gICAgICAgIGlmIChsb3cgPT0gaGlnaCkgcmV0dXJuIChsb3cgKyAxKSAqIHN0ZXA7XG4gICAgICAgIGN1cnJlbnQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgfVxufTtcbnNwaW5lLmxpbmVhclNlYXJjaCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHRhcmdldCwgc3RlcCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsYXN0ID0gdmFsdWVzLmxlbmd0aCAtIHN0ZXA7IGkgPD0gbGFzdDsgaSArPSBzdGVwKVxuICAgICAgICBpZiAodmFsdWVzW2ldID4gdGFyZ2V0KSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG59O1xuXG5zcGluZS5DdXJ2ZXMgPSBmdW5jdGlvbiAoZnJhbWVDb3VudCkge1xuICAgIHRoaXMuY3VydmVzID0gW107IC8vIGRmeCwgZGZ5LCBkZGZ4LCBkZGZ5LCBkZGRmeCwgZGRkZnksIC4uLlxuICAgIHRoaXMuY3VydmVzLmxlbmd0aCA9IChmcmFtZUNvdW50IC0gMSkgKiA2O1xufTtcbnNwaW5lLkN1cnZlcy5wcm90b3R5cGUgPSB7XG4gICAgc2V0TGluZWFyOiBmdW5jdGlvbiAoZnJhbWVJbmRleCkge1xuICAgICAgICB0aGlzLmN1cnZlc1tmcmFtZUluZGV4ICogNl0gPSAwLypMSU5FQVIqLztcbiAgICB9LFxuICAgIHNldFN0ZXBwZWQ6IGZ1bmN0aW9uIChmcmFtZUluZGV4KSB7XG4gICAgICAgIHRoaXMuY3VydmVzW2ZyYW1lSW5kZXggKiA2XSA9IC0xLypTVEVQUEVEKi87XG4gICAgfSxcbiAgICAvKiogU2V0cyB0aGUgY29udHJvbCBoYW5kbGUgcG9zaXRpb25zIGZvciBhbiBpbnRlcnBvbGF0aW9uIGJlemllciBjdXJ2ZSB1c2VkIHRvIHRyYW5zaXRpb24gZnJvbSB0aGlzIGtleWZyYW1lIHRvIHRoZSBuZXh0LlxuICAgICAqIGN4MSBhbmQgY3gyIGFyZSBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50IG9mIHRpbWUgYmV0d2VlbiB0aGUgdHdvIGtleWZyYW1lcy4gY3kxIGFuZCBjeTIgYXJlIHRoZSBwZXJjZW50IG9mXG4gICAgICogdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUga2V5ZnJhbWUncyB2YWx1ZXMuICovXG4gICAgc2V0Q3VydmU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCBjeDEsIGN5MSwgY3gyLCBjeTIpIHtcbiAgICAgICAgdmFyIHN1YmRpdl9zdGVwID0gMSAvIDEwLypCRVpJRVJfU0VHTUVOVFMqLztcbiAgICAgICAgdmFyIHN1YmRpdl9zdGVwMiA9IHN1YmRpdl9zdGVwICogc3ViZGl2X3N0ZXA7XG4gICAgICAgIHZhciBzdWJkaXZfc3RlcDMgPSBzdWJkaXZfc3RlcDIgKiBzdWJkaXZfc3RlcDtcbiAgICAgICAgdmFyIHByZTEgPSAzICogc3ViZGl2X3N0ZXA7XG4gICAgICAgIHZhciBwcmUyID0gMyAqIHN1YmRpdl9zdGVwMjtcbiAgICAgICAgdmFyIHByZTQgPSA2ICogc3ViZGl2X3N0ZXAyO1xuICAgICAgICB2YXIgcHJlNSA9IDYgKiBzdWJkaXZfc3RlcDM7XG4gICAgICAgIHZhciB0bXAxeCA9IC1jeDEgKiAyICsgY3gyO1xuICAgICAgICB2YXIgdG1wMXkgPSAtY3kxICogMiArIGN5MjtcbiAgICAgICAgdmFyIHRtcDJ4ID0gKGN4MSAtIGN4MikgKiAzICsgMTtcbiAgICAgICAgdmFyIHRtcDJ5ID0gKGN5MSAtIGN5MikgKiAzICsgMTtcbiAgICAgICAgdmFyIGkgPSBmcmFtZUluZGV4ICogNjtcbiAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuY3VydmVzO1xuICAgICAgICBjdXJ2ZXNbaV0gPSBjeDEgKiBwcmUxICsgdG1wMXggKiBwcmUyICsgdG1wMnggKiBzdWJkaXZfc3RlcDM7XG4gICAgICAgIGN1cnZlc1tpICsgMV0gPSBjeTEgKiBwcmUxICsgdG1wMXkgKiBwcmUyICsgdG1wMnkgKiBzdWJkaXZfc3RlcDM7XG4gICAgICAgIGN1cnZlc1tpICsgMl0gPSB0bXAxeCAqIHByZTQgKyB0bXAyeCAqIHByZTU7XG4gICAgICAgIGN1cnZlc1tpICsgM10gPSB0bXAxeSAqIHByZTQgKyB0bXAyeSAqIHByZTU7XG4gICAgICAgIGN1cnZlc1tpICsgNF0gPSB0bXAyeCAqIHByZTU7XG4gICAgICAgIGN1cnZlc1tpICsgNV0gPSB0bXAyeSAqIHByZTU7XG4gICAgfSxcbiAgICBnZXRDdXJ2ZVBlcmNlbnQ6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCBwZXJjZW50KSB7XG4gICAgICAgIHBlcmNlbnQgPSBwZXJjZW50IDwgMCA/IDAgOiAocGVyY2VudCA+IDEgPyAxIDogcGVyY2VudCk7XG4gICAgICAgIHZhciBjdXJ2ZUluZGV4ID0gZnJhbWVJbmRleCAqIDY7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmN1cnZlcztcbiAgICAgICAgdmFyIGRmeCA9IGN1cnZlc1tjdXJ2ZUluZGV4XTtcbiAgICAgICAgaWYgKCFkZngvKkxJTkVBUiovKSByZXR1cm4gcGVyY2VudDtcbiAgICAgICAgaWYgKGRmeCA9PSAtMS8qU1RFUFBFRCovKSByZXR1cm4gMDtcbiAgICAgICAgdmFyIGRmeSA9IGN1cnZlc1tjdXJ2ZUluZGV4ICsgMV07XG4gICAgICAgIHZhciBkZGZ4ID0gY3VydmVzW2N1cnZlSW5kZXggKyAyXTtcbiAgICAgICAgdmFyIGRkZnkgPSBjdXJ2ZXNbY3VydmVJbmRleCArIDNdO1xuICAgICAgICB2YXIgZGRkZnggPSBjdXJ2ZXNbY3VydmVJbmRleCArIDRdO1xuICAgICAgICB2YXIgZGRkZnkgPSBjdXJ2ZXNbY3VydmVJbmRleCArIDVdO1xuICAgICAgICB2YXIgeCA9IGRmeCwgeSA9IGRmeTtcbiAgICAgICAgdmFyIGkgPSAxMC8qQkVaSUVSX1NFR01FTlRTKi8gLSAyO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHggPj0gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0WCA9IHggLSBkZng7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RZID0geSAtIGRmeTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFkgKyAoeSAtIGxhc3RZKSAqIChwZXJjZW50IC0gbGFzdFgpIC8gKHggLSBsYXN0WCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWkpIGJyZWFrO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgZGZ4ICs9IGRkZng7XG4gICAgICAgICAgICBkZnkgKz0gZGRmeTtcbiAgICAgICAgICAgIGRkZnggKz0gZGRkZng7XG4gICAgICAgICAgICBkZGZ5ICs9IGRkZGZ5O1xuICAgICAgICAgICAgeCArPSBkZng7XG4gICAgICAgICAgICB5ICs9IGRmeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geSArICgxIC0geSkgKiAocGVyY2VudCAtIHgpIC8gKDEgLSB4KTsgLy8gTGFzdCBwb2ludCBpcyAxLDEuXG4gICAgfVxufTtcblxuc3BpbmUuUm90YXRlVGltZWxpbmUgPSBmdW5jdGlvbiAoZnJhbWVDb3VudCkge1xuICAgIHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcbiAgICB0aGlzLmZyYW1lcyA9IFtdOyAvLyB0aW1lLCBhbmdsZSwgLi4uXG4gICAgdGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudCAqIDI7XG59O1xuc3BpbmUuUm90YXRlVGltZWxpbmUucHJvdG90eXBlID0ge1xuICAgIGJvbmVJbmRleDogMCxcbiAgICBnZXRGcmFtZUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGggLyAyO1xuICAgIH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBhbmdsZSkge1xuICAgICAgICBmcmFtZUluZGV4ICo9IDI7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDFdID0gYW5nbGU7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCB0aW1lLCBhbHBoYSkge1xuICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXMsXG4gICAgICAgICAgICBhbW91bnQ7XG5cbiAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHJldHVybjsgLy8gVGltZSBpcyBiZWZvcmUgZmlyc3QgZnJhbWUuXG5cbiAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1t0aGlzLmJvbmVJbmRleF07XG5cbiAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAyXSkgeyAvLyBUaW1lIGlzIGFmdGVyIGxhc3QgZnJhbWUuXG4gICAgICAgICAgICBhbW91bnQgPSBib25lLmRhdGEucm90YXRpb24gKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdIC0gYm9uZS5yb3RhdGlvbjtcbiAgICAgICAgICAgIHdoaWxlIChhbW91bnQgPiAxODApXG4gICAgICAgICAgICAgICAgYW1vdW50IC09IDM2MDtcbiAgICAgICAgICAgIHdoaWxlIChhbW91bnQgPCAtMTgwKVxuICAgICAgICAgICAgICAgIGFtb3VudCArPSAzNjA7XG4gICAgICAgICAgICBib25lLnJvdGF0aW9uICs9IGFtb3VudCAqIGFscGhhO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICAgIHZhciBmcmFtZUluZGV4ID0gc3BpbmUuYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgMik7XG4gICAgICAgIHZhciBsYXN0RnJhbWVWYWx1ZSA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMV07XG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVJbmRleF07XG4gICAgICAgIHZhciBwZXJjZW50ID0gMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWVJbmRleCAtIDIvKkxBU1RfRlJBTUVfVElNRSovXSAtIGZyYW1lVGltZSk7XG4gICAgICAgIHBlcmNlbnQgPSB0aGlzLmN1cnZlcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWVJbmRleCAvIDIgLSAxLCBwZXJjZW50KTtcblxuICAgICAgICBhbW91bnQgPSBmcmFtZXNbZnJhbWVJbmRleCArIDEvKkZSQU1FX1ZBTFVFKi9dIC0gbGFzdEZyYW1lVmFsdWU7XG4gICAgICAgIHdoaWxlIChhbW91bnQgPiAxODApXG4gICAgICAgICAgICBhbW91bnQgLT0gMzYwO1xuICAgICAgICB3aGlsZSAoYW1vdW50IDwgLTE4MClcbiAgICAgICAgICAgIGFtb3VudCArPSAzNjA7XG4gICAgICAgIGFtb3VudCA9IGJvbmUuZGF0YS5yb3RhdGlvbiArIChsYXN0RnJhbWVWYWx1ZSArIGFtb3VudCAqIHBlcmNlbnQpIC0gYm9uZS5yb3RhdGlvbjtcbiAgICAgICAgd2hpbGUgKGFtb3VudCA+IDE4MClcbiAgICAgICAgICAgIGFtb3VudCAtPSAzNjA7XG4gICAgICAgIHdoaWxlIChhbW91bnQgPCAtMTgwKVxuICAgICAgICAgICAgYW1vdW50ICs9IDM2MDtcbiAgICAgICAgYm9uZS5yb3RhdGlvbiArPSBhbW91bnQgKiBhbHBoYTtcbiAgICB9XG59O1xuXG5zcGluZS5UcmFuc2xhdGVUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KSB7XG4gICAgdGhpcy5jdXJ2ZXMgPSBuZXcgc3BpbmUuQ3VydmVzKGZyYW1lQ291bnQpO1xuICAgIHRoaXMuZnJhbWVzID0gW107IC8vIHRpbWUsIHgsIHksIC4uLlxuICAgIHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQgKiAzO1xufTtcbnNwaW5lLlRyYW5zbGF0ZVRpbWVsaW5lLnByb3RvdHlwZSA9IHtcbiAgICBib25lSW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoIC8gMztcbiAgICB9LFxuICAgIHNldEZyYW1lOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgeCwgeSkge1xuICAgICAgICBmcmFtZUluZGV4ICo9IDM7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDFdID0geDtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDJdID0geTtcbiAgICB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24sIHRpbWUsIGFscGhhKSB7XG4gICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcbiAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHJldHVybjsgLy8gVGltZSBpcyBiZWZvcmUgZmlyc3QgZnJhbWUuXG5cbiAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1t0aGlzLmJvbmVJbmRleF07XG5cbiAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAzXSkgeyAvLyBUaW1lIGlzIGFmdGVyIGxhc3QgZnJhbWUuXG4gICAgICAgICAgICBib25lLnggKz0gKGJvbmUuZGF0YS54ICsgZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAyXSAtIGJvbmUueCkgKiBhbHBoYTtcbiAgICAgICAgICAgIGJvbmUueSArPSAoYm9uZS5kYXRhLnkgKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdIC0gYm9uZS55KSAqIGFscGhhO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICAgIHZhciBmcmFtZUluZGV4ID0gc3BpbmUuYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgMyk7XG4gICAgICAgIHZhciBsYXN0RnJhbWVYID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAyXTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVkgPSBmcmFtZXNbZnJhbWVJbmRleCAtIDFdO1xuICAgICAgICB2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lSW5kZXhdO1xuICAgICAgICB2YXIgcGVyY2VudCA9IDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAtMy8qTEFTVF9GUkFNRV9USU1FKi9dIC0gZnJhbWVUaW1lKTtcbiAgICAgICAgcGVyY2VudCA9IHRoaXMuY3VydmVzLmdldEN1cnZlUGVyY2VudChmcmFtZUluZGV4IC8gMyAtIDEsIHBlcmNlbnQpO1xuXG4gICAgICAgIGJvbmUueCArPSAoYm9uZS5kYXRhLnggKyBsYXN0RnJhbWVYICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMS8qRlJBTUVfWCovXSAtIGxhc3RGcmFtZVgpICogcGVyY2VudCAtIGJvbmUueCkgKiBhbHBoYTtcbiAgICAgICAgYm9uZS55ICs9IChib25lLmRhdGEueSArIGxhc3RGcmFtZVkgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAyLypGUkFNRV9ZKi9dIC0gbGFzdEZyYW1lWSkgKiBwZXJjZW50IC0gYm9uZS55KSAqIGFscGhhO1xuICAgIH1cbn07XG5cbnNwaW5lLlNjYWxlVGltZWxpbmUgPSBmdW5jdGlvbiAoZnJhbWVDb3VudCkge1xuICAgIHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcbiAgICB0aGlzLmZyYW1lcyA9IFtdOyAvLyB0aW1lLCB4LCB5LCAuLi5cbiAgICB0aGlzLmZyYW1lcy5sZW5ndGggPSBmcmFtZUNvdW50ICogMztcbn07XG5zcGluZS5TY2FsZVRpbWVsaW5lLnByb3RvdHlwZSA9IHtcbiAgICBib25lSW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoIC8gMztcbiAgICB9LFxuICAgIHNldEZyYW1lOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgeCwgeSkge1xuICAgICAgICBmcmFtZUluZGV4ICo9IDM7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDFdID0geDtcbiAgICAgICAgdGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDJdID0geTtcbiAgICB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24sIHRpbWUsIGFscGhhKSB7XG4gICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcbiAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHJldHVybjsgLy8gVGltZSBpcyBiZWZvcmUgZmlyc3QgZnJhbWUuXG5cbiAgICAgICAgdmFyIGJvbmUgPSBza2VsZXRvbi5ib25lc1t0aGlzLmJvbmVJbmRleF07XG5cbiAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAzXSkgeyAvLyBUaW1lIGlzIGFmdGVyIGxhc3QgZnJhbWUuXG4gICAgICAgICAgICBib25lLnNjYWxlWCArPSAoYm9uZS5kYXRhLnNjYWxlWCAtIDEgKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDJdIC0gYm9uZS5zY2FsZVgpICogYWxwaGE7XG4gICAgICAgICAgICBib25lLnNjYWxlWSArPSAoYm9uZS5kYXRhLnNjYWxlWSAtIDEgKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdIC0gYm9uZS5zY2FsZVkpICogYWxwaGE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSBzcGluZS5iaW5hcnlTZWFyY2goZnJhbWVzLCB0aW1lLCAzKTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVggPSBmcmFtZXNbZnJhbWVJbmRleCAtIDJdO1xuICAgICAgICB2YXIgbGFzdEZyYW1lWSA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMV07XG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVJbmRleF07XG4gICAgICAgIHZhciBwZXJjZW50ID0gMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWVJbmRleCArIC0zLypMQVNUX0ZSQU1FX1RJTUUqL10gLSBmcmFtZVRpbWUpO1xuICAgICAgICBwZXJjZW50ID0gdGhpcy5jdXJ2ZXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lSW5kZXggLyAzIC0gMSwgcGVyY2VudCk7XG5cbiAgICAgICAgYm9uZS5zY2FsZVggKz0gKGJvbmUuZGF0YS5zY2FsZVggLSAxICsgbGFzdEZyYW1lWCArIChmcmFtZXNbZnJhbWVJbmRleCArIDEvKkZSQU1FX1gqL10gLSBsYXN0RnJhbWVYKSAqIHBlcmNlbnQgLSBib25lLnNjYWxlWCkgKiBhbHBoYTtcbiAgICAgICAgYm9uZS5zY2FsZVkgKz0gKGJvbmUuZGF0YS5zY2FsZVkgLSAxICsgbGFzdEZyYW1lWSArIChmcmFtZXNbZnJhbWVJbmRleCArIDIvKkZSQU1FX1kqL10gLSBsYXN0RnJhbWVZKSAqIHBlcmNlbnQgLSBib25lLnNjYWxlWSkgKiBhbHBoYTtcbiAgICB9XG59O1xuXG5zcGluZS5Db2xvclRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpIHtcbiAgICB0aGlzLmN1cnZlcyA9IG5ldyBzcGluZS5DdXJ2ZXMoZnJhbWVDb3VudCk7XG4gICAgdGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgciwgZywgYiwgYSwgLi4uXG4gICAgdGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudCAqIDU7XG59O1xuc3BpbmUuQ29sb3JUaW1lbGluZS5wcm90b3R5cGUgPSB7XG4gICAgc2xvdEluZGV4OiAwLFxuICAgIGdldEZyYW1lQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDI7XG4gICAgfSxcbiAgICBzZXRGcmFtZTogZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHgsIHkpIHtcbiAgICAgICAgZnJhbWVJbmRleCAqPSA1O1xuICAgICAgICB0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSA9IHI7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAyXSA9IGc7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAzXSA9IGI7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyA0XSA9IGE7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCB0aW1lLCBhbHBoYSkge1xuICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG4gICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKSByZXR1cm47IC8vIFRpbWUgaXMgYmVmb3JlIGZpcnN0IGZyYW1lLlxuXG4gICAgICAgIHZhciBzbG90ID0gc2tlbGV0b24uc2xvdHNbdGhpcy5zbG90SW5kZXhdO1xuXG4gICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gNV0pIHsgLy8gVGltZSBpcyBhZnRlciBsYXN0IGZyYW1lLlxuICAgICAgICAgICAgdmFyIGkgPSBmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHNsb3QuciA9IGZyYW1lc1tpIC0gM107XG4gICAgICAgICAgICBzbG90LmcgPSBmcmFtZXNbaSAtIDJdO1xuICAgICAgICAgICAgc2xvdC5iID0gZnJhbWVzW2kgLSAxXTtcbiAgICAgICAgICAgIHNsb3QuYSA9IGZyYW1lc1tpXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAgICB2YXIgZnJhbWVJbmRleCA9IHNwaW5lLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDUpO1xuICAgICAgICB2YXIgbGFzdEZyYW1lUiA9IGZyYW1lc1tmcmFtZUluZGV4IC0gNF07XG4gICAgICAgIHZhciBsYXN0RnJhbWVHID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAzXTtcbiAgICAgICAgdmFyIGxhc3RGcmFtZUIgPSBmcmFtZXNbZnJhbWVJbmRleCAtIDJdO1xuICAgICAgICB2YXIgbGFzdEZyYW1lQSA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMV07XG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVJbmRleF07XG4gICAgICAgIHZhciBwZXJjZW50ID0gMSAtICh0aW1lIC0gZnJhbWVUaW1lKSAvIChmcmFtZXNbZnJhbWVJbmRleCAtIDUvKkxBU1RfRlJBTUVfVElNRSovXSAtIGZyYW1lVGltZSk7XG4gICAgICAgIHBlcmNlbnQgPSB0aGlzLmN1cnZlcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWVJbmRleCAvIDUgLSAxLCBwZXJjZW50KTtcblxuICAgICAgICB2YXIgciA9IGxhc3RGcmFtZVIgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAxLypGUkFNRV9SKi9dIC0gbGFzdEZyYW1lUikgKiBwZXJjZW50O1xuICAgICAgICB2YXIgZyA9IGxhc3RGcmFtZUcgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAyLypGUkFNRV9HKi9dIC0gbGFzdEZyYW1lRykgKiBwZXJjZW50O1xuICAgICAgICB2YXIgYiA9IGxhc3RGcmFtZUIgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAzLypGUkFNRV9CKi9dIC0gbGFzdEZyYW1lQikgKiBwZXJjZW50O1xuICAgICAgICB2YXIgYSA9IGxhc3RGcmFtZUEgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyA0LypGUkFNRV9BKi9dIC0gbGFzdEZyYW1lQSkgKiBwZXJjZW50O1xuICAgICAgICBpZiAoYWxwaGEgPCAxKSB7XG4gICAgICAgICAgICBzbG90LnIgKz0gKHIgLSBzbG90LnIpICogYWxwaGE7XG4gICAgICAgICAgICBzbG90LmcgKz0gKGcgLSBzbG90LmcpICogYWxwaGE7XG4gICAgICAgICAgICBzbG90LmIgKz0gKGIgLSBzbG90LmIpICogYWxwaGE7XG4gICAgICAgICAgICBzbG90LmEgKz0gKGEgLSBzbG90LmEpICogYWxwaGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbG90LnIgPSByO1xuICAgICAgICAgICAgc2xvdC5nID0gZztcbiAgICAgICAgICAgIHNsb3QuYiA9IGI7XG4gICAgICAgICAgICBzbG90LmEgPSBhO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuc3BpbmUuQXR0YWNobWVudFRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpIHtcbiAgICB0aGlzLmN1cnZlcyA9IG5ldyBzcGluZS5DdXJ2ZXMoZnJhbWVDb3VudCk7XG4gICAgdGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgLi4uXG4gICAgdGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudDtcbiAgICB0aGlzLmF0dGFjaG1lbnROYW1lcyA9IFtdOyAvLyB0aW1lLCAuLi5cbiAgICB0aGlzLmF0dGFjaG1lbnROYW1lcy5sZW5ndGggPSBmcmFtZUNvdW50O1xufTtcbnNwaW5lLkF0dGFjaG1lbnRUaW1lbGluZS5wcm90b3R5cGUgPSB7XG4gICAgc2xvdEluZGV4OiAwLFxuICAgIGdldEZyYW1lQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGg7XG4gICAgfSxcbiAgICBzZXRGcmFtZTogZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIGF0dGFjaG1lbnROYW1lKSB7XG4gICAgICAgIHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcbiAgICAgICAgdGhpcy5hdHRhY2htZW50TmFtZXNbZnJhbWVJbmRleF0gPSBhdHRhY2htZW50TmFtZTtcbiAgICB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24sIHRpbWUsIGFscGhhKSB7XG4gICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcbiAgICAgICAgaWYgKHRpbWUgPCBmcmFtZXNbMF0pIHJldHVybjsgLy8gVGltZSBpcyBiZWZvcmUgZmlyc3QgZnJhbWUuXG5cbiAgICAgICAgdmFyIGZyYW1lSW5kZXg7XG4gICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0pIC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cbiAgICAgICAgICAgIGZyYW1lSW5kZXggPSBmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZnJhbWVJbmRleCA9IHNwaW5lLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDEpIC0gMTtcblxuICAgICAgICB2YXIgYXR0YWNobWVudE5hbWUgPSB0aGlzLmF0dGFjaG1lbnROYW1lc1tmcmFtZUluZGV4XTtcbiAgICAgICAgc2tlbGV0b24uc2xvdHNbdGhpcy5zbG90SW5kZXhdLnNldEF0dGFjaG1lbnQoIWF0dGFjaG1lbnROYW1lID8gbnVsbCA6IHNrZWxldG9uLmdldEF0dGFjaG1lbnRCeVNsb3RJbmRleCh0aGlzLnNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpKTtcbiAgICB9XG59O1xuXG5zcGluZS5Ta2VsZXRvbkRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ib25lcyA9IFtdO1xuICAgIHRoaXMuc2xvdHMgPSBbXTtcbiAgICB0aGlzLnNraW5zID0gW107XG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG59O1xuc3BpbmUuU2tlbGV0b25EYXRhLnByb3RvdHlwZSA9IHtcbiAgICBkZWZhdWx0U2tpbjogbnVsbCxcbiAgICAvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBmaW5kQm9uZTogZnVuY3Rpb24gKGJvbmVOYW1lKSB7XG4gICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKGJvbmVzW2ldLm5hbWUgPT0gYm9uZU5hbWUpIHJldHVybiBib25lc1tpXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiAtMSBpZiB0aGUgYm9uZSB3YXMgbm90IGZvdW5kLiAqL1xuICAgIGZpbmRCb25lSW5kZXg6IGZ1bmN0aW9uIChib25lTmFtZSkge1xuICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChib25lc1tpXS5uYW1lID09IGJvbmVOYW1lKSByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZmluZFNsb3Q6IGZ1bmN0aW9uIChzbG90TmFtZSkge1xuICAgICAgICB2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHNsb3RzW2ldLm5hbWUgPT0gc2xvdE5hbWUpIHJldHVybiBzbG90W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gLTEgaWYgdGhlIGJvbmUgd2FzIG5vdCBmb3VuZC4gKi9cbiAgICBmaW5kU2xvdEluZGV4OiBmdW5jdGlvbiAoc2xvdE5hbWUpIHtcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoc2xvdHNbaV0ubmFtZSA9PSBzbG90TmFtZSkgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRTa2luOiBmdW5jdGlvbiAoc2tpbk5hbWUpIHtcbiAgICAgICAgdmFyIHNraW5zID0gdGhpcy5za2lucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBza2lucy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoc2tpbnNbaV0ubmFtZSA9PSBza2luTmFtZSkgcmV0dXJuIHNraW5zW2ldO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRBbmltYXRpb246IGZ1bmN0aW9uIChhbmltYXRpb25OYW1lKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbnNbaV0ubmFtZSA9PSBhbmltYXRpb25OYW1lKSByZXR1cm4gYW5pbWF0aW9uc1tpXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuc3BpbmUuU2tlbGV0b24gPSBmdW5jdGlvbiAoc2tlbGV0b25EYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gc2tlbGV0b25EYXRhO1xuXG4gICAgdGhpcy5ib25lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2tlbGV0b25EYXRhLmJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgYm9uZURhdGEgPSBza2VsZXRvbkRhdGEuYm9uZXNbaV07XG4gICAgICAgIHZhciBwYXJlbnQgPSAhYm9uZURhdGEucGFyZW50ID8gbnVsbCA6IHRoaXMuYm9uZXNbc2tlbGV0b25EYXRhLmJvbmVzLmluZGV4T2YoYm9uZURhdGEucGFyZW50KV07XG4gICAgICAgIHRoaXMuYm9uZXMucHVzaChuZXcgc3BpbmUuQm9uZShib25lRGF0YSwgcGFyZW50KSk7XG4gICAgfVxuXG4gICAgdGhpcy5zbG90cyA9IFtdO1xuICAgIHRoaXMuZHJhd09yZGVyID0gW107XG4gICAgZm9yIChpID0gMCwgbiA9IHNrZWxldG9uRGF0YS5zbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHNsb3REYXRhID0gc2tlbGV0b25EYXRhLnNsb3RzW2ldO1xuICAgICAgICB2YXIgYm9uZSA9IHRoaXMuYm9uZXNbc2tlbGV0b25EYXRhLmJvbmVzLmluZGV4T2Yoc2xvdERhdGEuYm9uZURhdGEpXTtcbiAgICAgICAgdmFyIHNsb3QgPSBuZXcgc3BpbmUuU2xvdChzbG90RGF0YSwgdGhpcywgYm9uZSk7XG4gICAgICAgIHRoaXMuc2xvdHMucHVzaChzbG90KTtcbiAgICAgICAgdGhpcy5kcmF3T3JkZXIucHVzaChzbG90KTtcbiAgICB9XG59O1xuc3BpbmUuU2tlbGV0b24ucHJvdG90eXBlID0ge1xuICAgIHg6IDAsIHk6IDAsXG4gICAgc2tpbjogbnVsbCxcbiAgICByOiAxLCBnOiAxLCBiOiAxLCBhOiAxLFxuICAgIHRpbWU6IDAsXG4gICAgZmxpcFg6IGZhbHNlLCBmbGlwWTogZmFsc2UsXG4gICAgLyoqIFVwZGF0ZXMgdGhlIHdvcmxkIHRyYW5zZm9ybSBmb3IgZWFjaCBib25lLiAqL1xuICAgIHVwZGF0ZVdvcmxkVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbGlwWCA9IHRoaXMuZmxpcFg7XG4gICAgICAgIHZhciBmbGlwWSA9IHRoaXMuZmxpcFk7XG4gICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgYm9uZXNbaV0udXBkYXRlV29ybGRUcmFuc2Zvcm0oZmxpcFgsIGZsaXBZKTtcbiAgICB9LFxuICAgIC8qKiBTZXRzIHRoZSBib25lcyBhbmQgc2xvdHMgdG8gdGhlaXIgc2V0dXAgcG9zZSB2YWx1ZXMuICovXG4gICAgc2V0VG9TZXR1cFBvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRCb25lc1RvU2V0dXBQb3NlKCk7XG4gICAgICAgIHRoaXMuc2V0U2xvdHNUb1NldHVwUG9zZSgpO1xuICAgIH0sXG4gICAgc2V0Qm9uZXNUb1NldHVwUG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGJvbmVzW2ldLnNldFRvU2V0dXBQb3NlKCk7XG4gICAgfSxcbiAgICBzZXRTbG90c1RvU2V0dXBQb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgc2xvdHNbaV0uc2V0VG9TZXR1cFBvc2UoaSk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiBNYXkgcmV0dXJuIG51bGwuICovXG4gICAgZ2V0Um9vdEJvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9uZXMubGVuZ3RoID8gdGhpcy5ib25lc1swXSA6IG51bGw7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBmaW5kQm9uZTogZnVuY3Rpb24gKGJvbmVOYW1lKSB7XG4gICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKGJvbmVzW2ldLmRhdGEubmFtZSA9PSBib25lTmFtZSkgcmV0dXJuIGJvbmVzW2ldO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIC0xIGlmIHRoZSBib25lIHdhcyBub3QgZm91bmQuICovXG4gICAgZmluZEJvbmVJbmRleDogZnVuY3Rpb24gKGJvbmVOYW1lKSB7XG4gICAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYm9uZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgaWYgKGJvbmVzW2ldLmRhdGEubmFtZSA9PSBib25lTmFtZSkgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRTbG90OiBmdW5jdGlvbiAoc2xvdE5hbWUpIHtcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoc2xvdHNbaV0uZGF0YS5uYW1lID09IHNsb3ROYW1lKSByZXR1cm4gc2xvdHNbaV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gLTEgaWYgdGhlIGJvbmUgd2FzIG5vdCBmb3VuZC4gKi9cbiAgICBmaW5kU2xvdEluZGV4OiBmdW5jdGlvbiAoc2xvdE5hbWUpIHtcbiAgICAgICAgdmFyIHNsb3RzID0gdGhpcy5zbG90cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBpZiAoc2xvdHNbaV0uZGF0YS5uYW1lID09IHNsb3ROYW1lKSByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgc2V0U2tpbkJ5TmFtZTogZnVuY3Rpb24gKHNraW5OYW1lKSB7XG4gICAgICAgIHZhciBza2luID0gdGhpcy5kYXRhLmZpbmRTa2luKHNraW5OYW1lKTtcbiAgICAgICAgaWYgKCFza2luKSB0aHJvdyBcIlNraW4gbm90IGZvdW5kOiBcIiArIHNraW5OYW1lO1xuICAgICAgICB0aGlzLnNldFNraW4oc2tpbik7XG4gICAgfSxcbiAgICAvKiogU2V0cyB0aGUgc2tpbiB1c2VkIHRvIGxvb2sgdXAgYXR0YWNobWVudHMgbm90IGZvdW5kIGluIHRoZSB7QGxpbmsgU2tlbGV0b25EYXRhI2dldERlZmF1bHRTa2luKCkgZGVmYXVsdCBza2lufS4gQXR0YWNobWVudHNcbiAgICAgKiBmcm9tIHRoZSBuZXcgc2tpbiBhcmUgYXR0YWNoZWQgaWYgdGhlIGNvcnJlc3BvbmRpbmcgYXR0YWNobWVudCBmcm9tIHRoZSBvbGQgc2tpbiB3YXMgYXR0YWNoZWQuXG4gICAgICogQHBhcmFtIG5ld1NraW4gTWF5IGJlIG51bGwuICovXG4gICAgc2V0U2tpbjogZnVuY3Rpb24gKG5ld1NraW4pIHtcbiAgICAgICAgaWYgKHRoaXMuc2tpbiAmJiBuZXdTa2luKSBuZXdTa2luLl9hdHRhY2hBbGwodGhpcywgdGhpcy5za2luKTtcbiAgICAgICAgdGhpcy5za2luID0gbmV3U2tpbjtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGdldEF0dGFjaG1lbnRCeVNsb3ROYW1lOiBmdW5jdGlvbiAoc2xvdE5hbWUsIGF0dGFjaG1lbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dGFjaG1lbnRCeVNsb3RJbmRleCh0aGlzLmRhdGEuZmluZFNsb3RJbmRleChzbG90TmFtZSksIGF0dGFjaG1lbnROYW1lKTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGdldEF0dGFjaG1lbnRCeVNsb3RJbmRleDogZnVuY3Rpb24gKHNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2tpbikge1xuICAgICAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGlzLnNraW4uZ2V0QXR0YWNobWVudChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKTtcbiAgICAgICAgICAgIGlmIChhdHRhY2htZW50KSByZXR1cm4gYXR0YWNobWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhLmRlZmF1bHRTa2luKSByZXR1cm4gdGhpcy5kYXRhLmRlZmF1bHRTa2luLmdldEF0dGFjaG1lbnQoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqIEBwYXJhbSBhdHRhY2htZW50TmFtZSBNYXkgYmUgbnVsbC4gKi9cbiAgICBzZXRBdHRhY2htZW50OiBmdW5jdGlvbiAoc2xvdE5hbWUsIGF0dGFjaG1lbnROYW1lKSB7XG4gICAgICAgIHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMuc2l6ZTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tpXTtcbiAgICAgICAgICAgIGlmIChzbG90LmRhdGEubmFtZSA9PSBzbG90TmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudCA9IHRoaXMuZ2V0QXR0YWNobWVudChpLCBhdHRhY2htZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50ID09IG51bGwpIHRocm93IFwiQXR0YWNobWVudCBub3QgZm91bmQ6IFwiICsgYXR0YWNobWVudE5hbWUgKyBcIiwgZm9yIHNsb3Q6IFwiICsgc2xvdE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsb3Quc2V0QXR0YWNobWVudChhdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgXCJTbG90IG5vdCBmb3VuZDogXCIgKyBzbG90TmFtZTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHRpbWUgKz0gZGVsdGE7XG4gICAgfVxufTtcblxuc3BpbmUuQXR0YWNobWVudFR5cGUgPSB7XG4gICAgcmVnaW9uOiAwXG59O1xuXG5zcGluZS5SZWdpb25BdHRhY2htZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub2Zmc2V0ID0gW107XG4gICAgdGhpcy5vZmZzZXQubGVuZ3RoID0gODtcbiAgICB0aGlzLnV2cyA9IFtdO1xuICAgIHRoaXMudXZzLmxlbmd0aCA9IDg7XG59O1xuc3BpbmUuUmVnaW9uQXR0YWNobWVudC5wcm90b3R5cGUgPSB7XG4gICAgeDogMCwgeTogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICBzY2FsZVg6IDEsIHNjYWxlWTogMSxcbiAgICB3aWR0aDogMCwgaGVpZ2h0OiAwLFxuICAgIHJlbmRlcmVyT2JqZWN0OiBudWxsLFxuICAgIHJlZ2lvbk9mZnNldFg6IDAsIHJlZ2lvbk9mZnNldFk6IDAsXG4gICAgcmVnaW9uV2lkdGg6IDAsIHJlZ2lvbkhlaWdodDogMCxcbiAgICByZWdpb25PcmlnaW5hbFdpZHRoOiAwLCByZWdpb25PcmlnaW5hbEhlaWdodDogMCxcbiAgICBzZXRVVnM6IGZ1bmN0aW9uICh1LCB2LCB1MiwgdjIsIHJvdGF0ZSkge1xuICAgICAgICB2YXIgdXZzID0gdGhpcy51dnM7XG4gICAgICAgIGlmIChyb3RhdGUpIHtcbiAgICAgICAgICAgIHV2c1syLypYMiovXSA9IHU7XG4gICAgICAgICAgICB1dnNbMy8qWTIqL10gPSB2MjtcbiAgICAgICAgICAgIHV2c1s0LypYMyovXSA9IHU7XG4gICAgICAgICAgICB1dnNbNS8qWTMqL10gPSB2O1xuICAgICAgICAgICAgdXZzWzYvKlg0Ki9dID0gdTI7XG4gICAgICAgICAgICB1dnNbNy8qWTQqL10gPSB2O1xuICAgICAgICAgICAgdXZzWzAvKlgxKi9dID0gdTI7XG4gICAgICAgICAgICB1dnNbMS8qWTEqL10gPSB2MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV2c1swLypYMSovXSA9IHU7XG4gICAgICAgICAgICB1dnNbMS8qWTEqL10gPSB2MjtcbiAgICAgICAgICAgIHV2c1syLypYMiovXSA9IHU7XG4gICAgICAgICAgICB1dnNbMy8qWTIqL10gPSB2O1xuICAgICAgICAgICAgdXZzWzQvKlgzKi9dID0gdTI7XG4gICAgICAgICAgICB1dnNbNS8qWTMqL10gPSB2O1xuICAgICAgICAgICAgdXZzWzYvKlg0Ki9dID0gdTI7XG4gICAgICAgICAgICB1dnNbNy8qWTQqL10gPSB2MjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlT2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWdpb25TY2FsZVggPSB0aGlzLndpZHRoIC8gdGhpcy5yZWdpb25PcmlnaW5hbFdpZHRoICogdGhpcy5zY2FsZVg7XG4gICAgICAgIHZhciByZWdpb25TY2FsZVkgPSB0aGlzLmhlaWdodCAvIHRoaXMucmVnaW9uT3JpZ2luYWxIZWlnaHQgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgdmFyIGxvY2FsWCA9IC10aGlzLndpZHRoIC8gMiAqIHRoaXMuc2NhbGVYICsgdGhpcy5yZWdpb25PZmZzZXRYICogcmVnaW9uU2NhbGVYO1xuICAgICAgICB2YXIgbG9jYWxZID0gLXRoaXMuaGVpZ2h0IC8gMiAqIHRoaXMuc2NhbGVZICsgdGhpcy5yZWdpb25PZmZzZXRZICogcmVnaW9uU2NhbGVZO1xuICAgICAgICB2YXIgbG9jYWxYMiA9IGxvY2FsWCArIHRoaXMucmVnaW9uV2lkdGggKiByZWdpb25TY2FsZVg7XG4gICAgICAgIHZhciBsb2NhbFkyID0gbG9jYWxZICsgdGhpcy5yZWdpb25IZWlnaHQgKiByZWdpb25TY2FsZVk7XG4gICAgICAgIHZhciByYWRpYW5zID0gdGhpcy5yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHJhZGlhbnMpO1xuICAgICAgICB2YXIgbG9jYWxYQ29zID0gbG9jYWxYICogY29zICsgdGhpcy54O1xuICAgICAgICB2YXIgbG9jYWxYU2luID0gbG9jYWxYICogc2luO1xuICAgICAgICB2YXIgbG9jYWxZQ29zID0gbG9jYWxZICogY29zICsgdGhpcy55O1xuICAgICAgICB2YXIgbG9jYWxZU2luID0gbG9jYWxZICogc2luO1xuICAgICAgICB2YXIgbG9jYWxYMkNvcyA9IGxvY2FsWDIgKiBjb3MgKyB0aGlzLng7XG4gICAgICAgIHZhciBsb2NhbFgyU2luID0gbG9jYWxYMiAqIHNpbjtcbiAgICAgICAgdmFyIGxvY2FsWTJDb3MgPSBsb2NhbFkyICogY29zICsgdGhpcy55O1xuICAgICAgICB2YXIgbG9jYWxZMlNpbiA9IGxvY2FsWTIgKiBzaW47XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgb2Zmc2V0WzAvKlgxKi9dID0gbG9jYWxYQ29zIC0gbG9jYWxZU2luO1xuICAgICAgICBvZmZzZXRbMS8qWTEqL10gPSBsb2NhbFlDb3MgKyBsb2NhbFhTaW47XG4gICAgICAgIG9mZnNldFsyLypYMiovXSA9IGxvY2FsWENvcyAtIGxvY2FsWTJTaW47XG4gICAgICAgIG9mZnNldFszLypZMiovXSA9IGxvY2FsWTJDb3MgKyBsb2NhbFhTaW47XG4gICAgICAgIG9mZnNldFs0LypYMyovXSA9IGxvY2FsWDJDb3MgLSBsb2NhbFkyU2luO1xuICAgICAgICBvZmZzZXRbNS8qWTMqL10gPSBsb2NhbFkyQ29zICsgbG9jYWxYMlNpbjtcbiAgICAgICAgb2Zmc2V0WzYvKlg0Ki9dID0gbG9jYWxYMkNvcyAtIGxvY2FsWVNpbjtcbiAgICAgICAgb2Zmc2V0WzcvKlk0Ki9dID0gbG9jYWxZQ29zICsgbG9jYWxYMlNpbjtcbiAgICB9LFxuICAgIGNvbXB1dGVWZXJ0aWNlczogZnVuY3Rpb24gKHgsIHksIGJvbmUsIHZlcnRpY2VzKSB7XG4gICAgICAgIHggKz0gYm9uZS53b3JsZFg7XG4gICAgICAgIHkgKz0gYm9uZS53b3JsZFk7XG4gICAgICAgIHZhciBtMDAgPSBib25lLm0wMDtcbiAgICAgICAgdmFyIG0wMSA9IGJvbmUubTAxO1xuICAgICAgICB2YXIgbTEwID0gYm9uZS5tMTA7XG4gICAgICAgIHZhciBtMTEgPSBib25lLm0xMTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2ZXJ0aWNlc1swLypYMSovXSA9IG9mZnNldFswLypYMSovXSAqIG0wMCArIG9mZnNldFsxLypZMSovXSAqIG0wMSArIHg7XG4gICAgICAgIHZlcnRpY2VzWzEvKlkxKi9dID0gb2Zmc2V0WzAvKlgxKi9dICogbTEwICsgb2Zmc2V0WzEvKlkxKi9dICogbTExICsgeTtcbiAgICAgICAgdmVydGljZXNbMi8qWDIqL10gPSBvZmZzZXRbMi8qWDIqL10gKiBtMDAgKyBvZmZzZXRbMy8qWTIqL10gKiBtMDEgKyB4O1xuICAgICAgICB2ZXJ0aWNlc1szLypZMiovXSA9IG9mZnNldFsyLypYMiovXSAqIG0xMCArIG9mZnNldFszLypZMiovXSAqIG0xMSArIHk7XG4gICAgICAgIHZlcnRpY2VzWzQvKlgzKi9dID0gb2Zmc2V0WzQvKlgzKi9dICogbTAwICsgb2Zmc2V0WzUvKlgzKi9dICogbTAxICsgeDtcbiAgICAgICAgdmVydGljZXNbNS8qWDMqL10gPSBvZmZzZXRbNC8qWDMqL10gKiBtMTAgKyBvZmZzZXRbNS8qWDMqL10gKiBtMTEgKyB5O1xuICAgICAgICB2ZXJ0aWNlc1s2LypYNCovXSA9IG9mZnNldFs2LypYNCovXSAqIG0wMCArIG9mZnNldFs3LypZNCovXSAqIG0wMSArIHg7XG4gICAgICAgIHZlcnRpY2VzWzcvKlk0Ki9dID0gb2Zmc2V0WzYvKlg0Ki9dICogbTEwICsgb2Zmc2V0WzcvKlk0Ki9dICogbTExICsgeTtcbiAgICB9XG59XG5cbnNwaW5lLkFuaW1hdGlvblN0YXRlRGF0YSA9IGZ1bmN0aW9uIChza2VsZXRvbkRhdGEpIHtcbiAgICB0aGlzLnNrZWxldG9uRGF0YSA9IHNrZWxldG9uRGF0YTtcbiAgICB0aGlzLmFuaW1hdGlvblRvTWl4VGltZSA9IHt9O1xufTtcbnNwaW5lLkFuaW1hdGlvblN0YXRlRGF0YS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGRlZmF1bHRNaXg6IDAsXG4gICAgc2V0TWl4QnlOYW1lOiBmdW5jdGlvbiAoZnJvbU5hbWUsIHRvTmFtZSwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGZyb21OYW1lKTtcbiAgICAgICAgaWYgKCFmcm9tKSB0aHJvdyBcIkFuaW1hdGlvbiBub3QgZm91bmQ6IFwiICsgZnJvbU5hbWU7XG4gICAgICAgIHZhciB0byA9IHRoaXMuc2tlbGV0b25EYXRhLmZpbmRBbmltYXRpb24odG9OYW1lKTtcbiAgICAgICAgaWYgKCF0bykgdGhyb3cgXCJBbmltYXRpb24gbm90IGZvdW5kOiBcIiArIHRvTmFtZTtcbiAgICAgICAgdGhpcy5zZXRNaXgoZnJvbSwgdG8sIGR1cmF0aW9uKTtcbiAgICB9LFxuICAgIHNldE1peDogZnVuY3Rpb24gKGZyb20sIHRvLCBkdXJhdGlvbikge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblRvTWl4VGltZVtmcm9tLm5hbWUgKyBcIjpcIiArIHRvLm5hbWVdID0gZHVyYXRpb247XG4gICAgfSxcbiAgICBnZXRNaXg6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICB2YXIgdGltZSA9IHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lW2Zyb20ubmFtZSArIFwiOlwiICsgdG8ubmFtZV07XG4gICAgICAgICAgICByZXR1cm4gdGltZSA/IHRpbWUgOiB0aGlzLmRlZmF1bHRNaXg7XG4gICAgfVxufTtcblxuc3BpbmUuQW5pbWF0aW9uU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGVEYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gc3RhdGVEYXRhO1xuICAgIHRoaXMucXVldWUgPSBbXTtcbn07XG5zcGluZS5BbmltYXRpb25TdGF0ZS5wcm90b3R5cGUgPSB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICBwcmV2aW91czogbnVsbCxcbiAgICBjdXJyZW50VGltZTogMCxcbiAgICBwcmV2aW91c1RpbWU6IDAsXG4gICAgY3VycmVudExvb3A6IGZhbHNlLFxuICAgIHByZXZpb3VzTG9vcDogZmFsc2UsXG4gICAgbWl4VGltZTogMCxcbiAgICBtaXhEdXJhdGlvbjogMCxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhO1xuICAgICAgICB0aGlzLnByZXZpb3VzVGltZSArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5taXhUaW1lICs9IGRlbHRhO1xuXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMucXVldWVbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VGltZSA+PSBlbnRyeS5kZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEFuaW1hdGlvbihlbnRyeS5hbmltYXRpb24sIGVudHJ5Lmxvb3ApO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbikge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5hcHBseShza2VsZXRvbiwgdGhpcy5wcmV2aW91c1RpbWUsIHRoaXMucHJldmlvdXNMb29wKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IHRoaXMubWl4VGltZSAvIHRoaXMubWl4RHVyYXRpb247XG4gICAgICAgICAgICBpZiAoYWxwaGEgPj0gMSkge1xuICAgICAgICAgICAgICAgIGFscGhhID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5taXgoc2tlbGV0b24sIHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudExvb3AsIGFscGhhKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYXBwbHkoc2tlbGV0b24sIHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudExvb3ApO1xuICAgIH0sXG4gICAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9zZXRBbmltYXRpb246IGZ1bmN0aW9uIChhbmltYXRpb24sIGxvb3ApIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgdGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLm1peER1cmF0aW9uID0gdGhpcy5kYXRhLmdldE1peCh0aGlzLmN1cnJlbnQsIGFuaW1hdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5taXhEdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1peFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1RpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNMb29wID0gdGhpcy5jdXJyZW50TG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBhbmltYXRpb247XG4gICAgICAgIHRoaXMuY3VycmVudExvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB9LFxuICAgIC8qKiBAc2VlICNzZXRBbmltYXRpb24oQW5pbWF0aW9uLCBCb29sZWFuKSAqL1xuICAgIHNldEFuaW1hdGlvbkJ5TmFtZTogZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWUsIGxvb3ApIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZGF0YS5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbihhbmltYXRpb25OYW1lKTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24pIHRocm93IFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBhbmltYXRpb25OYW1lO1xuICAgICAgICB0aGlzLnNldEFuaW1hdGlvbihhbmltYXRpb24sIGxvb3ApO1xuICAgIH0sXG4gICAgLyoqIFNldCB0aGUgY3VycmVudCBhbmltYXRpb24uIEFueSBxdWV1ZWQgYW5pbWF0aW9ucyBhcmUgY2xlYXJlZCBhbmQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHRpbWUgaXMgc2V0IHRvIDAuXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBNYXkgYmUgbnVsbC4gKi9cbiAgICBzZXRBbmltYXRpb246IGZ1bmN0aW9uIChhbmltYXRpb24sIGxvb3ApIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9zZXRBbmltYXRpb24oYW5pbWF0aW9uLCBsb29wKTtcbiAgICB9LFxuICAgIC8qKiBAc2VlICNhZGRBbmltYXRpb24oQW5pbWF0aW9uLCBCb29sZWFuLCBOdW1iZXIpICovXG4gICAgYWRkQW5pbWF0aW9uQnlOYW1lOiBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSwgbG9vcCwgZGVsYXkpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZGF0YS5za2VsZXRvbkRhdGEuZmluZEFuaW1hdGlvbihhbmltYXRpb25OYW1lKTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24pIHRocm93IFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBhbmltYXRpb25OYW1lO1xuICAgICAgICB0aGlzLmFkZEFuaW1hdGlvbihhbmltYXRpb24sIGxvb3AsIGRlbGF5KTtcbiAgICB9LFxuICAgIC8qKiBBZGRzIGFuIGFuaW1hdGlvbiB0byBiZSBwbGF5ZWQgZGVsYXkgc2Vjb25kcyBhZnRlciB0aGUgY3VycmVudCBvciBsYXN0IHF1ZXVlZCBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIGRlbGF5IE1heSBiZSA8PSAwIHRvIHVzZSBkdXJhdGlvbiBvZiBwcmV2aW91cyBhbmltYXRpb24gbWludXMgYW55IG1peCBkdXJhdGlvbiBwbHVzIHRoZSBuZWdhdGl2ZSBkZWxheS4gKi9cbiAgICBhZGRBbmltYXRpb246IGZ1bmN0aW9uIChhbmltYXRpb24sIGxvb3AsIGRlbGF5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHt9O1xuICAgICAgICBlbnRyeS5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIGVudHJ5Lmxvb3AgPSBsb29wO1xuXG4gICAgICAgIGlmICghZGVsYXkgfHwgZGVsYXkgPD0gMCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzQW5pbWF0aW9uID0gdGhpcy5xdWV1ZS5sZW5ndGggPyB0aGlzLnF1ZXVlW3RoaXMucXVldWUubGVuZ3RoIC0gMV0uYW5pbWF0aW9uIDogdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzQW5pbWF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZGVsYXkgPSBwcmV2aW91c0FuaW1hdGlvbi5kdXJhdGlvbiAtIHRoaXMuZGF0YS5nZXRNaXgocHJldmlvdXNBbmltYXRpb24sIGFuaW1hdGlvbikgKyAoZGVsYXkgfHwgMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LmRlbGF5ID0gZGVsYXk7XG5cbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKGVudHJ5KTtcbiAgICB9LFxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgbm8gYW5pbWF0aW9uIGlzIHNldCBvciBpZiB0aGUgY3VycmVudCB0aW1lIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uLCByZWdhcmRsZXNzIG9mIGxvb3BpbmcuICovXG4gICAgaXNDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY3VycmVudCB8fCB0aGlzLmN1cnJlbnRUaW1lID49IHRoaXMuY3VycmVudC5kdXJhdGlvbjtcbiAgICB9XG59O1xuXG5zcGluZS5Ta2VsZXRvbkpzb24gPSBmdW5jdGlvbiAoYXR0YWNobWVudExvYWRlcikge1xuICAgIHRoaXMuYXR0YWNobWVudExvYWRlciA9IGF0dGFjaG1lbnRMb2FkZXI7XG59O1xuc3BpbmUuU2tlbGV0b25Kc29uLnByb3RvdHlwZSA9IHtcbiAgICBzY2FsZTogMSxcbiAgICByZWFkU2tlbGV0b25EYXRhOiBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAvKmpzaGludCAtVzA2OSovXG4gICAgICAgIHZhciBza2VsZXRvbkRhdGEgPSBuZXcgc3BpbmUuU2tlbGV0b25EYXRhKCksXG4gICAgICAgICAgICBib25lRGF0YTtcblxuICAgICAgICAvLyBCb25lcy5cbiAgICAgICAgdmFyIGJvbmVzID0gcm9vdFtcImJvbmVzXCJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvbmVNYXAgPSBib25lc1tpXTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGJvbmVNYXBbXCJwYXJlbnRcIl0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUoYm9uZU1hcFtcInBhcmVudFwiXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHRocm93IFwiUGFyZW50IGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVNYXBbXCJwYXJlbnRcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib25lRGF0YSA9IG5ldyBzcGluZS5Cb25lRGF0YShib25lTWFwW1wibmFtZVwiXSwgcGFyZW50KTtcbiAgICAgICAgICAgIGJvbmVEYXRhLmxlbmd0aCA9IChib25lTWFwW1wibGVuZ3RoXCJdIHx8IDApICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGJvbmVEYXRhLnggPSAoYm9uZU1hcFtcInhcIl0gfHwgMCkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgYm9uZURhdGEueSA9IChib25lTWFwW1wieVwiXSB8fCAwKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBib25lRGF0YS5yb3RhdGlvbiA9IChib25lTWFwW1wicm90YXRpb25cIl0gfHwgMCk7XG4gICAgICAgICAgICBib25lRGF0YS5zY2FsZVggPSBib25lTWFwW1wic2NhbGVYXCJdIHx8IDE7XG4gICAgICAgICAgICBib25lRGF0YS5zY2FsZVkgPSBib25lTWFwW1wic2NhbGVZXCJdIHx8IDE7XG4gICAgICAgICAgICBza2VsZXRvbkRhdGEuYm9uZXMucHVzaChib25lRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbG90cy5cbiAgICAgICAgdmFyIHNsb3RzID0gcm9vdFtcInNsb3RzXCJdO1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2xvdE1hcCA9IHNsb3RzW2ldO1xuICAgICAgICAgICAgYm9uZURhdGEgPSBza2VsZXRvbkRhdGEuZmluZEJvbmUoc2xvdE1hcFtcImJvbmVcIl0pO1xuICAgICAgICAgICAgaWYgKCFib25lRGF0YSkgdGhyb3cgXCJTbG90IGJvbmUgbm90IGZvdW5kOiBcIiArIHNsb3RNYXBbXCJib25lXCJdO1xuICAgICAgICAgICAgdmFyIHNsb3REYXRhID0gbmV3IHNwaW5lLlNsb3REYXRhKHNsb3RNYXBbXCJuYW1lXCJdLCBib25lRGF0YSk7XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IHNsb3RNYXBbXCJjb2xvclwiXTtcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIHNsb3REYXRhLnIgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMCk7XG4gICAgICAgICAgICAgICAgc2xvdERhdGEuZyA9IHNwaW5lLlNrZWxldG9uSnNvbi50b0NvbG9yKGNvbG9yLCAxKTtcbiAgICAgICAgICAgICAgICBzbG90RGF0YS5iID0gc3BpbmUuU2tlbGV0b25Kc29uLnRvQ29sb3IoY29sb3IsIDIpO1xuICAgICAgICAgICAgICAgIHNsb3REYXRhLmEgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNsb3REYXRhLmF0dGFjaG1lbnROYW1lID0gc2xvdE1hcFtcImF0dGFjaG1lbnRcIl07XG5cbiAgICAgICAgICAgIHNrZWxldG9uRGF0YS5zbG90cy5wdXNoKHNsb3REYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraW5zLlxuICAgICAgICB2YXIgc2tpbnMgPSByb290W1wic2tpbnNcIl07XG4gICAgICAgIGZvciAodmFyIHNraW5OYW1lIGluIHNraW5zKSB7XG4gICAgICAgICAgICBpZiAoIXNraW5zLmhhc093blByb3BlcnR5KHNraW5OYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgc2tpbk1hcCA9IHNraW5zW3NraW5OYW1lXTtcbiAgICAgICAgICAgIHZhciBza2luID0gbmV3IHNwaW5lLlNraW4oc2tpbk5hbWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgc2xvdE5hbWUgaW4gc2tpbk1hcCkge1xuICAgICAgICAgICAgICAgIGlmICghc2tpbk1hcC5oYXNPd25Qcm9wZXJ0eShzbG90TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFNsb3RJbmRleChzbG90TmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNsb3RFbnRyeSA9IHNraW5NYXBbc2xvdE5hbWVdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGF0dGFjaG1lbnROYW1lIGluIHNsb3RFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsb3RFbnRyeS5oYXNPd25Qcm9wZXJ0eShhdHRhY2htZW50TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMucmVhZEF0dGFjaG1lbnQoc2tpbiwgYXR0YWNobWVudE5hbWUsIHNsb3RFbnRyeVthdHRhY2htZW50TmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudCAhPSBudWxsKSBza2luLmFkZEF0dGFjaG1lbnQoc2xvdEluZGV4LCBhdHRhY2htZW50TmFtZSwgYXR0YWNobWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2tlbGV0b25EYXRhLnNraW5zLnB1c2goc2tpbik7XG4gICAgICAgICAgICBpZiAoc2tpbi5uYW1lID09IFwiZGVmYXVsdFwiKSBza2VsZXRvbkRhdGEuZGVmYXVsdFNraW4gPSBza2luO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5pbWF0aW9ucy5cbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSByb290W1wiYW5pbWF0aW9uc1wiXTtcbiAgICAgICAgZm9yICh2YXIgYW5pbWF0aW9uTmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIWFuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkoYW5pbWF0aW9uTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5yZWFkQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUsIGFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0sIHNrZWxldG9uRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2tlbGV0b25EYXRhO1xuICAgIH0sXG4gICAgcmVhZEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChza2luLCBuYW1lLCBtYXApIHtcbiAgICAgICAgLypqc2hpbnQgLVcwNjkqL1xuICAgICAgICBuYW1lID0gbWFwW1wibmFtZVwiXSB8fCBuYW1lO1xuXG4gICAgICAgIHZhciB0eXBlID0gc3BpbmUuQXR0YWNobWVudFR5cGVbbWFwW1widHlwZVwiXSB8fCBcInJlZ2lvblwiXTtcblxuICAgICAgICBpZiAodHlwZSA9PSBzcGluZS5BdHRhY2htZW50VHlwZS5yZWdpb24pIHtcbiAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gbmV3IHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQoKTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQueCA9IChtYXBbXCJ4XCJdIHx8IDApICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQueSA9IChtYXBbXCJ5XCJdIHx8IDApICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQuc2NhbGVYID0gbWFwW1wic2NhbGVYXCJdIHx8IDE7XG4gICAgICAgICAgICBhdHRhY2htZW50LnNjYWxlWSA9IG1hcFtcInNjYWxlWVwiXSB8fCAxO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yb3RhdGlvbiA9IG1hcFtcInJvdGF0aW9uXCJdIHx8IDA7XG4gICAgICAgICAgICBhdHRhY2htZW50LndpZHRoID0gKG1hcFtcIndpZHRoXCJdIHx8IDMyKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBhdHRhY2htZW50LmhlaWdodCA9IChtYXBbXCJoZWlnaHRcIl0gfHwgMzIpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQudXBkYXRlT2Zmc2V0KCk7XG5cbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0LnNjYWxlID0ge307XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0LnNjYWxlLnggPSBhdHRhY2htZW50LnNjYWxlWDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3Quc2NhbGUueSA9IGF0dGFjaG1lbnQuc2NhbGVZO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZW5kZXJlck9iamVjdC5yb3RhdGlvbiA9IC1hdHRhY2htZW50LnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgIHJldHVybiBhdHRhY2htZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IFwiVW5rbm93biBhdHRhY2htZW50IHR5cGU6IFwiICsgdHlwZTtcbiAgICB9LFxuXG4gICAgcmVhZEFuaW1hdGlvbjogZnVuY3Rpb24gKG5hbWUsIG1hcCwgc2tlbGV0b25EYXRhKSB7XG4gICAgICAgIC8qanNoaW50IC1XMDY5Ki9cbiAgICAgICAgdmFyIHRpbWVsaW5lcyA9IFtdO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgZnJhbWVJbmRleCwgdGltZWxpbmUsIHRpbWVsaW5lTmFtZSwgdmFsdWVNYXAsIHZhbHVlcyxcbiAgICAgICAgICAgIGksIG47XG5cbiAgICAgICAgdmFyIGJvbmVzID0gbWFwW1wiYm9uZXNcIl07XG4gICAgICAgIGZvciAodmFyIGJvbmVOYW1lIGluIGJvbmVzKSB7XG4gICAgICAgICAgICBpZiAoIWJvbmVzLmhhc093blByb3BlcnR5KGJvbmVOYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgYm9uZUluZGV4ID0gc2tlbGV0b25EYXRhLmZpbmRCb25lSW5kZXgoYm9uZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGJvbmVJbmRleCA9PSAtMSkgdGhyb3cgXCJCb25lIG5vdCBmb3VuZDogXCIgKyBib25lTmFtZTtcbiAgICAgICAgICAgIHZhciBib25lTWFwID0gYm9uZXNbYm9uZU5hbWVdO1xuXG4gICAgICAgICAgICBmb3IgKHRpbWVsaW5lTmFtZSBpbiBib25lTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFib25lTWFwLmhhc093blByb3BlcnR5KHRpbWVsaW5lTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IGJvbmVNYXBbdGltZWxpbmVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVOYW1lID09IFwicm90YXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgc3BpbmUuUm90YXRlVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLmJvbmVJbmRleCA9IGJvbmVJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlTWFwID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCB2YWx1ZU1hcFtcImFuZ2xlXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaW5lLlNrZWxldG9uSnNvbi5yZWFkQ3VydmUodGltZWxpbmUsIGZyYW1lSW5kZXgsIHZhbHVlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgKiAyIC0gMl0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lbGluZU5hbWUgPT0gXCJ0cmFuc2xhdGVcIiB8fCB0aW1lbGluZU5hbWUgPT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVNjYWxlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTmFtZSA9PSBcInNjYWxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSA9IG5ldyBzcGluZS5TY2FsZVRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IHNwaW5lLlRyYW5zbGF0ZVRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVTY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVNYXAgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9ICh2YWx1ZU1hcFtcInhcIl0gfHwgMCkgKiB0aW1lbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSAodmFsdWVNYXBbXCJ5XCJdIHx8IDApICogdGltZWxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHZhbHVlTWFwW1widGltZVwiXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGluZS5Ta2VsZXRvbkpzb24ucmVhZEN1cnZlKHRpbWVsaW5lLCBmcmFtZUluZGV4LCB2YWx1ZU1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpICogMyAtIDNdKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGltZWxpbmUgdHlwZSBmb3IgYSBib25lOiBcIiArIHRpbWVsaW5lTmFtZSArIFwiIChcIiArIGJvbmVOYW1lICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNsb3RzID0gbWFwW1wic2xvdHNcIl07XG4gICAgICAgIGZvciAodmFyIHNsb3ROYW1lIGluIHNsb3RzKSB7XG4gICAgICAgICAgICBpZiAoIXNsb3RzLmhhc093blByb3BlcnR5KHNsb3ROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgc2xvdE1hcCA9IHNsb3RzW3Nsb3ROYW1lXTtcbiAgICAgICAgICAgIHZhciBzbG90SW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFNsb3RJbmRleChzbG90TmFtZSk7XG5cbiAgICAgICAgICAgIGZvciAodGltZWxpbmVOYW1lIGluIHNsb3RNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNsb3RNYXAuaGFzT3duUHJvcGVydHkodGltZWxpbmVOYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gc2xvdE1hcFt0aW1lbGluZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lbGluZU5hbWUgPT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gbmV3IHNwaW5lLkNvbG9yVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlTWFwID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdmFsdWVNYXBbXCJjb2xvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gc3BpbmUuU2tlbGV0b25Kc29uLnRvQ29sb3IoY29sb3IsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBzcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvcihjb2xvciwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHNwaW5lLlNrZWxldG9uSnNvbi50b0NvbG9yKGNvbG9yLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gc3BpbmUuU2tlbGV0b25Kc29uLnRvQ29sb3IoY29sb3IsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCByLCBnLCBiLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaW5lLlNrZWxldG9uSnNvbi5yZWFkQ3VydmUodGltZWxpbmUsIGZyYW1lSW5kZXgsIHZhbHVlTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgKiA1IC0gNV0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lbGluZU5hbWUgPT0gXCJhdHRhY2htZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgc3BpbmUuQXR0YWNobWVudFRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGluZS5zbG90SW5kZXggPSBzbG90SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZU1hcCA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgrKywgdmFsdWVNYXBbXCJ0aW1lXCJdLCB2YWx1ZU1hcFtcIm5hbWVcIl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxXSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRpbWVsaW5lIHR5cGUgZm9yIGEgc2xvdDogXCIgKyB0aW1lbGluZU5hbWUgKyBcIiAoXCIgKyBzbG90TmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNrZWxldG9uRGF0YS5hbmltYXRpb25zLnB1c2gobmV3IHNwaW5lLkFuaW1hdGlvbihuYW1lLCB0aW1lbGluZXMsIGR1cmF0aW9uKSk7XG4gICAgfVxufTtcbnNwaW5lLlNrZWxldG9uSnNvbi5yZWFkQ3VydmUgPSBmdW5jdGlvbiAodGltZWxpbmUsIGZyYW1lSW5kZXgsIHZhbHVlTWFwKSB7XG4gICAgLypqc2hpbnQgLVcwNjkqL1xuICAgIHZhciBjdXJ2ZSA9IHZhbHVlTWFwW1wiY3VydmVcIl07XG4gICAgaWYgKCFjdXJ2ZSkgcmV0dXJuO1xuICAgIGlmIChjdXJ2ZSA9PSBcInN0ZXBwZWRcIilcbiAgICAgICAgdGltZWxpbmUuY3VydmVzLnNldFN0ZXBwZWQoZnJhbWVJbmRleCk7XG4gICAgZWxzZSBpZiAoY3VydmUgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgdGltZWxpbmUuY3VydmVzLnNldEN1cnZlKGZyYW1lSW5kZXgsIGN1cnZlWzBdLCBjdXJ2ZVsxXSwgY3VydmVbMl0sIGN1cnZlWzNdKTtcbn07XG5zcGluZS5Ta2VsZXRvbkpzb24udG9Db2xvciA9IGZ1bmN0aW9uIChoZXhTdHJpbmcsIGNvbG9ySW5kZXgpIHtcbiAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAhPSA4KSB0aHJvdyBcIkNvbG9yIGhleGlkZWNpbWFsIGxlbmd0aCBtdXN0IGJlIDgsIHJlY2lldmVkOiBcIiArIGhleFN0cmluZztcbiAgICByZXR1cm4gcGFyc2VJbnQoaGV4U3RyaW5nLnN1YnN0cmluZyhjb2xvckluZGV4ICogMiwgMiksIDE2KSAvIDI1NTtcbn07XG5cbnNwaW5lLkF0bGFzID0gZnVuY3Rpb24gKGF0bGFzVGV4dCwgdGV4dHVyZUxvYWRlcikge1xuICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IHRleHR1cmVMb2FkZXI7XG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIHRoaXMucmVnaW9ucyA9IFtdO1xuXG4gICAgdmFyIHJlYWRlciA9IG5ldyBzcGluZS5BdGxhc1JlYWRlcihhdGxhc1RleHQpO1xuICAgIHZhciB0dXBsZSA9IFtdO1xuICAgIHR1cGxlLmxlbmd0aCA9IDQ7XG4gICAgdmFyIHBhZ2UgPSBudWxsO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBsaW5lID0gcmVhZGVyLnJlYWRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09IG51bGwpIGJyZWFrO1xuICAgICAgICBsaW5lID0gcmVhZGVyLnRyaW0obGluZSk7XG4gICAgICAgIGlmICghbGluZS5sZW5ndGgpXG4gICAgICAgICAgICBwYWdlID0gbnVsbDtcbiAgICAgICAgZWxzZSBpZiAoIXBhZ2UpIHtcbiAgICAgICAgICAgIHBhZ2UgPSBuZXcgc3BpbmUuQXRsYXNQYWdlKCk7XG4gICAgICAgICAgICBwYWdlLm5hbWUgPSBsaW5lO1xuXG4gICAgICAgICAgICBwYWdlLmZvcm1hdCA9IHNwaW5lLkF0bGFzLkZvcm1hdFtyZWFkZXIucmVhZFZhbHVlKCldO1xuXG4gICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcbiAgICAgICAgICAgIHBhZ2UubWluRmlsdGVyID0gc3BpbmUuQXRsYXMuVGV4dHVyZUZpbHRlclt0dXBsZVswXV07XG4gICAgICAgICAgICBwYWdlLm1hZ0ZpbHRlciA9IHNwaW5lLkF0bGFzLlRleHR1cmVGaWx0ZXJbdHVwbGVbMV1dO1xuXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcmVhZGVyLnJlYWRWYWx1ZSgpO1xuICAgICAgICAgICAgcGFnZS51V3JhcCA9IHNwaW5lLkF0bGFzLlRleHR1cmVXcmFwLmNsYW1wVG9FZGdlO1xuICAgICAgICAgICAgcGFnZS52V3JhcCA9IHNwaW5lLkF0bGFzLlRleHR1cmVXcmFwLmNsYW1wVG9FZGdlO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcInhcIilcbiAgICAgICAgICAgICAgICBwYWdlLnVXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAucmVwZWF0O1xuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09IFwieVwiKVxuICAgICAgICAgICAgICAgIHBhZ2UudldyYXAgPSBzcGluZS5BdGxhcy5UZXh0dXJlV3JhcC5yZXBlYXQ7XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT0gXCJ4eVwiKVxuICAgICAgICAgICAgICAgIHBhZ2UudVdyYXAgPSBwYWdlLnZXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAucmVwZWF0O1xuXG4gICAgICAgICAgICB0ZXh0dXJlTG9hZGVyLmxvYWQocGFnZSwgbGluZSk7XG5cbiAgICAgICAgICAgIHRoaXMucGFnZXMucHVzaChwYWdlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyBzcGluZS5BdGxhc1JlZ2lvbigpO1xuICAgICAgICAgICAgcmVnaW9uLm5hbWUgPSBsaW5lO1xuICAgICAgICAgICAgcmVnaW9uLnBhZ2UgPSBwYWdlO1xuXG4gICAgICAgICAgICByZWdpb24ucm90YXRlID0gcmVhZGVyLnJlYWRWYWx1ZSgpID09IFwidHJ1ZVwiO1xuXG4gICAgICAgICAgICByZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQodHVwbGVbMF0sIDEwKTtcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQodHVwbGVbMV0sIDEwKTtcblxuICAgICAgICAgICAgcmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUludCh0dXBsZVswXSwgMTApO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHR1cGxlWzFdLCAxMCk7XG5cbiAgICAgICAgICAgIHJlZ2lvbi51ID0geCAvIHBhZ2Uud2lkdGg7XG4gICAgICAgICAgICByZWdpb24udiA9IHkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChyZWdpb24ucm90YXRlKSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnUyID0gKHggKyBoZWlnaHQpIC8gcGFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICByZWdpb24udjIgPSAoeSArIHdpZHRoKSAvIHBhZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWdpb24udTIgPSAoeCArIHdpZHRoKSAvIHBhZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnYyID0gKHkgKyBoZWlnaHQpIC8gcGFnZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWdpb24ueCA9IHg7XG4gICAgICAgICAgICByZWdpb24ueSA9IHk7XG4gICAgICAgICAgICByZWdpb24ud2lkdGggPSBNYXRoLmFicyh3aWR0aCk7XG4gICAgICAgICAgICByZWdpb24uaGVpZ2h0ID0gTWF0aC5hYnMoaGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKHJlYWRlci5yZWFkVHVwbGUodHVwbGUpID09IDQpIHsgLy8gc3BsaXQgaXMgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICByZWdpb24uc3BsaXRzID0gW3BhcnNlSW50KHR1cGxlWzBdLCAxMCksIHBhcnNlSW50KHR1cGxlWzFdLCAxMCksIHBhcnNlSW50KHR1cGxlWzJdLCAxMCksIHBhcnNlSW50KHR1cGxlWzNdLCAxMCldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlYWRlci5yZWFkVHVwbGUodHVwbGUpID09IDQpIHsgLy8gcGFkIGlzIG9wdGlvbmFsLCBidXQgb25seSBwcmVzZW50IHdpdGggc3BsaXRzXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbi5wYWRzID0gW3BhcnNlSW50KHR1cGxlWzBdLCAxMCksIHBhcnNlSW50KHR1cGxlWzFdLCAxMCksIHBhcnNlSW50KHR1cGxlWzJdLCAxMCksIHBhcnNlSW50KHR1cGxlWzNdLCAxMCldO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVnaW9uLm9yaWdpbmFsV2lkdGggPSBwYXJzZUludCh0dXBsZVswXSwgMTApO1xuICAgICAgICAgICAgcmVnaW9uLm9yaWdpbmFsSGVpZ2h0ID0gcGFyc2VJbnQodHVwbGVbMV0sIDEwKTtcblxuICAgICAgICAgICAgcmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG4gICAgICAgICAgICByZWdpb24ub2Zmc2V0WCA9IHBhcnNlSW50KHR1cGxlWzBdLCAxMCk7XG4gICAgICAgICAgICByZWdpb24ub2Zmc2V0WSA9IHBhcnNlSW50KHR1cGxlWzFdLCAxMCk7XG5cbiAgICAgICAgICAgIHJlZ2lvbi5pbmRleCA9IHBhcnNlSW50KHJlYWRlci5yZWFkVmFsdWUoKSwgMTApO1xuXG4gICAgICAgICAgICB0aGlzLnJlZ2lvbnMucHVzaChyZWdpb24pO1xuICAgICAgICB9XG4gICAgfVxufTtcbnNwaW5lLkF0bGFzLnByb3RvdHlwZSA9IHtcbiAgICBmaW5kUmVnaW9uOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcmVnaW9ucyA9IHRoaXMucmVnaW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByZWdpb25zLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIGlmIChyZWdpb25zW2ldLm5hbWUgPT0gbmFtZSkgcmV0dXJuIHJlZ2lvbnNbaV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFnZXMgPSB0aGlzLnBhZ2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUxvYWRlci51bmxvYWQocGFnZXNbaV0ucmVuZGVyZXJPYmplY3QpO1xuICAgIH0sXG4gICAgdXBkYXRlVVZzOiBmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICB2YXIgcmVnaW9ucyA9IHRoaXMucmVnaW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByZWdpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHJlZ2lvbnNbaV07XG4gICAgICAgICAgICBpZiAocmVnaW9uLnBhZ2UgIT0gcGFnZSkgY29udGludWU7XG4gICAgICAgICAgICByZWdpb24udSA9IHJlZ2lvbi54IC8gcGFnZS53aWR0aDtcbiAgICAgICAgICAgIHJlZ2lvbi52ID0gcmVnaW9uLnkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChyZWdpb24ucm90YXRlKSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnUyID0gKHJlZ2lvbi54ICsgcmVnaW9uLmhlaWdodCkgLyBwYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHJlZ2lvbi52MiA9IChyZWdpb24ueSArIHJlZ2lvbi53aWR0aCkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnUyID0gKHJlZ2lvbi54ICsgcmVnaW9uLndpZHRoKSAvIHBhZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcmVnaW9uLnYyID0gKHJlZ2lvbi55ICsgcmVnaW9uLmhlaWdodCkgLyBwYWdlLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnNwaW5lLkF0bGFzLkZvcm1hdCA9IHtcbiAgICBhbHBoYTogMCxcbiAgICBpbnRlbnNpdHk6IDEsXG4gICAgbHVtaW5hbmNlQWxwaGE6IDIsXG4gICAgcmdiNTY1OiAzLFxuICAgIHJnYmE0NDQ0OiA0LFxuICAgIHJnYjg4ODogNSxcbiAgICByZ2JhODg4ODogNlxufTtcblxuc3BpbmUuQXRsYXMuVGV4dHVyZUZpbHRlciA9IHtcbiAgICBuZWFyZXN0OiAwLFxuICAgIGxpbmVhcjogMSxcbiAgICBtaXBNYXA6IDIsXG4gICAgbWlwTWFwTmVhcmVzdE5lYXJlc3Q6IDMsXG4gICAgbWlwTWFwTGluZWFyTmVhcmVzdDogNCxcbiAgICBtaXBNYXBOZWFyZXN0TGluZWFyOiA1LFxuICAgIG1pcE1hcExpbmVhckxpbmVhcjogNlxufTtcblxuc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAgPSB7XG4gICAgbWlycm9yZWRSZXBlYXQ6IDAsXG4gICAgY2xhbXBUb0VkZ2U6IDEsXG4gICAgcmVwZWF0OiAyXG59O1xuXG5zcGluZS5BdGxhc1BhZ2UgPSBmdW5jdGlvbiAoKSB7fTtcbnNwaW5lLkF0bGFzUGFnZS5wcm90b3R5cGUgPSB7XG4gICAgbmFtZTogbnVsbCxcbiAgICBmb3JtYXQ6IG51bGwsXG4gICAgbWluRmlsdGVyOiBudWxsLFxuICAgIG1hZ0ZpbHRlcjogbnVsbCxcbiAgICB1V3JhcDogbnVsbCxcbiAgICB2V3JhcDogbnVsbCxcbiAgICByZW5kZXJlck9iamVjdDogbnVsbCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbn07XG5cbnNwaW5lLkF0bGFzUmVnaW9uID0gZnVuY3Rpb24gKCkge307XG5zcGluZS5BdGxhc1JlZ2lvbi5wcm90b3R5cGUgPSB7XG4gICAgcGFnZTogbnVsbCxcbiAgICBuYW1lOiBudWxsLFxuICAgIHg6IDAsIHk6IDAsXG4gICAgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICB1OiAwLCB2OiAwLCB1MjogMCwgdjI6IDAsXG4gICAgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCxcbiAgICBvcmlnaW5hbFdpZHRoOiAwLCBvcmlnaW5hbEhlaWdodDogMCxcbiAgICBpbmRleDogMCxcbiAgICByb3RhdGU6IGZhbHNlLFxuICAgIHNwbGl0czogbnVsbCxcbiAgICBwYWRzOiBudWxsLFxufTtcblxuc3BpbmUuQXRsYXNSZWFkZXIgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHRoaXMubGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xufTtcbnNwaW5lLkF0bGFzUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICBpbmRleDogMCxcbiAgICB0cmltOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuICAgIH0sXG4gICAgcmVhZExpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5saW5lcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lc1t0aGlzLmluZGV4KytdO1xuICAgIH0sXG4gICAgcmVhZFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5yZWFkTGluZSgpO1xuICAgICAgICB2YXIgY29sb24gPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBpZiAoY29sb24gPT0gLTEpIHRocm93IFwiSW52YWxpZCBsaW5lOiBcIiArIGxpbmU7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaW0obGluZS5zdWJzdHJpbmcoY29sb24gKyAxKSk7XG4gICAgfSxcbiAgICAvKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHR1cGxlIHZhbHVlcyByZWFkICgyIG9yIDQpLiAqL1xuICAgIHJlYWRUdXBsZTogZnVuY3Rpb24gKHR1cGxlKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5yZWFkTGluZSgpO1xuICAgICAgICB2YXIgY29sb24gPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICBpZiAoY29sb24gPT0gLTEpIHRocm93IFwiSW52YWxpZCBsaW5lOiBcIiArIGxpbmU7XG4gICAgICAgIHZhciBpID0gMCwgbGFzdE1hdGNoPSBjb2xvbiArIDE7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29tbWEgPSBsaW5lLmluZGV4T2YoXCIsXCIsIGxhc3RNYXRjaCk7XG4gICAgICAgICAgICBpZiAoY29tbWEgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWkpIHRocm93IFwiSW52YWxpZCBsaW5lOiBcIiArIGxpbmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dXBsZVtpXSA9IHRoaXMudHJpbShsaW5lLnN1YnN0cihsYXN0TWF0Y2gsIGNvbW1hIC0gbGFzdE1hdGNoKSk7XG4gICAgICAgICAgICBsYXN0TWF0Y2ggPSBjb21tYSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdHVwbGVbaV0gPSB0aGlzLnRyaW0obGluZS5zdWJzdHJpbmcobGFzdE1hdGNoKSk7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICB9XG59XG5cbnNwaW5lLkF0bGFzQXR0YWNobWVudExvYWRlciA9IGZ1bmN0aW9uIChhdGxhcykge1xuICAgIHRoaXMuYXRsYXMgPSBhdGxhcztcbn1cbnNwaW5lLkF0bGFzQXR0YWNobWVudExvYWRlci5wcm90b3R5cGUgPSB7XG4gICAgbmV3QXR0YWNobWVudDogZnVuY3Rpb24gKHNraW4sIHR5cGUsIG5hbWUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2Ugc3BpbmUuQXR0YWNobWVudFR5cGUucmVnaW9uOlxuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHRoaXMuYXRsYXMuZmluZFJlZ2lvbihuYW1lKTtcbiAgICAgICAgICAgIGlmICghcmVnaW9uKSB0aHJvdyBcIlJlZ2lvbiBub3QgZm91bmQgaW4gYXRsYXM6IFwiICsgbmFtZSArIFwiIChcIiArIHR5cGUgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciBhdHRhY2htZW50ID0gbmV3IHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQobmFtZSk7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0ID0gcmVnaW9uO1xuICAgICAgICAgICAgYXR0YWNobWVudC5zZXRVVnMocmVnaW9uLnUsIHJlZ2lvbi52LCByZWdpb24udTIsIHJlZ2lvbi52MiwgcmVnaW9uLnJvdGF0ZSk7XG4gICAgICAgICAgICBhdHRhY2htZW50LnJlZ2lvbk9mZnNldFggPSByZWdpb24ub2Zmc2V0WDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVnaW9uT2Zmc2V0WSA9IHJlZ2lvbi5vZmZzZXRZO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZWdpb25XaWR0aCA9IHJlZ2lvbi53aWR0aDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVnaW9uSGVpZ2h0ID0gcmVnaW9uLmhlaWdodDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQucmVnaW9uT3JpZ2luYWxXaWR0aCA9IHJlZ2lvbi5vcmlnaW5hbFdpZHRoO1xuICAgICAgICAgICAgYXR0YWNobWVudC5yZWdpb25PcmlnaW5hbEhlaWdodCA9IHJlZ2lvbi5vcmlnaW5hbEhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBhdHRhY2htZW50O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwiVW5rbm93biBhdHRhY2htZW50IHR5cGU6IFwiICsgdHlwZTtcbiAgICB9XG59XG5cbnNwaW5lLkJvbmUueURvd24gPSB0cnVlO1xuUElYSS5BbmltQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgZW5hYmxlcyB0aGUgeW91IHRvIGltcG9ydCBhbmQgcnVuIHlvdXIgc3BpbmUgYW5pbWF0aW9ucyBpbiBwaXhpLlxuICogU3BpbmUgYW5pbWF0aW9uIGRhdGEgbmVlZHMgdG8gYmUgbG9hZGVkIHVzaW5nIHRoZSBQSVhJLkFzc2V0TG9hZGVyIG9yIFBJWEkuU3BpbmVMb2FkZXIgYmVmb3JlIGl0IGNhbiBiZSB1c2VkIGJ5IHRoaXMgY2xhc3NcbiAqIFNlZSBleGFtcGxlIDEyIChodHRwOi8vd3d3Lmdvb2Rib3lkaWdpdGFsLmNvbS9waXhpanMvZXhhbXBsZXMvMTIvKSB0byBzZWUgYSB3b3JraW5nIGV4YW1wbGUgYW5kIGNoZWNrIG91dCB0aGUgc291cmNlXG4gKlxuICogQGNsYXNzIFNwaW5lXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB1cmwge1N0cmluZ30gVGhlIHVybCBvZiB0aGUgc3BpbmUgYW5pbSBmaWxlIHRvIGJlIHVzZWRcbiAqL1xuUElYSS5TcGluZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc3BpbmVEYXRhID0gUElYSS5BbmltQ2FjaGVbdXJsXTtcblxuICAgIGlmICghdGhpcy5zcGluZURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3BpbmUgZGF0YSBtdXN0IGJlIHByZWxvYWRlZCB1c2luZyBQSVhJLlNwaW5lTG9hZGVyIG9yIFBJWEkuQXNzZXRMb2FkZXI6IFwiICsgdXJsKTtcbiAgICB9XG5cbiAgICB0aGlzLnNrZWxldG9uID0gbmV3IHNwaW5lLlNrZWxldG9uKHRoaXMuc3BpbmVEYXRhKTtcbiAgICB0aGlzLnNrZWxldG9uLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XG5cbiAgICB0aGlzLnN0YXRlRGF0YSA9IG5ldyBzcGluZS5BbmltYXRpb25TdGF0ZURhdGEodGhpcy5zcGluZURhdGEpO1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgc3BpbmUuQW5pbWF0aW9uU3RhdGUodGhpcy5zdGF0ZURhdGEpO1xuXG4gICAgdGhpcy5zbG90Q29udGFpbmVycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnNrZWxldG9uLmRyYXdPcmRlci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLnNrZWxldG9uLmRyYXdPcmRlcltpXTtcbiAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90LmF0dGFjaG1lbnQ7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gbmV3IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLnNsb3RDb250YWluZXJzLnB1c2goc2xvdENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoc2xvdENvbnRhaW5lcik7XG4gICAgICAgIGlmICghKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBzcGluZS5SZWdpb25BdHRhY2htZW50KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwcml0ZU5hbWUgPSBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0Lm5hbWU7XG4gICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLmNyZWF0ZVNwcml0ZShzbG90LCBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0KTtcbiAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlID0gc3ByaXRlO1xuICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGVOYW1lID0gc3ByaXRlTmFtZTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xuICAgIH1cbn07XG5cblBJWEkuU3BpbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlKTtcblBJWEkuU3BpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5TcGluZTtcblxuLypcbiAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICpcbiAqIEBtZXRob2QgdXBkYXRlVHJhbnNmb3JtXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlNwaW5lLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sYXN0VGltZSA9IHRoaXMubGFzdFRpbWUgfHwgRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZURlbHRhID0gKERhdGUubm93KCkgLSB0aGlzLmxhc3RUaW1lKSAqIDAuMDAxO1xuICAgIHRoaXMubGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc3RhdGUudXBkYXRlKHRpbWVEZWx0YSk7XG4gICAgdGhpcy5zdGF0ZS5hcHBseSh0aGlzLnNrZWxldG9uKTtcbiAgICB0aGlzLnNrZWxldG9uLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XG5cbiAgICB2YXIgZHJhd09yZGVyID0gdGhpcy5za2VsZXRvbi5kcmF3T3JkZXI7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBkcmF3T3JkZXIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBzbG90ID0gZHJhd09yZGVyW2ldO1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IHNsb3QuYXR0YWNobWVudDtcbiAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSB0aGlzLnNsb3RDb250YWluZXJzW2ldO1xuICAgICAgICBpZiAoIShhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuUmVnaW9uQXR0YWNobWVudCkpIHtcbiAgICAgICAgICAgIHNsb3RDb250YWluZXIudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0YWNobWVudC5yZW5kZXJlck9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFzbG90LmN1cnJlbnRTcHJpdGVOYW1lIHx8IHNsb3QuY3VycmVudFNwcml0ZU5hbWUgIT0gYXR0YWNobWVudC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZU5hbWUgPSBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0Lm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHNsb3QuY3VycmVudFNwcml0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNsb3Quc3ByaXRlcyA9IHNsb3Quc3ByaXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoc2xvdC5zcHJpdGVzW3Nwcml0ZU5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5zcHJpdGVzW3Nwcml0ZU5hbWVdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLmNyZWF0ZVNwcml0ZShzbG90LCBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUgPSBzbG90LnNwcml0ZXNbc3ByaXRlTmFtZV07XG4gICAgICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlTmFtZSA9IHNwcml0ZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2xvdENvbnRhaW5lci52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYm9uZSA9IHNsb3QuYm9uZTtcblxuICAgICAgICBzbG90Q29udGFpbmVyLnBvc2l0aW9uLnggPSBib25lLndvcmxkWCArIGF0dGFjaG1lbnQueCAqIGJvbmUubTAwICsgYXR0YWNobWVudC55ICogYm9uZS5tMDE7XG4gICAgICAgIHNsb3RDb250YWluZXIucG9zaXRpb24ueSA9IGJvbmUud29ybGRZICsgYXR0YWNobWVudC54ICogYm9uZS5tMTAgKyBhdHRhY2htZW50LnkgKiBib25lLm0xMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zY2FsZS54ID0gYm9uZS53b3JsZFNjYWxlWDtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zY2FsZS55ID0gYm9uZS53b3JsZFNjYWxlWTtcblxuICAgICAgICBzbG90Q29udGFpbmVyLnJvdGF0aW9uID0gLShzbG90LmJvbmUud29ybGRSb3RhdGlvbiAqIE1hdGguUEkgLyAxODApO1xuICAgIH1cblxuICAgIFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtLmNhbGwodGhpcyk7XG59O1xuXG5cblBJWEkuU3BpbmUucHJvdG90eXBlLmNyZWF0ZVNwcml0ZSA9IGZ1bmN0aW9uIChzbG90LCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIG5hbWUgPSBQSVhJLlRleHR1cmVDYWNoZVtkZXNjcmlwdG9yLm5hbWVdID8gZGVzY3JpcHRvci5uYW1lIDogZGVzY3JpcHRvci5uYW1lICsgXCIucG5nXCI7XG4gICAgdmFyIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZShQSVhJLlRleHR1cmUuZnJvbUZyYW1lKG5hbWUpKTtcbiAgICBzcHJpdGUuc2NhbGUgPSBkZXNjcmlwdG9yLnNjYWxlO1xuICAgIHNwcml0ZS5yb3RhdGlvbiA9IGRlc2NyaXB0b3Iucm90YXRpb247XG4gICAgc3ByaXRlLmFuY2hvci54ID0gc3ByaXRlLmFuY2hvci55ID0gMC41O1xuXG4gICAgc2xvdC5zcHJpdGVzID0gc2xvdC5zcHJpdGVzIHx8IHt9O1xuICAgIHNsb3Quc3ByaXRlc1tkZXNjcmlwdG9yLm5hbWVdID0gc3ByaXRlO1xuICAgIHJldHVybiBzcHJpdGU7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblBJWEkuQmFzZVRleHR1cmVDYWNoZSA9IHt9O1xuUElYSS50ZXh0dXJlc1RvVXBkYXRlID0gW107XG5QSVhJLnRleHR1cmVzVG9EZXN0cm95ID0gW107XG5cblBJWEkuQmFzZVRleHR1cmVDYWNoZUlkR2VuZXJhdG9yID0gMDtcblxuLyoqXG4gKiBBIHRleHR1cmUgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2UuIEFsbCB0ZXh0dXJlcyBoYXZlIGEgYmFzZSB0ZXh0dXJlXG4gKlxuICogQGNsYXNzIEJhc2VUZXh0dXJlXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gc291cmNlIHtTdHJpbmd9IHRoZSBzb3VyY2Ugb2JqZWN0IChpbWFnZSBvciBjYW52YXMpXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIFBJWEkuc2NhbGVNb2RlIGNvbnN0c1xuICovXG5QSVhJLkJhc2VUZXh0dXJlID0gZnVuY3Rpb24oc291cmNlLCBzY2FsZU1vZGUpXG57XG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKCB0aGlzICk7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgd2lkdGggb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDEwMDtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBoZWlnaHQgb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMTAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIG1vZGUgdG8gYXBwbHkgd2hlbiBzY2FsaW5nIHRoaXMgdGV4dHVyZVxuICAgICAqIEBwcm9wZXJ0eSBzY2FsZU1vZGVcbiAgICAgKiBAdHlwZSBQSVhJLnNjYWxlTW9kZXNcbiAgICAgKiBAZGVmYXVsdCBQSVhJLnNjYWxlTW9kZXMuTElORUFSXG4gICAgICovXG4gICAgdGhpcy5zY2FsZU1vZGUgPSBzY2FsZU1vZGUgfHwgUElYSS5zY2FsZU1vZGVzLkRFRkFVTFQ7XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBEZXNjcmliZXMgaWYgdGhlIGJhc2UgdGV4dHVyZSBoYXMgbG9hZGVkIG9yIG5vdFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhhc0xvYWRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmhhc0xvYWRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNvdXJjZSB0aGF0IGlzIGxvYWRlZCB0byBjcmVhdGUgdGhlIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzb3VyY2VcbiAgICAgKiBAdHlwZSBJbWFnZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgLy9UT0RPIHdpbGwgYmUgdXNlZCBmb3IgZnV0ZXIgcGl4aSAxLjUuLi5cbiAgICB0aGlzLmlkID0gUElYSS5CYXNlVGV4dHVyZUNhY2hlSWRHZW5lcmF0b3IrKztcblxuICAgIC8vIHVzZWQgZm9yIHdlYkdMXG4gICAgdGhpcy5fZ2xUZXh0dXJlcyA9IFtdO1xuICAgIFxuICAgIGlmKCFzb3VyY2UpcmV0dXJuO1xuXG4gICAgaWYodGhpcy5zb3VyY2UuY29tcGxldGUgfHwgdGhpcy5zb3VyY2UuZ2V0Q29udGV4dClcbiAgICB7XG4gICAgICAgIHRoaXMuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuc291cmNlLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuc291cmNlLmhlaWdodDtcblxuICAgICAgICBQSVhJLnRleHR1cmVzVG9VcGRhdGUucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICB0aGlzLnNvdXJjZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgc2NvcGUuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNjb3BlLndpZHRoID0gc2NvcGUuc291cmNlLndpZHRoO1xuICAgICAgICAgICAgc2NvcGUuaGVpZ2h0ID0gc2NvcGUuc291cmNlLmhlaWdodDtcblxuICAgICAgICAgICAgLy8gYWRkIGl0IHRvIHNvbWV3aGVyZS4uLlxuICAgICAgICAgICAgUElYSS50ZXh0dXJlc1RvVXBkYXRlLnB1c2goc2NvcGUpO1xuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnbG9hZGVkJywgY29udGVudDogc2NvcGUgfSApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuaW1hZ2VVcmwgPSBudWxsO1xuICAgIHRoaXMuX3Bvd2VyT2YyID0gZmFsc2U7XG5cbiAgICBcblxufTtcblxuUElYSS5CYXNlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkJhc2VUZXh0dXJlO1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgYmFzZSB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKi9cblBJWEkuQmFzZVRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5pbWFnZVVybClcbiAgICB7XG4gICAgICAgIGRlbGV0ZSBQSVhJLkJhc2VUZXh0dXJlQ2FjaGVbdGhpcy5pbWFnZVVybF07XG4gICAgICAgIHRoaXMuaW1hZ2VVcmwgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZS5zcmMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgUElYSS50ZXh0dXJlc1RvRGVzdHJveS5wdXNoKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBzb3VyY2UgaW1hZ2Ugb2YgdGhlIHRleHR1cmVcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVNvdXJjZUltYWdlXG4gKiBAcGFyYW0gbmV3U3JjIHtTdHJpbmd9IHRoZSBwYXRoIG9mIHRoZSBpbWFnZVxuICovXG5QSVhJLkJhc2VUZXh0dXJlLnByb3RvdHlwZS51cGRhdGVTb3VyY2VJbWFnZSA9IGZ1bmN0aW9uKG5ld1NyYylcbntcbiAgICB0aGlzLmhhc0xvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc291cmNlLnNyYyA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2Uuc3JjID0gbmV3U3JjO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxuICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgYmFzZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tSW1hZ2VcbiAqIEBwYXJhbSBpbWFnZVVybCB7U3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFxuICogQHBhcmFtIHNjYWxlTW9kZSB7TnVtYmVyfSBTaG91bGQgYmUgb25lIG9mIHRoZSBQSVhJLnNjYWxlTW9kZSBjb25zdHNcbiAqIEByZXR1cm4gQmFzZVRleHR1cmVcbiAqL1xuUElYSS5CYXNlVGV4dHVyZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbihpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgYmFzZVRleHR1cmUgPSBQSVhJLkJhc2VUZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuICAgIFxuICAgIGlmKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpY3Jvc3NvcmlnaW4gPSB0cnVlO1xuXG4gICAgaWYoIWJhc2VUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgLy8gbmV3IEltYWdlKCkgYnJlYWtzIHRleCBsb2FkaW5nIGluIHNvbWUgdmVyc2lvbnMgb2YgQ2hyb21lLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIzODA3MVxuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsvL2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VVcmw7XG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IFBJWEkuQmFzZVRleHR1cmUoaW1hZ2UsIHNjYWxlTW9kZSk7XG4gICAgICAgIGJhc2VUZXh0dXJlLmltYWdlVXJsID0gaW1hZ2VVcmw7XG4gICAgICAgIFBJWEkuQmFzZVRleHR1cmVDYWNoZVtpbWFnZVVybF0gPSBiYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZVRleHR1cmU7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBiYXNlIHRleHR1cmUgYmFzZWQgb24gYSBjYW52YXMgZWxlbWVudFxuICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgYmFzZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tQ2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4gKiBAcmV0dXJuIEJhc2VUZXh0dXJlXG4gKi9cblBJWEkuQmFzZVRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uKGNhbnZhcywgc2NhbGVNb2RlKVxue1xuICAgIGlmKCFjYW52YXMuX3BpeGlJZClcbiAgICB7XG4gICAgICAgIGNhbnZhcy5fcGl4aUlkID0gJ2NhbnZhc18nICsgUElYSS5UZXh0dXJlQ2FjaGVJZEdlbmVyYXRvcisrO1xuICAgIH1cblxuICAgIHZhciBiYXNlVGV4dHVyZSA9IFBJWEkuQmFzZVRleHR1cmVDYWNoZVtjYW52YXMuX3BpeGlJZF07XG5cbiAgICBpZighYmFzZVRleHR1cmUpXG4gICAge1xuICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBQSVhJLkJhc2VUZXh0dXJlKGNhbnZhcywgc2NhbGVNb2RlKTtcbiAgICAgICAgUElYSS5CYXNlVGV4dHVyZUNhY2hlW2NhbnZhcy5fcGl4aUlkXSA9IGJhc2VUZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbn07XG5cblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cblBJWEkuVGV4dHVyZUNhY2hlID0ge307XG5QSVhJLkZyYW1lQ2FjaGUgPSB7fTtcblxuUElYSS5UZXh0dXJlQ2FjaGVJZEdlbmVyYXRvciA9IDA7XG5cbi8qKlxuICogQSB0ZXh0dXJlIHN0b3JlcyB0aGUgaW5mb3JtYXRpb24gdGhhdCByZXByZXNlbnRzIGFuIGltYWdlIG9yIHBhcnQgb2YgYW4gaW1hZ2UuIEl0IGNhbm5vdCBiZSBhZGRlZFxuICogdG8gdGhlIGRpc3BsYXkgbGlzdCBkaXJlY3RseS4gVG8gZG8gdGhpcyB1c2UgUElYSS5TcHJpdGUuIElmIG5vIGZyYW1lIGlzIHByb3ZpZGVkIHRoZW4gdGhlIHdob2xlIGltYWdlIGlzIHVzZWRcbiAqXG4gKiBAY2xhc3MgVGV4dHVyZVxuICogQHVzZXMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGJhc2VUZXh0dXJlIHtCYXNlVGV4dHVyZX0gVGhlIGJhc2UgdGV4dHVyZSBzb3VyY2UgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlIGZyb21cbiAqIEBwYXJhbSBmcmFtZSB7UmVjdGFuZ2xlfSBUaGUgcmVjdGFuZ2xlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlIHRvIHNob3dcbiAqL1xuUElYSS5UZXh0dXJlID0gZnVuY3Rpb24oYmFzZVRleHR1cmUsIGZyYW1lKVxue1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCggdGhpcyApO1xuXG4gICAgaWYoIWZyYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy5ub0ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgZnJhbWUgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwwLDEsMSk7XG4gICAgfVxuXG4gICAgaWYoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBQSVhJLlRleHR1cmUpXG4gICAgICAgIGJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmUuYmFzZVRleHR1cmU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIG9mIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlVGV4dHVyZVxuICAgICAqIEB0eXBlIEJhc2VUZXh0dXJlXG4gICAgICovXG4gICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lIHNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyYW1lXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRyaW0gcG9pbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0cmltXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy50cmltID0gbnVsbDtcbiAgXG4gICAgdGhpcy5zY29wZSA9IHRoaXM7XG5cbiAgICB0aGlzLl91dnMgPSBudWxsO1xuICAgIFxuICAgIGlmKGJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMubm9GcmFtZSlmcmFtZSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgXG4gICAgICAgIHRoaXMuc2V0RnJhbWUoZnJhbWUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICBiYXNlVGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbigpeyBzY29wZS5vbkJhc2VUZXh0dXJlTG9hZGVkKCk7IH0pO1xuICAgIH1cbn07XG5cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlRleHR1cmU7XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBpcyBsb2FkZWRcbiAqXG4gKiBAbWV0aG9kIG9uQmFzZVRleHR1cmVMb2FkZWRcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5UZXh0dXJlLnByb3RvdHlwZS5vbkJhc2VUZXh0dXJlTG9hZGVkID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBiYXNlVGV4dHVyZSA9IHRoaXMuYmFzZVRleHR1cmU7XG4gICAgYmFzZVRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWRlZCcsIHRoaXMub25Mb2FkZWQgKTtcblxuICAgIGlmKHRoaXMubm9GcmFtZSl0aGlzLmZyYW1lID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XG4gICAgXG4gICAgdGhpcy5zZXRGcmFtZSh0aGlzLmZyYW1lKTtcblxuICAgIHRoaXMuc2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJywgY29udGVudDogdGhpcyB9ICk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICpcbiAqIEBtZXRob2QgZGVzdHJveVxuICogQHBhcmFtIGRlc3Ryb3lCYXNlIHtCb29sZWFufSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gKi9cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGRlc3Ryb3lCYXNlKVxue1xuICAgIGlmKGRlc3Ryb3lCYXNlKSB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSByZWN0YW5nbGUgcmVnaW9uIG9mIHRoZSBiYXNlVGV4dHVyZVxuICpcbiAqIEBtZXRob2Qgc2V0RnJhbWVcbiAqIEBwYXJhbSBmcmFtZSB7UmVjdGFuZ2xlfSBUaGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2V0IGl0IHRvXG4gKi9cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZSlcbntcbiAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gICAgdGhpcy53aWR0aCA9IGZyYW1lLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuXG4gICAgaWYoZnJhbWUueCArIGZyYW1lLndpZHRoID4gdGhpcy5iYXNlVGV4dHVyZS53aWR0aCB8fCBmcmFtZS55ICsgZnJhbWUuaGVpZ2h0ID4gdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmUgRXJyb3I6IGZyYW1lIGRvZXMgbm90IGZpdCBpbnNpZGUgdGhlIGJhc2UgVGV4dHVyZSBkaW1lbnNpb25zICcgKyB0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUZyYW1lID0gdHJ1ZTtcblxuICAgIFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMucHVzaCh0aGlzKTtcblxuXG4gICAgLy90aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3VwZGF0ZScsIGNvbnRlbnQ6IHRoaXMgfSApO1xufTtcblxuUElYSS5UZXh0dXJlLnByb3RvdHlwZS5fdXBkYXRlV2ViR0x1dnMgPSBmdW5jdGlvbigpXG57XG4gICAgaWYoIXRoaXMuX3V2cyl0aGlzLl91dnMgPSBuZXcgUElYSS5UZXh0dXJlVXZzKCk7XG5cbiAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lO1xuICAgIHZhciB0dyA9IHRoaXMuYmFzZVRleHR1cmUud2lkdGg7XG4gICAgdmFyIHRoID0gdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQ7XG5cbiAgICB0aGlzLl91dnMueDAgPSBmcmFtZS54IC8gdHc7XG4gICAgdGhpcy5fdXZzLnkwID0gZnJhbWUueSAvIHRoO1xuXG4gICAgdGhpcy5fdXZzLngxID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICB0aGlzLl91dnMueTEgPSBmcmFtZS55IC8gdGg7XG5cbiAgICB0aGlzLl91dnMueDIgPSAoZnJhbWUueCArIGZyYW1lLndpZHRoKSAvIHR3O1xuICAgIHRoaXMuX3V2cy55MiA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIHRoO1xuXG4gICAgdGhpcy5fdXZzLngzID0gZnJhbWUueCAvIHR3O1xuICAgIHRoaXMuX3V2cy55MyA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIHRoO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBiYXNlZCBvbiBhbiBpbWFnZSB1cmxcbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSAgY3JlYXRlZCBhbmQgbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tSW1hZ2VcbiAqIEBwYXJhbSBpbWFnZVVybCB7U3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4gKiBAcmV0dXJuIFRleHR1cmVcbiAqL1xuUElYSS5UZXh0dXJlLmZyb21JbWFnZSA9IGZ1bmN0aW9uKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxue1xuICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuXG4gICAgaWYoIXRleHR1cmUpXG4gICAge1xuICAgICAgICB0ZXh0dXJlID0gbmV3IFBJWEkuVGV4dHVyZShQSVhJLkJhc2VUZXh0dXJlLmZyb21JbWFnZShpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSkpO1xuICAgICAgICBQSVhJLlRleHR1cmVDYWNoZVtpbWFnZVVybF0gPSB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBiYXNlZCBvbiBhIGZyYW1lIGlkXG4gKiBJZiB0aGUgZnJhbWUgaWQgaXMgbm90IGluIHRoZSB0ZXh0dXJlIGNhY2hlIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tRnJhbWVcbiAqIEBwYXJhbSBmcmFtZUlkIHtTdHJpbmd9IFRoZSBmcmFtZSBpZCBvZiB0aGUgdGV4dHVyZVxuICogQHJldHVybiBUZXh0dXJlXG4gKi9cblBJWEkuVGV4dHVyZS5mcm9tRnJhbWUgPSBmdW5jdGlvbihmcmFtZUlkKVxue1xuICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XG4gICAgaWYoIXRleHR1cmUpIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSAnKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgYmFzZWQgb24gYSBjYW52YXMgZWxlbWVudFxuICogSWYgdGhlIGNhbnZhcyBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSAgY3JlYXRlZCBhbmQgbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tQ2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2hvdWxkIGJlIG9uZSBvZiB0aGUgUElYSS5zY2FsZU1vZGUgY29uc3RzXG4gKiBAcmV0dXJuIFRleHR1cmVcbiAqL1xuUElYSS5UZXh0dXJlLmZyb21DYW52YXMgPSBmdW5jdGlvbihjYW52YXMsIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgYmFzZVRleHR1cmUgPSBQSVhJLkJhc2VUZXh0dXJlLmZyb21DYW52YXMoY2FudmFzLCBzY2FsZU1vZGUpO1xuXG4gICAgcmV0dXJuIG5ldyBQSVhJLlRleHR1cmUoIGJhc2VUZXh0dXJlICk7XG5cbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgdGV4dHVyZSB0byB0aGUgdGV4dHVyZUNhY2hlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYWRkVGV4dHVyZVRvQ2FjaGVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfVxuICogQHBhcmFtIGlkIHtTdHJpbmd9IHRoZSBpZCB0aGF0IHRoZSB0ZXh0dXJlIHdpbGwgYmUgc3RvcmVkIGFnYWluc3QuXG4gKi9cblBJWEkuVGV4dHVyZS5hZGRUZXh0dXJlVG9DYWNoZSA9IGZ1bmN0aW9uKHRleHR1cmUsIGlkKVxue1xuICAgIFBJWEkuVGV4dHVyZUNhY2hlW2lkXSA9IHRleHR1cmU7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZUNhY2hlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcmVtb3ZlVGV4dHVyZUZyb21DYWNoZVxuICogQHBhcmFtIGlkIHtTdHJpbmd9IHRoZSBpZCBvZiB0aGUgdGV4dHVyZSB0byBiZSByZW1vdmVkXG4gKiBAcmV0dXJuIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXG4gKi9cblBJWEkuVGV4dHVyZS5yZW1vdmVUZXh0dXJlRnJvbUNhY2hlID0gZnVuY3Rpb24oaWQpXG57XG4gICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmVDYWNoZVtpZF07XG4gICAgZGVsZXRlIFBJWEkuVGV4dHVyZUNhY2hlW2lkXTtcbiAgICBkZWxldGUgUElYSS5CYXNlVGV4dHVyZUNhY2hlW2lkXTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8vIHRoaXMgaXMgbW9yZSBmb3Igd2ViR0wuLiBpdCBjb250YWlucyB1cGRhdGVkIGZyYW1lcy4uXG5QSVhJLlRleHR1cmUuZnJhbWVVcGRhdGVzID0gW107XG5cblBJWEkuVGV4dHVyZVV2cyA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLngwID0gMDtcbiAgICB0aGlzLnkwID0gMDtcblxuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuXG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG5cbiAgICB0aGlzLngzID0gMDtcbiAgICB0aGlzLnk0ID0gMDtcblxuXG59O1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gQSBSZW5kZXJUZXh0dXJlIGlzIGEgc3BlY2lhbCB0ZXh0dXJlIHRoYXQgYWxsb3dzIGFueSBwaXhpIGRpc3BsYXlPYmplY3QgdG8gYmUgcmVuZGVyZWQgdG8gaXQuXG5cbiBfX0hpbnRfXzogQWxsIERpc3BsYXlPYmplY3RzIChleG1wbC4gU3ByaXRlcykgdGhhdCByZW5kZXIgb24gUmVuZGVyVGV4dHVyZSBzaG91bGQgYmUgcHJlbG9hZGVkLlxuIE90aGVyd2lzZSBibGFjayByZWN0YW5nbGVzIHdpbGwgYmUgZHJhd24gaW5zdGVhZC5cblxuIFJlbmRlclRleHR1cmUgdGFrZXMgc25hcHNob3Qgb2YgRGlzcGxheU9iamVjdCBwYXNzZWQgdG8gcmVuZGVyIG1ldGhvZC4gSWYgRGlzcGxheU9iamVjdCBpcyBwYXNzZWQgdG8gcmVuZGVyIG1ldGhvZCwgcG9zaXRpb24gYW5kIHJvdGF0aW9uIG9mIGl0IHdpbGwgYmUgaWdub3JlZC4gRm9yIGV4YW1wbGU6XG5cbiAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBQSVhJLlJlbmRlclRleHR1cmUoODAwLCA2MDApO1xuICAgIHZhciBzcHJpdGUgPSBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoXCJzcGluT2JqXzAxLnBuZ1wiKTtcbiAgICBzcHJpdGUucG9zaXRpb24ueCA9IDgwMC8yO1xuICAgIHNwcml0ZS5wb3NpdGlvbi55ID0gNjAwLzI7XG4gICAgc3ByaXRlLmFuY2hvci54ID0gMC41O1xuICAgIHNwcml0ZS5hbmNob3IueSA9IDAuNTtcbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcihzcHJpdGUpO1xuXG4gU3ByaXRlIGluIHRoaXMgY2FzZSB3aWxsIGJlIHJlbmRlcmVkIHRvIDAsMCBwb3NpdGlvbi4gVG8gcmVuZGVyIHRoaXMgc3ByaXRlIGF0IGNlbnRlciBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIHNob3VsZCBiZSB1c2VkOlxuXG4gICAgdmFyIGRvYyA9IG5ldyBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIoKTtcbiAgICBkb2MuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcihkb2MpOyAgLy8gUmVuZGVycyB0byBjZW50ZXIgb2YgcmVuZGVyVGV4dHVyZVxuXG4gKiBAY2xhc3MgUmVuZGVyVGV4dHVyZVxuICogQGV4dGVuZHMgVGV4dHVyZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICovXG5QSVhJLlJlbmRlclRleHR1cmUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCByZW5kZXJlcilcbntcbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aXRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDEwMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDEwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmFtZVxuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWUgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgdGV4dHVyZSBvYmplY3QgdGhhdCB0aGlzIHRleHR1cmUgdXNlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhc2VUZXh0dXJlXG4gICAgICogQHR5cGUgQmFzZVRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLmJhc2VUZXh0dXJlID0gbmV3IFBJWEkuQmFzZVRleHR1cmUoKTtcbiAgICB0aGlzLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXMgPSBbXTtcblxuICAgIHRoaXMuYmFzZVRleHR1cmUuaGFzTG9hZGVkID0gdHJ1ZTtcblxuICAgIC8vIGVhY2ggcmVuZGVyIHRleHR1cmUgY2FuIG9ubHkgYmVsb25nIHRvIG9uZSByZW5kZXJlciBhdCB0aGUgbW9tZW50IGlmIGl0cyB3ZWJHTFxuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciB8fCBQSVhJLmRlZmF1bHRSZW5kZXJlcjtcblxuICAgIGlmKHRoaXMucmVuZGVyZXIudHlwZSA9PT0gUElYSS5XRUJHTF9SRU5ERVJFUilcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlQnVmZmVyID0gbmV3IFBJWEkuRmlsdGVyVGV4dHVyZShnbCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9ICB0aGlzLnRleHR1cmVCdWZmZXIudGV4dHVyZTtcblxuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyV2ViR0w7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbiA9IG5ldyBQSVhJLlBvaW50KHRoaXMud2lkdGgvMiAsIC10aGlzLmhlaWdodC8yKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlckNhbnZhcztcbiAgICAgICAgdGhpcy50ZXh0dXJlQnVmZmVyID0gbmV3IFBJWEkuQ2FudmFzQnVmZmVyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgPSB0aGlzLnRleHR1cmVCdWZmZXIuY2FudmFzO1xuICAgIH1cblxuICAgIFBJWEkuVGV4dHVyZS5mcmFtZVVwZGF0ZXMucHVzaCh0aGlzKTtcblxuXG59O1xuXG5QSVhJLlJlbmRlclRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQSVhJLlRleHR1cmUucHJvdG90eXBlKTtcblBJWEkuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlJlbmRlclRleHR1cmU7XG5cblBJWEkuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmZyYW1lLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLmZyYW1lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgaWYodGhpcy5yZW5kZXJlci50eXBlID09PSBQSVhJLldFQkdMX1JFTkRFUkVSKVxuICAgIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uLnggPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uLnkgPSAtdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAgdGhpcy53aWR0aCwgIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlQnVmZmVyLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgUElYSS5UZXh0dXJlLmZyYW1lVXBkYXRlcy5wdXNoKHRoaXMpO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZHJhdyB0aGUgZGlzcGxheSBvYmplY3QgdG8gdGhlIHRleHR1cmUuXG4gKlxuICogQG1ldGhvZCByZW5kZXJXZWJHTFxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXG4gKiBAcGFyYW0gY2xlYXIge0Jvb2xlYW59IElmIHRydWUgdGhlIHRleHR1cmUgd2lsbCBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgZGlzcGxheU9iamVjdCBpcyBkcmF3blxuICogQHByaXZhdGVcbiAqL1xuUElYSS5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QsIHBvc2l0aW9uLCBjbGVhcilcbntcbiAgICAvL1RPT0QgcmVwbGFjZSBwb3NpdGlvbiB3aXRoIG1hdHJpeC4uXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcblxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy50ZXh0dXJlQnVmZmVyLmZyYW1lQnVmZmVyICk7XG5cbiAgICBpZihjbGVhcil0aGlzLnRleHR1cmVCdWZmZXIuY2xlYXIoKTtcblxuICAgIC8vIFRISVMgV0lMTCBNRVNTIFdJVEggSElUIFRFU1RJTkchXG4gICAgdmFyIGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcblxuICAgIC8vVE9ETyAtPyBjcmVhdGUgYSBuZXcgb25lPz8/IGRvbnQgdGhpbmsgc28hXG4gICAgdmFyIG9yaWdpbmFsV29ybGRUcmFuc2Zvcm0gPSBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtO1xuICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0gPSBQSVhJLlJlbmRlclRleHR1cmUudGVtcE1hdHJpeDtcbiAgICAvLyBtb2RpZnkgdG8gZmxpcC4uLlxuICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uZCA9IC0xO1xuICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0udHkgPSB0aGlzLnByb2plY3Rpb24ueSAqIC0yO1xuXG4gICAgaWYocG9zaXRpb24pXG4gICAge1xuICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLnR4ID0gcG9zaXRpb24ueDtcbiAgICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS50eSAtPSBwb3NpdGlvbi55O1xuICAgIH1cblxuICAgIGZvcih2YXIgaT0wLGo9Y2hpbGRyZW4ubGVuZ3RoOyBpPGo7IGkrKylcbiAgICB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgdGV4dHVyZXMhXG4gICAgUElYSS5XZWJHTFJlbmRlcmVyLnVwZGF0ZVRleHR1cmVzKCk7XG5cbiAgICAvLyBcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckRpc3BsYXlPYmplY3QoZGlzcGxheU9iamVjdCwgdGhpcy5wcm9qZWN0aW9uLCB0aGlzLnRleHR1cmVCdWZmZXIuZnJhbWVCdWZmZXIpO1xuXG4gICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybSA9IG9yaWdpbmFsV29ybGRUcmFuc2Zvcm07XG59O1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGRyYXcgdGhlIGRpc3BsYXkgb2JqZWN0IHRvIHRoZSB0ZXh0dXJlLlxuICpcbiAqIEBtZXRob2QgcmVuZGVyQ2FudmFzXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXkgb2JqZWN0IHRvIHJlbmRlciB0aGlzIHRleHR1cmUgb25cbiAqIEBwYXJhbSBjbGVhciB7Qm9vbGVhbn0gSWYgdHJ1ZSB0aGUgdGV4dHVyZSB3aWxsIGJlIGNsZWFyZWQgYmVmb3JlIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGRyYXduXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlJlbmRlclRleHR1cmUucHJvdG90eXBlLnJlbmRlckNhbnZhcyA9IGZ1bmN0aW9uKGRpc3BsYXlPYmplY3QsIHBvc2l0aW9uLCBjbGVhcilcbntcbiAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgdmFyIG9yaWdpbmFsV29ybGRUcmFuc2Zvcm0gPSBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtO1xuXG4gICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybSA9IFBJWEkuUmVuZGVyVGV4dHVyZS50ZW1wTWF0cml4O1xuXG4gICAgaWYocG9zaXRpb24pXG4gICAge1xuICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLnR4ID0gcG9zaXRpb24ueDtcbiAgICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS50eSA9IHBvc2l0aW9uLnk7XG4gICAgfVxuXG4gICAgZm9yKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIGlmKGNsZWFyKXRoaXMudGV4dHVyZUJ1ZmZlci5jbGVhcigpO1xuXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLnRleHR1cmVCdWZmZXIuY29udGV4dDtcblxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCBjb250ZXh0KTtcblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcblxuICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0gPSBvcmlnaW5hbFdvcmxkVHJhbnNmb3JtO1xufTtcblxuUElYSS5SZW5kZXJUZXh0dXJlLnRlbXBNYXRyaXggPSBuZXcgUElYSS5NYXRyaXgoKTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogQSBDbGFzcyB0aGF0IGxvYWRzIGEgYnVuY2ggb2YgaW1hZ2VzIC8gc3ByaXRlIHNoZWV0IC8gYml0bWFwIGZvbnQgZmlsZXMuIE9uY2UgdGhlXG4gKiBhc3NldHMgaGF2ZSBiZWVuIGxvYWRlZCB0aGV5IGFyZSBhZGRlZCB0byB0aGUgUElYSSBUZXh0dXJlIGNhY2hlIGFuZCBjYW4gYmUgYWNjZXNzZWRcbiAqIGVhc2lseSB0aHJvdWdoIFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoKSBhbmQgUElYSS5TcHJpdGUuZnJvbUltYWdlKClcbiAqIFdoZW4gYWxsIGl0ZW1zIGhhdmUgYmVlbiBsb2FkZWQgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGEgJ29uTG9hZGVkJyBldmVudFxuICogQXMgZWFjaCBpbmRpdmlkdWFsIGl0ZW0gaXMgbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdvblByb2dyZXNzJyBldmVudFxuICpcbiAqIEBjbGFzcyBBc3NldExvYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBhc3NldFVSTHMgYW4gYXJyYXkgb2YgaW1hZ2Uvc3ByaXRlIHNoZWV0IHVybHMgdGhhdCB5b3Ugd291bGQgbGlrZSBsb2FkZWRcbiAqICAgICAgc3VwcG9ydGVkLiBTdXBwb3J0ZWQgaW1hZ2UgZm9ybWF0cyBpbmNsdWRlICdqcGVnJywgJ2pwZycsICdwbmcnLCAnZ2lmJy4gU3VwcG9ydGVkXG4gKiAgICAgIHNwcml0ZSBzaGVldCBkYXRhIGZvcm1hdHMgb25seSBpbmNsdWRlICdKU09OJyBhdCB0aGlzIHRpbWUuIFN1cHBvcnRlZCBiaXRtYXAgZm9udFxuICogICAgICBkYXRhIGZvcm1hdHMgaW5jbHVkZSAneG1sJyBhbmQgJ2ZudCcuXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqL1xuUElYSS5Bc3NldExvYWRlciA9IGZ1bmN0aW9uKGFzc2V0VVJMcywgY3Jvc3NvcmlnaW4pXG57XG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIGFzc2V0IFVSTHMgdGhhdCBhcmUgZ29pbmcgdG8gYmUgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYXNzZXRVUkxzXG4gICAgICogQHR5cGUgQXJyYXk8U3RyaW5nPlxuICAgICAqL1xuICAgIHRoaXMuYXNzZXRVUkxzID0gYXNzZXRVUkxzO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3Mgb3JpZ2luXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY3Jvc3NvcmlnaW5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jcm9zc29yaWdpbiA9IGNyb3Nzb3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogTWFwcyBmaWxlIGV4dGVuc2lvbiB0byBsb2FkZXIgdHlwZXNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsb2FkZXJzQnlUeXBlXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5sb2FkZXJzQnlUeXBlID0ge1xuICAgICAgICAnanBnJzogIFBJWEkuSW1hZ2VMb2FkZXIsXG4gICAgICAgICdqcGVnJzogUElYSS5JbWFnZUxvYWRlcixcbiAgICAgICAgJ3BuZyc6ICBQSVhJLkltYWdlTG9hZGVyLFxuICAgICAgICAnZ2lmJzogIFBJWEkuSW1hZ2VMb2FkZXIsXG4gICAgICAgICdqc29uJzogUElYSS5Kc29uTG9hZGVyLFxuICAgICAgICAnYXRsYXMnOiBQSVhJLkF0bGFzTG9hZGVyLFxuICAgICAgICAnYW5pbSc6IFBJWEkuU3BpbmVMb2FkZXIsXG4gICAgICAgICd4bWwnOiAgUElYSS5CaXRtYXBGb250TG9hZGVyLFxuICAgICAgICAnZm50JzogIFBJWEkuQml0bWFwRm9udExvYWRlclxuICAgIH07XG59O1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gYW4gaXRlbSBoYXMgbG9hZGVkXG4gKiBAZXZlbnQgb25Qcm9ncmVzc1xuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBhbGwgdGhlIGFzc2V0cyBoYXZlIGxvYWRlZFxuICogQGV2ZW50IG9uQ29tcGxldGVcbiAqL1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5Bc3NldExvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkFzc2V0TG9hZGVyO1xuXG4vKipcbiAqIEdpdmVuIGEgZmlsZW5hbWUsIHJldHVybnMgaXRzIGV4dGVuc2lvbiwgd2lsXG4gKlxuICogQG1ldGhvZCBfZ2V0RGF0YVR5cGVcbiAqIEBwYXJhbSBzdHIge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGFzc2V0XG4gKi9cblBJWEkuQXNzZXRMb2FkZXIucHJvdG90eXBlLl9nZXREYXRhVHlwZSA9IGZ1bmN0aW9uKHN0cilcbntcbiAgICB2YXIgdGVzdCA9ICdkYXRhOic7XG4gICAgLy9zdGFydHMgd2l0aCAnZGF0YTonXG4gICAgdmFyIHN0YXJ0ID0gc3RyLnNsaWNlKDAsIHRlc3QubGVuZ3RoKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChzdGFydCA9PT0gdGVzdCkge1xuICAgICAgICB2YXIgZGF0YSA9IHN0ci5zbGljZSh0ZXN0Lmxlbmd0aCk7XG5cbiAgICAgICAgdmFyIHNlcElkeCA9IGRhdGEuaW5kZXhPZignLCcpO1xuICAgICAgICBpZiAoc2VwSWR4ID09PSAtMSkgLy9tYWxmb3JtZWQgZGF0YSBVUkkgc2NoZW1lXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAvL2UuZy4gJ2ltYWdlL2dpZjtiYXNlNjQnID0+ICdpbWFnZS9naWYnXG4gICAgICAgIHZhciBpbmZvID0gZGF0YS5zbGljZSgwLCBzZXBJZHgpLnNwbGl0KCc7JylbMF07XG5cbiAgICAgICAgLy9XZSBtaWdodCBuZWVkIHRvIGhhbmRsZSBzb21lIHNwZWNpYWwgY2FzZXMgaGVyZS4uLlxuICAgICAgICAvL3N0YW5kYXJkaXplIHRleHQvcGxhaW4gdG8gJ3R4dCcgZmlsZSBleHRlbnNpb25cbiAgICAgICAgaWYgKCFpbmZvIHx8IGluZm8udG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQvcGxhaW4nKVxuICAgICAgICAgICAgcmV0dXJuICd0eHQnO1xuXG4gICAgICAgIC8vVXNlciBzcGVjaWZpZWQgbWltZSB0eXBlLCB0cnkgc3BsaXR0aW5nIGl0IGJ5ICcvJ1xuICAgICAgICByZXR1cm4gaW5mby5zcGxpdCgnLycpLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBsb2FkaW5nIHRoZSBhc3NldHMgc2VxdWVudGlhbGx5XG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuQXNzZXRMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIG9uTG9hZChldnQpIHtcbiAgICAgICAgc2NvcGUub25Bc3NldExvYWRlZChldnQuY29udGVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkQ291bnQgPSB0aGlzLmFzc2V0VVJMcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCB0aGlzLmFzc2V0VVJMcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuYXNzZXRVUkxzW2ldO1xuICAgICAgICAvL2ZpcnN0IHNlZSBpZiB3ZSBoYXZlIGEgZGF0YSBVUkkgc2NoZW1lLi5cbiAgICAgICAgdmFyIGZpbGVUeXBlID0gdGhpcy5fZ2V0RGF0YVR5cGUoZmlsZU5hbWUpO1xuXG4gICAgICAgIC8vaWYgbm90LCBhc3N1bWUgaXQncyBhIGZpbGUgVVJJXG4gICAgICAgIGlmICghZmlsZVR5cGUpXG4gICAgICAgICAgICBmaWxlVHlwZSA9IGZpbGVOYW1lLnNwbGl0KCc/Jykuc2hpZnQoKS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5sb2FkZXJzQnlUeXBlW2ZpbGVUeXBlXTtcbiAgICAgICAgaWYoIUNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZpbGVUeXBlICsgJyBpcyBhbiB1bnN1cHBvcnRlZCBmaWxlIHR5cGUnKTtcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IENvbnN0cnVjdG9yKGZpbGVOYW1lLCB0aGlzLmNyb3Nzb3JpZ2luKTtcblxuICAgICAgICBsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgb25Mb2FkKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludm9rZWQgYWZ0ZXIgZWFjaCBmaWxlIGlzIGxvYWRlZFxuICpcbiAqIEBtZXRob2Qgb25Bc3NldExvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5Bc3NldExvYWRlci5wcm90b3R5cGUub25Bc3NldExvYWRlZCA9IGZ1bmN0aW9uKGxvYWRlcilcbntcbiAgICB0aGlzLmxvYWRDb3VudC0tO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICdvblByb2dyZXNzJywgY29udGVudDogdGhpcywgbG9hZGVyOiBsb2FkZXIgfSk7XG4gICAgaWYgKHRoaXMub25Qcm9ncmVzcykgdGhpcy5vblByb2dyZXNzKGxvYWRlcik7XG5cbiAgICBpZiAoIXRoaXMubG9hZENvdW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnb25Db21wbGV0ZScsIGNvbnRlbnQ6IHRoaXN9KTtcbiAgICAgICAgaWYodGhpcy5vbkNvbXBsZXRlKSB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIGpzb24gZmlsZSBsb2FkZXIgaXMgdXNlZCB0byBsb2FkIGluIEpTT04gZGF0YSBhbmQgcGFyc2UgaXRcbiAqIFdoZW4gbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdsb2FkZWQnIGV2ZW50XG4gKiBJZiBsb2FkaW5nIGZhaWxzIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhbiAnZXJyb3InIGV2ZW50XG4gKlxuICogQGNsYXNzIEpzb25Mb2FkZXJcbiAqIEB1c2VzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB1cmwge1N0cmluZ30gVGhlIHVybCBvZiB0aGUgSlNPTiBmaWxlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqL1xuUElYSS5Kc29uTG9hZGVyID0gZnVuY3Rpb24gKHVybCwgY3Jvc3NvcmlnaW4pIHtcbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXJsIG9mIHRoZSBiaXRtYXAgZm9udCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zcyBvcmlnaW5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjcm9zc29yaWdpblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmNyb3Nzb3JpZ2luID0gY3Jvc3NvcmlnaW47XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgYmFzZSB1cmwgb2YgdGhlIGJpdG1hcCBmb250IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlVXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5iYXNlVXJsID0gdXJsLnJlcGxhY2UoL1teXFwvXSokLywgJycpO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gV2hldGhlciB0aGUgZGF0YSBoYXMgbG9hZGVkIHlldFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxvYWRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5Kc29uTG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuSnNvbkxvYWRlcjtcblxuLyoqXG4gKiBMb2FkcyB0aGUgSlNPTiBkYXRhXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuSnNvbkxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcblxuXG4gICAgaWYod2luZG93LlhEb21haW5SZXF1ZXN0KVxuICAgIHtcbiAgICAgICAgdGhpcy5hamF4UmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KVxuICAgIHtcbiAgICAgICAgdGhpcy5hamF4UmVxdWVzdCA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5hamF4UmVxdWVzdCA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9XG5cbiAgICBcblxuXG4gICAvLyB0aGlzLmFqYXhSZXF1ZXN0ID0gbmV3IFBJWEkuQWpheFJlcXVlc3QodGhpcy5jcm9zc29yaWdpbik7XG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICBcblxuICAgIFxuXG4gICAgdGhpcy5hamF4UmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjb3BlLm9uSlNPTkxvYWRlZCgpO1xuICAgIH07XG5cbiAgIC8vIHRoaXMuYWpheFJlcXVlc3Qub3BlbignR0VUJywgdGhpcy51cmwsIHRydWUpO1xuICAvLyAgaWYgKHRoaXMuYWpheFJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSkgdGhpcy5hamF4UmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIC8vICB0aGlzLmFqYXhSZXF1ZXN0LnNlbmQobnVsbCk7XG5cbiAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9wZW4oJ0dFVCcsdGhpcy51cmwsZmFsc2UpO1xuICAgIHRoaXMuYWpheFJlcXVlc3Quc2VuZCgpO1xufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBKU09OIGZpbGUgaXMgbG9hZGVkXG4gKlxuICogQG1ldGhvZCBvbkpTT05Mb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSnNvbkxvYWRlci5wcm90b3R5cGUub25KU09OTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgLy8gaWYgKHRoaXMuYWpheFJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAvLyAgIGlmICh0aGlzLmFqYXhSZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IC0xKSB7XG4gICAgdGhpcy5qc29uID0gSlNPTi5wYXJzZSh0aGlzLmFqYXhSZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG5cbiAgICBpZih0aGlzLmpzb24uZnJhbWVzKVxuICAgIHtcbiAgICAgICAgLy8gc3ByaXRlIHNoZWV0XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgIHZhciB0ZXh0dXJlVXJsID0gdGhpcy5iYXNlVXJsICsgdGhpcy5qc29uLm1ldGEuaW1hZ2U7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBQSVhJLkltYWdlTG9hZGVyKHRleHR1cmVVcmwsIHRoaXMuY3Jvc3NvcmlnaW4pO1xuICAgICAgICB2YXIgZnJhbWVEYXRhID0gdGhpcy5qc29uLmZyYW1lcztcblxuICAgICAgICB0aGlzLnRleHR1cmUgPSBpbWFnZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLm9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gZnJhbWVEYXRhKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGZyYW1lRGF0YVtpXS5mcmFtZTtcbiAgICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgUElYSS5UZXh0dXJlQ2FjaGVbaV0gPSBuZXcgUElYSS5UZXh0dXJlKHRoaXMudGV4dHVyZSwge1xuICAgICAgICAgICAgICAgICAgICB4OiByZWN0LngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJlY3QueSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJlY3QudyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZnRoZSBzcHJpdGUgaGEgYmVlbiB0cmltbWVkLi5cbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVEYXRhW2ldLnRyaW1tZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZSA9ICBQSVhJLlRleHR1cmVDYWNoZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWxTaXplID0gZnJhbWVEYXRhW2ldLnNvdXJjZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFsU2l6ZSA9IGZyYW1lRGF0YVtpXS5zcHJpdGVTb3VyY2VTaXplO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUudHJpbSA9IG5ldyBQSVhJLlJlY3RhbmdsZShyZWFsU2l6ZS54LCByZWFsU2l6ZS55LCBhY3R1YWxTaXplLncsIGFjdHVhbFNpemUuaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2UubG9hZCgpO1xuXG4gICAgfVxuICAgIGVsc2UgaWYodGhpcy5qc29uLmJvbmVzKVxuICAgIHtcbiAgICAgICAgLy8gc3BpbmUgYW5pbWF0aW9uXG4gICAgICAgIHZhciBzcGluZUpzb25QYXJzZXIgPSBuZXcgc3BpbmUuU2tlbGV0b25Kc29uKCk7XG4gICAgICAgIHZhciBza2VsZXRvbkRhdGEgPSBzcGluZUpzb25QYXJzZXIucmVhZFNrZWxldG9uRGF0YSh0aGlzLmpzb24pO1xuICAgICAgICBQSVhJLkFuaW1DYWNoZVt0aGlzLnVybF0gPSBza2VsZXRvbkRhdGE7XG4gICAgICAgIHRoaXMub25Mb2FkZWQoKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5vbkxvYWRlZCgpO1xuICAgIH1cbiAgICAgLy8gICB9XG4gICAgICAvLyAgZWxzZVxuICAgICAgICAvL3tcbiAgICAgICAgICAvLyAgdGhpcy5vbkVycm9yKCk7XG4gICAgICAgLy8gLyB9XG4gICAvLyB9XG59O1xuXG4vKipcbiAqIEludm9rZSB3aGVuIGpzb24gZmlsZSBsb2FkZWRcbiAqXG4gKiBAbWV0aG9kIG9uTG9hZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkpzb25Mb2FkZXIucHJvdG90eXBlLm9uTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnbG9hZGVkJyxcbiAgICAgICAgY29udGVudDogdGhpc1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBlcnJvciBvY2N1cmVkXG4gKlxuICogQG1ldGhvZCBvbkVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkpzb25Mb2FkZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgY29udGVudDogdGhpc1xuICAgIH0pO1xufTtcbi8qKlxuICogQGF1dGhvciBNYXJ0aW4gS2VsbSBodHRwOi8vbWtlbG0uZ2l0aHViLmNvbVxuICovXG5cbi8qKlxuICogVGhlIGF0bGFzIGZpbGUgbG9hZGVyIGlzIHVzZWQgdG8gbG9hZCBpbiBBdGxhcyBkYXRhIGFuZCBwYXJzZSBpdFxuICogV2hlbiBsb2FkZWQgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGEgJ2xvYWRlZCcgZXZlbnRcbiAqIElmIGxvYWRpbmcgZmFpbHMgdGhpcyBjbGFzcyB3aWxsIGRpc3BhdGNoIGFuICdlcnJvcicgZXZlbnRcbiAqIEBjbGFzcyBBdGxhc0xvYWRlclxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHVybCB0aGUgdXJsIG9mIHRoZSBKU09OIGZpbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY3Jvc3NvcmlnaW5cbiAqL1xuXG5QSVhJLkF0bGFzTG9hZGVyID0gZnVuY3Rpb24gKHVybCwgY3Jvc3NvcmlnaW4pIHtcbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5iYXNlVXJsID0gdXJsLnJlcGxhY2UoL1teXFwvXSokLywgJycpO1xuICAgIHRoaXMuY3Jvc3NvcmlnaW4gPSBjcm9zc29yaWdpbjtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5BdGxhc0xvYWRlci5jb25zdHJ1Y3RvciA9IFBJWEkuQXRsYXNMb2FkZXI7XG5cblxuIC8qKlxuICogU3RhcnRzIGxvYWRpbmcgdGhlIEpTT04gZmlsZVxuICpcbiAqIEBtZXRob2QgbG9hZFxuICovXG5QSVhJLkF0bGFzTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWpheFJlcXVlc3QgPSBuZXcgUElYSS5BamF4UmVxdWVzdCgpO1xuICAgIHRoaXMuYWpheFJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vbkF0bGFzTG9hZGVkLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoaXMudXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy5hamF4UmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKSB0aGlzLmFqYXhSZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB0aGlzLmFqYXhSZXF1ZXN0LnNlbmQobnVsbCk7XG59O1xuXG4vKipcbiAqIEludm9rZSB3aGVuIEpTT04gZmlsZSBpcyBsb2FkZWRcbiAqIEBtZXRob2Qgb25BdGxhc0xvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5BdGxhc0xvYWRlci5wcm90b3R5cGUub25BdGxhc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hamF4UmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGlmICh0aGlzLmFqYXhSZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJ2h0dHAnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYXRsYXMgPSB7XG4gICAgICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgOiBbXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnJhbWVzIDogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hamF4UmVxdWVzdC5yZXNwb25zZVRleHQuc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgICAgIHZhciBsaW5lQ291bnQgPSAtMztcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRJbWFnZUlkID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG5hbWVJbk5leHRMaW5lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgICAgICBzZWxmT25Mb2FkZWQgPSB0aGlzLm9uTG9hZGVkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIHBhcnNlciB3aXRob3V0IHJvdGF0aW9uIHN1cHBvcnQgeWV0IVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtpXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUluTmV4dExpbmUgPSBpKzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZUluTmV4dExpbmUgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXRsYXMubWV0YS5pbWFnZS5wdXNoKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW1hZ2VJZCA9IHRoaXMuYXRsYXMubWV0YS5pbWFnZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdGxhcy5mcmFtZXMucHVzaCh7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQ291bnQgPSAtMztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZUNvdW50ICUgNyA9PT0gMSkgeyAvLyBmcmFtZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSAhPSBudWxsKSB7IC8vanNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXRsYXMuZnJhbWVzW2N1cnJlbnRJbWFnZUlkXVtjdXJyZW50RnJhbWUubmFtZV0gPSBjdXJyZW50RnJhbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZSA9IHsgbmFtZTogcmVzdWx0W2ldLCBmcmFtZSA6IHt9IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gcmVzdWx0W2ldLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVDb3VudCAlIDcgPT09IDMpIHsgLy8gcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmZyYW1lLnggPSBOdW1iZXIodGV4dFsxXS5yZXBsYWNlKCcsJywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmZyYW1lLnkgPSBOdW1iZXIodGV4dFsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lQ291bnQgJSA3ID09PSA0KSB7IC8vIHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmZyYW1lLncgPSBOdW1iZXIodGV4dFsxXS5yZXBsYWNlKCcsJywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmZyYW1lLmggPSBOdW1iZXIodGV4dFsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lQ291bnQgJSA3ID09PSA1KSB7IC8vIHJlYWwgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhbFNpemUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA6IE51bWJlcih0ZXh0WzFdLnJlcGxhY2UoJywnLCAnJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA6IE51bWJlcih0ZXh0WzJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFsU2l6ZS53ID4gY3VycmVudEZyYW1lLmZyYW1lLncgfHwgcmVhbFNpemUuaCA+IGN1cnJlbnRGcmFtZS5mcmFtZS5oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUudHJpbW1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUucmVhbFNpemUgPSByZWFsU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS50cmltbWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lICE9IG51bGwpIHsgLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICB0aGlzLmF0bGFzLmZyYW1lc1tjdXJyZW50SW1hZ2VJZF1bY3VycmVudEZyYW1lLm5hbWVdID0gY3VycmVudEZyYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5hdGxhcy5tZXRhLmltYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLmF0bGFzLm1ldGEuaW1hZ2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ByaXRlIHNoZWV0XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlVXJsID0gdGhpcy5iYXNlVXJsICsgdGhpcy5hdGxhcy5tZXRhLmltYWdlW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVEYXRhID0gdGhpcy5hdGxhcy5mcmFtZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2gobmV3IFBJWEkuSW1hZ2VMb2FkZXIodGV4dHVyZVVybCwgdGhpcy5jcm9zc29yaWdpbikpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBmcmFtZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZnJhbWVEYXRhW2ldLmZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQSVhJLlRleHR1cmVDYWNoZVtpXSA9IG5ldyBQSVhJLlRleHR1cmUodGhpcy5pbWFnZXNbal0udGV4dHVyZS5iYXNlVGV4dHVyZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiByZWN0LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHJlY3QueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJlY3QudyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVEYXRhW2ldLnRyaW1tZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUElYSS5UZXh0dXJlQ2FjaGVbaV0ucmVhbFNpemUgPSBmcmFtZURhdGFbaV0ucmVhbFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaW0gaW4gcGl4aSBub3Qgc3VwcG9ydGVkIHlldCwgdG9kbyB1cGRhdGUgdHJpbSBwcm9wZXJ0aWVzIGlmIGl0IGlzIGRvbmUgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBJWEkuVGV4dHVyZUNhY2hlW2ldLnRyaW0ueCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBJWEkuVGV4dHVyZUNhY2hlW2ldLnRyaW0ueSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SW1hZ2VJZCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuaW1hZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW2pdLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIHNlbGZPbkxvYWRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW3RoaXMuY3VycmVudEltYWdlSWRdLmxvYWQoKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZGVkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBqc29uIGZpbGUgaGFzIGxvYWRlZFxuICogQG1ldGhvZCBvbkxvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5BdGxhc0xvYWRlci5wcm90b3R5cGUub25Mb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VzLmxlbmd0aCAtIDEgPiB0aGlzLmN1cnJlbnRJbWFnZUlkKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEltYWdlSWQrKztcbiAgICAgICAgdGhpcy5pbWFnZXNbdGhpcy5jdXJyZW50SW1hZ2VJZF0ubG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6ICdsb2FkZWQnLFxuICAgICAgICAgICAgY29udGVudDogdGhpc1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludm9rZSB3aGVuIGVycm9yIG9jY3VyZWRcbiAqIEBtZXRob2Qgb25FcnJvclxuICogQHByaXZhdGVcbiAqL1xuUElYSS5BdGxhc0xvYWRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICBjb250ZW50OiB0aGlzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIHNwcml0ZSBzaGVldCBsb2FkZXIgaXMgdXNlZCB0byBsb2FkIGluIEpTT04gc3ByaXRlIHNoZWV0IGRhdGFcbiAqIFRvIGdlbmVyYXRlIHRoZSBkYXRhIHlvdSBjYW4gdXNlIGh0dHA6Ly93d3cuY29kZWFuZHdlYi5jb20vdGV4dHVyZXBhY2tlciBhbmQgcHVibGlzaCBpbiB0aGUgJ0pTT04nIGZvcm1hdFxuICogVGhlcmUgaXMgYSBmcmVlIHZlcnNpb24gc28gdGhhdHMgbmljZSwgYWx0aG91Z2ggdGhlIHBhaWQgdmVyc2lvbiBpcyBncmVhdCB2YWx1ZSBmb3IgbW9uZXkuXG4gKiBJdCBpcyBoaWdobHkgcmVjb21tZW5kZWQgdG8gdXNlIFNwcml0ZSBzaGVldHMgKGFsc28ga25vdyBhcyBhICd0ZXh0dXJlIGF0bGFzJykgYXMgaXQgbWVhbnMgc3ByaXRlcyBjYW4gYmUgYmF0Y2hlZCBhbmQgZHJhd24gdG9nZXRoZXIgZm9yIGhpZ2hseSBpbmNyZWFzZWQgcmVuZGVyaW5nIHNwZWVkLlxuICogT25jZSB0aGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQgdGhlIGZyYW1lcyBhcmUgc3RvcmVkIGluIHRoZSBQSVhJIHRleHR1cmUgY2FjaGUgYW5kIGNhbiBiZSBhY2Nlc3NlZCB0aG91Z2ggUElYSS5UZXh0dXJlLmZyb21GcmFtZUlkKCkgYW5kIFBJWEkuU3ByaXRlLmZyb21GcmFtZUlkKClcbiAqIFRoaXMgbG9hZGVyIHdpbGwgbG9hZCB0aGUgaW1hZ2UgZmlsZSB0aGF0IHRoZSBTcHJpdGVzaGVldCBwb2ludHMgdG8gYXMgd2VsbCBhcyB0aGUgZGF0YS5cbiAqIFdoZW4gbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdsb2FkZWQnIGV2ZW50XG4gKlxuICogQGNsYXNzIFNwcml0ZVNoZWV0TG9hZGVyXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdXJsIHtTdHJpbmd9IFRoZSB1cmwgb2YgdGhlIHNwcml0ZSBzaGVldCBKU09OIGZpbGVcbiAqIEBwYXJhbSBjcm9zc29yaWdpbiB7Qm9vbGVhbn0gV2hldGhlciByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zc29yaWdpblxuICovXG5QSVhJLlNwcml0ZVNoZWV0TG9hZGVyID0gZnVuY3Rpb24gKHVybCwgY3Jvc3NvcmlnaW4pIHtcbiAgICAvKlxuICAgICAqIGkgdXNlIHRleHR1cmUgcGFja2VyIHRvIGxvYWQgdGhlIGFzc2V0cy4uXG4gICAgICogaHR0cDovL3d3dy5jb2RlYW5kd2ViLmNvbS90ZXh0dXJlcGFja2VyXG4gICAgICogbWFrZSBzdXJlIHRvIHNldCB0aGUgZm9ybWF0IGFzICdKU09OJ1xuICAgICAqL1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cmwgb2YgdGhlIGJpdG1hcCBmb250IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB1cmxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IHVybDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3NzIG9yaWdpblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNyb3Nzb3JpZ2luXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NvcmlnaW4gPSBjcm9zc29yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBiYXNlIHVybCBvZiB0aGUgYml0bWFwIGZvbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJhc2VVcmxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmJhc2VVcmwgPSB1cmwucmVwbGFjZSgvW15cXC9dKiQvLCAnJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dHVyZSBiZWluZyBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0dXJlXG4gICAgICogQHR5cGUgVGV4dHVyZVxuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhbWVzIG9mIHRoZSBzcHJpdGUgc2hlZXRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmFtZXNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lcyA9IHt9O1xufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuU3ByaXRlU2hlZXRMb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5TcHJpdGVTaGVldExvYWRlcjtcblxuLyoqXG4gKiBUaGlzIHdpbGwgYmVnaW4gbG9hZGluZyB0aGUgSlNPTiBmaWxlXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuU3ByaXRlU2hlZXRMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICB2YXIganNvbkxvYWRlciA9IG5ldyBQSVhJLkpzb25Mb2FkZXIodGhpcy51cmwsIHRoaXMuY3Jvc3NvcmlnaW4pO1xuICAgIGpzb25Mb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNjb3BlLmpzb24gPSBldmVudC5jb250ZW50Lmpzb247XG4gICAgICAgIHNjb3BlLm9uTG9hZGVkKCk7XG4gICAgfSk7XG4gICAganNvbkxvYWRlci5sb2FkKCk7XG59O1xuXG4vKipcbiAqIEludm9rZSB3aGVuIGFsbCBmaWxlcyBhcmUgbG9hZGVkIChqc29uIGFuZCB0ZXh0dXJlKVxuICpcbiAqIEBtZXRob2Qgb25Mb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuU3ByaXRlU2hlZXRMb2FkZXIucHJvdG90eXBlLm9uTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6ICdsb2FkZWQnLFxuICAgICAgICBjb250ZW50OiB0aGlzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIGltYWdlIGxvYWRlciBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBpbWFnZXMgZmlsZSBmb3JtYXRzICgnanBlZycsICdqcGcnLCAncG5nJyBhbmQgJ2dpZicpXG4gKiBPbmNlIHRoZSBpbWFnZSBoYXMgYmVlbiBsb2FkZWQgaXQgaXMgc3RvcmVkIGluIHRoZSBQSVhJIHRleHR1cmUgY2FjaGUgYW5kIGNhbiBiZSBhY2Nlc3NlZCB0aG91Z2ggUElYSS5UZXh0dXJlLmZyb21GcmFtZUlkKCkgYW5kIFBJWEkuU3ByaXRlLmZyb21GcmFtZUlkKClcbiAqIFdoZW4gbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdsb2FkZWQnIGV2ZW50XG4gKlxuICogQGNsYXNzIEltYWdlTG9hZGVyXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdXJsIHtTdHJpbmd9IFRoZSB1cmwgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge0Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqL1xuUElYSS5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uKHVybCwgY3Jvc3NvcmlnaW4pXG57XG4gICAgUElYSS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgYmVpbmcgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGV4dHVyZVxuICAgICAqIEB0eXBlIFRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKHVybCwgY3Jvc3NvcmlnaW4pO1xuXG4gICAgLyoqXG4gICAgICogaWYgdGhlIGltYWdlIGlzIGxvYWRlZCB3aXRoIGxvYWRGcmFtZWRTcHJpdGVTaGVldFxuICAgICAqIGZyYW1lcyB3aWxsIGNvbnRhaW4gdGhlIHNwcml0ZSBzaGVldCBmcmFtZXNcbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVzID0gW107XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5JbWFnZUxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkltYWdlTG9hZGVyO1xuXG4vKipcbiAqIExvYWRzIGltYWdlIG9yIHRha2VzIGl0IGZyb20gY2FjaGVcbiAqXG4gKiBAbWV0aG9kIGxvYWRcbiAqL1xuUElYSS5JbWFnZUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZighdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNjb3BlLm9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLm9uTG9hZGVkKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnZva2VkIHdoZW4gaW1hZ2UgZmlsZSBpcyBsb2FkZWQgb3IgaXQgaXMgYWxyZWFkeSBjYWNoZWQgYW5kIHJlYWR5IHRvIHVzZVxuICpcbiAqIEBtZXRob2Qgb25Mb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuSW1hZ2VMb2FkZXIucHJvdG90eXBlLm9uTG9hZGVkID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTogJ2xvYWRlZCcsIGNvbnRlbnQ6IHRoaXN9KTtcbn07XG5cbi8qKlxuICogTG9hZHMgaW1hZ2UgYW5kIHNwbGl0IGl0IHRvIHVuaWZvcm0gc2l6ZWQgZnJhbWVzXG4gKlxuICpcbiAqIEBtZXRob2QgbG9hZEZyYW1lZFNwcml0ZVNoZWV0XG4gKiBAcGFyYW0gZnJhbWVXaWR0aCB7TnVtYmVyfSB3aWR0aCBvZiBlYWNoIGZyYW1lXG4gKiBAcGFyYW0gZnJhbWVIZWlnaHQge051bWJlcn0gaGVpZ2h0IG9mIGVhY2ggZnJhbWVcbiAqIEBwYXJhbSB0ZXh0dXJlTmFtZSB7U3RyaW5nfSBpZiBnaXZlbiwgdGhlIGZyYW1lcyB3aWxsIGJlIGNhY2hlZCBpbiA8dGV4dHVyZU5hbWU+LTxvcmQ+IGZvcm1hdFxuICovXG5QSVhJLkltYWdlTG9hZGVyLnByb3RvdHlwZS5sb2FkRnJhbWVkU3ByaXRlU2hlZXQgPSBmdW5jdGlvbihmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCwgdGV4dHVyZU5hbWUpXG57XG4gICAgdGhpcy5mcmFtZXMgPSBbXTtcbiAgICB2YXIgY29scyA9IE1hdGguZmxvb3IodGhpcy50ZXh0dXJlLndpZHRoIC8gZnJhbWVXaWR0aCk7XG4gICAgdmFyIHJvd3MgPSBNYXRoLmZsb29yKHRoaXMudGV4dHVyZS5oZWlnaHQgLyBmcmFtZUhlaWdodCk7XG5cbiAgICB2YXIgaT0wO1xuICAgIGZvciAodmFyIHk9MDsgeTxyb3dzOyB5KyspXG4gICAge1xuICAgICAgICBmb3IgKHZhciB4PTA7IHg8Y29sczsgeCsrLGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgUElYSS5UZXh0dXJlKHRoaXMudGV4dHVyZSwge1xuICAgICAgICAgICAgICAgIHg6IHgqZnJhbWVXaWR0aCxcbiAgICAgICAgICAgICAgICB5OiB5KmZyYW1lSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmcmFtZVdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZnJhbWVIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmZyYW1lcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICAgICAgaWYgKHRleHR1cmVOYW1lKSBQSVhJLlRleHR1cmVDYWNoZVt0ZXh0dXJlTmFtZSArICctJyArIGldID0gdGV4dHVyZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKCF0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2NvcGUub25Mb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMub25Mb2FkZWQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIHhtbCBsb2FkZXIgaXMgdXNlZCB0byBsb2FkIGluIFhNTCBiaXRtYXAgZm9udCBkYXRhICgneG1sJyBvciAnZm50JylcbiAqIFRvIGdlbmVyYXRlIHRoZSBkYXRhIHlvdSBjYW4gdXNlIGh0dHA6Ly93d3cuYW5nZWxjb2RlLmNvbS9wcm9kdWN0cy9ibWZvbnQvXG4gKiBUaGlzIGxvYWRlciB3aWxsIGFsc28gbG9hZCB0aGUgaW1hZ2UgZmlsZSBhcyB0aGUgZGF0YS5cbiAqIFdoZW4gbG9hZGVkIHRoaXMgY2xhc3Mgd2lsbCBkaXNwYXRjaCBhICdsb2FkZWQnIGV2ZW50XG4gKlxuICogQGNsYXNzIEJpdG1hcEZvbnRMb2FkZXJcbiAqIEB1c2VzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB1cmwge1N0cmluZ30gVGhlIHVybCBvZiB0aGUgc3ByaXRlIHNoZWV0IEpTT04gZmlsZVxuICogQHBhcmFtIGNyb3Nzb3JpZ2luIHtCb29sZWFufSBXaGV0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3Nzb3JpZ2luXG4gKi9cblBJWEkuQml0bWFwRm9udExvYWRlciA9IGZ1bmN0aW9uKHVybCwgY3Jvc3NvcmlnaW4pXG57XG4gICAgLypcbiAgICAgKiBJIHVzZSB0ZXh0dXJlIHBhY2tlciB0byBsb2FkIHRoZSBhc3NldHMuLlxuICAgICAqIGh0dHA6Ly93d3cuY29kZWFuZHdlYi5jb20vdGV4dHVyZXBhY2tlclxuICAgICAqIG1ha2Ugc3VyZSB0byBzZXQgdGhlIGZvcm1hdCBhcyAnSlNPTidcbiAgICAgKi9cbiAgICBQSVhJLkV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXJsIG9mIHRoZSBiaXRtYXAgZm9udCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zcyBvcmlnaW5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjcm9zc29yaWdpblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmNyb3Nzb3JpZ2luID0gY3Jvc3NvcmlnaW47XG5cbiAgICAvKipcbiAgICAgKiBbcmVhZC1vbmx5XSBUaGUgYmFzZSB1cmwgb2YgdGhlIGJpdG1hcCBmb250IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBiYXNlVXJsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5iYXNlVXJsID0gdXJsLnJlcGxhY2UoL1teXFwvXSokLywgJycpO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIHRleHR1cmUgb2YgdGhlIGJpdG1hcCBmb250XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmFzZVVybFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuUElYSS5CaXRtYXBGb250TG9hZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQml0bWFwRm9udExvYWRlcjtcblxuLyoqXG4gKiBMb2FkcyB0aGUgWE1MIGZvbnQgZGF0YVxuICpcbiAqIEBtZXRob2QgbG9hZFxuICovXG5QSVhJLkJpdG1hcEZvbnRMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5hamF4UmVxdWVzdCA9IG5ldyBQSVhJLkFqYXhSZXF1ZXN0KCk7XG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICB0aGlzLmFqYXhSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHNjb3BlLm9uWE1MTG9hZGVkKCk7XG4gICAgfTtcblxuICAgIHRoaXMuYWpheFJlcXVlc3Qub3BlbignR0VUJywgdGhpcy51cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLmFqYXhSZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHRoaXMuYWpheFJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSgnYXBwbGljYXRpb24veG1sJyk7XG4gICAgdGhpcy5hamF4UmVxdWVzdC5zZW5kKG51bGwpO1xufTtcblxuLyoqXG4gKiBJbnZva2VkIHdoZW4gdGhlIFhNTCBmaWxlIGlzIGxvYWRlZCwgcGFyc2VzIHRoZSBkYXRhXG4gKlxuICogQG1ldGhvZCBvblhNTExvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5CaXRtYXBGb250TG9hZGVyLnByb3RvdHlwZS5vblhNTExvYWRlZCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZiAodGhpcy5hamF4UmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYWpheFJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZVhNTCA9IHRoaXMuYWpheFJlcXVlc3QucmVzcG9uc2VYTUw7XG4gICAgICAgICAgICBpZighcmVzcG9uc2VYTUwgfHwgL01TSUUgOS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgbmF2aWdhdG9yLmlzQ29jb29uSlMpIHtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2Yod2luZG93LkRPTVBhcnNlcikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbXBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VYTUwgPSBkb21wYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRoaXMuYWpheFJlcXVlc3QucmVzcG9uc2VUZXh0LCAndGV4dC94bWwnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSB0aGlzLmFqYXhSZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VYTUwgPSBkaXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGV4dHVyZVVybCA9IHRoaXMuYmFzZVVybCArIHJlc3BvbnNlWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlJylbMF0uZ2V0QXR0cmlidXRlKCdmaWxlJyk7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgUElYSS5JbWFnZUxvYWRlcih0ZXh0dXJlVXJsLCB0aGlzLmNyb3Nzb3JpZ2luKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IGltYWdlLnRleHR1cmUuYmFzZVRleHR1cmU7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICB2YXIgaW5mbyA9IHJlc3BvbnNlWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbmZvJylbMF07XG4gICAgICAgICAgICB2YXIgY29tbW9uID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NvbW1vbicpWzBdO1xuICAgICAgICAgICAgZGF0YS5mb250ID0gaW5mby5nZXRBdHRyaWJ1dGUoJ2ZhY2UnKTtcbiAgICAgICAgICAgIGRhdGEuc2l6ZSA9IHBhcnNlSW50KGluZm8uZ2V0QXR0cmlidXRlKCdzaXplJyksIDEwKTtcbiAgICAgICAgICAgIGRhdGEubGluZUhlaWdodCA9IHBhcnNlSW50KGNvbW1vbi5nZXRBdHRyaWJ1dGUoJ2xpbmVIZWlnaHQnKSwgMTApO1xuICAgICAgICAgICAgZGF0YS5jaGFycyA9IHt9O1xuXG4gICAgICAgICAgICAvL3BhcnNlIGxldHRlcnNcbiAgICAgICAgICAgIHZhciBsZXR0ZXJzID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NoYXInKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXR0ZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpLCAxMCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZVJlY3QgPSBuZXcgUElYSS5SZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd4JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3knKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksIDEwKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBkYXRhLmNoYXJzW2NoYXJDb2RlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeE9mZnNldDogcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3hvZmZzZXQnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0OiBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneW9mZnNldCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHhBZHZhbmNlOiBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneGFkdmFuY2UnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBrZXJuaW5nOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTogUElYSS5UZXh0dXJlQ2FjaGVbY2hhckNvZGVdID0gbmV3IFBJWEkuVGV4dHVyZSh0aGlzLnRleHR1cmUsIHRleHR1cmVSZWN0KVxuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9wYXJzZSBrZXJuaW5nc1xuICAgICAgICAgICAgdmFyIGtlcm5pbmdzID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2tlcm5pbmcnKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXJuaW5ncy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZUludChrZXJuaW5nc1tpXS5nZXRBdHRyaWJ1dGUoJ2ZpcnN0JyksIDEwKTtcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kID0gcGFyc2VJbnQoa2VybmluZ3NbaV0uZ2V0QXR0cmlidXRlKCdzZWNvbmQnKSwgMTApO1xuICAgICAgICAgICAgICAgIHZhciBhbW91bnQgPSBwYXJzZUludChrZXJuaW5nc1tpXS5nZXRBdHRyaWJ1dGUoJ2Ftb3VudCcpLCAxMCk7XG5cbiAgICAgICAgICAgICAgICBkYXRhLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUElYSS5CaXRtYXBUZXh0LmZvbnRzW2RhdGEuZm9udF0gPSBkYXRhO1xuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUub25Mb2FkZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW1hZ2UubG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnZva2VkIHdoZW4gYWxsIGZpbGVzIGFyZSBsb2FkZWQgKHhtbC9mbnQgYW5kIHRleHR1cmUpXG4gKlxuICogQG1ldGhvZCBvbkxvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5CaXRtYXBGb250TG9hZGVyLnByb3RvdHlwZS5vbkxvYWRlZCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6ICdsb2FkZWQnLCBjb250ZW50OiB0aGlzfSk7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICogYmFzZWQgb24gcGl4aSBpbXBhY3Qgc3BpbmUgaW1wbGVtZW50YXRpb24gbWFkZSBieSBFZW1lbGkgS2Vsb2tvcnBpIChAZWtlbG9rb3JwaSkgaHR0cHM6Ly9naXRodWIuY29tL2VrZWxva29ycGlcbiAqXG4gKiBBd2Vzb21lIEpTIHJ1biB0aW1lIHByb3ZpZGVkIGJ5IEVzb3RlcmljU29mdHdhcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc290ZXJpY1NvZnR3YXJlL3NwaW5lLXJ1bnRpbWVzXG4gKlxuICovXG5cbi8qKlxuICogVGhlIFNwaW5lIGxvYWRlciBpcyB1c2VkIHRvIGxvYWQgaW4gSlNPTiBzcGluZSBkYXRhXG4gKiBUbyBnZW5lcmF0ZSB0aGUgZGF0YSB5b3UgbmVlZCB0byB1c2UgaHR0cDovL2Vzb3Rlcmljc29mdHdhcmUuY29tLyBhbmQgZXhwb3J0IGluIHRoZSBcIkpTT05cIiBmb3JtYXRcbiAqIER1ZSB0byBhIGNsYXNoIG9mIG5hbWVzICBZb3Ugd2lsbCBuZWVkIHRvIGNoYW5nZSB0aGUgZXh0ZW5zaW9uIG9mIHRoZSBzcGluZSBmaWxlIGZyb20gKi5qc29uIHRvICouYW5pbSBmb3IgaXQgdG8gbG9hZFxuICogU2VlIGV4YW1wbGUgMTIgKGh0dHA6Ly93d3cuZ29vZGJveWRpZ2l0YWwuY29tL3BpeGlqcy9leGFtcGxlcy8xMi8pIHRvIHNlZSBhIHdvcmtpbmcgZXhhbXBsZSBhbmQgY2hlY2sgb3V0IHRoZSBzb3VyY2VcbiAqIFlvdSB3aWxsIG5lZWQgdG8gZ2VuZXJhdGUgYSBzcHJpdGUgc2hlZXQgdG8gYWNjb21wYW55IHRoZSBzcGluZSBkYXRhXG4gKiBXaGVuIGxvYWRlZCB0aGlzIGNsYXNzIHdpbGwgZGlzcGF0Y2ggYSBcImxvYWRlZFwiIGV2ZW50XG4gKlxuICogQGNsYXNzIFNwaW5lXG4gKiBAdXNlcyBFdmVudFRhcmdldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gdXJsIHtTdHJpbmd9IFRoZSB1cmwgb2YgdGhlIEpTT04gZmlsZVxuICogQHBhcmFtIGNyb3Nzb3JpZ2luIHtCb29sZWFufSBXaGV0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3Nzb3JpZ2luXG4gKi9cblBJWEkuU3BpbmVMb2FkZXIgPSBmdW5jdGlvbih1cmwsIGNyb3Nzb3JpZ2luKVxue1xuICAgIFBJWEkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cmwgb2YgdGhlIGJpdG1hcCBmb250IGRhdGFcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB1cmxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IHVybDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlcXVlc3RzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGNyb3NzIG9yaWdpblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNyb3Nzb3JpZ2luXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NvcmlnaW4gPSBjcm9zc29yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFdoZXRoZXIgdGhlIGRhdGEgaGFzIGxvYWRlZCB5ZXRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsb2FkZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbn07XG5cblBJWEkuU3BpbmVMb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5TcGluZUxvYWRlcjtcblxuLyoqXG4gKiBMb2FkcyB0aGUgSlNPTiBkYXRhXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKi9cblBJWEkuU3BpbmVMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgIHZhciBqc29uTG9hZGVyID0gbmV3IFBJWEkuSnNvbkxvYWRlcih0aGlzLnVybCwgdGhpcy5jcm9zc29yaWdpbik7XG4gICAganNvbkxvYWRlci5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzY29wZS5qc29uID0gZXZlbnQuY29udGVudC5qc29uO1xuICAgICAgICBzY29wZS5vbkxvYWRlZCgpO1xuICAgIH0pO1xuICAgIGpzb25Mb2FkZXIubG9hZCgpO1xufTtcblxuLyoqXG4gKiBJbnZva2Ugd2hlbiBKU09OIGZpbGUgaXMgbG9hZGVkXG4gKlxuICogQG1ldGhvZCBvbkxvYWRlZFxuICogQHByaXZhdGVcbiAqL1xuUElYSS5TcGluZUxvYWRlci5wcm90b3R5cGUub25Mb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7dHlwZTogXCJsb2FkZWRcIiwgY29udGVudDogdGhpc30pO1xufTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgYSBwaXhpLmpzIGZpbHRlci4gQ3VycmVudGx5IG9ubHkgd2ViR0wgc3VwcG9ydHMgZmlsdGVycy5cbiAqIElmIHlvdSB3YW50IHRvIG1ha2UgYSBjdXN0b20gZmlsdGVyIHRoaXMgc2hvdWxkIGJlIHlvdXIgYmFzZSBjbGFzcy5cbiAqIEBjbGFzcyBBYnN0cmFjdEZpbHRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZnJhZ21lbnRTcmNcbiAqIEBwYXJhbSB1bmlmb3Jtc1xuICovXG5QSVhJLkFic3RyYWN0RmlsdGVyID0gZnVuY3Rpb24oZnJhZ21lbnRTcmMsIHVuaWZvcm1zKVxue1xuICAgIC8qKlxuICAgICogQW4gYXJyYXkgb2YgcGFzc2VzIC0gc29tZSBmaWx0ZXJzIGNvbnRhaW4gYSBmZXcgc3RlcHMgdGhpcyBhcnJheSBzaW1wbHkgc3RvcmVzIHRoZSBzdGVwcyBpbiBhIGxpbmllYXIgZmFzaGlvbi5cbiAgICAqIEZvciBleGFtcGxlIHRoZSBibHVyIGZpbHRlciBoYXMgdHdvIHBhc3NlcyBibHVyWCBhbmQgYmx1clkuXG4gICAgKiBAcHJvcGVydHkgcGFzc2VzXG4gICAgKiBAdHlwZSBBcnJheSBhbiBhcnJheSBvZiBmaWx0ZXIgb2JqZWN0c1xuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkgc2hhZGVyc1xuICAgICogQHR5cGUgQXJyYXkgYW4gYXJyYXkgb2Ygc2hhZGVyc1xuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuc2hhZGVycyA9IFtdO1xuICAgIFxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMucGFkZGluZyA9IDA7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB1bmlmb3Jtc1xuICAgICogQHR5cGUgb2JqZWN0XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy51bmlmb3JtcyA9IHVuaWZvcm1zIHx8IHt9O1xuICAgIC8qKlxuICAgICogQHByb3BlcnR5IGZyYWdtZW50U3JjXG4gICAgKiBAdHlwZSBBcnJheVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYyB8fCBbXTtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhlIEFscGhhTWFza0ZpbHRlciBjbGFzcyB1c2VzIHRoZSBwaXhlbCB2YWx1ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRleHR1cmUgKGNhbGxlZCB0aGUgZGlzcGxhY2VtZW50IG1hcCkgdG8gcGVyZm9ybSBhIGRpc3BsYWNlbWVudCBvZiBhbiBvYmplY3QuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGZpbHRlciB0byBhcHBseSBhbGwgbWFub3Igb2YgY3Jhenkgd2FycGluZyBlZmZlY3RzXG4gKiBDdXJyZW50bHkgdGhlIHIgcHJvcGVydHkgb2YgdGhlIHRleHR1cmUgaXMgdXNlZCB0byBvZmZzZXQgdGhlIHggYW5kIHRoZSBnIHByb3Blcnkgb2YgdGhlIHRleHR1cmUgaXMgdXNlZCB0byBvZmZzZXQgdGhlIHkuXG4gKiBAY2xhc3MgQWxwaGFNYXNrRmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW10ZW50IG1hcCAqIG11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlIGF0IHRoZSBtb21lbnRcbiAqL1xuUElYSS5BbHBoYU1hc2tGaWx0ZXIgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5fcG93ZXJPZjIgPSB0cnVlO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIG1hc2s6IHt0eXBlOiAnc2FtcGxlcjJEJywgdmFsdWU6dGV4dHVyZX0sXG4gICAgICAgIG1hcERpbWVuc2lvbnM6ICAge3R5cGU6ICcyZicsIHZhbHVlOnt4OjEsIHk6NTExMn19LFxuICAgICAgICBkaW1lbnNpb25zOiAgIHt0eXBlOiAnNGZ2JywgdmFsdWU6WzAsMCwwLDBdfVxuICAgIH07XG5cbiAgICBpZih0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFzay52YWx1ZS54ID0gdGV4dHVyZS53aWR0aDtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlLnkgPSB0ZXh0dXJlLmhlaWdodDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5ib3VuZExvYWRlZEZ1bmN0aW9uID0gdGhpcy5vblRleHR1cmVMb2FkZWQuYmluZCh0aGlzKTtcblxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLm9uKCdsb2FkZWQnLCB0aGlzLmJvdW5kTG9hZGVkRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIG1hc2s7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgb2Zmc2V0OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgZGltZW5zaW9uczsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG1hcERpbWVuc2lvbnM7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMiBtYXBDb3JkcyA9IHZUZXh0dXJlQ29vcmQueHk7JyxcbiAgICAgICAgJyAgIG1hcENvcmRzICs9IChkaW1lbnNpb25zLnp3ICsgb2Zmc2V0KS8gZGltZW5zaW9ucy54eSA7JyxcbiAgICAgICAgJyAgIG1hcENvcmRzLnkgKj0gLTEuMDsnLFxuICAgICAgICAnICAgbWFwQ29yZHMueSArPSAxLjA7JyxcbiAgICAgICAgJyAgIG1hcENvcmRzICo9IGRpbWVuc2lvbnMueHkgLyBtYXBEaW1lbnNpb25zOycsXG5cbiAgICAgICAgJyAgIHZlYzQgb3JpZ2luYWwgPSAgdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsnLFxuICAgICAgICAnICAgZmxvYXQgbWFza0FscGhhID0gIHRleHR1cmUyRChtYXNrLCBtYXBDb3JkcykucjsnLFxuICAgICAgICAnICAgb3JpZ2luYWwgKj0gbWFza0FscGhhOycsXG4gICAgICAgIC8vJyAgIG9yaWdpbmFsLnJnYiAqPSBtYXNrQWxwaGE7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9ICBvcmlnaW5hbDsnLFxuICAgICAgICAvLycgICBnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3I7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuQWxwaGFNYXNrRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkFscGhhTWFza0ZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkFscGhhTWFza0ZpbHRlcjtcblxuUElYSS5BbHBoYU1hc2tGaWx0ZXIucHJvdG90eXBlLm9uVGV4dHVyZUxvYWRlZCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnVuaWZvcm1zLm1hcERpbWVuc2lvbnMudmFsdWUueCA9IHRoaXMudW5pZm9ybXMubWFzay52YWx1ZS53aWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLm1hcERpbWVuc2lvbnMudmFsdWUueSA9IHRoaXMudW5pZm9ybXMubWFzay52YWx1ZS5oZWlnaHQ7XG5cbiAgICB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWUuYmFzZVRleHR1cmUub2ZmKCdsb2FkZWQnLCB0aGlzLmJvdW5kTG9hZGVkRnVuY3Rpb24pO1xufTtcblxuLyoqXG4gKiBUaGUgdGV4dHVyZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtdGVudCBtYXAgKiBtdXN0IGJlIHBvd2VyIG9mIDIgdGV4dHVyZSBhdCB0aGUgbW9tZW50XG4gKlxuICogQHByb3BlcnR5IG1hcFxuICogQHR5cGUgVGV4dHVyZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5BbHBoYU1hc2tGaWx0ZXIucHJvdG90eXBlLCAnbWFwJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFzay52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhlIENvbG9yTWF0cml4RmlsdGVyIGNsYXNzIGxldHMgeW91IGFwcGx5IGEgNHg0IG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgUkdCQVxuICogY29sb3IgYW5kIGFscGhhIHZhbHVlcyBvZiBldmVyeSBwaXhlbCBvbiB5b3VyIGRpc3BsYXlPYmplY3QgdG8gcHJvZHVjZSBhIHJlc3VsdFxuICogd2l0aCBhIG5ldyBzZXQgb2YgUkdCQSBjb2xvciBhbmQgYWxwaGEgdmFsdWVzLiBJdHMgcHJldHR5IHBvd2VyZnVsIVxuICogQGNsYXNzIENvbG9yTWF0cml4RmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLkNvbG9yTWF0cml4RmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgbWF0cml4OiB7dHlwZTogJ21hdDQnLCB2YWx1ZTogWzEsMCwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDEsMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwwLDEsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwwLDFdfSxcbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBpbnZlcnQ7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCBtYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiBtYXRyaXg7JyxcbiAgICAgIC8vICAnICAgZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ29sb3JNYXRyaXhGaWx0ZXI7XG5cbi8qKlxuICogU2V0cyB0aGUgbWF0cml4IG9mIHRoZSBjb2xvciBtYXRyaXggZmlsdGVyXG4gKlxuICogQHByb3BlcnR5IG1hdHJpeFxuICogQHR5cGUgQXJyYXkgYW5kIGFycmF5IG9mIDI2IG51bWJlcnNcbiAqIEBkZWZhdWx0IFsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUsICdtYXRyaXgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWF0cml4LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hdHJpeC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIHR1cm5zIHlvdXIgZGlzcGxheU9iamVjdHMgdG8gYmxhY2sgYW5kIHdoaXRlLlxuICogQGNsYXNzIEdyYXlGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuR3JheUZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGdyYXk6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMX0sXG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGdyYXk7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peChnbF9GcmFnQ29sb3IucmdiLCB2ZWMzKDAuMjEyNipnbF9GcmFnQ29sb3IuciArIDAuNzE1MipnbF9GcmFnQ29sb3IuZyArIDAuMDcyMipnbF9GcmFnQ29sb3IuYiksIGdyYXkpOycsXG4gICAgIC8vICAgJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5HcmF5RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkdyYXlGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5HcmF5RmlsdGVyO1xuXG4vKipcblRoZSBzdHJlbmd0aCBvZiB0aGUgZ3JheS4gMSB3aWxsIG1ha2UgdGhlIG9iamVjdCBibGFjayBhbmQgd2hpdGUsIDAgd2lsbCBtYWtlIHRoZSBvYmplY3QgaXRzIG5vcm1hbCBjb2xvclxuQHByb3BlcnR5IGdyYXlcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5HcmF5RmlsdGVyLnByb3RvdHlwZSwgJ2dyYXknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ3JheS52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5ncmF5LnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhlIERpc3BsYWNlbWVudEZpbHRlciBjbGFzcyB1c2VzIHRoZSBwaXhlbCB2YWx1ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRleHR1cmUgKGNhbGxlZCB0aGUgZGlzcGxhY2VtZW50IG1hcCkgdG8gcGVyZm9ybSBhIGRpc3BsYWNlbWVudCBvZiBhbiBvYmplY3QuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGZpbHRlciB0byBhcHBseSBhbGwgbWFub3Igb2YgY3Jhenkgd2FycGluZyBlZmZlY3RzXG4gKiBDdXJyZW50bHkgdGhlIHIgcHJvcGVydHkgb2YgdGhlIHRleHR1cmUgaXMgdXNlZCBvZmZzZXQgdGhlIHggYW5kIHRoZSBnIHByb3Blcnkgb2YgdGhlIHRleHR1cmUgaXMgdXNlZCB0byBvZmZzZXQgdGhlIHkuXG4gKiBAY2xhc3MgRGlzcGxhY2VtZW50RmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW10ZW50IG1hcCAqIG11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlIGF0IHRoZSBtb21lbnRcbiAqL1xuUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXIgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5fcG93ZXJPZjIgPSB0cnVlO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGRpc3BsYWNlbWVudE1hcDoge3R5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTp0ZXh0dXJlfSxcbiAgICAgICAgc2NhbGU6ICAgICAgICAgICB7dHlwZTogJzJmJywgdmFsdWU6e3g6MzAsIHk6MzB9fSxcbiAgICAgICAgb2Zmc2V0OiAgICAgICAgICB7dHlwZTogJzJmJywgdmFsdWU6e3g6MCwgeTowfX0sXG4gICAgICAgIG1hcERpbWVuc2lvbnM6ICAge3R5cGU6ICcyZicsIHZhbHVlOnt4OjEsIHk6NTExMn19LFxuICAgICAgICBkaW1lbnNpb25zOiAgIHt0eXBlOiAnNGZ2JywgdmFsdWU6WzAsMCwwLDBdfVxuICAgIH07XG5cbiAgICBpZih0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFwRGltZW5zaW9ucy52YWx1ZS54ID0gdGV4dHVyZS53aWR0aDtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnkgPSB0ZXh0dXJlLmhlaWdodDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5ib3VuZExvYWRlZEZ1bmN0aW9uID0gdGhpcy5vblRleHR1cmVMb2FkZWQuYmluZCh0aGlzKTtcblxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLm9uKCdsb2FkZWQnLCB0aGlzLmJvdW5kTG9hZGVkRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBtYXBEaW1lbnNpb25zOycsLy8gPSB2ZWMyKDI1Ni4wLCAyNTYuMCk7JyxcbiAgICAgICAgLy8gJ2NvbnN0IHZlYzIgdGV4dHVyZURpbWVuc2lvbnMgPSB2ZWMyKDc1MC4wLCA3NTAuMCk7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMiBtYXBDb3JkcyA9IHZUZXh0dXJlQ29vcmQueHk7JyxcbiAgICAgICAgLy8nICAgbWFwQ29yZHMgLT0gOycsXG4gICAgICAgICcgICBtYXBDb3JkcyArPSAoZGltZW5zaW9ucy56dyArIG9mZnNldCkvIGRpbWVuc2lvbnMueHkgOycsXG4gICAgICAgICcgICBtYXBDb3Jkcy55ICo9IC0xLjA7JyxcbiAgICAgICAgJyAgIG1hcENvcmRzLnkgKz0gMS4wOycsXG4gICAgICAgICcgICB2ZWMyIG1hdFNhbXBsZSA9IHRleHR1cmUyRChkaXNwbGFjZW1lbnRNYXAsIG1hcENvcmRzKS54eTsnLFxuICAgICAgICAnICAgbWF0U2FtcGxlIC09IDAuNTsnLFxuICAgICAgICAnICAgbWF0U2FtcGxlICo9IHNjYWxlOycsXG4gICAgICAgICcgICBtYXRTYW1wbGUgLz0gbWFwRGltZW5zaW9uczsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIG1hdFNhbXBsZS54LCB2VGV4dHVyZUNvb3JkLnkgKyBtYXRTYW1wbGUueSkpOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBnbF9GcmFnQ29sb3IucmdiLCAxLjApOycsXG4gICAgICAgICcgICB2ZWMyIGNvcmQgPSB2VGV4dHVyZUNvb3JkOycsXG5cbiAgICAgICAgLy8nICAgZ2xfRnJhZ0NvbG9yID0gIHRleHR1cmUyRChkaXNwbGFjZW1lbnRNYXAsIGNvcmQpOycsXG4gICAgIC8vICAgJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuRGlzcGxhY2VtZW50RmlsdGVyO1xuXG5QSVhJLkRpc3BsYWNlbWVudEZpbHRlci5wcm90b3R5cGUub25UZXh0dXJlTG9hZGVkID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudW5pZm9ybXMubWFwRGltZW5zaW9ucy52YWx1ZS54ID0gdGhpcy51bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUud2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnkgPSB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZS5oZWlnaHQ7XG5cbiAgICB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZS5iYXNlVGV4dHVyZS5vZmYoJ2xvYWRlZCcsIHRoaXMuYm91bmRMb2FkZWRGdW5jdGlvbik7XG59O1xuXG4vKipcbiAqIFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW10ZW50IG1hcCAqIG11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlIGF0IHRoZSBtb21lbnRcbiAqXG4gKiBAcHJvcGVydHkgbWFwXG4gKiBAdHlwZSBUZXh0dXJlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYWNlbWVudEZpbHRlci5wcm90b3R5cGUsICdtYXAnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBtdWx0aXBsaWVyIHVzZWQgdG8gc2NhbGUgdGhlIGRpc3BsYWNlbWVudCByZXN1bHQgZnJvbSB0aGUgbWFwIGNhbGN1bGF0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSBzY2FsZVxuICogQHR5cGUgUG9pbnRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZSwgJ3NjYWxlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogVGhlIG9mZnNldCB1c2VkIHRvIG1vdmUgdGhlIGRpc3BsYWNlbWVudCBtYXAuXG4gKlxuICogQHByb3BlcnR5IG9mZnNldFxuICogQHR5cGUgUG9pbnRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMub2Zmc2V0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBmaWx0ZXIgYXBwbGllcyBhIHBpeGVsYXRlIGVmZmVjdCBtYWtpbmcgZGlzcGxheSBvYmplY3RzIGFwcGVhciAnYmxvY2t5J1xuICogQGNsYXNzIFBpeGVsYXRlRmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLlBpeGVsYXRlRmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgaW52ZXJ0OiB7dHlwZTogJzFmJywgdmFsdWU6IDB9LFxuICAgICAgICBkaW1lbnNpb25zOiB7dHlwZTogJzRmdicsIHZhbHVlOm5ldyBGbG9hdDMyQXJyYXkoWzEwMDAwLCAxMDAsIDEwLCAxMF0pfSxcbiAgICAgICAgcGl4ZWxTaXplOiB7dHlwZTogJzJmJywgdmFsdWU6e3g6MTAsIHk6MTB9fSxcbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIHRlc3REaW07JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCBkaW1lbnNpb25zOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcGl4ZWxTaXplOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICB2ZWMyIGNvb3JkID0gdlRleHR1cmVDb29yZDsnLFxuXG4gICAgICAgICcgICB2ZWMyIHNpemUgPSBkaW1lbnNpb25zLnh5L3BpeGVsU2l6ZTsnLFxuXG4gICAgICAgICcgICB2ZWMyIGNvbG9yID0gZmxvb3IoICggdlRleHR1cmVDb29yZCAqIHNpemUgKSApIC8gc2l6ZSArIHBpeGVsU2l6ZS9kaW1lbnNpb25zLnh5ICogMC41OycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvbG9yKTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5QaXhlbGF0ZUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5QaXhlbGF0ZUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlBpeGVsYXRlRmlsdGVyO1xuXG4vKipcbiAqXG4gKiBUaGlzIGEgcG9pbnQgdGhhdCBkZXNjcmliZXMgdGhlIHNpemUgb2YgdGhlIGJsb2NzLiB4IGlzIHRoZSB3aWR0aCBvZiB0aGUgYmxvY2sgYW5kIHkgaXMgdGhlIHRoZSBoZWlnaHRcbiAqIEBwcm9wZXJ0eSBzaXplXG4gKiBAdHlwZSBQb2ludFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5QaXhlbGF0ZUZpbHRlci5wcm90b3R5cGUsICdzaXplJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnBpeGVsU2l6ZS52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMucGl4ZWxTaXplLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuUElYSS5CbHVyWEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGJsdXI6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMS81MTJ9LFxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGJsdXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzQgc3VtID0gdmVjNCgwLjApOycsXG5cbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54IC0gNC4wKmJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4wNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSAzLjAqYmx1ciwgdlRleHR1cmVDb29yZC55KSkgKiAwLjA5OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIDIuMCpibHVyLCB2VGV4dHVyZUNvb3JkLnkpKSAqIDAuMTI7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54IC0gYmx1ciwgdlRleHR1cmVDb29yZC55KSkgKiAwLjE1OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55KSkgKiAwLjE2OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIGJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4xNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyAyLjAqYmx1ciwgdlRleHR1cmVDb29yZC55KSkgKiAwLjEyOycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIDMuMCpibHVyLCB2VGV4dHVyZUNvb3JkLnkpKSAqIDAuMDk7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgNC4wKmJsdXIsIHZUZXh0dXJlQ29vcmQueSkpICogMC4wNTsnLFxuXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSBzdW07JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuQmx1clhGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuQmx1clhGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CbHVyWEZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1clhGaWx0ZXIucHJvdG90eXBlLCAnYmx1cicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlIC8gKDEvNzAwMCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYmx1ci52YWx1ZSA9ICgxLzcwMDApICogdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuUElYSS5CbHVyWUZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIGJsdXI6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMS81MTJ9LFxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGJsdXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzQgc3VtID0gdmVjNCgwLjApOycsXG5cbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgLSA0LjAqYmx1cikpICogMC4wNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSAtIDMuMCpibHVyKSkgKiAwLjA5OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55IC0gMi4wKmJsdXIpKSAqIDAuMTI7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgLSBibHVyKSkgKiAwLjE1OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55KSkgKiAwLjE2OycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55ICsgYmx1cikpICogMC4xNTsnLFxuICAgICAgICAnICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSArIDIuMCpibHVyKSkgKiAwLjEyOycsXG4gICAgICAgICcgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55ICsgMy4wKmJsdXIpKSAqIDAuMDk7JyxcbiAgICAgICAgJyAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgKyA0LjAqYmx1cikpICogMC4wNTsnLFxuXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSBzdW07JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuQmx1cllGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuQmx1cllGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CbHVyWUZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1cllGaWx0ZXIucHJvdG90eXBlLCAnYmx1cicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlIC8gKDEvNzAwMCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vdGhpcy5wYWRkaW5nID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYmx1ci52YWx1ZSA9ICgxLzcwMDApICogdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhlIEJsdXJGaWx0ZXIgYXBwbGllcyBhIEdhdXNzaWFuIGJsdXIgdG8gYW4gb2JqZWN0LlxuICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyIGNhbiBiZSBzZXQgZm9yIHgtIGFuZCB5LWF4aXMgc2VwYXJhdGVseSAoYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSBzdGFnZSkuXG4gKlxuICogQGNsYXNzIEJsdXJGaWx0ZXJcbiAqIEBjb250cnVjdG9yXG4gKi9cblBJWEkuQmx1ckZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmJsdXJYRmlsdGVyID0gbmV3IFBJWEkuQmx1clhGaWx0ZXIoKTtcbiAgICB0aGlzLmJsdXJZRmlsdGVyID0gbmV3IFBJWEkuQmx1cllGaWx0ZXIoKTtcblxuICAgIHRoaXMucGFzc2VzID1bdGhpcy5ibHVyWEZpbHRlciwgdGhpcy5ibHVyWUZpbHRlcl07XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gKlxuICogQHByb3BlcnR5IGJsdXJcbiAqIEB0eXBlIE51bWJlciB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJcbiAqIEBkZWZhdWx0IDJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1ckZpbHRlci5wcm90b3R5cGUsICdibHVyJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWCBwcm9wZXJ0eVxuICpcbiAqIEBwcm9wZXJ0eSBibHVyWFxuICogQHR5cGUgTnVtYmVyIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clhcbiAqIEBkZWZhdWx0IDJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQmx1ckZpbHRlci5wcm90b3R5cGUsICdibHVyWCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcbiAqXG4gKiBAcHJvcGVydHkgYmx1cllcbiAqIEB0eXBlIE51bWJlciB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJZXG4gKiBAZGVmYXVsdCAyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkJsdXJGaWx0ZXIucHJvdG90eXBlLCAnYmx1clknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuYmx1cjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBpbnZlcnRzIHlvdXIgZGlzcGxheU9iamVjdHMgY29sb3JzLlxuICogQGNsYXNzIEludmVydEZpbHRlclxuICogQGNvbnRydWN0b3JcbiAqL1xuUElYSS5JbnZlcnRGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgUElYSS5BYnN0cmFjdEZpbHRlci5jYWxsKCB0aGlzICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFt0aGlzXTtcblxuICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICBpbnZlcnQ6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMX0sXG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgaW52ZXJ0OycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IucmdiID0gbWl4KCAodmVjMygxKS1nbF9GcmFnQ29sb3IucmdiKSAqIGdsX0ZyYWdDb2xvci5hLCBnbF9GcmFnQ29sb3IucmdiLCAxLjAgLSBpbnZlcnQpOycsXG4gICAgICAgIC8vJyAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBnbF9GcmFnQ29sb3IucmdiICAqIGdsX0ZyYWdDb2xvci5hOycsXG4gICAgICAvLyAgJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHZDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5JbnZlcnRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuSW52ZXJ0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuSW52ZXJ0RmlsdGVyO1xuXG4vKipcblRoZSBzdHJlbmd0aCBvZiB0aGUgaW52ZXJ0LiAxIHdpbGwgZnVsbHkgaW52ZXJ0IHRoZSBjb2xvcnMsIDAgd2lsbCBtYWtlIHRoZSBvYmplY3QgaXRzIG5vcm1hbCBjb2xvclxuQHByb3BlcnR5IGludmVydFxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkludmVydEZpbHRlci5wcm90b3R5cGUsICdpbnZlcnQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuaW52ZXJ0LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmludmVydC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICpcbiAqIFRoaXMgYXBwbGllcyBhIHNlcGlhIGVmZmVjdCB0byB5b3VyIGRpc3BsYXlPYmplY3RzLlxuICogQGNsYXNzIFNlcGlhRmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLlNlcGlhRmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgc2VwaWE6IHt0eXBlOiAnMWYnLCB2YWx1ZTogMX0sXG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgc2VwaWE7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgJ2NvbnN0IG1hdDMgc2VwaWFNYXRyaXggPSBtYXQzKDAuMzU4OCwgMC43MDQ0LCAwLjEzNjgsIDAuMjk5MCwgMC41ODcwLCAwLjExNDAsIDAuMjM5MiwgMC40Njk2LCAwLjA5MTIpOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGdsX0ZyYWdDb2xvci5yZ2IgKiBzZXBpYU1hdHJpeCwgc2VwaWEpOycsXG4gICAgICAgLy8gJyAgIGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHZDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5TZXBpYUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5TZXBpYUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlNlcGlhRmlsdGVyO1xuXG4vKipcblRoZSBzdHJlbmd0aCBvZiB0aGUgc2VwaWEuIDEgd2lsbCBhcHBseSB0aGUgZnVsbCBzZXBpYSBlZmZlY3QsIDAgd2lsbCBtYWtlIHRoZSBvYmplY3QgaXRzIG5vcm1hbCBjb2xvclxuQHByb3BlcnR5IHNlcGlhXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuU2VwaWFGaWx0ZXIucHJvdG90eXBlLCAnc2VwaWEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2VwaWEudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc2VwaWEudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIGZpbHRlciBhcHBsaWVzIGEgdHdpc3QgZWZmZWN0IG1ha2luZyBkaXNwbGF5IG9iamVjdHMgYXBwZWFyIHR3aXN0ZWQgaW4gdGhlIGdpdmVuIGRpcmVjdGlvblxuICogQGNsYXNzIFR3aXN0RmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLlR3aXN0RmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgcmFkaXVzOiB7dHlwZTogJzFmJywgdmFsdWU6MC41fSxcbiAgICAgICAgYW5nbGU6IHt0eXBlOiAnMWYnLCB2YWx1ZTo1fSxcbiAgICAgICAgb2Zmc2V0OiB7dHlwZTogJzJmJywgdmFsdWU6e3g6MC41LCB5OjAuNX19LFxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgZGltZW5zaW9uczsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndW5pZm9ybSBmbG9hdCByYWRpdXM7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYW5nbGU7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXQ7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgLSBvZmZzZXQ7JyxcbiAgICAgICAgJyAgIGZsb2F0IGRpc3RhbmNlID0gbGVuZ3RoKGNvb3JkKTsnLFxuXG4gICAgICAgICcgICBpZiAoZGlzdGFuY2UgPCByYWRpdXMpIHsnLFxuICAgICAgICAnICAgICAgIGZsb2F0IHJhdGlvID0gKHJhZGl1cyAtIGRpc3RhbmNlKSAvIHJhZGl1czsnLFxuICAgICAgICAnICAgICAgIGZsb2F0IGFuZ2xlTW9kID0gcmF0aW8gKiByYXRpbyAqIGFuZ2xlOycsXG4gICAgICAgICcgICAgICAgZmxvYXQgcyA9IHNpbihhbmdsZU1vZCk7JyxcbiAgICAgICAgJyAgICAgICBmbG9hdCBjID0gY29zKGFuZ2xlTW9kKTsnLFxuICAgICAgICAnICAgICAgIGNvb3JkID0gdmVjMihjb29yZC54ICogYyAtIGNvb3JkLnkgKiBzLCBjb29yZC54ICogcyArIGNvb3JkLnkgKiBjKTsnLFxuICAgICAgICAnICAgfScsXG5cbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQrb2Zmc2V0KTsnLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5Ud2lzdEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5Ud2lzdEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlR3aXN0RmlsdGVyO1xuXG4vKipcbiAqXG4gKiBUaGlzIHBvaW50IGRlc2NyaWJlcyB0aGUgdGhlIG9mZnNldCBvZiB0aGUgdHdpc3RcbiAqIEBwcm9wZXJ0eSBzaXplXG4gKiBAdHlwZSBQb2ludFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Ud2lzdEZpbHRlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMub2Zmc2V0LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKlxuICogVGhpcyByYWRpdXMgZGVzY3JpYmVzIHNpemUgb2YgdGhlIHR3aXN0XG4gKiBAcHJvcGVydHkgc2l6ZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLlR3aXN0RmlsdGVyLnByb3RvdHlwZSwgJ3JhZGl1cycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5yYWRpdXMudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqXG4gKiBUaGlzIHJhZGl1cyBkZXNjcmliZXMgYW5nbGUgb2YgdGhlIHR3aXN0XG4gKiBAcHJvcGVydHkgYW5nbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Ud2lzdEZpbHRlci5wcm90b3R5cGUsICdhbmdsZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYW5nbGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKlxuICogVGhpcyBsb3dlcnMgdGhlIGNvbG9yIGRlcHRoIG9mIHlvdXIgaW1hZ2UgYnkgdGhlIGdpdmVuIGFtb3VudCwgcHJvZHVjaW5nIGFuIGltYWdlIHdpdGggYSBzbWFsbGVyIHBhbGV0dGUuXG4gKiBAY2xhc3MgQ29sb3JTdGVwRmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLkNvbG9yU3RlcEZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIHN0ZXA6IHt0eXBlOiAnMWYnLCB2YWx1ZTogNX0sXG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHN0ZXA7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7JyxcbiAgICAgICAgJyAgIGNvbG9yID0gZmxvb3IoY29sb3IgKiBzdGVwKSAvIHN0ZXA7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkNvbG9yU3RlcEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5Db2xvclN0ZXBGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5Db2xvclN0ZXBGaWx0ZXI7XG5cbi8qKlxuVGhlIG51bWJlciBvZiBzdGVwcy5cbkBwcm9wZXJ0eSBzdGVwXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQ29sb3JTdGVwRmlsdGVyLnByb3RvdHlwZSwgJ3N0ZXAnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc3RlcC52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdGVwLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKiBvcmlnaW5hbCBmaWx0ZXI6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzL2Jsb2IvbWFzdGVyL3NyYy9maWx0ZXJzL2Z1bi9kb3RzY3JlZW4uanNcbiAqL1xuXG4vKipcbiAqXG4gKiBUaGlzIGZpbHRlciBhcHBsaWVzIGEgZG90c2NyZWVuIGVmZmVjdCBtYWtpbmcgZGlzcGxheSBvYmplY3RzIGFwcGVhciB0byBiZSBtYWRlIG91dCBvZiBibGFjayBhbmQgd2hpdGUgaGFsZnRvbmUgZG90cyBsaWtlIGFuIG9sZCBwcmludGVyXG4gKiBAY2xhc3MgRG90U2NyZWVuRmlsdGVyXG4gKiBAY29udHJ1Y3RvclxuICovXG5QSVhJLkRvdFNjcmVlbkZpbHRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLkFic3RyYWN0RmlsdGVyLmNhbGwoIHRoaXMgKTtcblxuICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgIHNjYWxlOiB7dHlwZTogJzFmJywgdmFsdWU6MX0sXG4gICAgICAgIGFuZ2xlOiB7dHlwZTogJzFmJywgdmFsdWU6NX0sXG4gICAgICAgIGRpbWVuc2lvbnM6ICAge3R5cGU6ICc0ZnYnLCB2YWx1ZTpbMCwwLDAsMF19XG4gICAgfTtcblxuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCBkaW1lbnNpb25zOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGFuZ2xlOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHNjYWxlOycsXG5cbiAgICAgICAgJ2Zsb2F0IHBhdHRlcm4oKSB7JyxcbiAgICAgICAgJyAgIGZsb2F0IHMgPSBzaW4oYW5nbGUpLCBjID0gY29zKGFuZ2xlKTsnLFxuICAgICAgICAnICAgdmVjMiB0ZXggPSB2VGV4dHVyZUNvb3JkICogZGltZW5zaW9ucy54eTsnLFxuICAgICAgICAnICAgdmVjMiBwb2ludCA9IHZlYzIoJyxcbiAgICAgICAgJyAgICAgICBjICogdGV4LnggLSBzICogdGV4LnksJyxcbiAgICAgICAgJyAgICAgICBzICogdGV4LnggKyBjICogdGV4LnknLFxuICAgICAgICAnICAgKSAqIHNjYWxlOycsXG4gICAgICAgICcgICByZXR1cm4gKHNpbihwb2ludC54KSAqIHNpbihwb2ludC55KSkgKiA0LjA7JyxcbiAgICAgICAgJ30nLFxuXG4gICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgJyAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOycsXG4gICAgICAgICcgICBmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjA7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyhhdmVyYWdlICogMTAuMCAtIDUuMCArIHBhdHRlcm4oKSksIGNvbG9yLmEpOycsXG4gICAgICAgICd9J1xuICAgIF07XG59O1xuXG5QSVhJLkRvdFNjcmVlbkZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQSVhJLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSApO1xuUElYSS5Eb3RTY3JlZW5GaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5Eb3RTY3JlZW5GaWx0ZXI7XG5cbi8qKlxuICpcbiAqIFRoaXMgZGVzY3JpYmVzIHRoZSB0aGUgc2NhbGVcbiAqIEBwcm9wZXJ0eSBzY2FsZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRvdFNjcmVlbkZpbHRlci5wcm90b3R5cGUsICdzY2FsZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKlxuICogVGhpcyByYWRpdXMgZGVzY3JpYmVzIGFuZ2xlXG4gKiBAcHJvcGVydHkgYW5nbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUElYSS5Eb3RTY3JlZW5GaWx0ZXIucHJvdG90eXBlLCAnYW5nbGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYW5nbGUudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmFuZ2xlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuUElYSS5Dcm9zc0hhdGNoRmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgYmx1cjoge3R5cGU6ICcxZicsIHZhbHVlOiAxIC8gNTEyfSxcbiAgICB9O1xuXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBibHVyOycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICAgZmxvYXQgbHVtID0gbGVuZ3RoKHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSkucmdiKTsnLFxuXG4gICAgICAgICcgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApOycsXG5cbiAgICAgICAgJyAgICBpZiAobHVtIDwgMS4wMCkgeycsXG4gICAgICAgICcgICAgICAgIGlmIChtb2QoZ2xfRnJhZ0Nvb3JkLnggKyBnbF9GcmFnQ29vcmQueSwgMTAuMCkgPT0gMC4wKSB7JyxcbiAgICAgICAgJyAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgJyAgICB9JyxcblxuICAgICAgICAnICAgIGlmIChsdW0gPCAwLjc1KSB7JyxcbiAgICAgICAgJyAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCAtIGdsX0ZyYWdDb29yZC55LCAxMC4wKSA9PSAwLjApIHsnLFxuICAgICAgICAnICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAnICAgIH0nLFxuXG4gICAgICAgICcgICAgaWYgKGx1bSA8IDAuNTApIHsnLFxuICAgICAgICAnICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54ICsgZ2xfRnJhZ0Nvb3JkLnkgLSA1LjAsIDEwLjApID09IDAuMCkgeycsXG4gICAgICAgICcgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICcgICAgfScsXG5cbiAgICAgICAgJyAgICBpZiAobHVtIDwgMC4zKSB7JyxcbiAgICAgICAgJyAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCAtIGdsX0ZyYWdDb29yZC55IC0gNS4wLCAxMC4wKSA9PSAwLjApIHsnLFxuICAgICAgICAnICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAnICAgIH0nLFxuICAgICAgICAnfSdcbiAgICBdO1xufTtcblxuUElYSS5Dcm9zc0hhdGNoRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBJWEkuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlICk7XG5QSVhJLkNyb3NzSGF0Y2hGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CbHVyWUZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuQ3Jvc3NIYXRjaEZpbHRlci5wcm90b3R5cGUsICdibHVyJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgLyAoMS83MDAwKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy90aGlzLnBhZGRpbmcgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5ibHVyLnZhbHVlID0gKDEvNzAwMCkgKiB2YWx1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLlJHQlNwbGl0RmlsdGVyID0gZnVuY3Rpb24oKVxue1xuICAgIFBJWEkuQWJzdHJhY3RGaWx0ZXIuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSBbdGhpc107XG5cbiAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgcmVkOiB7dHlwZTogJzJmJywgdmFsdWU6IHt4OjIwLCB5OjIwfX0sXG4gICAgICAgIGdyZWVuOiB7dHlwZTogJzJmJywgdmFsdWU6IHt4Oi0yMCwgeToyMH19LFxuICAgICAgICBibHVlOiB7dHlwZTogJzJmJywgdmFsdWU6IHt4OjIwLCB5Oi0yMH19LFxuICAgICAgICBkaW1lbnNpb25zOiAgIHt0eXBlOiAnNGZ2JywgdmFsdWU6WzAsMCwwLDBdfVxuICAgIH07XG5cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcmVkOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgZ3JlZW47JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBibHVlOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgZGltZW5zaW9uczsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLnIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyByZWQvZGltZW5zaW9ucy54eSkucjsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLmcgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBncmVlbi9kaW1lbnNpb25zLnh5KS5nOycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IuYiA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIGJsdWUvZGltZW5zaW9ucy54eSkuYjsnLFxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yLmEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpLmE7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcbn07XG5cblBJWEkuUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUgKTtcblBJWEkuUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5SR0JTcGxpdEZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlLCAnYW5nbGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmx1ci52YWx1ZSAvICgxLzcwMDApO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvL3RoaXMucGFkZGluZyA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgPSAoMS83MDAwKSAqIHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUElYSTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLlBJWEkgPSBQSVhJO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoUElYSSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5QSVhJID0gUElYSTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQSVhJO1xufSkuY2FsbCh0aGlzKTtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBCb3gyRCA9IHJlcXVpcmUoJy4vYm94MmR3ZWIvQm94MmRXZWItMi4xLmEuMy5qcycpO1xudmFyIGIyID0gcmVxdWlyZSgnLi4vdXRpbHMvYjJIZWxwZXJzLmpzJyk7XG5cbnZhciBydWJlRmlsZUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB7fTtcblxuICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHR5cGVvZih0aGlzW3Byb3BlcnR5XSkgIT09ICd1bmRlZmluZWQnO1xuICB9O1xuXG4gIHZhciBiMkNpcmNsZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlLFxuICAgIGIyUG9seWdvblNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlBvbHlnb25TaGFwZSxcbiAgICBiMlZlYzIgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzIsXG4gICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxuICAgIGIyRml4dHVyZURlZiA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcbiAgICBiMldvcmxkID0gQm94MkQuRHluYW1pY3MuYjJXb3JsZCxcbiAgICBGZWF0dXJlcyA9IEJveDJELkNvbGxpc2lvbi5GZWF0dXJlcztcblxuICB0aGF0LmxvYWRCb2R5RnJvbVJVQkUgPSBmdW5jdGlvbiAoYm9keUpzbywgd29ybGQsIGxvYWRpbmdJbmRleCkge1xuXG4gICAgaWYgKCFib2R5SnNvLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQm9keSBkb2VzIG5vdCBoYXZlIGEgJ3R5cGUnIHByb3BlcnR5XCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJkID0gbmV3IGIyQm9keURlZigpO1xuICAgIGlmIChib2R5SnNvLnR5cGUgPT0gMilcbiAgICAgIGJkLnR5cGUgPSBiMi5keW4uYjJCb2R5LmIyX2R5bmFtaWNCb2R5O1xuICAgIGVsc2UgaWYgKGJvZHlKc28udHlwZSA9PSAxKVxuICAgICAgYmQudHlwZSA9IGIyLmR5bi5iMkJvZHkuYjJfa2luZW1hdGljQm9keTtcbiAgICBpZiAoYm9keUpzby5oYXNPd25Qcm9wZXJ0eSgnYW5nbGUnKSlcbiAgICAgIGJkLmFuZ2xlID0gYm9keUpzby5hbmdsZTtcbiAgICBpZiAoYm9keUpzby5oYXNPd25Qcm9wZXJ0eSgnYW5ndWxhclZlbG9jaXR5JykpXG4gICAgICBiZC5hbmd1bGFyVmVsb2NpdHkgPSBib2R5SnNvLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICBpZiAoYm9keUpzby5oYXNPd25Qcm9wZXJ0eSgnYWN0aXZlJykpXG4gICAgICBiZC5hd2FrZSA9IGJvZHlKc28uYWN0aXZlO1xuICAgIGlmIChib2R5SnNvLmhhc093blByb3BlcnR5KCdmaXhlZFJvdGF0aW9uJykpXG4gICAgICBiZC5maXhlZFJvdGF0aW9uID0gYm9keUpzby5maXhlZFJvdGF0aW9uO1xuICAgIGlmIChib2R5SnNvLmhhc093blByb3BlcnR5KCdsaW5lYXJWZWxvY2l0eScpICYmIGJvZHlKc28ubGluZWFyVmVsb2NpdHkgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICBiZC5saW5lYXJWZWxvY2l0eS5TZXRWKGJvZHlKc28ubGluZWFyVmVsb2NpdHkpO1xuICAgIGlmIChib2R5SnNvLmhhc093blByb3BlcnR5KCdwb3NpdGlvbicpICYmIGJvZHlKc28ucG9zaXRpb24gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGJkLnBvc2l0aW9uLnkgPSBiZC5wb3NpdGlvbi55O1xuICAgICAgYmQucG9zaXRpb24uU2V0Vihib2R5SnNvLnBvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKGJvZHlKc28uaGFzT3duUHJvcGVydHkoJ2F3YWtlJykpXG4gICAgICBiZC5hd2FrZSA9IGJvZHlKc28uYXdha2U7XG4gICAgZWxzZVxuICAgICAgYmQuYXdha2UgPSBmYWxzZTtcbiAgICB2YXIgYm9keSA9IHdvcmxkLkNyZWF0ZUJvZHkoYmQpO1xuICAgIGlmIChib2R5SnNvLmhhc093blByb3BlcnR5KCdmaXh0dXJlJykpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYm9keUpzby5maXh0dXJlLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBmaXh0dXJlSnNvID0gYm9keUpzby5maXh0dXJlW2tdO1xuICAgICAgICB0aGF0LmxvYWRGaXh0dXJlRnJvbVJVQkUoYm9keSwgZml4dHVyZUpzbyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChib2R5SnNvLmhhc093blByb3BlcnR5KCduYW1lJykpXG4gICAgICBib2R5Lm5hbWUgPSBib2R5SnNvLm5hbWU7XG4gICAgaWYgKGJvZHlKc28uaGFzT3duUHJvcGVydHkoJ2N1c3RvbVByb3BlcnRpZXMnKSkge1xuICAgICAgLy8gYWRkIHRoZSBsb2FkaW5nSW5kZXggaWYgYXBwbGljYWJsZVxuICAgICAgdGhhdC5zZXRDdXN0b21Qcm9wZXJ0eShib2R5SnNvLCAnaW50JywgJ2xvYWRpbmdJbmRleCcsIGxvYWRpbmdJbmRleCk7XG5cbiAgICAgIGJvZHkuY3VzdG9tUHJvcGVydGllcyA9IGJvZHlKc28uY3VzdG9tUHJvcGVydGllcztcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICB0aGF0LmxvYWRGaXh0dXJlRnJvbVJVQkUgPSBmdW5jdGlvbiAoYm9keSwgZml4dHVyZUpzbykge1xuICAgIHZhciBmZCA9IG5ldyBiMkZpeHR1cmVEZWYoKTtcbiAgICBpZiAoZml4dHVyZUpzby5oYXNPd25Qcm9wZXJ0eSgnZnJpY3Rpb24nKSlcbiAgICAgIGZkLmZyaWN0aW9uID0gZml4dHVyZUpzby5mcmljdGlvbjtcbiAgICBpZiAoZml4dHVyZUpzby5oYXNPd25Qcm9wZXJ0eSgnZGVuc2l0eScpKVxuICAgICAgZmQuZGVuc2l0eSA9IGZpeHR1cmVKc28uZGVuc2l0eTtcbiAgICBpZiAoZml4dHVyZUpzby5oYXNPd25Qcm9wZXJ0eSgncmVzdGl0dXRpb24nKSlcbiAgICAgIGZkLnJlc3RpdHV0aW9uID0gZml4dHVyZUpzby5yZXN0aXR1dGlvbjtcbiAgICBpZiAoZml4dHVyZUpzby5oYXNPd25Qcm9wZXJ0eSgnc2Vuc29yJykpXG4gICAgICBmZC5pc1NlbnNvciA9IGZpeHR1cmVKc28uc2Vuc29yO1xuICAgIGlmIChmaXh0dXJlSnNvLmhhc093blByb3BlcnR5KCdmaWx0ZXItY2F0ZWdvcnlCaXRzJykpXG4gICAgICBmZC5maWx0ZXIuY2F0ZWdvcnlCaXRzID0gZml4dHVyZUpzb1snZmlsdGVyLWNhdGVnb3J5Qml0cyddO1xuICAgIGlmIChmaXh0dXJlSnNvLmhhc093blByb3BlcnR5KCdmaWx0ZXItbWFza0JpdHMnKSlcbiAgICAgIGZkLmZpbHRlci5tYXNrQml0cyA9IGZpeHR1cmVKc29bJ2ZpbHRlci1tYXNrQml0cyddO1xuICAgIGlmIChmaXh0dXJlSnNvLmhhc093blByb3BlcnR5KCdmaWx0ZXItZ3JvdXBJbmRleCcpKVxuICAgICAgZmQuZmlsdGVyLmdyb3VwSW5kZXggPSBmaXh0dXJlSnNvWydmaWx0ZXItZ3JvdXBJbmRleCddO1xuICAgIHZhciBmaXh0dXJlO1xuICAgIGlmIChmaXh0dXJlSnNvLmhhc093blByb3BlcnR5KCdjaXJjbGUnKSkge1xuICAgICAgZmQuc2hhcGUgPSBuZXcgYjJDaXJjbGVTaGFwZSgpO1xuICAgICAgZmQuc2hhcGUubV9yYWRpdXMgPSBmaXh0dXJlSnNvLmNpcmNsZS5yYWRpdXM7XG4gICAgICBpZiAoZml4dHVyZUpzby5jaXJjbGUuY2VudGVyKVxuICAgICAgICBmZC5zaGFwZS5tX3AuU2V0VihmaXh0dXJlSnNvLmNpcmNsZS5jZW50ZXIpO1xuICAgICAgZml4dHVyZSA9IGJvZHkuQ3JlYXRlRml4dHVyZShmZCk7XG4gICAgICBpZiAoZml4dHVyZUpzby5uYW1lKVxuICAgICAgICBmaXh0dXJlLm5hbWUgPSBmaXh0dXJlSnNvLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpeHR1cmVKc28uaGFzT3duUHJvcGVydHkoJ3BvbHlnb24nKSkge1xuICAgICAgZmQuc2hhcGUgPSBuZXcgYjJQb2x5Z29uU2hhcGUoKTtcbiAgICAgIHZhciB2ZXJ0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBmaXh0dXJlSnNvLnBvbHlnb24udmVydGljZXMueC5sZW5ndGg7IHYrKylcbiAgICAgICAgdmVydHMucHVzaChuZXcgYjJWZWMyKGZpeHR1cmVKc28ucG9seWdvbi52ZXJ0aWNlcy54W3ZdLCBmaXh0dXJlSnNvLnBvbHlnb24udmVydGljZXMueVt2XSkpO1xuICAgICAgZmQuc2hhcGUuU2V0QXNBcnJheSh2ZXJ0cywgdmVydHMubGVuZ3RoKTtcbiAgICAgIGZpeHR1cmUgPSBib2R5LkNyZWF0ZUZpeHR1cmUoZmQpO1xuICAgICAgaWYgKGZpeHR1cmUgJiYgZml4dHVyZUpzby5uYW1lKVxuICAgICAgICBmaXh0dXJlLm5hbWUgPSBmaXh0dXJlSnNvLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpeHR1cmVKc28uaGFzT3duUHJvcGVydHkoJ2NoYWluJykpIHtcbiAgICAgIGZkLnNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICB2YXIgbGFzdFZlcnRleCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgZml4dHVyZUpzby5jaGFpbi52ZXJ0aWNlcy54Lmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciB0aGlzVmVydGV4ID0gbmV3IGIyVmVjMihmaXh0dXJlSnNvLmNoYWluLnZlcnRpY2VzLnhbdl0sIGZpeHR1cmVKc28uY2hhaW4udmVydGljZXMueVt2XSk7XG4gICAgICAgIGlmICh2ID4gMCkge1xuICAgICAgICAgIGZkLnNoYXBlLlNldEFzRWRnZShsYXN0VmVydGV4LCB0aGlzVmVydGV4KTtcbiAgICAgICAgICBmaXh0dXJlID0gYm9keS5DcmVhdGVGaXh0dXJlKGZkKTtcbiAgICAgICAgICBpZiAoZml4dHVyZUpzby5uYW1lKVxuICAgICAgICAgICAgZml4dHVyZS5uYW1lID0gZml4dHVyZUpzby5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RWZXJ0ZXggPSB0aGlzVmVydGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IGZpbmQgc2hhcGUgdHlwZSBmb3IgZml4dHVyZVwiKTtcbiAgICB9XG4gICAgaWYgKGZpeHR1cmVKc28uaGFzT3duUHJvcGVydHkoJ2N1c3RvbVByb3BlcnRpZXMnKSkge1xuICAgICAgZml4dHVyZS5jdXN0b21Qcm9wZXJ0aWVzID0gZml4dHVyZUpzby5jdXN0b21Qcm9wZXJ0aWVzO1xuICAgIH1cbiAgfVxuXG4gIHRoYXQuZ2V0VmVjdG9yVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgfVxuXG4gIHRoYXQubG9hZEpvaW50Q29tbW9uUHJvcGVydGllcyA9IGZ1bmN0aW9uIChqZCwgam9pbnRKc28sIGxvYWRlZEJvZGllcywgbG9hZGluZ0luZGV4KSB7XG5cbiAgICAvL2pvaW50SnNvXG4gICAgLy9jb25zb2xlLmxvZyhsb2FkZWRCb2RpZXMpO1xuICAgIGpkLmJvZHlBID0gbG9hZGVkQm9kaWVzW2pvaW50SnNvLmJvZHlBXTtcbiAgICBqZC5ib2R5QiA9IGxvYWRlZEJvZGllc1tqb2ludEpzby5ib2R5Ql07XG4gICAgamQubG9jYWxBbmNob3JBLlNldFYodGhhdC5nZXRWZWN0b3JWYWx1ZShqb2ludEpzby5hbmNob3JBKSk7XG4gICAgamQubG9jYWxBbmNob3JCLlNldFYodGhhdC5nZXRWZWN0b3JWYWx1ZShqb2ludEpzby5hbmNob3JCKSk7XG4gICAgaWYgKGpvaW50SnNvLmNvbGxpZGVDb25uZWN0ZWQpXG4gICAgICBqZC5jb2xsaWRlQ29ubmVjdGVkID0gam9pbnRKc28uY29sbGlkZUNvbm5lY3RlZDtcblxuICB9XG5cbiAgdGhhdC5sb2FkSm9pbnRGcm9tUlVCRSA9IGZ1bmN0aW9uIChqb2ludEpzbywgd29ybGQsIGxvYWRlZEJvZGllcywgbG9hZGluZ0luZGV4KSB7XG4gICAgaWYgKCFqb2ludEpzby5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkpvaW50IGRvZXMgbm90IGhhdmUgYSAndHlwZScgcHJvcGVydHlcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGpvaW50SnNvLmJvZHlBID49IGxvYWRlZEJvZGllcy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiSW5kZXggZm9yIGJvZHlBIGlzIGludmFsaWQ6IFwiICsgam9pbnRKc28uYm9keUEpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChqb2ludEpzby5ib2R5QiA+PSBsb2FkZWRCb2RpZXMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkluZGV4IGZvciBib2R5QiBpcyBpbnZhbGlkOiBcIiArIGpvaW50SnNvLmJvZHlCKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBqb2ludCA9IG51bGw7XG4gICAgdmFyIGpkO1xuICAgIGlmIChqb2ludEpzby50eXBlID09IFwicmV2b2x1dGVcIikge1xuICAgICAgamQgPSBuZXcgYjIuam9pbnRzLmIyUmV2b2x1dGVKb2ludERlZigpO1xuICAgICAgdGhhdC5sb2FkSm9pbnRDb21tb25Qcm9wZXJ0aWVzKGpkLCBqb2ludEpzbywgbG9hZGVkQm9kaWVzLCBsb2FkaW5nSW5kZXgpO1xuICAgICAgLy9jb25zb2xlLmxvZygnamQgOiAnLCBqZCk7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ3JlZkFuZ2xlJykpXG4gICAgICAgIGpkLnJlZmVyZW5jZUFuZ2xlID0gam9pbnRKc28ucmVmQW5nbGU7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2xvd2VyTGltaXQnKSlcbiAgICAgICAgamQubG93ZXJBbmdsZSA9IGpvaW50SnNvLmxvd2VyTGltaXQ7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ3VwcGVyTGltaXQnKSlcbiAgICAgICAgamQudXBwZXJBbmdsZSA9IGpvaW50SnNvLnVwcGVyTGltaXQ7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ21heE1vdG9yVG9ycXVlJykpXG4gICAgICAgIGpkLm1heE1vdG9yVG9ycXVlID0gam9pbnRKc28ubWF4TW90b3JUb3JxdWU7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ21vdG9yU3BlZWQnKSlcbiAgICAgICAgamQubW90b3JTcGVlZCA9IGpvaW50SnNvLm1vdG9yU3BlZWQ7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2VuYWJsZUxpbWl0JykpXG4gICAgICAgIGpkLmVuYWJsZUxpbWl0ID0gam9pbnRKc28uZW5hYmxlTGltaXQ7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2VuYWJsZU1vdG9yJykpXG4gICAgICAgIGpkLmVuYWJsZU1vdG9yID0gam9pbnRKc28uZW5hYmxlTW90b3I7XG5cbiAgICAgIGpkLmxvd2VyQW5nbGUgPSAwO1xuICAgICAgamQudXBwZXJBbmdsZSA9IDA7XG4gICAgICBqZC5yZWZlcmVuY2VBbmdsZSA9IDA7XG5cblxuICAgICAgam9pbnQgPSB3b3JsZC5DcmVhdGVKb2ludChqZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGpvaW50SnNvLnR5cGUgPT0gXCJkaXN0YW5jZVwiIHx8IGpvaW50SnNvLnR5cGUgPT0gXCJyb3BlXCIpIHtcbiAgICAgIGlmIChqb2ludEpzby50eXBlID09IFwicm9wZVwiKVxuICAgICAgICBjb25zb2xlLmxvZyhcIlJlcGxhY2luZyB1bnN1cHBvcnRlZCByb3BlIGpvaW50IHdpdGggZGlzdGFuY2Ugam9pbnQhXCIpO1xuICAgICAgamQgPSBuZXcgYjJEaXN0YW5jZUpvaW50RGVmKCk7XG4gICAgICB0aGF0LmxvYWRKb2ludENvbW1vblByb3BlcnRpZXMoamQsIGpvaW50SnNvLCBsb2FkZWRCb2RpZXMsIGxvYWRpbmdJbmRleCk7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2xlbmd0aCcpKVxuICAgICAgICBqZC5sZW5ndGggPSBqb2ludEpzby5sZW5ndGg7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2RhbXBpbmdSYXRpbycpKVxuICAgICAgICBqZC5kYW1waW5nUmF0aW8gPSBqb2ludEpzby5kYW1waW5nUmF0aW87XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2ZyZXF1ZW5jeScpKVxuICAgICAgICBqZC5mcmVxdWVuY3lIeiA9IGpvaW50SnNvLmZyZXF1ZW5jeTtcbiAgICAgIGpvaW50ID0gd29ybGQuQ3JlYXRlSm9pbnQoamQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChqb2ludEpzby50eXBlID09IFwicHJpc21hdGljXCIpIHtcbiAgICAgIGpkID0gbmV3IGIyUHJpc21hdGljSm9pbnREZWYoKTtcbiAgICAgIHRoYXQubG9hZEpvaW50Q29tbW9uUHJvcGVydGllcyhqZCwgam9pbnRKc28sIGxvYWRlZEJvZGllcywgbG9hZGluZ0luZGV4KTtcbiAgICAgIGlmIChqb2ludEpzby5oYXNPd25Qcm9wZXJ0eSgnbG9jYWxBeGlzQScpKVxuICAgICAgICBqZC5sb2NhbEF4aXNBLlNldFYodGhhdC5nZXRWZWN0b3JWYWx1ZShqb2ludEpzby5sb2NhbEF4aXNBKSk7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ3JlZkFuZ2xlJykpXG4gICAgICAgIGpkLnJlZmVyZW5jZUFuZ2xlID0gam9pbnRKc28ucmVmQW5nbGU7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2VuYWJsZUxpbWl0JykpXG4gICAgICAgIGpkLmVuYWJsZUxpbWl0ID0gam9pbnRKc28uZW5hYmxlTGltaXQ7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2xvd2VyTGltaXQnKSlcbiAgICAgICAgamQubG93ZXJUcmFuc2xhdGlvbiA9IGpvaW50SnNvLmxvd2VyTGltaXQ7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ3VwcGVyTGltaXQnKSlcbiAgICAgICAgamQudXBwZXJUcmFuc2xhdGlvbiA9IGpvaW50SnNvLnVwcGVyTGltaXQ7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ2VuYWJsZU1vdG9yJykpXG4gICAgICAgIGpkLmVuYWJsZU1vdG9yID0gam9pbnRKc28uZW5hYmxlTW90b3I7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ21heE1vdG9yRm9yY2UnKSlcbiAgICAgICAgamQubWF4TW90b3JGb3JjZSA9IGpvaW50SnNvLm1heE1vdG9yRm9yY2U7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ21vdG9yU3BlZWQnKSlcbiAgICAgICAgamQubW90b3JTcGVlZCA9IGpvaW50SnNvLm1vdG9yU3BlZWQ7XG4gICAgICBqb2ludCA9IHdvcmxkLkNyZWF0ZUpvaW50KGpkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoam9pbnRKc28udHlwZSA9PSBcIndoZWVsXCIpIHtcbiAgICAgIC8vTWFrZSBhIGZha2Ugd2hlZWwgam9pbnQgdXNpbmcgYSBsaW5lIGpvaW50IGFuZCBhIGRpc3RhbmNlIGpvaW50LlxuICAgICAgLy9SZXR1cm4gdGhlIGxpbmUgam9pbnQgYmVjYXVzZSBpdCBoYXMgdGhlIGxpbmVhciBtb3RvciBjb250cm9scy5cbiAgICAgIC8vVXNlIEFwcGx5VG9ycXVlIG9uIHRoZSBib2RpZXMgdG8gc3BpbiB0aGUgd2hlZWwuLi5cblxuICAgICAgamQgPSBuZXcgYjJEaXN0YW5jZUpvaW50RGVmKCk7XG4gICAgICB0aGF0LmxvYWRKb2ludENvbW1vblByb3BlcnRpZXMoamQsIGpvaW50SnNvLCBsb2FkZWRCb2RpZXMsIGxvYWRpbmdJbmRleCk7XG4gICAgICBqZC5sZW5ndGggPSAwLjA7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ3NwcmluZ0RhbXBpbmdSYXRpbycpKVxuICAgICAgICBqZC5kYW1waW5nUmF0aW8gPSBqb2ludEpzby5zcHJpbmdEYW1waW5nUmF0aW87XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ3NwcmluZ0ZyZXF1ZW5jeScpKVxuICAgICAgICBqZC5mcmVxdWVuY3lIeiA9IGpvaW50SnNvLnNwcmluZ0ZyZXF1ZW5jeTtcbiAgICAgIHdvcmxkLkNyZWF0ZUpvaW50KGpkKTtcblxuICAgICAgamQgPSBuZXcgYjJMaW5lSm9pbnREZWYoKTtcbiAgICAgIHRoYXQubG9hZEpvaW50Q29tbW9uUHJvcGVydGllcyhqZCwgam9pbnRKc28sIGxvYWRlZEJvZGllcywgbG9hZGluZ0luZGV4KTtcbiAgICAgIGlmIChqb2ludEpzby5oYXNPd25Qcm9wZXJ0eSgnbG9jYWxBeGlzQScpKVxuICAgICAgICBqZC5sb2NhbEF4aXNBLlNldFYodGhhdC5nZXRWZWN0b3JWYWx1ZShqb2ludEpzby5sb2NhbEF4aXNBKSk7XG5cbiAgICAgIGpvaW50ID0gd29ybGQuQ3JlYXRlSm9pbnQoamQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChqb2ludEpzby50eXBlID09IFwiZnJpY3Rpb25cIikge1xuICAgICAgamQgPSBuZXcgYjJGcmljdGlvbkpvaW50RGVmKCk7XG4gICAgICB0aGF0LmxvYWRKb2ludENvbW1vblByb3BlcnRpZXMoamQsIGpvaW50SnNvLCBsb2FkZWRCb2RpZXMsIGxvYWRpbmdJbmRleCk7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ21heEZvcmNlJykpXG4gICAgICAgIGpkLm1heEZvcmNlID0gam9pbnRKc28ubWF4Rm9yY2U7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ21heFRvcnF1ZScpKVxuICAgICAgICBqZC5tYXhUb3JxdWUgPSBqb2ludEpzby5tYXhUb3JxdWU7XG4gICAgICBqb2ludCA9IHdvcmxkLkNyZWF0ZUpvaW50KGpkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoam9pbnRKc28udHlwZSA9PSBcIndlbGRcIikge1xuICAgICAgamQgPSBuZXcgYjIuam9pbnRzLmIyV2VsZEpvaW50RGVmKCk7XG4gICAgICB0aGF0LmxvYWRKb2ludENvbW1vblByb3BlcnRpZXMoamQsIGpvaW50SnNvLCBsb2FkZWRCb2RpZXMsIGxvYWRpbmdJbmRleCk7XG4gICAgICBpZiAoam9pbnRKc28uaGFzT3duUHJvcGVydHkoJ3JlZmVyZW5jZUFuZ2xlJykpXG4gICAgICAgIGpkLnJlZmVyZW5jZUFuZ2xlID0gam9pbnRKc28ucmVmZXJlbmNlQW5nbGU7XG4gICAgICBqb2ludCA9IHdvcmxkLkNyZWF0ZUpvaW50KGpkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVuc3VwcG9ydGVkIGpvaW50IHR5cGU6IFwiICsgam9pbnRKc28udHlwZSk7XG4gICAgICBjb25zb2xlLmxvZyhqb2ludEpzbyk7XG4gICAgfVxuICAgIGlmIChqb2ludCAmJiBqb2ludEpzby5uYW1lKVxuICAgICAgam9pbnQubmFtZSA9IGpvaW50SnNvLm5hbWU7XG5cblxuICAgIGlmIChqb2ludEpzby5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tUHJvcGVydGllcycpKSB7XG4gICAgICAvLyBhZGQgdGhlIGxvYWRpbmdJbmRleCBpZiBhcHBsaWNhYmxlXG4gICAgICB0aGF0LnNldEN1c3RvbVByb3BlcnR5KGpvaW50SnNvLCAnaW50JywgJ2xvYWRpbmdJbmRleCcsIGxvYWRpbmdJbmRleCk7XG5cbiAgICAgIGpvaW50LmN1c3RvbVByb3BlcnRpZXMgPSBqb2ludEpzby5jdXN0b21Qcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIC8vY29uc29sZS5sb2coam9pbnQpO1xuICAgIHJldHVybiBqb2ludDtcbiAgfVxuXG4gIHRoYXQubWFrZUNsb25lID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBuZXdPYmogPSAob2JqIGluc3RhbmNlb2YgQXJyYXkpID8gW10gOiB7fTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgaWYgKG9ialtpXSAmJiB0eXBlb2Ygb2JqW2ldID09IFwib2JqZWN0XCIpXG4gICAgICAgIG5ld09ialtpXSA9IHRoYXQubWFrZUNsb25lKG9ialtpXSk7XG4gICAgICBlbHNlXG4gICAgICAgIG5ld09ialtpXSA9IG9ialtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfVxuXG4gIHRoYXQubG9hZEltYWdlRnJvbVJVQkUgPSBmdW5jdGlvbiAoaW1hZ2VKc28sIHdvcmxkLCBsb2FkZWRCb2RpZXMpIHtcbiAgICB2YXIgaW1hZ2UgPSB0aGF0Lm1ha2VDbG9uZShpbWFnZUpzbyk7XG5cbiAgICBpZiAoaW1hZ2UuaGFzT3duUHJvcGVydHkoJ2JvZHknKSAmJiBpbWFnZS5ib2R5ID49IDApXG4gICAgICBpbWFnZS5ib2R5ID0gbG9hZGVkQm9kaWVzW2ltYWdlLmJvZHldOy8vY2hhbmdlIGluZGV4IHRvIHRoZSBhY3R1YWwgYm9keVxuICAgIGVsc2VcbiAgICAgIGltYWdlLmJvZHkgPSBudWxsO1xuXG4gICAgaW1hZ2UuY2VudGVyID0gbmV3IGIyVmVjMigpO1xuICAgIGltYWdlLmNlbnRlci5TZXRWKHRoYXQuZ2V0VmVjdG9yVmFsdWUoaW1hZ2VKc28uY2VudGVyKSk7XG5cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cblxuLy9tYWlubHkganVzdCBhIGNvbnZlbmllbmNlIGZvciB0aGUgdGVzdGJlZCAtIHVzZXMgZ2xvYmFsICd3b3JsZCcgdmFyaWFibGVcbiAgdGhhdC5sb2FkU2NlbmVGcm9tUlVCRSA9IGZ1bmN0aW9uICh3b3JsZEpzbykge1xuICAgIHJldHVybiB0aGF0LmxvYWRTY2VuZUludG9Xb3JsZCh3b3JsZEpzbywgd29ybGQpO1xuICB9XG5cbi8vbG9hZCB0aGUgc2NlbmUgaW50byBhbiBhbHJlYWR5IGV4aXN0aW5nIHdvcmxkIHZhcmlhYmxlXG4gIHRoYXQubG9hZFNjZW5lSW50b1dvcmxkID0gZnVuY3Rpb24gKHdvcmxkSnNvLCB3b3JsZCwgbG9hZGluZ0luZGV4KSB7XG4gICAgdmFyIHN1Y2Nlc3MgPSB0cnVlO1xuICAgIHZhciBsb2FkZWRCb2RpZXMgPSBbXTtcbiAgICBpZiAod29ybGRKc28uaGFzT3duUHJvcGVydHkoJ2JvZHknKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JsZEpzby5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBib2R5SnNvID0gd29ybGRKc28uYm9keVtpXTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGF0LmxvYWRCb2R5RnJvbVJVQkUoYm9keUpzbywgd29ybGQsIGxvYWRpbmdJbmRleCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgIGxvYWRlZEJvZGllcy5wdXNoKGJvZHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2FkZWRKb2ludHMgPSBbXTtcbiAgICBpZiAod29ybGRKc28uaGFzT3duUHJvcGVydHkoJ2pvaW50JykpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd29ybGRKc28uam9pbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGpvaW50SnNvID0gd29ybGRKc28uam9pbnRbal07XG4gICAgICAgIHZhciBqb2ludCA9IHRoYXQubG9hZEpvaW50RnJvbVJVQkUoam9pbnRKc28sIHdvcmxkLCBsb2FkZWRCb2RpZXMsIGxvYWRpbmdJbmRleCk7XG4gICAgICAgIGlmIChqb2ludClcbiAgICAgICAgICBsb2FkZWRKb2ludHMucHVzaChqb2ludCk7XG4gICAgICAgIC8vZWxzZVxuICAgICAgICAvLyAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvYWRlZEltYWdlcyA9IFtdO1xuICAgIGlmICh3b3JsZEpzby5oYXNPd25Qcm9wZXJ0eSgnaW1hZ2UnKSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB3b3JsZEpzby5pbWFnZS5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaW1hZ2VKc28gPSB3b3JsZEpzby5pbWFnZVtrXTtcbiAgICAgICAgdmFyIGltYWdlID0gdGhhdC5sb2FkSW1hZ2VGcm9tUlVCRShpbWFnZUpzbywgd29ybGQsIGxvYWRlZEJvZGllcyk7XG4gICAgICAgIGlmIChpbWFnZSlcbiAgICAgICAgICBsb2FkZWRJbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB3b3JsZC5pbWFnZXMgPSBsb2FkZWRJbWFnZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cblxuLy9jcmVhdGUgYSB3b3JsZCB2YXJpYWJsZSBhbmQgcmV0dXJuIGl0IGlmIGxvYWRpbmcgc3VjY2VlZHNcbi8vIGxvYWRpbmdJbmRleCBzaG91bGQgYmUgZmlsbGVkIGluIGluIGJvZGllcyBhbmQgam9pbnRzIGVsZW1lbnRzIGxvYWRlZCBpbiBvcmRlciB0byB0cmFjayB0aGVtIGluIHRoZVxuLy8gY2FzZSBvZiBtdWx0aXBsZSB3b3JsZHMgaW1wb3J0c1xuICB0aGF0LmxvYWRXb3JsZEZyb21SVUJFID0gZnVuY3Rpb24gKHdvcmxkSnNvLCBpbnB1dFdvcmxkLCBsb2FkaW5nSW5kZXgpIHtcbiAgICAvL2NvbnNvbGUubG9nKFwiTG9hZGluZ0luZGV4OiBcIiwgbG9hZGluZ0luZGV4KTtcbiAgICB2YXIgZ3Jhdml0eSA9IG5ldyBiMlZlYzIoMCwgMCk7XG4gICAgaWYgKHdvcmxkSnNvLmhhc093blByb3BlcnR5KCdncmF2aXR5JykgJiYgd29ybGRKc28uZ3Jhdml0eSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgIGdyYXZpdHkuU2V0Vih3b3JsZEpzby5ncmF2aXR5KTtcbiAgICB2YXIgd29ybGQ7XG4gICAgLy90eXBlb2YgaW5wdXRXb3JsZFxuICAgIGlmICh0eXBlb2YgaW5wdXRXb3JsZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dFdvcmxkICE9PSBudWxsKSB7XG4gICAgICB3b3JsZCA9IGlucHV0V29ybGQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHdvcmxkID0gbmV3IGIyV29ybGQoZ3Jhdml0eSk7XG5cbiAgICBpZiAoIXRoYXQubG9hZFNjZW5lSW50b1dvcmxkKHdvcmxkSnNvLCB3b3JsZCwgbG9hZGluZ0luZGV4KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gd29ybGQ7XG4gIH1cblxuICB0aGF0LmdldE5hbWVkQm9kaWVzID0gZnVuY3Rpb24gKHdvcmxkLCBuYW1lKSB7XG4gICAgdmFyIGJvZGllcyA9IFtdO1xuICAgIGZvciAodmFyIGIgPSB3b3JsZC5tX2JvZHlMaXN0OyBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgIGlmIChiLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgYm9kaWVzLnB1c2goYik7XG4gICAgfVxuICAgIHJldHVybiBib2RpZXM7XG4gIH1cblxuICB0aGF0LmdldEJvZGllc1dpdGhOYW1lc1N0YXJ0aW5nV2l0aCA9IGZ1bmN0aW9uICh3b3JsZCwgc3RhcnROYW1lKSB7XG4gICAgdmFyIGJvZGllcyA9IFtdO1xuICAgIGZvciAodmFyIGIgPSB3b3JsZC5tX2JvZHlMaXN0OyBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgIGlmICh0eXBlb2YgYi5uYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGIubmFtZS5pbmRleE9mKHN0YXJ0TmFtZSkgPT09IDApXG4gICAgICAgIGJvZGllcy5wdXNoKGIpO1xuICAgIH1cbiAgICByZXR1cm4gYm9kaWVzO1xuICB9XG5cbiAgdGhhdC5nZXRCb2RpZXMgPSBmdW5jdGlvbiAod29ybGQpIHtcbiAgICB2YXIgYm9kaWVzID0gW107XG4gICAgZm9yICh2YXIgYiA9IHdvcmxkLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgYm9kaWVzLnB1c2goYik7XG4gICAgfVxuICAgIHJldHVybiBib2RpZXM7XG4gIH1cblxuICB0aGF0LmdldE5hbWVkRml4dHVyZXMgPSBmdW5jdGlvbiAod29ybGQsIG5hbWUpIHtcbiAgICB2YXIgZml4dHVyZXMgPSBbXTtcbiAgICBmb3IgKHZhciBiID0gd29ybGQubV9ib2R5TGlzdDsgYjsgYiA9IGIubV9uZXh0KSB7XG4gICAgICBmb3IgKHZhciBmID0gYi5tX2ZpeHR1cmVMaXN0OyBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgaWYgKGYubmFtZSA9PSBuYW1lKVxuICAgICAgICAgIGZpeHR1cmVzLnB1c2goZik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaXh0dXJlcztcbiAgfVxuXG4gIHRoYXQuZ2V0TmFtZWRKb2ludHMgPSBmdW5jdGlvbiAod29ybGQsIG5hbWUpIHtcbiAgICB2YXIgam9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaiA9IHdvcmxkLm1fam9pbnRMaXN0OyBqOyBqID0gai5tX25leHQpIHtcbiAgICAgIGlmIChqLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgam9pbnRzLnB1c2goaik7XG4gICAgfVxuICAgIHJldHVybiBqb2ludHM7XG4gIH1cblxuICB0aGF0LmdldE5hbWVkSW1hZ2VzID0gZnVuY3Rpb24gKHdvcmxkLCBuYW1lKSB7XG4gICAgdmFyIGltYWdlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29ybGQuaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAod29ybGQuaW1hZ2VzW2ldLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgaW1hZ2VzLnB1c2god29ybGQuaW1hZ2VzW2ldLm5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VzO1xuICB9XG5cbi8vY3VzdG9tIHByb3BlcnRpZXNcbiAgdGhhdC5nZXRCb2RpZXNCeUN1c3RvbVByb3BlcnR5ID0gZnVuY3Rpb24gKHdvcmxkLCBwcm9wZXJ0eVR5cGUsIHByb3BlcnR5TmFtZSwgdmFsdWVUb01hdGNoKSB7XG4gICAgdmFyIGJvZGllcyA9IFtdO1xuICAgIGZvciAodmFyIGIgPSB3b3JsZC5tX2JvZHlMaXN0OyBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tUHJvcGVydGllcycpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5jdXN0b21Qcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghYi5jdXN0b21Qcm9wZXJ0aWVzW2ldLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFiLmN1c3RvbVByb3BlcnRpZXNbaV0uaGFzT3duUHJvcGVydHkocHJvcGVydHlUeXBlKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGIuY3VzdG9tUHJvcGVydGllc1tpXS5uYW1lID09IHByb3BlcnR5TmFtZSAmJlxuICAgICAgICAgIGIuY3VzdG9tUHJvcGVydGllc1tpXVtwcm9wZXJ0eVR5cGVdID09IHZhbHVlVG9NYXRjaClcbiAgICAgICAgICBib2RpZXMucHVzaChiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvZGllcztcbiAgfVxuXG4vL2N1c3RvbSBwcm9wZXJ0aWVzXG4gIHRoYXQuZmlsdGVyRWxlbWVudHNCeUN1c3RvbVByb3BlcnR5ID0gZnVuY3Rpb24gKGlucHV0RWxlbWVudHMsIHByb3BlcnR5VHlwZSwgcHJvcGVydHlOYW1lLCB2YWx1ZVRvTWF0Y2gpIHtcbiAgICAvL2NvbnNvbGUubG9nKCdpbnB1dEVsZW1lbnRzIDogJywgaW5wdXRFbGVtZW50cywgJ3NlYXJjaGluZyBmb3IgJywgdmFsdWVUb01hdGNoKTtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGlucHV0RWxlbWVudHMpIHtcbiAgICAgIHZhciBiID0gaW5wdXRFbGVtZW50c1tpXTtcbiAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tUHJvcGVydGllcycpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5jdXN0b21Qcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghYi5jdXN0b21Qcm9wZXJ0aWVzW2ldLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFiLmN1c3RvbVByb3BlcnRpZXNbaV0uaGFzT3duUHJvcGVydHkocHJvcGVydHlUeXBlKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGIuY3VzdG9tUHJvcGVydGllc1tpXS5uYW1lID09IHByb3BlcnR5TmFtZSAmJlxuICAgICAgICAgIGIuY3VzdG9tUHJvcGVydGllc1tpXVtwcm9wZXJ0eVR5cGVdID09IHZhbHVlVG9NYXRjaClcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKCdJIEZvdW5kICA6ICcsIGVsZW1lbnRzKTtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH1cblxuICB0aGF0Lmhhc0N1c3RvbVByb3BlcnR5ID0gZnVuY3Rpb24gKGl0ZW0sIHByb3BlcnR5VHlwZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgaWYgKCFpdGVtLmhhc093blByb3BlcnR5KCdjdXN0b21Qcm9wZXJ0aWVzJykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtLmN1c3RvbVByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXRlbS5jdXN0b21Qcm9wZXJ0aWVzW2ldLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIWl0ZW0uY3VzdG9tUHJvcGVydGllc1tpXS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eVR5cGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGF0LmdldEN1c3RvbVByb3BlcnR5ID0gZnVuY3Rpb24gKGl0ZW0sIHByb3BlcnR5VHlwZSwgcHJvcGVydHlOYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoIWl0ZW0uaGFzT3duUHJvcGVydHkoJ2N1c3RvbVByb3BlcnRpZXMnKSlcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtLmN1c3RvbVByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXRlbS5jdXN0b21Qcm9wZXJ0aWVzW2ldLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIWl0ZW0uY3VzdG9tUHJvcGVydGllc1tpXS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eVR5cGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChpdGVtLmN1c3RvbVByb3BlcnRpZXNbaV0ubmFtZSA9PSBwcm9wZXJ0eU5hbWUpXG4gICAgICAgIHJldHVybiBpdGVtLmN1c3RvbVByb3BlcnRpZXNbaV1bcHJvcGVydHlUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIHRoYXQuc2V0Q3VzdG9tUHJvcGVydHkgPSBmdW5jdGlvbiAoaXRlbSwgcHJvcGVydHlUeXBlLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpdGVtLmhhc093blByb3BlcnR5KCdjdXN0b21Qcm9wZXJ0aWVzJykpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtLmN1c3RvbVByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXRlbS5jdXN0b21Qcm9wZXJ0aWVzW2ldLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIWl0ZW0uY3VzdG9tUHJvcGVydGllc1tpXS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eVR5cGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChpdGVtLmN1c3RvbVByb3BlcnRpZXNbaV0ubmFtZSA9PSBwcm9wZXJ0eU5hbWUpXG4gICAgICAgIGl0ZW0uY3VzdG9tUHJvcGVydGllc1tpXVtwcm9wZXJ0eVR5cGVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG5cbiAgcmV0dXJuIHRoYXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJ1YmVGaWxlTG9hZGVyKCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgYjIgPSByZXF1aXJlKCcuL3V0aWxzL2IySGVscGVycy5qcycpO1xyXG52YXIgY29uZmlncyA9IHJlcXVpcmUoJy4vY29uZmlncy5qcycpO1xyXG5cclxudmFyIHBsYXllckNhck1ha2VyID0gZnVuY3Rpb24gKGNhcikge1xyXG5cclxuICB2YXIgdGhhdCA9IGNhcjtcclxuXHJcbiAgdGhhdC5sb2NhbEJyYWtlVmVjdG9yID0gYjIubWF0aC5NdWxGVigtMC41LCB0aGF0LmxvY2FsQWNjZWxlcmF0aW9uVmVjdG9yKTtcclxuICB0aGF0LmxvY2FsSGFuZEJyYWtlVmVjdG9yID0gYjIubWF0aC5NdWxGVigtMC41LCB0aGF0LmxvY2FsQWNjZWxlcmF0aW9uVmVjdG9yKTtcclxuXHJcblxyXG4gIHRoYXQuZGVzaXJlZEFuZ2xlID0gMDtcclxuXHJcbiAgdGhhdC5oYW5kbGVLZXlib2FyZCA9IGZ1bmN0aW9uIChrZXlib2FyZERhdGEpIHtcclxuICAgIGlmIChrZXlib2FyZERhdGEuYWNjZWxlcmF0ZSkge1xyXG4gICAgICB0aGF0LmFjY2VsZXJhdGUoKTtcclxuICAgIH1cclxuICAgIGlmIChrZXlib2FyZERhdGEuaGFuZGJyYWtlKSB7XHJcbiAgICAgIHRoYXQuaGFuZEJyYWtlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGF0LmhhbmRCcmFrZVJlbGVhc2UoKTtcclxuICAgIH1cclxuICAgIGlmIChrZXlib2FyZERhdGEuYnJha2UpIHtcclxuICAgICAgdGhhdC5icmFrZSgpO1xyXG4gICAgfVxyXG4gICAgdGhhdC51cGRhdGVTdGVlcmluZyhrZXlib2FyZERhdGEpO1xyXG4gIH07XHJcblxyXG4gIHRoYXQudXBkYXRlU3RlZXJpbmcgPSBmdW5jdGlvbiAoa2V5Ym9hcmREYXRhKSB7XHJcbiAgICB2YXIgYW5nbGVOb3csIGFuZ2xlVG9UdXJuLCBuZXdBbmdsZSwgcG9zaXRpb247XHJcbiAgICBpZiAoa2V5Ym9hcmREYXRhLnJpZ2h0ICYmICF0aGF0LnB1ZGRsZUVmZmVjdCkge1xyXG4gICAgICB0aGF0LmRlc2lyZWRBbmdsZSA9IHRoYXQubG9ja0FuZ2xlRGVnICogdGhhdC5jb25zdHMuREVHVE9SQUQ7XHJcbiAgICB9IGVsc2UgaWYgKGtleWJvYXJkRGF0YS5sZWZ0ICYmICF0aGF0LnB1ZGRsZUVmZmVjdCkge1xyXG4gICAgICB0aGF0LmRlc2lyZWRBbmdsZSA9IC10aGF0LmxvY2tBbmdsZURlZyAqIHRoYXQuY29uc3RzLkRFR1RPUkFEO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhhdC5kZXNpcmVkQW5nbGUgPSAwO1xyXG4gICAgfVxyXG4gICAgYW5nbGVOb3cgPSB0aGF0LmRpcmVjdGlvbkpvaW50c1swXS5HZXRKb2ludEFuZ2xlKCk7XHJcbiAgICBhbmdsZVRvVHVybiA9IHRoYXQuZGVzaXJlZEFuZ2xlIC0gYW5nbGVOb3c7XHJcbiAgICBpZiAoTWF0aC5hYnMoYW5nbGVOb3cpID4gdGhhdC5sb2NrQW5nbGVEZWcpIHtcclxuICAgICAgYW5nbGVUb1R1cm4gPSAtYW5nbGVOb3c7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhbmdsZVRvVHVybiA9IGIyLm1hdGguQ2xhbXAoYW5nbGVUb1R1cm4sIC10aGF0LnR1cm5QZXJUaW1lU3RlcCwgdGhhdC50dXJuUGVyVGltZVN0ZXApO1xyXG4gICAgfVxyXG4gICAgbmV3QW5nbGUgPSBhbmdsZU5vdyArIGFuZ2xlVG9UdXJuO1xyXG4gICAgdGhhdC5kaXJlY3Rpb25Kb2ludHNbMF0uU2V0TGltaXRzKG5ld0FuZ2xlLCBuZXdBbmdsZSk7XHJcbiAgICB0aGF0LmRpcmVjdGlvbkpvaW50c1sxXS5TZXRMaW1pdHMobmV3QW5nbGUsIG5ld0FuZ2xlKTtcclxuICAgIHRoYXQudXBkYXRlRnJpY3Rpb24oKTtcclxuICAgIHBvc2l0aW9uID0gdGhhdC5iMkJvZHkuR2V0UG9zaXRpb24oKTtcclxuICAgIHRoYXQucGl4aVNwcml0ZS5wb3NpdGlvbi54ID0gcG9zaXRpb24ueCAqIGNvbmZpZ3MuY29uc3RzLk1FVEVSO1xyXG4gICAgdGhhdC5waXhpU3ByaXRlLnBvc2l0aW9uLnkgPSBwb3NpdGlvbi55ICogY29uZmlncy5jb25zdHMuTUVURVI7XHJcbiAgICB0aGF0LnBpeGlTcHJpdGUucm90YXRpb24gPSB0aGF0LmIyQm9keS5HZXRBbmdsZSgpO1xyXG4gIH07XHJcblxyXG4gIHRoYXQuYWNjZWxlcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpLCB0aXJlcztcclxuICAgIHRpcmVzID0gdGhhdC50aXJlcztcclxuICAgIGZvciAoaSBpbiB0aXJlcykge1xyXG4gICAgICBiMi5hcHBseUZvcmNlVG9DZW50ZXIodGlyZXNbaV0sIHRoYXQubG9jYWxBY2NlbGVyYXRpb25WZWN0b3IpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoYXQuYnJha2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaSwgdGlyZXM7XHJcbiAgICB0aXJlcyA9IHRoYXQudGlyZXM7XHJcbiAgICBmb3IgKGkgaW4gdGlyZXMpIHtcclxuICAgICAgYjIuYXBwbHlGb3JjZVRvQ2VudGVyKHRpcmVzW2ldLCB0aGF0LmxvY2FsQnJha2VWZWN0b3IpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoYXQuaGFuZEJyYWtlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGksIHRpcmVzO1xyXG4gICAgdGlyZXMgPSB0aGF0LnRpcmVzO1xyXG4gICAgZm9yIChpIGluIHRpcmVzKSB7XHJcbiAgICAgIGIyLmFwcGx5Rm9yY2VUb0NlbnRlcih0aXJlc1tpXSwgdGhhdC5sb2NhbEhhbmRCcmFrZVZlY3Rvcik7XHJcbiAgICAgIHRoYXQuZHJpZnRpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoYXQuaGFuZEJyYWtlUmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoYXQuZHJpZnRpbmcgPSBmYWxzZTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gdGhhdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcGxheWVyQ2FyTWFrZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBsaW5rZWRMaXN0TWFrZXIgPSByZXF1aXJlKCcuL3V0aWxzL2xpbmtlZExpc3QuanMnKTtcbnZhciBrZXlib2FyZEhhbmRsZXIgPSByZXF1aXJlKCcuL2tleWJvYXJkSGFuZGxlci5qcycpO1xudmFyIGIyID0gcmVxdWlyZSgnLi91dGlscy9iMkhlbHBlcnMuanMnKTtcbnZhciB3b3JsZFNldHVwID0gcmVxdWlyZSgnLi93b3JsZFNldHVwLmpzJyk7XG52YXIgY29uZmlncyA9ICByZXF1aXJlKCcuL2NvbmZpZ3MuanMnKTtcbnZhciBjYXJNYWtlciA9IHJlcXVpcmUoJy4vY2FyTWFrZXIuanMnKTtcbnZhciBwbGF5ZXJDYXJNYWtlciA9IHJlcXVpcmUoJy4vcGxheWVyQ2FyTWFrZXIuanMnKTtcbnZhciBjaGVja3BvaW50TWFuYWdlck1ha2VyID0gcmVxdWlyZSgnLi9jaGVja3BvaW50TWFuYWdlck1ha2VyLmpzJyk7XG52YXIgY29udGFjdE1hbmFnZXJNYWtlciA9IHJlcXVpcmUoJy4vY29udGFjdE1hbmFnZXJNYWtlci5qcycpO1xudmFyIGRhdCA9IHJlcXVpcmUoJ2RhdC1ndWknKTtcbnZhciBydWJlRmlsZUxvYWRlciA9IHJlcXVpcmUoJy4vbGlicy9ydWJlRmlsZUxvYWRlci5qcycpO1xuXG52YXIgdW5pdmVyc2VfbWFrZXIgPSBmdW5jdGlvbiAoX3BpeGlTdGFnZSwgX3RyYWNrSWQsIF9jYXJJZHMsIGdhbWVTdGVwQ2FsbGJhY2spIHtcblxuICB2YXIgdGhhdCA9IHt9O1xuICB2YXIgY29udGFjdExpc3RlbmVyLCBwdWRkbGVSYW5kb21EaXJlY3Rpb25BcnJheTtcbiAgdGhhdC5fcGl4aVN0YWdlID0gX3BpeGlTdGFnZTtcbiAgdGhhdC5fdHJhY2tJZCA9IF90cmFja0lkO1xuICB0aGF0Ll9jYXJJZHMgPSBfY2FySWRzO1xuICB0aGF0LmdhbWVTdGVwQ2FsbGJhY2sgPSBnYW1lU3RlcENhbGxiYWNrO1xuXG4gIHRoYXQudHJhY2tJZCA9IHRoYXQuX3RyYWNrSWQ7XG4gIHRoYXQuY2FySWRzID0gdGhhdC5fY2FySWRzO1xuICB0aGF0LndvcmxkID0gbmV3IGIyLmR5bi5iMldvcmxkKG5ldyBiMi5jTWF0aC5iMlZlYzIoMCwgMCksIHRydWUpO1xuICBjb250YWN0TGlzdGVuZXIgPSBuZXcgYjIuZHluLmIyQ29udGFjdExpc3RlbmVyKCk7XG4gIHRoYXQucGxheWVyQ2FyID0gbnVsbDtcbiAgdGhhdC5pYUNhcnMgPSBbXTtcbiAgcHVkZGxlUmFuZG9tRGlyZWN0aW9uQXJyYXkgPSBuZXcgQXJyYXkoMSwgLTEpO1xuICB0aGF0Lmpzb25zQXNzZXRzTGlzdCA9IG51bGw7XG4gIHRoYXQucGl4aVN0YWdlID0gdGhhdC5fcGl4aVN0YWdlO1xuICB0aGF0LmNvbnRhY3RNYW5hZ2VyID0gbnVsbDtcbiAgdGhhdC5wb3NpdGlvbmluZyA9IDA7XG4gIHRoYXQucGl4aVJlbmRlcmVyID0gbnVsbDtcblxuICB0aGF0LnNldFBpeGlSZW5kZXJlciA9IGZ1bmN0aW9uIChfcGl4aVJlbmRlcmVyKSB7XG4gICAgdGhhdC5fcGl4aVJlbmRlcmVyID0gX3BpeGlSZW5kZXJlcjtcbiAgICByZXR1cm4gdGhhdC5waXhpUmVuZGVyZXIgPSB0aGF0Ll9waXhpUmVuZGVyZXI7XG4gIH07XG5cbiAgdGhhdC5sb2FkQm94MmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhcklkLCBqLCBsZW4sIGxvYWRpbmdJbmRleCwgcmVmLCB3b3JsZFNldHRpbmdVcDtcblxuICAgIHRoYXQuanNvbnNBc3NldHNMaXN0ID0gbGlua2VkTGlzdE1ha2VyKCk7XG4gICAgdGhhdC5qc29uc0Fzc2V0c0xpc3QuYWRkKGNvbmZpZ3MudHJhY2tzW3RoYXQudHJhY2tJZF0uanNvblBhdGgsICd0cmFjaycpO1xuICAgIHJlZiA9IHRoYXQuY2FySWRzO1xuICAgIGZvciAobG9hZGluZ0luZGV4ID0gaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGxvYWRpbmdJbmRleCA9ICsraikge1xuICAgICAgY2FySWQgPSByZWZbbG9hZGluZ0luZGV4XTtcbiAgICAgIHRoYXQuanNvbnNBc3NldHNMaXN0LmFkZChjb25maWdzLmNhcnNbY2FySWRdLmpzb25QYXRoLCAnY2FyJyk7XG4gICAgICBpZiAobG9hZGluZ0luZGV4ICE9PSAwKSB7XG4gICAgICAgIHRoYXQuanNvbnNBc3NldHNMaXN0LmFkZChjb25maWdzLmNhcnNbY2FySWRdLnByb2Jlc1N5c3RlbVBhdGgsICdwcm9iZVN5c3RlbScpO1xuICAgICAgfVxuICAgIH1cbiAgICB3b3JsZFNldHRpbmdVcCA9IHdvcmxkU2V0dXAodGhhdC5qc29uc0Fzc2V0c0xpc3QpO1xuICAgIHdvcmxkU2V0dGluZ1VwLnNldFdvcmxkKHRoYXQud29ybGQpO1xuICAgIHdvcmxkU2V0dGluZ1VwLmxhdW5jaE11bHRpTG9hZCh0aGF0LmJveDJkTG9hZGVkKTtcbiAgfTtcblxuICAvKlxuICAgKiBsb2FkZXJUcmFja1dhbGxzU2V0IGlzIGFuIGFycmF5IG9mIGJveDJkIGJvZGllcyByZXByZXNlbnRpbmcgdGhlIHdhbGxzXG4gICAqIHBsYXllckNhclNldCBpcyBhbiBvYmplY3QgcmVwcmVuc2VudGluZyB0aGUgcGxheWVyIGNhciwgaXQncyBidWlsdCBsaWtlIHNvOlxuICAge1xuICAgY2FyQm9keSA6IGJveDJkYm9keSxcbiAgIHJlYXJUaXJlcyA6IGJveDJkYm9keVtdLFxuICAgZnJvbnRUaXJlcyA6IGJveDJkYm9keVtdLFxuICAgZGlyZWN0aW9uSm9pbnRzIDogYm94MmRKb2ludFxuICAgfVxuICAgKiBvdGhlckNhcnNTZXRzIGlzIGFuIGFycmF5IG9mIHN1Y2ggb2JqZWN0c1xuICAgKi9cbiAgdGhhdC5ib3gyZExvYWRlZCA9IGZ1bmN0aW9uIChsb2FkZXJUcmFja1dhbGxzU2V0LCBwbGF5ZXJDYXJTZXQsIG90aGVyQ2Fyc1NldHMpIHtcbiAgICB2YXIgY2FyU2V0LCBpLCBpYSwgaiwgbGVuLCByZWYsIGJhc2VDYXI7XG4gICAgdGhhdC5sb2FkZXJUcmFja1dhbGxzU2V0ID0gbG9hZGVyVHJhY2tXYWxsc1NldDtcbiAgICB0aGF0LnBsYXllckNhclNldCA9IHBsYXllckNhclNldDtcbiAgICB0aGF0Lm90aGVyQ2Fyc1NldHMgPSBvdGhlckNhcnNTZXRzO1xuXG4gICAgYmFzZUNhciA9IGNhck1ha2VyKDApO1xuICAgIHRoYXQucGxheWVyQ2FyID0gcGxheWVyQ2FyTWFrZXIoYmFzZUNhcik7XG4gICAgdGhhdC5wbGF5ZXJDYXIuY2hlY2tQb2ludE1hbmFnZXIgPSBjaGVja3BvaW50TWFuYWdlck1ha2VyKDMpO1xuICAgIHRoYXQucGxheWVyQ2FyLnNldEJveDJkRGF0YSh0aGF0LnBsYXllckNhclNldCk7XG5cbiAgICB0aGF0LnNldFVwRGF0R3VpKHRoYXQucGxheWVyQ2FyKTtcbiAgICB0aGF0LmNvbnRhY3RNYW5hZ2VyID0gY29udGFjdE1hbmFnZXJNYWtlcih0aGF0LndvcmxkLCBbdGhhdC5wbGF5ZXJDYXJdKTtcbiAgICByZWYgPSB0aGF0Lm90aGVyQ2Fyc1NldHM7XG4gICAgLy9mb3IgKGkgPSBqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgIC8vICBjYXJTZXQgPSByZWZbaV07XG4gICAgLy8gIGlhID0gbmV3IGlhQ2FyKHRoYXQuY29uc3RzLCAwLCBDYXJzQ29uZmlnW3RoYXQuY2FySWRzW2ldXSk7XG4gICAgLy8gIGlhLnNldEJveDJkRGF0YShjYXJTZXQpO1xuICAgIC8vICB0aGF0LnBvc2l0aW9uQ2FyKGlhLCB0aGF0LnBpeGlTdGFnZSk7XG4gICAgLy8gIHRoYXQuaWFDYXJzLnB1c2goaWEpO1xuICAgIC8vfVxuXG4gICAgdGhhdC5waXhpU3RhZ2UuYWRkQ2hpbGQodGhhdC5wbGF5ZXJDYXIucGl4aVNwcml0ZSk7XG4gICAgdGhhdC5wb3NpdGlvbkNhcih0aGF0LnBsYXllckNhciwgdGhhdC5waXhpU3RhZ2UpO1xuICAgIHRoYXQucG9zaXRpb25UcmFjayh0aGF0LmxvYWRlclRyYWNrV2FsbHNTZXQpO1xuICAgIGRvY3VtZW50Lm9ua2V5ZG93biA9IGtleWJvYXJkSGFuZGxlci5oYW5kbGVLZXlEb3duO1xuICAgIGRvY3VtZW50Lm9ua2V5dXAgPSBrZXlib2FyZEhhbmRsZXIuaGFuZGxlS2V5VXA7XG4gICAgdGhhdC51cGRhdGUoKTtcbiAgfTtcblxuICB0aGF0LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FyLCBqLCBsZW4sIHJlZjtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhhdC51cGRhdGUpO1xuICAgIHRoYXQud29ybGQuU3RlcCgxIC8gNjAsIDMsIDMpO1xuICAgIHRoYXQud29ybGQuQ2xlYXJGb3JjZXMoKTtcbiAgICB0aGF0LndvcmxkLkRyYXdEZWJ1Z0RhdGEoKTtcbiAgICB0aGF0LnBsYXllckNhci51cGRhdGVEYXRhKCk7XG4gICAgdGhhdC5wbGF5ZXJDYXIuaGFuZGxlS2V5Ym9hcmQoa2V5Ym9hcmRIYW5kbGVyLmtleXMpO1xuICAgIHJlZiA9IHRoYXQuaWFDYXJzO1xuICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgY2FyID0gcmVmW2pdO1xuICAgICAgY29uc29sZS5sb2coY2FyKTtcbiAgICAgIGNhci51cGRhdGVEYXRhKCk7XG4gICAgICBjYXIudXBkYXRlRnJpY3Rpb24oKTtcbiAgICB9XG4gICAgdGhhdC5nYW1lU3RlcENhbGxiYWNrKCk7XG4gIH07XG5cbiAgdGhhdC5wb3NpdGlvblRyYWNrID0gZnVuY3Rpb24gKHRyYWNrV2FsbHMpIHtcbiAgICB2YXIgaiwgbGVuLCBwb3NpdGlvbiwgdHJhY2tXYWxsO1xuICAgIGZvciAoaiA9IDAsIGxlbiA9IHRyYWNrV2FsbHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHRyYWNrV2FsbCA9IHRyYWNrV2FsbHNbal07XG4gICAgICBwb3NpdGlvbiA9IHRyYWNrV2FsbC5HZXRQb3NpdGlvbigpO1xuICAgICAgdHJhY2tXYWxsLlNldFBvc2l0aW9uKGIyLm1hdGguQWRkVlYoY29uZmlncy5jb25zdHMuU2NyZWVuQ2VudGVyVmVjdG9yLCBwb3NpdGlvbikpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0LnBvc2l0aW9uQ2FyID0gZnVuY3Rpb24gKGNhckluc3RhbmNlKSB7XG4gICAgdmFyIHBvcywgc3RhcnRQb3NpdGlvbnM7XG4gICAgc3RhcnRQb3NpdGlvbnMgPSBydWJlRmlsZUxvYWRlci5nZXRCb2RpZXNXaXRoTmFtZXNTdGFydGluZ1dpdGgodGhhdC53b3JsZCwgXCJzdGFydFwiKTtcbiAgICBwb3MgPSBzdGFydFBvc2l0aW9uc1t0aGF0LnBvc2l0aW9uaW5nKytdLkdldFBvc2l0aW9uKCk7XG4gICAgY2FySW5zdGFuY2Uuc2V0UG9zaXRpb24oYjIubWF0aC5BZGRWVihjb25maWdzLmNvbnN0cy5TY3JlZW5DZW50ZXJWZWN0b3IsIHBvcykpO1xuICB9O1xuXG4gIHRoYXQuc2V0VXBEYXRHdWkgPSBmdW5jdGlvbiAocmVmT2JqZWN0KSB7XG4gICAgdmFyIGYxLCBndWk7XG4gICAgZ3VpID0gbmV3IGRhdC5HVUkoKTtcbiAgICBmMSA9IGd1aS5hZGRGb2xkZXIoJ0NhciBCZWhhdmlvdXInKTtcbiAgICBmMS5hZGQocmVmT2JqZWN0LCAnYWNjZWxlcmF0aW9uRmFjdG9yJywgMC4wNSwgMC4yKTtcbiAgICBmMS5hZGQocmVmT2JqZWN0LCAnbG9ja0FuZ2xlRGVnJywgMjAsIDUwKTtcbiAgICBmMS5hZGQocmVmT2JqZWN0LCAnZHJpZnRUcmlnZ2VyJywgMC4wMDEsIDAuMDEpO1xuICAgIGYxLm9wZW4oKTtcbiAgfTtcblxuICByZXR1cm4gdGhhdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pdmVyc2VfbWFrZXI7IiwidmFyIEJveDJEID0gcmVxdWlyZSgnLi4vbGlicy9ib3gyZHdlYi9Cb3gyZFdlYi0yLjEuYS4zLmpzJyk7XG5cbnZhciBiMiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB7fTtcblxuXG4gIHRoYXQuZHluID0gQm94MkQuRHluYW1pY3M7XG5cbiAgdGhhdC5zaGFwZXMgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzO1xuXG4gIHRoYXQuY01hdGggPSBCb3gyRC5Db21tb24uTWF0aDtcblxuICB0aGF0Lm1hdGggPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGg7XG5cbiAgdGhhdC5qb2ludHMgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHM7XG5cbiAgdGhhdC5maW5kQ3VzdG9tUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChiMkJvZHksIGNQcm9wZXJ0eU5hbWUsIHR5cGVOYW1lKSB7XG4gICAgdmFyIGksIGxlbiwgcHJvcGVydHksIHJlZjtcbiAgICBpZiAoYjJCb2R5LmN1c3RvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgcmVmID0gYjJCb2R5LmN1c3RvbVByb3BlcnRpZXM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSByZWZbaV07XG4gICAgICAgIGlmIChwcm9wZXJ0eS5uYW1lID09PSBjUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5W3R5cGVOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0aGF0LmFwcGx5Rm9yY2VUb0NlbnRlciA9IGZ1bmN0aW9uIChiMkJvZHksIHZlY3RvcjIpIHtcbiAgICByZXR1cm4gYjJCb2R5LkFwcGx5Rm9yY2UoYjJCb2R5LkdldFdvcmxkVmVjdG9yKHZlY3RvcjIpLCBiMkJvZHkuR2V0V29ybGRDZW50ZXIoKSk7XG4gIH07XG5cbiAgcmV0dXJuIHRoYXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGIyKCk7XG4iLCJ2YXIgbGlua2VkTGlzdF9tYWtlciA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdGhhdCA9IHt9O1xuXG4gIHRoYXQuZmlyc3ROb2RlID0gbnVsbDtcbiAgdGhhdC5sYXN0Tm9kZSA9IG51bGw7XG4gIHRoYXQuc2l6ZSA9IDA7XG5cbiAgdGhhdC5hZGQgPSBmdW5jdGlvbiAoZGF0YSwgZGF0YVR5cGUpIHtcbiAgICB2YXIgbmV3Tm9kZSA9IHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBuZXh0OiBudWxsLFxuICAgICAgZGF0YVR5cGU6IGRhdGFUeXBlXG4gICAgfTtcblxuICAgIGlmICh0aGF0LmZpcnN0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgdGhhdC5maXJzdE5vZGUgPSBuZXdOb2RlO1xuICAgICAgdGhhdC5sYXN0Tm9kZSA9IG5ld05vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQubGFzdE5vZGUubmV4dCA9IG5ld05vZGU7XG4gICAgICB0aGF0Lmxhc3ROb2RlID0gbmV3Tm9kZTtcbiAgICB9XG4gICAgdGhhdC5zaXplICs9IDE7XG4gICAgcmV0dXJuIHRoYXQuc2l6ZTtcbiAgfTtcblxuICByZXR1cm4gdGhhdDtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBsaW5rZWRMaXN0X21ha2VyOyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHVybEhlbHBlciA9IGZ1bmN0aW9uKCl7XHJcbiAgdmFyIHRoYXQgPSB7fTtcclxuXHJcbiAgdGhhdC5sb2FkUXVlcnlDb25maWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcXVlcnlQYXJhbXMsIHVybFBhcmFtcztcclxuXHJcbiAgICB1cmxQYXJhbXMgPSB0aGF0LnBhcnNlUXVlcnlTdHJpbmcoKTtcclxuICAgIHF1ZXJ5UGFyYW1zID0ge307XHJcbiAgICBpZiAodXJsUGFyYW1zLmhhc093blByb3BlcnR5KCd0cmFjaycpKSB7XHJcbiAgICAgIHF1ZXJ5UGFyYW1zLnRyYWNrID0gdXJsUGFyYW1zLnRyYWNrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcXVlcnlQYXJhbXMudHJhY2sgPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKHVybFBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnY2FycycpKSB7XHJcbiAgICAgIHF1ZXJ5UGFyYW1zLmNhcnMgPSB1cmxQYXJhbXMuY2Fycy5zcGxpdCgnLCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcXVlcnlQYXJhbXMuY2FycyA9IFswLCAwXTtcclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeVBhcmFtcztcclxuICB9O1xyXG5cclxuICB0aGF0LnBhcnNlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXNzb2MsIGRlY29kZSwgaSwga2V5LCBrZXlWYWx1ZXMsIGxlbiwgdmFsO1xyXG4gICAgYXNzb2MgPSB7fTtcclxuICAgIGtleVZhbHVlcyA9IGxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKS5zcGxpdCgnJicpO1xyXG4gICAgZGVjb2RlID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcclxuICAgIH07XHJcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlWYWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgdmFsID0ga2V5VmFsdWVzW2ldO1xyXG4gICAgICBrZXkgPSB2YWwuc3BsaXQoJz0nKTtcclxuICAgICAgaWYgKDEgPCBrZXkubGVuZ3RoKSB7XHJcbiAgICAgICAgYXNzb2NbZGVjb2RlKGtleVswXSldID0gZGVjb2RlKGtleVsxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhc3NvYztcclxuICB9O1xyXG5cclxuXHJcbiAgcmV0dXJuIHRoYXQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdXJsSGVscGVyKCk7IiwidmFyIHJ1YmVGaWxlTG9hZGVyID0gcmVxdWlyZSgnLi9saWJzL3J1YmVGaWxlTG9hZGVyLmpzJyk7XHJcbnZhciBiMiA9IHJlcXVpcmUoJy4vdXRpbHMvYjJIZWxwZXJzLmpzJyk7XHJcblxyXG52YXIgd29ybGRTZXR1cCA9IGZ1bmN0aW9uIChyZXNvdXJjZXNMaXN0KSB7XHJcblxyXG4gIGNvbnNvbGUubG9nKHJlc291cmNlc0xpc3QpO1xyXG4gIHZhciB0aGF0ID0ge307XHJcbiAgdGhhdC5qc29uTGlua2VkTGlzdCA9IHJlc291cmNlc0xpc3Q7XHJcbiAgdGhhdC5wbGF5ZXJDYXIgPSBudWxsO1xyXG4gIHRoYXQub3RoZXJDYXJzID0gW107XHJcbiAgdGhhdC5pYVByb2JlU3lzdGVtcyA9IFtdO1xyXG4gIHRoYXQudHJhY2tXYWxscyA9IFtdO1xyXG4gIHRoYXQudHJhY2tTdGFydFBvc2l0aW9ucyA9IFtdO1xyXG4gIHRoYXQubWFpbkxvYWRlckNhbGxiYWNrID0gbnVsbDtcclxuICB0aGF0LnJlZldvcmxkID0gbnVsbDtcclxuICB0aGF0LmZpcnN0Q2FyTG9hZGVkID0gZmFsc2U7XHJcbiAgdGhhdC5yZXNvdXJjZUxvYWRpbmdJbmRleCA9IDA7XHJcblxyXG4gIHRoYXQubGF1bmNoTXVsdGlMb2FkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICB0aGF0Lm1haW5Mb2FkZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgdGhhdC5sb2FkUmVzb3VyY2UodGhhdC5qc29uTGlua2VkTGlzdC5maXJzdE5vZGUpO1xyXG4gIH07XHJcblxyXG4gIHRoYXQuc2V0V29ybGQgPSBmdW5jdGlvbiAod29ybGQpIHtcclxuICAgIHRoYXQucmVmV29ybGQgPSB3b3JsZDtcclxuICB9O1xyXG5cclxuICB0aGF0LmxvYWRSZXNvdXJjZSA9IGZ1bmN0aW9uIChyZXNvdXJjZU5vZGUpIHtcclxuICAgIGlmIChyZXNvdXJjZU5vZGUuZGF0YSA9PT0gXCJcIikge1xyXG4gICAgICB0aGF0LmxvYWRSZXNvdXJjZShyZXNvdXJjZU5vZGUubmV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhhdC5sb2FkSlNPTihyZXNvdXJjZU5vZGUuZGF0YSwgKGZ1bmN0aW9uIChfdGhhdCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHJhd0pzb24pIHtcclxuICAgICAgICB2YXIgY2FyQm9keSwgY2FyRnJvbnRUaXJlcywgY2FyUmVhclRpcmVzLCBjYXJTZXQsIGNhcnNJbldvcmxkLCBkaXJKb2ludHMsIGRpckpvaW50c0luV29ybGQsIGZyb250VGlyZXNJbldvcmxkLCBpYUJvdW5kRGVmLCBpYUNhckJvZHksIGpvaW50LCBwYXJzZWRKc29uLCBwcm9iZVN5c3RlbSwgcHJvYmVTeXN0ZW1zSW5Xb3JsZCwgcmVhclRpcmVzSW5Xb3JsZDtcclxuICAgICAgICBwYXJzZWRKc29uID0gSlNPTi5wYXJzZShyYXdKc29uKTtcclxuICAgICAgICBwYXJzZWRKc29uID0gX3RoYXQucHJlcHJvY2Vzc1J1YmUocGFyc2VkSnNvbik7XHJcbiAgICAgICAgX3RoYXQucmVmV29ybGQgPSBydWJlRmlsZUxvYWRlci5sb2FkV29ybGRGcm9tUlVCRShwYXJzZWRKc29uLCBfdGhhdC5yZWZXb3JsZCwgX3RoYXQucmVzb3VyY2VMb2FkaW5nSW5kZXgpO1xyXG4gICAgICAgIGlmIChyZXNvdXJjZU5vZGUuZGF0YVR5cGUgPT09IFwiY2FyXCIpIHtcclxuICAgICAgICAgIGNhcnNJbldvcmxkID0gcnViZUZpbGVMb2FkZXIuZ2V0Qm9kaWVzQnlDdXN0b21Qcm9wZXJ0eShfdGhhdC5yZWZXb3JsZCwgXCJzdHJpbmdcIiwgXCJjYXRlZ29yeVwiLCBcImNhcl9ib2R5XCIpO1xyXG4gICAgICAgICAgcmVhclRpcmVzSW5Xb3JsZCA9IHJ1YmVGaWxlTG9hZGVyLmdldEJvZGllc0J5Q3VzdG9tUHJvcGVydHkoX3RoYXQucmVmV29ybGQsIFwic3RyaW5nXCIsIFwiY2F0ZWdvcnlcIiwgXCJ3aGVlbF9yZWFyXCIpO1xyXG4gICAgICAgICAgZnJvbnRUaXJlc0luV29ybGQgPSBydWJlRmlsZUxvYWRlci5nZXRCb2RpZXNCeUN1c3RvbVByb3BlcnR5KF90aGF0LnJlZldvcmxkLCBcInN0cmluZ1wiLCBcImNhdGVnb3J5XCIsIFwid2hlZWxfZnJvbnRcIik7XHJcbiAgICAgICAgICBkaXJKb2ludHNJbldvcmxkID0gcnViZUZpbGVMb2FkZXIuZ2V0TmFtZWRKb2ludHMoX3RoYXQucmVmV29ybGQsIFwiZGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgY2FyQm9keSA9IHJ1YmVGaWxlTG9hZGVyLmZpbHRlckVsZW1lbnRzQnlDdXN0b21Qcm9wZXJ0eShjYXJzSW5Xb3JsZCwgJ2ludCcsICdsb2FkaW5nSW5kZXgnLCBfdGhhdC5yZXNvdXJjZUxvYWRpbmdJbmRleClbMF07XHJcbiAgICAgICAgICBjYXJSZWFyVGlyZXMgPSBydWJlRmlsZUxvYWRlci5maWx0ZXJFbGVtZW50c0J5Q3VzdG9tUHJvcGVydHkocmVhclRpcmVzSW5Xb3JsZCwgJ2ludCcsICdsb2FkaW5nSW5kZXgnLCBfdGhhdC5yZXNvdXJjZUxvYWRpbmdJbmRleCk7XHJcbiAgICAgICAgICBjYXJGcm9udFRpcmVzID0gcnViZUZpbGVMb2FkZXIuZmlsdGVyRWxlbWVudHNCeUN1c3RvbVByb3BlcnR5KGZyb250VGlyZXNJbldvcmxkLCAnaW50JywgJ2xvYWRpbmdJbmRleCcsIF90aGF0LnJlc291cmNlTG9hZGluZ0luZGV4KTtcclxuICAgICAgICAgIGRpckpvaW50cyA9IHJ1YmVGaWxlTG9hZGVyLmZpbHRlckVsZW1lbnRzQnlDdXN0b21Qcm9wZXJ0eShkaXJKb2ludHNJbldvcmxkLCAnaW50JywgJ2xvYWRpbmdJbmRleCcsIF90aGF0LnJlc291cmNlTG9hZGluZ0luZGV4KTtcclxuICAgICAgICAgIGNhclNldCA9IHtcclxuICAgICAgICAgICAgY2FyQm9keTogY2FyQm9keSxcclxuICAgICAgICAgICAgcmVhclRpcmVzOiBjYXJSZWFyVGlyZXMsXHJcbiAgICAgICAgICAgIGZyb250VGlyZXM6IGNhckZyb250VGlyZXMsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbkpvaW50czogZGlySm9pbnRzXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgaWYgKCFfdGhhdC5maXJzdENhckxvYWRlZCkge1xyXG4gICAgICAgICAgICBfdGhhdC5wbGF5ZXJDYXIgPSBjYXJTZXQ7XHJcbiAgICAgICAgICAgIF90aGF0LmZpcnN0Q2FyTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF90aGF0Lm90aGVyQ2Fycy5wdXNoKGNhclNldCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZU5vZGUuZGF0YVR5cGUgPT09ICdwcm9iZVN5c3RlbScpIHtcclxuICAgICAgICAgIHByb2JlU3lzdGVtc0luV29ybGQgPSBydWJlRmlsZUxvYWRlci5nZXRCb2RpZXNCeUN1c3RvbVByb3BlcnR5KF90aGF0LnJlZldvcmxkLCBcInN0cmluZ1wiLCBcImNhdGVnb3J5XCIsIFwicHJvYmVTeXN0ZW1cIik7XHJcbiAgICAgICAgICBwcm9iZVN5c3RlbSA9IHJ1YmVGaWxlTG9hZGVyLmZpbHRlckVsZW1lbnRzQnlDdXN0b21Qcm9wZXJ0eShwcm9iZVN5c3RlbXNJbldvcmxkLCAnaW50JywgJ2xvYWRpbmdJbmRleCcsIF90aGF0LnJlc291cmNlTG9hZGluZ0luZGV4KVswXTtcclxuICAgICAgICAgIGlhQ2FyQm9keSA9IF90aGF0Lm90aGVyQ2Fyc1tfdGhhdC5vdGhlckNhcnMubGVuZ3RoIC0gMV0uY2FyQm9keTtcclxuICAgICAgICAgIGlhQm91bmREZWYgPSBuZXcgYjIuam9pbnRzLmIyRGlzdGFuY2VKb2ludERlZigpO1xyXG4gICAgICAgICAgaWFCb3VuZERlZi5ib2R5QSA9IHByb2JlU3lzdGVtO1xyXG4gICAgICAgICAgaWFCb3VuZERlZi5ib2R5QiA9IGlhQ2FyQm9keTtcclxuICAgICAgICAgIGlhQm91bmREZWYuY29sbGlkZUNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgaWFCb3VuZERlZi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgaWFCb3VuZERlZi5sb2NhbEFuY2hvckIuU2V0VihuZXcgYjIuY01hdGguYjJWZWMyKDAsIDAuMjUpKTtcclxuICAgICAgICAgIGpvaW50ID0gX3RoYXQucmVmV29ybGQuQ3JlYXRlSm9pbnQoaWFCb3VuZERlZik7XHJcbiAgICAgICAgICBfdGhhdC5vdGhlckNhcnNbX3RoYXQub3RoZXJDYXJzLmxlbmd0aCAtIDFdLnByb2JlU3lzdGVtID0gcHJvYmVTeXN0ZW07XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZU5vZGUuZGF0YVR5cGUgPT09IFwidHJhY2tcIikge1xyXG4gICAgICAgICAgX3RoYXQudHJhY2tXYWxscyA9IHJ1YmVGaWxlTG9hZGVyLmdldEJvZGllcyhfdGhhdC5yZWZXb3JsZCk7XHJcbiAgICAgICAgICBfdGhhdC50cmFja1N0YXJ0UG9zaXRpb25zID0gcnViZUZpbGVMb2FkZXIuZ2V0Qm9kaWVzV2l0aE5hbWVzU3RhcnRpbmdXaXRoKF90aGF0LnJlZldvcmxkKTtcclxuICAgICAgICAgIF90aGF0LnRyYWNrSWFMaW5lID0gcnViZUZpbGVMb2FkZXIuZ2V0Qm9kaWVzQnlDdXN0b21Qcm9wZXJ0eShfdGhhdC5yZWZXb3JsZCwgXCJzdHJpbmdcIiwgXCJjYXRlZ29yeVwiLCBcImlhTGluZVwiKVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoYXQucmVzb3VyY2VMb2FkaW5nSW5kZXgrKztcclxuICAgICAgICBpZiAocmVzb3VyY2VOb2RlLm5leHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgX3RoYXQubG9hZFJlc291cmNlKHJlc291cmNlTm9kZS5uZXh0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgX3RoYXQubWFpbkxvYWRlckNhbGxiYWNrLmFwcGx5KG51bGwsIFtfdGhhdC50cmFja1dhbGxzLCBfdGhhdC5wbGF5ZXJDYXIsIF90aGF0Lm90aGVyQ2Fyc10pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0pKHRoaXMpKTtcclxuICB9O1xyXG5cclxuICB0aGF0LnByZXByb2Nlc3NSdWJlID0gZnVuY3Rpb24gKHBhcnNlZEpzb24pIHtcclxuICAgIHZhciBmaXh0dXJlLCBpLCBpbmRleCwgaiwgam9pbnQsIGpzb25Cb2R5LCBrLCBsZW4sIGxlbjEsIGxlbjIsIHJlZiwgcmVmMSwgcmVmMjtcclxuICAgIHJlZiA9IHBhcnNlZEpzb24uYm9keTtcclxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBqc29uQm9keSA9IHJlZltpXTtcclxuICAgICAgaWYgKGpzb25Cb2R5LnBvc2l0aW9uICE9PSAwKSB7XHJcbiAgICAgICAganNvbkJvZHkucG9zaXRpb24ueSA9IGpzb25Cb2R5LnBvc2l0aW9uLnkgKiAtMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGpzb25Cb2R5LmZpeHR1cmUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICByZWYxID0ganNvbkJvZHkuZml4dHVyZTtcclxuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcclxuICAgICAgICAgIGZpeHR1cmUgPSByZWYxW2pdO1xyXG4gICAgICAgICAgaWYgKGZpeHR1cmUuaGFzT3duUHJvcGVydHkoXCJwb2x5Z29uXCIpKSB7XHJcbiAgICAgICAgICAgIGZvciAoaW5kZXggaW4gZml4dHVyZS5wb2x5Z29uLnZlcnRpY2VzLnkpIHtcclxuICAgICAgICAgICAgICBmaXh0dXJlLnBvbHlnb24udmVydGljZXMueVtpbmRleF0gPSAtZml4dHVyZS5wb2x5Z29uLnZlcnRpY2VzLnlbaW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpeHR1cmUucG9seWdvbi52ZXJ0aWNlcy54LnJldmVyc2UoKTtcclxuICAgICAgICAgICAgZml4dHVyZS5wb2x5Z29uLnZlcnRpY2VzLnkucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGZpeHR1cmUuaGFzT3duUHJvcGVydHkoXCJjaGFpblwiKSkge1xyXG4gICAgICAgICAgICBmb3IgKGluZGV4IGluIGZpeHR1cmUuY2hhaW4udmVydGljZXMueSkge1xyXG4gICAgICAgICAgICAgIGZpeHR1cmUuY2hhaW4udmVydGljZXMueVtpbmRleF0gPSAtZml4dHVyZS5jaGFpbi52ZXJ0aWNlcy55W2luZGV4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaXh0dXJlLmNoYWluLnZlcnRpY2VzLngucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICBmaXh0dXJlLmNoYWluLnZlcnRpY2VzLnkucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhcnNlZEpzb24uaGFzT3duUHJvcGVydHkoXCJqb2ludFwiKSkge1xyXG4gICAgICByZWYyID0gcGFyc2VkSnNvbi5qb2ludDtcclxuICAgICAgZm9yIChrID0gMCwgbGVuMiA9IHJlZjIubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XHJcbiAgICAgICAgam9pbnQgPSByZWYyW2tdO1xyXG4gICAgICAgIGlmIChqb2ludC5hbmNob3JBICE9PSAwKSB7XHJcbiAgICAgICAgICBqb2ludC5hbmNob3JBLnkgPSBqb2ludC5hbmNob3JBLnkgKiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGpvaW50LmFuY2hvckIgIT09IDApIHtcclxuICAgICAgICAgIGpvaW50LmFuY2hvckIueSA9IGpvaW50LmFuY2hvckIueSAqIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBqb2ludC51cHBlckxpbWl0ID0gMDtcclxuICAgICAgICBqb2ludC5sb3dlckxpbWl0ID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnNlZEpzb247XHJcbiAgfTtcclxuXHJcbiAgdGhhdC5sb2FkSlNPTiA9IGZ1bmN0aW9uIChmaWxlUGF0aCwgY2FsbGJhY2spIHtcclxuICAgIHZhciB4b2JqO1xyXG4gICAgeG9iaiA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgeG9iai5vdmVycmlkZU1pbWVUeXBlKFwiYXBwbGljYXRpb24vanNvblwiKTtcclxuICAgIHhvYmoub3BlbignR0VUJywgZmlsZVBhdGgsIHRydWUpO1xyXG4gICAgeG9iai5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh4b2JqLnJlYWR5U3RhdGUgPT09IDQgJiYgeG9iai5zdGF0dXMgPT09IDIwMCkge1xyXG4gICAgICAgIGNhbGxiYWNrKHhvYmoucmVzcG9uc2VUZXh0KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHhvYmouc2VuZChudWxsKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gdGhhdDtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHdvcmxkU2V0dXA7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3ZlbmRvci9kYXQuZ3VpJylcbm1vZHVsZS5leHBvcnRzLmNvbG9yID0gcmVxdWlyZSgnLi92ZW5kb3IvZGF0LmNvbG9yJykiLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuLyoqIEBuYW1lc3BhY2UgKi9cbnZhciBkYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGRhdCB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb2xvciA9IGRhdC5jb2xvciB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC51dGlscyA9IGRhdC51dGlscyB8fCB7fTtcblxuZGF0LnV0aWxzLmNvbW1vbiA9IChmdW5jdGlvbiAoKSB7XG4gIFxuICB2YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgdmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogQmFuZC1haWQgbWV0aG9kcyBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGEgbG90IGVhc2llciBpbiBKYXZhU2NyaXB0LlxuICAgKiBJbXBsZW1lbnRhdGlvbiBhbmQgc3RydWN0dXJlIGluc3BpcmVkIGJ5IHVuZGVyc2NvcmUuanNcbiAgICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICAgKi9cblxuICByZXR1cm4geyBcbiAgICBcbiAgICBCUkVBSzoge30sXG4gIFxuICAgIGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZhdWx0czogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgXG4gICAgfSxcbiAgICBcbiAgICBjb21wb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b0NhbGwgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRyLCBzY29wZSkge1xuXG4gICAgICBcbiAgICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHsgXG4gICAgICAgIFxuICAgICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7IC8vIElzIG51bWJlciBidXQgbm90IE5hTlxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgXG4gICAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZlcjogZnVuY3Rpb24oZm5jKSB7XG4gICAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gICAgfSxcbiAgICBcbiAgICB0b0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgICB9LFxuXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdWxsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gICAgfSxcbiAgICBcbiAgICBpc05hTjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaiswO1xuICAgIH0sXG4gICAgXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKycnO1xuICAgIH0sXG4gICAgXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgXG4gIH07XG4gICAgXG59KSgpO1xuXG5cbmRhdC5jb2xvci50b1N0cmluZyA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9yKSB7XG5cbiAgICBpZiAoY29sb3IuYSA9PSAxIHx8IGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5hKSkge1xuXG4gICAgICB2YXIgcyA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgICB3aGlsZSAocy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgcztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChjb2xvci5yKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZykgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmIpICsgJywnICsgY29sb3IuYSArICcpJztcblxuICAgIH1cblxuICB9XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5Db2xvciA9IGRhdC5jb2xvci5Db2xvciA9IChmdW5jdGlvbiAoaW50ZXJwcmV0LCBtYXRoLCB0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyAnRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcblxuXG4gIH07XG5cbiAgQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsJ2cnLCdiJywnaCcsJ3MnLCd2JywnaGV4JywnYSddO1xuXG4gIGNvbW1vbi5leHRlbmQoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfSxcblxuICAgIHRvT3JpZ2luYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cblxuICB9KTtcblxuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuXG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICghdGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gbWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlUkdCKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcblxuICAgICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gbWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblxuICAgICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBtYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhyb3cgJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZSc7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlSFNWKGNvbG9yKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gbWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLFxuICAgICAgICB7XG4gICAgICAgICAgczogcmVzdWx0LnMsXG4gICAgICAgICAgdjogcmVzdWx0LnZcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICAgIH0gZWxzZSBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29sb3I7XG5cbn0pKGRhdC5jb2xvci5pbnRlcnByZXQgPSAoZnVuY3Rpb24gKHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgcmVzdWx0LCB0b1JldHVybjtcblxuICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0b1JldHVybiA9IGZhbHNlO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBjb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuXG4gICAgY29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbihmYW1pbHkpIHtcblxuICAgICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG5cbiAgICAgICAgY29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbihjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcblxuICAgICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfTtcblxuICB2YXIgSU5URVJQUkVUQVRJT05TID0gW1xuXG4gICAgLy8gU3RyaW5nc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNTdHJpbmcsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgVEhSRUVfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzNdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgU0lYX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XXs2fSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQjoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCQToge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE51bWJlcnNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzTnVtYmVyLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIEhFWDoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBBcnJheXNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzQXJyYXksXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gMykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCQV9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gT2JqZWN0c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNPYmplY3QsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG5cbiAgXTtcblxuICByZXR1cm4gaW50ZXJwcmV0O1xuXG5cbn0pKGRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbG9yLm1hdGggPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciB0bXBDb21wb25lbnQ7XG5cbiAgcmV0dXJuIHtcblxuICAgIGhzdl90b19yZ2I6IGZ1bmN0aW9uKGgsIHMsIHYpIHtcblxuICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcblxuICAgICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgICB2YXIgcSA9IHYgKiAoMS4wIC0gKGYgKiBzKSk7XG4gICAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKCgxLjAgLSBmKSAqIHMpKTtcbiAgICAgIHZhciBjID0gW1xuICAgICAgICBbdiwgdCwgcF0sXG4gICAgICAgIFtxLCB2LCBwXSxcbiAgICAgICAgW3AsIHYsIHRdLFxuICAgICAgICBbcCwgcSwgdl0sXG4gICAgICAgIFt0LCBwLCB2XSxcbiAgICAgICAgW3YsIHAsIHFdXG4gICAgICBdW2hpXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgICAgYjogY1syXSAqIDI1NVxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICByZ2JfdG9faHN2OiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICBoLCBzO1xuXG4gICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBOYU4sXG4gICAgICAgICAgczogMCxcbiAgICAgICAgICB2OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyID09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgaCAvPSA2O1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCAqIDM2MCxcbiAgICAgICAgczogcyxcbiAgICAgICAgdjogbWF4IC8gMjU1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZ2JfdG9faGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICAgIHJldHVybiBoZXg7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgICAgcmV0dXJuIChoZXggPj4gKGNvbXBvbmVudEluZGV4ICogOCkpICYgMHhGRjtcbiAgICB9LFxuXG4gICAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgKGhleCAmIH4gKDB4RkYgPDwgdG1wQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gIH1cblxufSkoKSxcbmRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pOyIsIi8qKlxuICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4vKiogQG5hbWVzcGFjZSAqL1xudmFyIGRhdCA9IG1vZHVsZS5leHBvcnRzID0gZGF0IHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0Lmd1aSA9IGRhdC5ndWkgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQudXRpbHMgPSBkYXQudXRpbHMgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuY29udHJvbGxlcnMgPSBkYXQuY29udHJvbGxlcnMgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuZG9tID0gZGF0LmRvbSB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb2xvciA9IGRhdC5jb2xvciB8fCB7fTtcblxuZGF0LnV0aWxzLmNzcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbG9hZDogZnVuY3Rpb24gKHVybCwgZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICBsaW5rLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9LFxuICAgIGluamVjdDogZnVuY3Rpb24oY3NzLCBkb2MpIHtcbiAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBpbmplY3RlZC50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgIGluamVjdGVkLmlubmVySFRNTCA9IGNzcztcbiAgICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cblxuZGF0LnV0aWxzLmNvbW1vbiA9IChmdW5jdGlvbiAoKSB7XG4gIFxuICB2YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgdmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogQmFuZC1haWQgbWV0aG9kcyBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGEgbG90IGVhc2llciBpbiBKYXZhU2NyaXB0LlxuICAgKiBJbXBsZW1lbnRhdGlvbiBhbmQgc3RydWN0dXJlIGluc3BpcmVkIGJ5IHVuZGVyc2NvcmUuanNcbiAgICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICAgKi9cblxuICByZXR1cm4geyBcbiAgICBcbiAgICBCUkVBSzoge30sXG4gIFxuICAgIGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZhdWx0czogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgXG4gICAgfSxcbiAgICBcbiAgICBjb21wb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b0NhbGwgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRyLCBzY29wZSkge1xuXG4gICAgICBcbiAgICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHsgXG4gICAgICAgIFxuICAgICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7IC8vIElzIG51bWJlciBidXQgbm90IE5hTlxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgXG4gICAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZlcjogZnVuY3Rpb24oZm5jKSB7XG4gICAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gICAgfSxcbiAgICBcbiAgICB0b0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgICB9LFxuXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdWxsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gICAgfSxcbiAgICBcbiAgICBpc05hTjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaiswO1xuICAgIH0sXG4gICAgXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKycnO1xuICAgIH0sXG4gICAgXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgXG4gIH07XG4gICAgXG59KSgpO1xuXG5cbmRhdC5jb250cm9sbGVycy5Db250cm9sbGVyID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIEFuIFwiYWJzdHJhY3RcIiBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgIC8qKlxuICAgICAqIFRob3NlIHdobyBleHRlbmQgdGhpcyBjbGFzcyB3aWxsIHB1dCB0aGVpciBET00gZWxlbWVudHMgaW4gaGVyZS5cbiAgICAgKiBAdHlwZSB7RE9NRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgdG8gbWFuaXB1bGF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gbWFuaXB1bGF0ZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjaGFuZ2UuXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fb25DaGFuZ2UgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGZpbmlzaGluZyBjaGFuZ2UuXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG5cbiAgfTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlci5wcm90b3R5cGUgKi9cbiAgICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSB0aGF0IGEgZnVuY3Rpb24gZmlyZSBldmVyeSB0aW1lIHNvbWVvbmUgY2hhbmdlcyB0aGUgdmFsdWUgd2l0aFxuICAgICAgICAgKiB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuYyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZVxuICAgICAgICAgKiBpcyBtb2RpZmllZCB2aWEgdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UgPSBmbmM7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgdGhhdCBhIGZ1bmN0aW9uIGZpcmUgZXZlcnkgdGltZSBzb21lb25lIFwiZmluaXNoZXNcIiBjaGFuZ2luZ1xuICAgICAgICAgKiB0aGUgdmFsdWUgd2loIHRoaXMgQ29udHJvbGxlci4gVXNlZnVsIGZvciB2YWx1ZXMgdGhhdCBjaGFuZ2VcbiAgICAgICAgICogaW5jcmVtZW50YWxseSBsaWtlIG51bWJlcnMgb3Igc3RyaW5ncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5jIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXJcbiAgICAgICAgICogc29tZW9uZSBcImZpbmlzaGVzXCIgY2hhbmdpbmcgdGhlIHZhbHVlIHZpYSB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgb25GaW5pc2hDaGFuZ2U6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IGZuYztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIHRoZSB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCB2YWx1ZSBvZiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaGVzIHRoZSB2aXN1YWwgZGlzcGxheSBvZiBhIENvbnRyb2xsZXIgaW4gb3JkZXIgdG8ga2VlcCBzeW5jXG4gICAgICAgICAqIHdpdGggdGhlIG9iamVjdCdzIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSB2YWx1ZSBoYXMgZGV2aWF0ZWQgZnJvbSBpbml0aWFsVmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGlzTW9kaWZpZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdGhpcy5nZXRWYWx1ZSgpXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIENvbnRyb2xsZXI7XG5cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmRvbS5kb20gPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIHZhciBFVkVOVF9NQVAgPSB7XG4gICAgJ0hUTUxFdmVudHMnOiBbJ2NoYW5nZSddLFxuICAgICdNb3VzZUV2ZW50cyc6IFsnY2xpY2snLCdtb3VzZW1vdmUnLCdtb3VzZWRvd24nLCdtb3VzZXVwJywgJ21vdXNlb3ZlciddLFxuICAgICdLZXlib2FyZEV2ZW50cyc6IFsna2V5ZG93biddXG4gIH07XG5cbiAgdmFyIEVWRU5UX01BUF9JTlYgPSB7fTtcbiAgY29tbW9uLmVhY2goRVZFTlRfTUFQLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgY29tbW9uLmVhY2godiwgZnVuY3Rpb24oZSkge1xuICAgICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBDU1NfVkFMVUVfUElYRUxTID0gLyhcXGQrKFxcLlxcZCspPylweC87XG5cbiAgZnVuY3Rpb24gY3NzVmFsdWVUb1BpeGVscyh2YWwpIHtcblxuICAgIGlmICh2YWwgPT09ICcwJyB8fCBjb21tb24uaXNVbmRlZmluZWQodmFsKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goQ1NTX1ZBTFVFX1BJWEVMUyk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc051bGwobWF0Y2gpKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAuLi5lbXM/ICU/XG5cbiAgICByZXR1cm4gMDtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQG1lbWJlciBkYXQuZG9tXG4gICAqL1xuICB2YXIgZG9tID0ge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gc2VsZWN0YWJsZVxuICAgICAqL1xuICAgIG1ha2VTZWxlY3RhYmxlOiBmdW5jdGlvbihlbGVtLCBzZWxlY3RhYmxlKSB7XG5cbiAgICAgIGlmIChlbGVtID09PSB1bmRlZmluZWQgfHwgZWxlbS5zdHlsZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIGVsZW0ub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcblxuICAgICAgZWxlbS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgIGVsZW0uc3R5bGUuS2h0bWxVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgIGVsZW0udW5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZSA/ICdvbicgOiAnb2ZmJztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGhvcml6b250YWxcbiAgICAgKiBAcGFyYW0gdmVydGljYWxcbiAgICAgKi9cbiAgICBtYWtlRnVsbHNjcmVlbjogZnVuY3Rpb24oZWxlbSwgaG9yaXpvbnRhbCwgdmVydGljYWwpIHtcblxuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkgaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHZlcnRpY2FsKSkgdmVydGljYWwgPSB0cnVlO1xuXG4gICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xuICAgICAgICBlbGVtLnN0eWxlLmJvdHRvbSA9IDA7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgZmFrZUV2ZW50OiBmdW5jdGlvbihlbGVtLCBldmVudFR5cGUsIHBhcmFtcywgYXV4KSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuICAgICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0eXBlICcgKyBldmVudFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoY2xhc3NOYW1lKTtcbiAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcbiAgICAgICAgICB2YXIgY2xpZW50WCA9IHBhcmFtcy54IHx8IHBhcmFtcy5jbGllbnRYIHx8IDA7XG4gICAgICAgICAgdmFyIGNsaWVudFkgPSBwYXJhbXMueSB8fCBwYXJhbXMuY2xpZW50WSB8fCAwO1xuICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlLCB3aW5kb3csIHBhcmFtcy5jbGlja0NvdW50IHx8IDEsXG4gICAgICAgICAgICAgIDAsIC8vc2NyZWVuIFhcbiAgICAgICAgICAgICAgMCwgLy9zY3JlZW4gWVxuICAgICAgICAgICAgICBjbGllbnRYLCAvL2NsaWVudCBYXG4gICAgICAgICAgICAgIGNsaWVudFksIC8vY2xpZW50IFlcbiAgICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLZXlib2FyZEV2ZW50cyc6XG4gICAgICAgICAgdmFyIGluaXQgPSBldnQuaW5pdEtleWJvYXJkRXZlbnQgfHwgZXZ0LmluaXRLZXlFdmVudDsgLy8gd2Via2l0IHx8IG1velxuICAgICAgICAgIGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGtleUNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYXJDb2RlOiB1bmRlZmluZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbml0KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlLCB3aW5kb3csXG4gICAgICAgICAgICAgIHBhcmFtcy5jdHJsS2V5LCBwYXJhbXMuYWx0S2V5LFxuICAgICAgICAgICAgICBwYXJhbXMuc2hpZnRLZXksIHBhcmFtcy5tZXRhS2V5LFxuICAgICAgICAgICAgICBwYXJhbXMua2V5Q29kZSwgcGFyYW1zLmNoYXJDb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29tbW9uLmRlZmF1bHRzKGV2dCwgYXV4KTtcbiAgICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKiBAcGFyYW0gYm9vbFxuICAgICAqL1xuICAgIGJpbmQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBib29sKSB7XG4gICAgICBib29sID0gYm9vbCB8fCBmYWxzZTtcbiAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgICBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KVxuICAgICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKiBAcGFyYW0gYm9vbFxuICAgICAqL1xuICAgIHVuYmluZDogZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIGJvb2wpIHtcbiAgICAgIGJvb2wgPSBib29sIHx8IGZhbHNlO1xuICAgICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICAgIGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpXG4gICAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lICE9PSBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09IC0xKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgPT09IGNsYXNzTmFtZSkge1xuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoPzpcXFxccyt8JCknKS50ZXN0KGVsZW0uY2xhc3NOYW1lKSB8fCBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbihlbGVtKSB7XG5cbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cbiAgICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItbGVmdC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWxlZnQnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3dpZHRoJ10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbihlbGVtKSB7XG5cbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG5cbiAgICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItdG9wLXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItYm90dG9tLXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXRvcCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1ib3R0b20nXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2hlaWdodCddKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldE9mZnNldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgdmFyIG9mZnNldCA9IHtsZWZ0OiAwLCB0b3A6MH07XG4gICAgICBpZiAoZWxlbS5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgICBvZmZzZXQudG9wICs9IGVsZW0ub2Zmc2V0VG9wO1xuICAgICAgICB9IHdoaWxlIChlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3Bvc3RzLzI2ODQ1NjEvcmV2aXNpb25zXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmICk7XG4gICAgfVxuXG4gIH07XG5cbiAgcmV0dXJuIGRvbTtcblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIHNlbGVjdCBpbnB1dCB0byBhbHRlciB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCB1c2luZyBhXG4gICAqIGxpc3Qgb2YgYWNjZXB0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmdbXX0gb3B0aW9ucyBBIG1hcCBvZiBsYWJlbHMgdG8gYWNjZXB0YWJsZSB2YWx1ZXMsIG9yXG4gICAqIGEgbGlzdCBvZiBhY2NlcHRhYmxlIHN0cmluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgT3B0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIG9wdGlvbnMpIHtcblxuICAgIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkcm9wIGRvd24gbWVudVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cbiAgICBpZiAoY29tbW9uLmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgIGNvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgbWFwW2VsZW1lbnRdID0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucyA9IG1hcDtcbiAgICB9XG5cbiAgICBjb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cbiAgICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICBvcHQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICAgIF90aGlzLl9fc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG5cbiAgICB9KTtcblxuICAgIC8vIEFja25vd2xlZGdlIG9yaWdpbmFsIHZhbHVlXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGVzaXJlZFZhbHVlID0gdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShkZXNpcmVkVmFsdWUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19zZWxlY3QpO1xuXG4gIH07XG5cbiAgT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX19zZWxlY3QudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBPcHRpb25Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5taW5dIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhdIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5zdGVwXSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICB0aGlzLl9fbWluID0gcGFyYW1zLm1pbjtcbiAgICB0aGlzLl9fbWF4ID0gcGFyYW1zLm1heDtcbiAgICB0aGlzLl9fc3RlcCA9IHBhcmFtcy5zdGVwO1xuXG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZCh0aGlzLl9fc3RlcCkpIHtcblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlID09IDApIHtcbiAgICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gMTsgLy8gV2hhdCBhcmUgd2UsIHBzeWNoaWNzP1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGV5IERvdWcsIGNoZWNrIHRoaXMgb3V0LlxuICAgICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyh0aGlzLmluaXRpYWxWYWx1ZSkvTWF0aC5MTjEwKSkvMTA7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSB0aGlzLl9fc3RlcDtcblxuICAgIH1cblxuICAgIHRoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyh0aGlzLl9faW1wbGllZFN0ZXApO1xuXG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlICovXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICAgIGlmICh0aGlzLl9fbWluICE9PSB1bmRlZmluZWQgJiYgdiA8IHRoaXMuX19taW4pIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLl9fbWluO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fX21heCAhPT0gdW5kZWZpbmVkICYmIHYgPiB0aGlzLl9fbWF4KSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5fX21heDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5fX3N0ZXAgIT09IHVuZGVmaW5lZCAmJiB2ICUgdGhpcy5fX3N0ZXAgIT0gMCkge1xuICAgICAgICAgICAgdiA9IE1hdGgucm91bmQodiAvIHRoaXMuX19zdGVwKSAqIHRoaXMuX19zdGVwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIG1pbmltdW0gdmFsdWUgZm9yIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgVGhlIG1pbmltdW0gdmFsdWUgZm9yXG4gICAgICAgICAqIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgbWluOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX21pbiA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBtYXhpbXVtIHZhbHVlIGZvciA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFZhbHVlIFRoZSBtYXhpbXVtIHZhbHVlIGZvclxuICAgICAgICAgKiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG1heDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19tYXggPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgc3RlcCB2YWx1ZSB0aGF0IGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAgICAgICAqIGluY3JlbWVudHMgYnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwVmFsdWUgVGhlIHN0ZXAgdmFsdWUgZm9yXG4gICAgICAgICAqIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAgICAgICAqIEBkZWZhdWx0IGlmIG1pbmltdW0gYW5kIG1heGltdW0gc3BlY2lmaWVkIGluY3JlbWVudCBpcyAxJSBvZiB0aGVcbiAgICAgICAgICogZGlmZmVyZW5jZSBvdGhlcndpc2Ugc3RlcFZhbHVlIGlzIDFcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBzdGVwOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX3N0ZXAgPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIG51bURlY2ltYWxzKHgpIHtcbiAgICB4ID0geC50b1N0cmluZygpO1xuICAgIGlmICh4LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICByZXR1cm4geC5sZW5ndGggLSB4LmluZGV4T2YoJy4nKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94ID0gKGZ1bmN0aW9uIChOdW1iZXJDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyIGFuZFxuICAgKiBwcm92aWRlcyBhbiBpbnB1dCBlbGVtZW50IHdpdGggd2hpY2ggdG8gbWFuaXB1bGF0ZSBpdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWluXSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWF4XSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuc3RlcF0gSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXJCb3ggPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIHtOdW1iZXJ9IFByZXZpb3VzIG1vdXNlIHkgcG9zaXRpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdmFyIHByZXZfeTtcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG5cbiAgICAvLyBNYWtlcyBpdCBzbyBtYW51YWxseSBzcGVjaWZpZWQgdmFsdWVzIGFyZSBub3QgdHJ1bmNhdGVkLlxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAvLyBXaGVuIHByZXNzaW5nIGVudGlyZSwgeW91IGNhbiBiZSBhcyBwcmVjaXNlIGFzIHlvdSB3YW50LlxuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHZhciBhdHRlbXB0ZWQgPSBwYXJzZUZsb2F0KF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgICAgaWYgKCFjb21tb24uaXNOYU4oYXR0ZW1wdGVkKSkgX3RoaXMuc2V0VmFsdWUoYXR0ZW1wdGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBvbkNoYW5nZSgpO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIHByZXZfeSA9IGUuY2xpZW50WTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG5cbiAgICAgIHZhciBkaWZmID0gcHJldl95IC0gZS5jbGllbnRZO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuZ2V0VmFsdWUoKSArIGRpZmYgKiBfdGhpcy5fX2ltcGxpZWRTdGVwKTtcblxuICAgICAgcHJldl95ID0gZS5jbGllbnRZO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MgPSBOdW1iZXJDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlLFxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID8gdGhpcy5nZXRWYWx1ZSgpIDogcm91bmRUb0RlY2ltYWwodGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl9fcHJlY2lzaW9uKTtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgdmFyIHRlblRvID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHRlblRvKSAvIHRlblRvO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJCb3g7XG5cbn0pKGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IChmdW5jdGlvbiAoTnVtYmVyQ29udHJvbGxlciwgZG9tLCBjc3MsIGNvbW1vbiwgc3R5bGVTaGVldCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0aGF0IGlzIGEgbnVtYmVyLCBjb250YWluc1xuICAgKiBhIG1pbmltdW0gYW5kIG1heGltdW0sIGFuZCBwcm92aWRlcyBhIHNsaWRlciBlbGVtZW50IHdpdGggd2hpY2ggdG9cbiAgICogbWFuaXB1bGF0ZSBpdC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgdGhlIHNsaWRlciBlbGVtZW50IGlzIG1hZGUgdXAgb2ZcbiAgICogPGNvZGU+Jmx0O2RpdiZndDs8L2NvZGU+IHRhZ3MsIDxzdHJvbmc+bm90PC9zdHJvbmc+IHRoZSBodG1sNVxuICAgKiA8Y29kZT4mbHQ7c2xpZGVyJmd0OzwvY29kZT4gZWxlbWVudC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5WYWx1ZSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFZhbHVlIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFZhbHVlIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyU2xpZGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgbWluLCBtYXgsIHN0ZXApIHtcblxuICAgIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBcblxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2JhY2tncm91bmQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19iYWNrZ3JvdW5kLCAnc2xpZGVyJyk7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19mb3JlZ3JvdW5kLCAnc2xpZGVyLWZnJyk7XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG5cbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXG4gICAgICBvbk1vdXNlRHJhZyhlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIG9mZnNldCA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19iYWNrZ3JvdW5kKTtcbiAgICAgIHZhciB3aWR0aCA9IGRvbS5nZXRXaWR0aChfdGhpcy5fX2JhY2tncm91bmQpO1xuICAgICAgXG4gICAgICBfdGhpcy5zZXRWYWx1ZShcbiAgICAgICAgbWFwKGUuY2xpZW50WCwgb2Zmc2V0LmxlZnQsIG9mZnNldC5sZWZ0ICsgd2lkdGgsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLl9fYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLl9fZm9yZWdyb3VuZCk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19iYWNrZ3JvdW5kKTtcblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcyA9IE51bWJlckNvbnRyb2xsZXI7XG5cbiAgLyoqXG4gICAqIEluamVjdHMgZGVmYXVsdCBzdHlsZXNoZWV0IGZvciBzbGlkZXIgZWxlbWVudHMuXG4gICAqL1xuICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnVzZURlZmF1bHRTdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICBjc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xuICB9O1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE51bWJlckNvbnRyb2xsZXJTbGlkZXIucHJvdG90eXBlLFxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGN0ID0gKHRoaXMuZ2V0VmFsdWUoKSAtIHRoaXMuX19taW4pLyh0aGlzLl9fbWF4IC0gdGhpcy5fX21pbik7XG4gICAgICAgICAgdGhpcy5fX2ZvcmVncm91bmQuc3R5bGUud2lkdGggPSBwY3QqMTAwKyclJztcbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG5cblxuICApO1xuXG4gIGZ1bmN0aW9uIG1hcCh2LCBpMSwgaTIsIG8xLCBvMikge1xuICAgIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlcjtcbiAgXG59KShkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNzcyxcbmRhdC51dGlscy5jb21tb24sXG5cIi5zbGlkZXIge1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAycHggNHB4IHJnYmEoMCwwLDAsMC4xNSk7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICBwYWRkaW5nOiAwIDAuNWVtO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnNsaWRlci1mZyB7XFxuICBwYWRkaW5nOiAxcHggMCAycHggMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNhYWE7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIG1hcmdpbi1sZWZ0OiAtMC41ZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjVlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbSAwIDAgMWVtO1xcbn1cXG5cXG4uc2xpZGVyLWZnOmFmdGVyIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBib3JkZXI6ICAxcHggc29saWQgI2FhYTtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgbWFyZ2luLXJpZ2h0OiAtMWVtO1xcbiAgbWFyZ2luLXRvcDogLTFweDtcXG4gIGhlaWdodDogMC45ZW07XFxuICB3aWR0aDogMC45ZW07XFxufVwiKTtcblxuXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBHVUkgaW50ZXJmYWNlIHRvIGZpcmUgYSBzcGVjaWZpZWQgbWV0aG9kLCBhIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBGdW5jdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCB0ZXh0KSB7XG5cbiAgICBGdW5jdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fYnV0dG9uLmlubmVySFRNTCA9IHRleHQgPT09IHVuZGVmaW5lZCA/ICdGaXJlJyA6IHRleHQ7XG4gICAgZG9tLmJpbmQodGhpcy5fX2J1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuZmlyZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19idXR0b24sICdidXR0b24nKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fYnV0dG9uKTtcblxuXG4gIH07XG5cbiAgRnVuY3Rpb25Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEZ1bmN0aW9uQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIHtcbiAgICAgICAgXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmdldFZhbHVlKCkuY2FsbCh0aGlzLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBGdW5jdGlvbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIGNoZWNrYm94IGlucHV0IHRvIGFsdGVyIHRoZSBib29sZWFuIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBCb29sZWFuQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgICB0aGlzLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKTtcblxuXG4gICAgZG9tLmJpbmQodGhpcy5fX2NoZWNrYm94LCAnY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2hlY2tib3gpO1xuXG4gICAgLy8gTWF0Y2ggb3JpZ2luYWwgdmFsdWVcbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XG4gICAgfVxuXG4gIH07XG5cbiAgQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciB0b1JldHVybiA9IEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdik7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSB0cnVlOyAgICBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBCb29sZWFuQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb2xvci50b1N0cmluZyA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9yKSB7XG5cbiAgICBpZiAoY29sb3IuYSA9PSAxIHx8IGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5hKSkge1xuXG4gICAgICB2YXIgcyA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgICB3aGlsZSAocy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgcztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChjb2xvci5yKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZykgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmIpICsgJywnICsgY29sb3IuYSArICcpJztcblxuICAgIH1cblxuICB9XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb2xvci5pbnRlcnByZXQgPSAoZnVuY3Rpb24gKHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgcmVzdWx0LCB0b1JldHVybjtcblxuICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0b1JldHVybiA9IGZhbHNlO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBjb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuXG4gICAgY29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbihmYW1pbHkpIHtcblxuICAgICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG5cbiAgICAgICAgY29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbihjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcblxuICAgICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfTtcblxuICB2YXIgSU5URVJQUkVUQVRJT05TID0gW1xuXG4gICAgLy8gU3RyaW5nc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNTdHJpbmcsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgVEhSRUVfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzNdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgU0lYX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XXs2fSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQjoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCQToge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE51bWJlcnNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzTnVtYmVyLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIEhFWDoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBBcnJheXNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzQXJyYXksXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gMykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCQV9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gT2JqZWN0c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNPYmplY3QsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG5cbiAgXTtcblxuICByZXR1cm4gaW50ZXJwcmV0O1xuXG5cbn0pKGRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5HVUkgPSBkYXQuZ3VpLkdVSSA9IChmdW5jdGlvbiAoY3NzLCBzYXZlRGlhbG9ndWVDb250ZW50cywgc3R5bGVTaGVldCwgY29udHJvbGxlckZhY3RvcnksIENvbnRyb2xsZXIsIEJvb2xlYW5Db250cm9sbGVyLCBGdW5jdGlvbkNvbnRyb2xsZXIsIE51bWJlckNvbnRyb2xsZXJCb3gsIE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIE9wdGlvbkNvbnRyb2xsZXIsIENvbG9yQ29udHJvbGxlciwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBDZW50ZXJlZERpdiwgZG9tLCBjb21tb24pIHtcblxuICBjc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xuXG4gIC8qKiBPdXRlci1tb3N0IGNsYXNzTmFtZSBmb3IgR1VJJ3MgKi9cbiAgdmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xuXG4gIHZhciBISURFX0tFWV9DT0RFID0gNzI7XG5cbiAgLyoqIFRoZSBvbmx5IHZhbHVlIHNoYXJlZCBiZXR3ZWVuIHRoZSBKUyBhbmQgU0NTUy4gVXNlIGNhdXRpb24uICovXG4gIHZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG5cbiAgdmFyIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSA9ICdEZWZhdWx0JztcblxuICB2YXIgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdyAmJiB3aW5kb3dbJ2xvY2FsU3RvcmFnZSddICE9PSBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgdmFyIFNBVkVfRElBTE9HVUU7XG5cbiAgLyoqIEhhdmUgd2UgeWV0IHRvIGNyZWF0ZSBhbiBhdXRvUGxhY2UgR1VJPyAqL1xuICB2YXIgYXV0b19wbGFjZV92aXJnaW4gPSB0cnVlO1xuXG4gIC8qKiBGaXhlZCBwb3NpdGlvbiBkaXYgdGhhdCBhdXRvIHBsYWNlIEdVSSdzIGdvIGluc2lkZSAqL1xuICB2YXIgYXV0b19wbGFjZV9jb250YWluZXI7XG5cbiAgLyoqIEFyZSB3ZSBoaWRpbmcgdGhlIEdVSSdzID8gKi9cbiAgdmFyIGhpZGUgPSBmYWxzZTtcblxuICAvKiogR1VJJ3Mgd2hpY2ggc2hvdWxkIGJlIGhpZGRlbiAqL1xuICB2YXIgaGlkZWFibGVfZ3VpcyA9IFtdO1xuXG4gIC8qKlxuICAgKiBBIGxpZ2h0d2VpZ2h0IGNvbnRyb2xsZXIgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC4gSXQgYWxsb3dzIHlvdSB0byBlYXNpbHlcbiAgICogbWFuaXB1bGF0ZSB2YXJpYWJsZXMgYW5kIGZpcmUgZnVuY3Rpb25zIG9uIHRoZSBmbHkuXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5ndWlcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLm5hbWVdIFRoZSBuYW1lIG9mIHRoaXMgR1VJLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcy5sb2FkXSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNhdmVkIHN0YXRlIG9mXG4gICAqIHRoaXMgR1VJLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuYXV0bz10cnVlXVxuICAgKiBAcGFyYW0ge2RhdC5ndWkuR1VJfSBbcGFyYW1zLnBhcmVudF0gVGhlIEdVSSBJJ20gbmVzdGVkIGluLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuY2xvc2VkXSBJZiB0cnVlLCBzdGFydHMgY2xvc2VkXG4gICAqL1xuICB2YXIgR1VJID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogT3V0ZXJtb3N0IERPTSBFbGVtZW50XG4gICAgICogQHR5cGUgRE9NRWxlbWVudFxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX191bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XG5cbiAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBDU1NfTkFNRVNQQUNFKTtcblxuICAgIC8qKlxuICAgICAqIE5lc3RlZCBHVUkncyBieSBuYW1lXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19mb2xkZXJzID0ge307XG5cbiAgICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2Ygb2JqZWN0cyBJJ20gcmVtZW1iZXJpbmcgZm9yIHNhdmUsIG9ubHkgdXNlZCBpbiB0b3AgbGV2ZWwgR1VJXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTWFwcyB0aGUgaW5kZXggb2YgcmVtZW1iZXJlZCBvYmplY3RzIHRvIGEgbWFwIG9mIGNvbnRyb2xsZXJzLCBvbmx5IHVzZWRcbiAgICAgKiBpbiB0b3AgbGV2ZWwgR1VJLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFtcbiAgICAgKiAge1xuICAgICAqICAgIHByb3BlcnR5TmFtZTogQ29udHJvbGxlcixcbiAgICAgKiAgICBhbm90aGVyUHJvcGVydHlOYW1lOiBDb250cm9sbGVyXG4gICAgICogIH0sXG4gICAgICogIHtcbiAgICAgKiAgICBwcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXJcbiAgICAgKiAgfVxuICAgICAqIF1cbiAgICAgKi9cbiAgICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzID0gW107XG5cbiAgICB0aGlzLl9fbGlzdGVuaW5nID0gW107XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAvLyBEZWZhdWx0IHBhcmFtZXRlcnNcbiAgICBwYXJhbXMgPSBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICBhdXRvUGxhY2U6IHRydWUsXG4gICAgICB3aWR0aDogR1VJLkRFRkFVTFRfV0lEVEhcbiAgICB9KTtcblxuICAgIHBhcmFtcyA9IGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcbiAgICAgIGhpZGVhYmxlOiBwYXJhbXMuYXV0b1BsYWNlXG4gICAgfSk7XG5cblxuICAgIGlmICghY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5sb2FkKSkge1xuXG4gICAgICAvLyBFeHBsaWNpdCBwcmVzZXRcbiAgICAgIGlmIChwYXJhbXMucHJlc2V0KSBwYXJhbXMubG9hZC5wcmVzZXQgPSBwYXJhbXMucHJlc2V0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcGFyYW1zLmxvYWQgPSB7IHByZXNldDogREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FIH07XG5cbiAgICB9XG5cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5oaWRlYWJsZSkge1xuICAgICAgaGlkZWFibGVfZ3Vpcy5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgcm9vdCBsZXZlbCBHVUkncyBhcmUgcmVzaXphYmxlLlxuICAgIHBhcmFtcy5yZXNpemFibGUgPSBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnJlc2l6YWJsZTtcblxuXG4gICAgaWYgKHBhcmFtcy5hdXRvUGxhY2UgJiYgY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5zY3JvbGxhYmxlKSkge1xuICAgICAgcGFyYW1zLnNjcm9sbGFibGUgPSB0cnVlO1xuICAgIH1cbi8vICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5zY3JvbGxhYmxlID09PSB0cnVlO1xuXG4gICAgLy8gTm90IHBhcnQgb2YgcGFyYW1zIGJlY2F1c2UgSSBkb24ndCB3YW50IHBlb3BsZSBwYXNzaW5nIHRoaXMgaW4gdmlhXG4gICAgLy8gY29uc3RydWN0b3IuIFNob3VsZCBiZSBhICdyZW1lbWJlcmVkJyB2YWx1ZS5cbiAgICB2YXIgdXNlX2xvY2FsX3N0b3JhZ2UgPVxuICAgICAgICBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZSc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuXG4gICAgICAgIC8qKiBAbGVuZHMgZGF0Lmd1aS5HVUkucHJvdG90eXBlICovXG4gICAgICAgIHtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBwYXJlbnQgPGNvZGU+R1VJPC9jb2RlPlxuICAgICAgICAgICAqIEB0eXBlIGRhdC5ndWkuR1VJXG4gICAgICAgICAgICovXG4gICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2Nyb2xsYWJsZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBIYW5kbGVzIDxjb2RlPkdVSTwvY29kZT4ncyBlbGVtZW50IHBsYWNlbWVudCBmb3IgeW91XG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIGF1dG9QbGFjZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5hdXRvUGxhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBpZGVudGlmaWVyIGZvciBhIHNldCBvZiBzYXZlZCB2YWx1ZXNcbiAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwcmVzZXQ6IHtcblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSb290KCkucHJlc2V0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRQcmVzZXRTZWxlY3RJbmRleCh0aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHdpZHRoIG9mIDxjb2RlPkdVSTwvY29kZT4gZWxlbWVudFxuICAgICAgICAgICAqIEB0eXBlIE51bWJlclxuICAgICAgICAgICAqL1xuICAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLndpZHRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuICAgICAgICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBuYW1lIG9mIDxjb2RlPkdVSTwvY29kZT4uIFVzZWQgZm9yIGZvbGRlcnMuIGkuZVxuICAgICAgICAgICAqIGEgZm9sZGVyJ3MgbmFtZVxuICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBDaGVjayBmb3IgY29sbGlzaW9ucyBhbW9uZyBzaWJsaW5nIGZvbGRlcnNcbiAgICAgICAgICAgICAgcGFyYW1zLm5hbWUgPSB2O1xuICAgICAgICAgICAgICBpZiAodGl0bGVfcm93X25hbWUpIHtcbiAgICAgICAgICAgICAgICB0aXRsZV9yb3dfbmFtZS5pbm5lckhUTUwgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGV0aGVyIHRoZSA8Y29kZT5HVUk8L2NvZGU+IGlzIGNvbGxhcHNlZCBvciBub3RcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgY2xvc2VkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHY7XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBhcmVuJ3QgZ29pbmcgdG8gcmVzcGVjdCB0aGUgQ1NTIHRyYW5zaXRpb24sXG4gICAgICAgICAgICAgIC8vIExldHMganVzdCBjaGVjayBvdXIgaGVpZ2h0IGFnYWluc3QgdGhlIHdpbmRvdyBoZWlnaHQgcmlnaHQgb2ZmXG4gICAgICAgICAgICAgIC8vIHRoZSBiYXQuXG4gICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcblxuICAgICAgICAgICAgICBpZiAoX3RoaXMuX19jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gdiA/IEdVSS5URVhUX09QRU4gOiBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ29udGFpbnMgYWxsIHByZXNldHNcbiAgICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsb2FkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gdXNlIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vU3RvcmFnZSNsb2NhbFN0b3JhZ2VcIj5sb2NhbFN0b3JhZ2U8L2E+IGFzIHRoZSBtZWFucyBmb3JcbiAgICAgICAgICAgKiA8Y29kZT5yZW1lbWJlcjwvY29kZT5pbmdcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlOiB7XG5cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1c2VfbG9jYWxfc3RvcmFnZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGJvb2wpIHtcbiAgICAgICAgICAgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICAgICAgICAgICAgICB1c2VfbG9jYWxfc3RvcmFnZSA9IGJvb2w7XG4gICAgICAgICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSwgYm9vbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgIC8vIEFyZSB3ZSBhIHJvb3QgbGV2ZWwgR1VJP1xuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcblxuICAgICAgcGFyYW1zLmNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfTUFJTik7XG4gICAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBzdXBwb3NlZCB0byBiZSBsb2FkaW5nIGxvY2FsbHk/XG4gICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXG4gICAgICAgIGlmICh1c2VfbG9jYWxfc3RvcmFnZSkge1xuXG4gICAgICAgICAgX3RoaXMudXNlTG9jYWxTdG9yYWdlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzYXZlZF9ndWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XG5cbiAgICAgICAgICBpZiAoc2F2ZWRfZ3VpKSB7XG4gICAgICAgICAgICBwYXJhbXMubG9hZCA9IEpTT04ucGFyc2Uoc2F2ZWRfZ3VpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19jbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CVVRUT04pO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jbG9zZUJ1dHRvbik7XG5cbiAgICAgIGRvbS5iaW5kKHRoaXMuX19jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcblxuXG4gICAgICB9KTtcblxuXG4gICAgICAvLyBPaCwgeW91J3JlIGEgbmVzdGVkIEdVSSFcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAocGFyYW1zLmNsb3NlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGl0bGVfcm93X25hbWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXJhbXMubmFtZSk7XG4gICAgICBkb20uYWRkQ2xhc3ModGl0bGVfcm93X25hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcblxuICAgICAgdmFyIHRpdGxlX3JvdyA9IGFkZFJvdyhfdGhpcywgdGl0bGVfcm93X25hbWUpO1xuXG4gICAgICB2YXIgb25fY2xpY2tfdGl0bGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aXRsZV9yb3csICd0aXRsZScpO1xuICAgICAgZG9tLmJpbmQodGl0bGVfcm93LCAnY2xpY2snLCBvbl9jbGlja190aXRsZSk7XG5cbiAgICAgIGlmICghcGFyYW1zLmNsb3NlZCkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hdXRvUGxhY2UpIHtcblxuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuXG4gICAgICAgIGlmIChhdXRvX3BsYWNlX3Zpcmdpbikge1xuICAgICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9fcGxhY2VfY29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b19wbGFjZV9jb250YWluZXIsIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUik7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdXRvX3BsYWNlX2NvbnRhaW5lcik7XG4gICAgICAgICAgYXV0b19wbGFjZV92aXJnaW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBpdCBpbiB0aGUgZG9tIGZvciB5b3UuXG4gICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGhlIGF1dG8gc3R5bGVzXG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19BVVRPX1BMQUNFKTtcblxuICAgICAgfVxuXG5cbiAgICAgIC8vIE1ha2UgaXQgbm90IGVsYXN0aWMuXG4gICAgICBpZiAoIXRoaXMucGFyZW50KSBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcblxuICAgIH1cblxuICAgIGRvbS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKTsgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ29UcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuXG5cbiAgICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuICAgICAgYWRkUmVzaXplSGFuZGxlKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVUb0xvY2FsU3RvcmFnZSgpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdndWknKSwgSlNPTi5zdHJpbmdpZnkoX3RoaXMuZ2V0U2F2ZU9iamVjdCgpKSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgICAgIHJvb3Qud2lkdGggKz0gMTtcbiAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJvb3Qud2lkdGggLT0gMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLnBhcmVudCkge1xuICAgICAgICByZXNldFdpZHRoKCk7XG4gICAgICB9XG5cbiAgfTtcblxuICBHVUkudG9nZ2xlSGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaGlkZSA9ICFoaWRlO1xuICAgIGNvbW1vbi5lYWNoKGhpZGVhYmxlX2d1aXMsIGZ1bmN0aW9uKGd1aSkge1xuICAgICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUuekluZGV4ID0gaGlkZSA/IC05OTkgOiA5OTk7XG4gICAgICBndWkuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gaGlkZSA/IDAgOiAxO1xuICAgIH0pO1xuICB9O1xuXG4gIEdVSS5DTEFTU19BVVRPX1BMQUNFID0gJ2EnO1xuICBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIgPSAnYWMnO1xuICBHVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcbiAgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XID0gJ2NyJztcbiAgR1VJLkNMQVNTX1RPT19UQUxMID0gJ3RhbGxlci10aGFuLXdpbmRvdyc7XG4gIEdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcbiAgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTiA9ICdjbG9zZS1idXR0b24nO1xuICBHVUkuQ0xBU1NfRFJBRyA9ICdkcmFnJztcblxuICBHVUkuREVGQVVMVF9XSURUSCA9IDI0NTtcbiAgR1VJLlRFWFRfQ0xPU0VEID0gJ0Nsb3NlIENvbnRyb2xzJztcbiAgR1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcblxuICBkb20uYmluZCh3aW5kb3csICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSAhPT0gJ3RleHQnICYmXG4gICAgICAgIChlLndoaWNoID09PSBISURFX0tFWV9DT0RFIHx8IGUua2V5Q29kZSA9PSBISURFX0tFWV9DT0RFKSkge1xuICAgICAgR1VJLnRvZ2dsZUhpZGUoKTtcbiAgICB9XG5cbiAgfSwgZmFsc2UpO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEdVSS5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0Lmd1aS5HVUkgKi9cbiAgICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSBUaGUgbmV3IGNvbnRyb2xsZXIgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlcbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db2xvckNvbnRyb2xsZXJ9IFRoZSBuZXcgY29udHJvbGxlciB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDb2xvcjogZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbG9yOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBjb250cm9sbGVyXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cbiAgICAgICAgICAvLyBUT0RPIGxpc3RlbmluZz9cbiAgICAgICAgICB0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoY29udHJvbGxlci5fX2xpKTtcbiAgICAgICAgICB0aGlzLl9fY29udHJvbGxlcnMuc2xpY2UodGhpcy5fX2NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlciksIDEpO1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0Lmd1aS5HVUl9IFRoZSBuZXcgZm9sZGVyLlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhpcyBHVUkgYWxyZWFkeSBoYXMgYSBmb2xkZXIgYnkgdGhlIHNwZWNpZmllZFxuICAgICAgICAgKiBuYW1lXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRm9sZGVyOiBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIHByZXZlbnQgY29sbGlzaW9ucyBvbiBuYW1lcyBpbiBvcmRlciB0byBoYXZlIGEga2V5XG4gICAgICAgICAgLy8gYnkgd2hpY2ggdG8gcmVtZW1iZXIgc2F2ZWQgdmFsdWVzXG4gICAgICAgICAgaWYgKHRoaXMuX19mb2xkZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFscmVhZHkgaGF2ZSBhIGZvbGRlciBpbiB0aGlzIEdVSSBieSB0aGUnICtcbiAgICAgICAgICAgICAgICAnIG5hbWUgXCInICsgbmFtZSArICdcIicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdfZ3VpX3BhcmFtcyA9IHsgbmFtZTogbmFtZSwgcGFyZW50OiB0aGlzIH07XG5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHBhc3MgZG93biB0aGUgYXV0b1BsYWNlIHRyYWl0IHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0byBvcGVuL2Nsb3NlIGZvbGRlciBhY3Rpb25zIHRvXG4gICAgICAgICAgLy8gZW5zdXJlIHRoYXQgYSBzY3JvbGxiYXIgYXBwZWFycyBpZiB0aGUgd2luZG93IGlzIHRvbyBzaG9ydC5cbiAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5hdXRvUGxhY2UgPSB0aGlzLmF1dG9QbGFjZTtcblxuICAgICAgICAgIC8vIERvIHdlIGhhdmUgc2F2ZWQgYXBwZWFyYW5jZSBkYXRhIGZvciB0aGlzIGZvbGRlcj9cblxuICAgICAgICAgIGlmICh0aGlzLmxvYWQgJiYgLy8gQW55dGhpbmcgbG9hZGVkP1xuICAgICAgICAgICAgICB0aGlzLmxvYWQuZm9sZGVycyAmJiAvLyBXYXMgbXkgcGFyZW50IGEgZGVhZC1lbmQ/XG4gICAgICAgICAgICAgIHRoaXMubG9hZC5mb2xkZXJzW25hbWVdKSB7IC8vIERpZCBkYWRkeSByZW1lbWJlciBtZT9cblxuICAgICAgICAgICAgLy8gU3RhcnQgbWUgY2xvc2VkIGlmIEkgd2FzIGNsb3NlZFxuICAgICAgICAgICAgbmV3X2d1aV9wYXJhbXMuY2xvc2VkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0uY2xvc2VkO1xuXG4gICAgICAgICAgICAvLyBQYXNzIGRvd24gdGhlIGxvYWRlZCBkYXRhXG4gICAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5sb2FkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV07XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdfZ3VpX3BhcmFtcyk7XG4gICAgICAgICAgdGhpcy5fX2ZvbGRlcnNbbmFtZV0gPSBndWk7XG5cbiAgICAgICAgICB2YXIgbGkgPSBhZGRSb3codGhpcywgZ3VpLmRvbUVsZW1lbnQpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2ZvbGRlcicpO1xuICAgICAgICAgIHJldHVybiBndWk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmdldFJvb3QoKTtcblxuICAgICAgICAgIGlmIChyb290LnNjcm9sbGFibGUpIHtcblxuICAgICAgICAgICAgdmFyIHRvcCA9IGRvbS5nZXRPZmZzZXQocm9vdC5fX3VsKS50b3A7XG4gICAgICAgICAgICB2YXIgaCA9IDA7XG5cbiAgICAgICAgICAgIGNvbW1vbi5lYWNoKHJvb3QuX191bC5jaGlsZE5vZGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgIGlmICghIChyb290LmF1dG9QbGFjZSAmJiBub2RlID09PSByb290Ll9fc2F2ZV9yb3cpKVxuICAgICAgICAgICAgICAgIGggKz0gZG9tLmdldEhlaWdodChub2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCA8IGgpIHtcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgKyAncHgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuICAgICAgICAgICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByb290Ll9fcmVzaXplX2hhbmRsZS5zdHlsZS5oZWlnaHQgPSByb290Ll9fdWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyb290Ll9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgIHJvb3QuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHJvb3Qud2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIG9iamVjdHMgZm9yIHNhdmluZy4gVGhlIG9yZGVyIG9mIHRoZXNlIG9iamVjdHMgY2Fubm90IGNoYW5nZSBhc1xuICAgICAgICAgKiB0aGUgR1VJIGdyb3dzLiBXaGVuIHJlbWVtYmVyaW5nIG5ldyBvYmplY3RzLCBhcHBlbmQgdGhlbSB0byB0aGUgZW5kXG4gICAgICAgICAqIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC4uLn0gb2JqZWN0c1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm90IGNhbGxlZCBvbiBhIHRvcCBsZXZlbCBHVUkuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtZW1iZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChTQVZFX0RJQUxPR1VFKSkge1xuICAgICAgICAgICAgU0FWRV9ESUFMT0dVRSA9IG5ldyBDZW50ZXJlZERpdigpO1xuICAgICAgICAgICAgU0FWRV9ESUFMT0dVRS5kb21FbGVtZW50LmlubmVySFRNTCA9IHNhdmVEaWFsb2d1ZUNvbnRlbnRzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbiBvbmx5IGNhbGwgcmVtZW1iZXIgb24gYSB0b3AgbGV2ZWwgR1VJLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgY29tbW9uLmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICBhZGRTYXZlTWVudShfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgICAgICAgIC8vIFNldCBzYXZlIHJvdyB3aWR0aFxuICAgICAgICAgICAgc2V0V2lkdGgodGhpcywgdGhpcy53aWR0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuZ3VpLkdVSX0gdGhlIHRvcG1vc3QgcGFyZW50IEdVSSBvZiBhIG5lc3RlZCBHVUkuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGd1aSA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcbiAgICAgICAgICAgIGd1aSA9IGd1aS5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBndWk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEgSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mXG4gICAgICAgICAqIHRoaXMgR1VJIGFzIHdlbGwgYXMgaXRzIHJlbWVtYmVyZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTYXZlT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciB0b1JldHVybiA9IHRoaXMubG9hZDtcblxuICAgICAgICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuXG4gICAgICAgICAgLy8gQW0gSSByZW1lbWJlcmluZyBhbnkgdmFsdWVzP1xuICAgICAgICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICB0b1JldHVybi5wcmVzZXQgPSB0aGlzLnByZXNldDtcblxuICAgICAgICAgICAgaWYgKCF0b1JldHVybi5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9SZXR1cm4uZm9sZGVycyA9IHt9O1xuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbihlbGVtZW50LCBrZXkpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmVBczogZnVuY3Rpb24ocHJlc2V0TmFtZSkge1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICAgICAgICAvLyBSZXRhaW4gZGVmYXVsdCB2YWx1ZXMgdXBvbiBmaXJzdCBzYXZlXG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtwcmVzZXROYW1lXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgICAgICAgdGhpcy5wcmVzZXQgPSBwcmVzZXROYW1lO1xuICAgICAgICAgIGFkZFByZXNldE9wdGlvbih0aGlzLCBwcmVzZXROYW1lLCB0cnVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHJldmVydDogZnVuY3Rpb24oZ3VpKSB7XG5cbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgcmV2ZXJ0IHdvcmsgb24gRGVmYXVsdC5cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRSb290KCkubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUoY29udHJvbGxlci5pbml0aWFsVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjYWxsU2F2ZWRWYWx1ZShndWkgfHwgdGhpcy5nZXRSb290KCksIGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uKGZvbGRlcikge1xuICAgICAgICAgICAgZm9sZGVyLnJldmVydChmb2xkZXIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFndWkpIHtcbiAgICAgICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLmdldFJvb3QoKSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdGVuOiBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cbiAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuX19saXN0ZW5pbmcubGVuZ3RoID09IDA7XG4gICAgICAgICAgdGhpcy5fX2xpc3RlbmluZy5wdXNoKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIGlmIChpbml0KSB1cGRhdGVEaXNwbGF5cyh0aGlzLl9fbGlzdGVuaW5nKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIGFkZChndWksIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IFwiICsgb2JqZWN0ICsgXCIgaGFzIG5vIHByb3BlcnR5IFxcXCJcIiArIHByb3BlcnR5ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBjb250cm9sbGVyO1xuXG4gICAgaWYgKHBhcmFtcy5jb2xvcikge1xuXG4gICAgICBjb250cm9sbGVyID0gbmV3IENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QscHJvcGVydHldLmNvbmNhdChwYXJhbXMuZmFjdG9yeUFyZ3MpO1xuICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJGYWN0b3J5LmFwcGx5KGd1aSwgZmFjdG9yeUFyZ3MpO1xuXG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgICBwYXJhbXMuYmVmb3JlID0gcGFyYW1zLmJlZm9yZS5fX2xpO1xuICAgIH1cblxuICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKTtcblxuICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG5cbiAgICB2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgICBuYW1lLmlubmVySFRNTCA9IGNvbnRyb2xsZXIucHJvcGVydHk7XG5cbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5hbWUpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250cm9sbGVyLmRvbUVsZW1lbnQpO1xuXG4gICAgdmFyIGxpID0gYWRkUm93KGd1aSwgY29udGFpbmVyLCBwYXJhbXMuYmVmb3JlKTtcblxuICAgIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgICBkb20uYWRkQ2xhc3MobGksIHR5cGVvZiBjb250cm9sbGVyLmdldFZhbHVlKCkpO1xuXG4gICAgYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcik7XG5cbiAgICBndWkuX19jb250cm9sbGVycy5wdXNoKGNvbnRyb2xsZXIpO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSByb3cgdG8gdGhlIGVuZCBvZiB0aGUgR1VJIG9yIGJlZm9yZSBhbm90aGVyIHJvdy5cbiAgICpcbiAgICogQHBhcmFtIGd1aVxuICAgKiBAcGFyYW0gW2RvbV0gSWYgc3BlY2lmaWVkLCBpbnNlcnRzIHRoZSBkb20gY29udGVudCBpbiB0aGUgbmV3IHJvd1xuICAgKiBAcGFyYW0gW2xpQmVmb3JlXSBJZiBzcGVjaWZpZWQsIHBsYWNlcyB0aGUgbmV3IHJvdyBiZWZvcmUgYW5vdGhlciByb3dcbiAgICovXG4gIGZ1bmN0aW9uIGFkZFJvdyhndWksIGRvbSwgbGlCZWZvcmUpIHtcbiAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIGlmIChkb20pIGxpLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgaWYgKGxpQmVmb3JlKSB7XG4gICAgICBndWkuX191bC5pbnNlcnRCZWZvcmUobGksIHBhcmFtcy5iZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBndWkuX191bC5hcHBlbmRDaGlsZChsaSk7XG4gICAgfVxuICAgIGd1aS5vblJlc2l6ZSgpO1xuICAgIHJldHVybiBsaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcblxuICAgIGNvbnRyb2xsZXIuX19saSA9IGxpO1xuICAgIGNvbnRyb2xsZXIuX19ndWkgPSBndWk7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbnRyb2xsZXIsIHtcblxuICAgICAgb3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbY29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNBcnJheShvcHRpb25zKSB8fCBjb21tb24uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW29wdGlvbnNdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgbmFtZTogZnVuY3Rpb24odikge1xuICAgICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gdjtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9LFxuXG4gICAgICBsaXN0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250cm9sbGVyLl9fZ3VpLmxpc3Rlbihjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250cm9sbGVyLl9fZ3VpLnJlbW92ZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIEFsbCBzbGlkZXJzIHNob3VsZCBiZSBhY2NvbXBhbmllZCBieSBhIGJveC5cbiAgICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcblxuICAgICAgdmFyIGJveCA9IG5ldyBOdW1iZXJDb250cm9sbGVyQm94KGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuXG4gICAgICBjb21tb24uZWFjaChbJ3VwZGF0ZURpc3BsYXknLCAnb25DaGFuZ2UnLCAnb25GaW5pc2hDaGFuZ2UnXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIHZhciBwYyA9IGNvbnRyb2xsZXJbbWV0aG9kXTtcbiAgICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICAgIGNvbnRyb2xsZXJbbWV0aG9kXSA9IGJveFttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIHBjLmFwcGx5KGNvbnRyb2xsZXIsIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZG9tLmFkZENsYXNzKGxpLCAnaGFzLXNsaWRlcicpO1xuICAgICAgY29udHJvbGxlci5kb21FbGVtZW50Lmluc2VydEJlZm9yZShib3guZG9tRWxlbWVudCwgY29udHJvbGxlci5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlckJveCkge1xuXG4gICAgICB2YXIgciA9IGZ1bmN0aW9uKHJldHVybmVkKSB7XG5cbiAgICAgICAgLy8gSGF2ZSB3ZSBkZWZpbmVkIGJvdGggYm91bmRhcmllcz9cbiAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWluKSAmJiBjb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21heCkpIHtcblxuICAgICAgICAgIC8vIFdlbGwsIHRoZW4gbGV0cyBqdXN0IHJlcGxhY2UgdGhpcyB3aXRoIGEgc2xpZGVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbnRyb2xsZXIuX19taW4sIGNvbnRyb2xsZXIuX19tYXgsIGNvbnRyb2xsZXIuX19zdGVwXVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybmVkO1xuXG4gICAgICB9O1xuXG4gICAgICBjb250cm9sbGVyLm1pbiA9IGNvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICAgIGNvbnRyb2xsZXIubWF4ID0gY29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5tYXgpO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBCb29sZWFuQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudHMgZG91YmxlLXRvZ2dsZVxuICAgICAgfSlcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRnVuY3Rpb25Db250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fYnV0dG9uLCAnY2xpY2snKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChsaSwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQobGksICdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgICB9KTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkgPSBjb21tb24uY29tcG9zZShmdW5jdGlvbihyKSB7XG4gICAgICAgIGxpLnN0eWxlLmJvcmRlckxlZnRDb2xvciA9IGNvbnRyb2xsZXIuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG5cbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgfVxuXG4gICAgY29udHJvbGxlci5zZXRWYWx1ZSA9IGNvbW1vbi5jb21wb3NlKGZ1bmN0aW9uKHIpIHtcbiAgICAgIGlmIChndWkuZ2V0Um9vdCgpLl9fcHJlc2V0X3NlbGVjdCAmJiBjb250cm9sbGVyLmlzTW9kaWZpZWQoKSkge1xuICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLmdldFJvb3QoKSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBjb250cm9sbGVyLnNldFZhbHVlKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpIHtcblxuICAgIC8vIEZpbmQgdGhlIHRvcG1vc3QgR1VJLCB0aGF0J3Mgd2hlcmUgcmVtZW1iZXJlZCBvYmplY3RzIGxpdmUuXG4gICAgdmFyIHJvb3QgPSBndWkuZ2V0Um9vdCgpO1xuXG4gICAgLy8gRG9lcyB0aGUgb2JqZWN0IHdlJ3JlIGNvbnRyb2xsaW5nIG1hdGNoIGFueXRoaW5nIHdlJ3ZlIGJlZW4gdG9sZCB0b1xuICAgIC8vIHJlbWVtYmVyP1xuICAgIHZhciBtYXRjaGVkX2luZGV4ID0gcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2YoY29udHJvbGxlci5vYmplY3QpO1xuXG4gICAgLy8gV2h5IHllcywgaXQgZG9lcyFcbiAgICBpZiAobWF0Y2hlZF9pbmRleCAhPSAtMSkge1xuXG4gICAgICAvLyBMZXQgbWUgZmV0Y2ggYSBtYXAgb2YgY29udHJvbGxlcnMgZm9yIHRoY29tbW9uLmlzT2JqZWN0LlxuICAgICAgdmFyIGNvbnRyb2xsZXJfbWFwID1cbiAgICAgICAgICByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRfaW5kZXhdO1xuXG4gICAgICAvLyBPaHAsIEkgYmVsaWV2ZSB0aGlzIGlzIHRoZSBmaXJzdCBjb250cm9sbGVyIHdlJ3ZlIGNyZWF0ZWQgZm9yIHRoaXNcbiAgICAgIC8vIG9iamVjdC4gTGV0cyBtYWtlIHRoZSBtYXAgZnJlc2guXG4gICAgICBpZiAoY29udHJvbGxlcl9tYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250cm9sbGVyX21hcCA9IHt9O1xuICAgICAgICByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRfaW5kZXhdID1cbiAgICAgICAgICAgIGNvbnRyb2xsZXJfbWFwO1xuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoaXMgY29udHJvbGxlclxuICAgICAgY29udHJvbGxlcl9tYXBbY29udHJvbGxlci5wcm9wZXJ0eV0gPSBjb250cm9sbGVyO1xuXG4gICAgICAvLyBPa2F5LCBub3cgaGF2ZSB3ZSBzYXZlZCBhbnkgdmFsdWVzIGZvciB0aGlzIGNvbnRyb2xsZXI/XG4gICAgICBpZiAocm9vdC5sb2FkICYmIHJvb3QubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgICAgdmFyIHByZXNldF9tYXAgPSByb290LmxvYWQucmVtZW1iZXJlZDtcblxuICAgICAgICAvLyBXaGljaCBwcmVzZXQgYXJlIHdlIHRyeWluZyB0byBsb2FkP1xuICAgICAgICB2YXIgcHJlc2V0O1xuXG4gICAgICAgIGlmIChwcmVzZXRfbWFwW2d1aS5wcmVzZXRdKSB7XG5cbiAgICAgICAgICBwcmVzZXQgPSBwcmVzZXRfbWFwW2d1aS5wcmVzZXRdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocHJlc2V0X21hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdKSB7XG5cbiAgICAgICAgICAvLyBVaGgsIHlvdSBjYW4gaGF2ZSB0aGUgZGVmYXVsdCBpbnN0ZWFkP1xuICAgICAgICAgIHByZXNldCA9IHByZXNldF9tYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gTmFkYS5cblxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBEaWQgdGhlIGxvYWRlZCBvYmplY3QgcmVtZW1iZXIgdGhjb21tb24uaXNPYmplY3Q/XG4gICAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZF9pbmRleF0gJiZcblxuICAgICAgICAgIC8vIERpZCB3ZSByZW1lbWJlciB0aGlzIHBhcnRpY3VsYXIgcHJvcGVydHk/XG4gICAgICAgICAgICBwcmVzZXRbbWF0Y2hlZF9pbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgLy8gV2UgZGlkIHJlbWVtYmVyIHNvbWV0aGluZyBmb3IgdGhpcyBndXkgLi4uXG4gICAgICAgICAgdmFyIHZhbHVlID0gcHJlc2V0W21hdGNoZWRfaW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuXG4gICAgICAgICAgLy8gQW5kIHRoYXQncyB3aGF0IGl0IGlzLlxuICAgICAgICAgIGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCBrZXkpIHtcbiAgICAvLyBUT0RPIGhvdyBkb2VzIHRoaXMgZGVhbCB3aXRoIG11bHRpcGxlIEdVSSdzP1xuICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcblxuICAgIHZhciBkaXYgPSBndWkuX19zYXZlX3JvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICBkb20uYWRkQ2xhc3MoZ3VpLmRvbUVsZW1lbnQsICdoYXMtc2F2ZScpO1xuXG4gICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG5cbiAgICBkb20uYWRkQ2xhc3MoZGl2LCAnc2F2ZS1yb3cnKTtcblxuICAgIHZhciBnZWFycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBnZWFycy5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcblxuICAgIC8vIFRPRE8gcmVwbGFjZSB3aXRoIEZ1bmN0aW9uQ29udHJvbGxlclxuICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ3NhdmUnKTtcblxuICAgIHZhciBidXR0b24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbjIuaW5uZXJIVE1MID0gJ05ldyc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ3NhdmUtYXMnKTtcblxuICAgIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbjMuaW5uZXJIVE1MID0gJ1JldmVydCc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuXG4gICAgdmFyIHNlbGVjdCA9IGd1aS5fX3ByZXNldF9zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcblxuICAgIGlmIChndWkubG9hZCAmJiBndWkubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgIGNvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwga2V5LCBrZXkgPT0gZ3VpLnByZXNldCk7XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBkb20uYmluZChzZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblxuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuXG4gICAgfSk7XG5cbiAgICBkaXYuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoZ2VhcnMpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMyk7XG5cbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuXG4gICAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG5cbiAgICAgIHNhdmVMb2NhbGx5LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICB2YXIgbG9jYWxTdG9yYWdlQ2hlY2tCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtc3RvcmFnZScpO1xuXG4gICAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlQ2hlY2tCb3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvd0hpZGVFeHBsYWluKCkge1xuICAgICAgICBleHBsYWluLnN0eWxlLmRpc3BsYXkgPSBndWkudXNlTG9jYWxTdG9yYWdlID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgIH1cblxuICAgICAgc2hvd0hpZGVFeHBsYWluKCk7XG5cbiAgICAgIC8vIFRPRE86IFVzZSBhIGJvb2xlYW4gY29udHJvbGxlciwgZm9vbCFcbiAgICAgIGRvbS5iaW5kKGxvY2FsU3RvcmFnZUNoZWNrQm94LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgICAgc2hvd0hpZGVFeHBsYWluKCk7XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuXG4gICAgZG9tLmJpbmQobmV3Q29uc3RydWN0b3JUZXh0QXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5tZXRhS2V5ICYmIChlLndoaWNoID09PSA2NyB8fCBlLmtleUNvZGUgPT0gNjcpKSB7XG4gICAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoZ2VhcnMsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgICAgU0FWRV9ESUFMT0dVRS5zaG93KCk7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmZvY3VzKCk7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIGd1aS5zYXZlKCk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24yLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcmVzZXROYW1lID0gcHJvbXB0KCdFbnRlciBhIG5ldyBwcmVzZXQgbmFtZS4nKTtcbiAgICAgIGlmIChwcmVzZXROYW1lKSBndWkuc2F2ZUFzKHByZXNldE5hbWUpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBndWkucmV2ZXJ0KCk7XG4gICAgfSk7XG5cbi8vICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVzaXplSGFuZGxlKGd1aSkge1xuXG4gICAgZ3VpLl9fcmVzaXplX2hhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29tbW9uLmV4dGVuZChndWkuX19yZXNpemVfaGFuZGxlLnN0eWxlLCB7XG5cbiAgICAgIHdpZHRoOiAnNnB4JyxcbiAgICAgIG1hcmdpbkxlZnQ6ICctM3B4JyxcbiAgICAgIGhlaWdodDogJzIwMHB4JyxcbiAgICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuLy8gICAgICBib3JkZXI6ICcxcHggc29saWQgYmx1ZSdcblxuICAgIH0pO1xuXG4gICAgdmFyIHBtb3VzZVg7XG5cbiAgICBkb20uYmluZChndWkuX19yZXNpemVfaGFuZGxlLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcbiAgICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG5cbiAgICBndWkuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoZ3VpLl9fcmVzaXplX2hhbmRsZSwgZ3VpLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuXG4gICAgICBkb20uYWRkQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhZyhlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgZ3VpLndpZHRoICs9IHBtb3VzZVggLSBlLmNsaWVudFg7XG4gICAgICBndWkub25SZXNpemUoKTtcbiAgICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYWdTdG9wKCkge1xuXG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFdpZHRoKGd1aSwgdykge1xuICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgLy8gQXV0byBwbGFjZWQgc2F2ZS1yb3dzIGFyZSBwb3NpdGlvbiBmaXhlZCwgc28gd2UgaGF2ZSB0b1xuICAgIC8vIHNldCB0aGUgd2lkdGggbWFudWFsbHkgaWYgd2Ugd2FudCBpdCB0byBibGVlZCB0byB0aGUgZWRnZVxuICAgIGlmIChndWkuX19zYXZlX3JvdyAmJiBndWkuYXV0b1BsYWNlKSB7XG4gICAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIH1pZiAoZ3VpLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFByZXNldChndWksIHVzZUluaXRpYWxWYWx1ZXMpIHtcblxuICAgIHZhciB0b1JldHVybiA9IHt9O1xuXG4gICAgLy8gRm9yIGVhY2ggb2JqZWN0IEknbSByZW1lbWJlcmluZ1xuICAgIGNvbW1vbi5lYWNoKGd1aS5fX3JlbWVtYmVyZWRPYmplY3RzLCBmdW5jdGlvbih2YWwsIGluZGV4KSB7XG5cbiAgICAgIHZhciBzYXZlZF92YWx1ZXMgPSB7fTtcblxuICAgICAgLy8gVGhlIGNvbnRyb2xsZXJzIEkndmUgbWFkZSBmb3IgdGhjb21tb24uaXNPYmplY3QgYnkgcHJvcGVydHlcbiAgICAgIHZhciBjb250cm9sbGVyX21hcCA9XG4gICAgICAgICAgZ3VpLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW2luZGV4XTtcblxuICAgICAgLy8gUmVtZW1iZXIgZWFjaCB2YWx1ZSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAgY29tbW9uLmVhY2goY29udHJvbGxlcl9tYXAsIGZ1bmN0aW9uKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICAgIHNhdmVkX3ZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2F2ZSB0aGUgdmFsdWVzIGZvciB0aGNvbW1vbi5pc09iamVjdFxuICAgICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRfdmFsdWVzO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFByZXNldE9wdGlvbihndWksIG5hbWUsIHNldFNlbGVjdGVkKSB7XG4gICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIG9wdC5pbm5lckhUTUwgPSBuYW1lO1xuICAgIG9wdC52YWx1ZSA9IG5hbWU7XG4gICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICAgIGlmIChzZXRTZWxlY3RlZCkge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByZXNldFNlbGVjdEluZGV4KGd1aSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09IGd1aS5wcmVzZXQpIHtcbiAgICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1ByZXNldE1vZGlmaWVkKGd1aSwgbW9kaWZpZWQpIHtcbiAgICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuLy8gICAgY29uc29sZS5sb2coJ21hcmsnLCBtb2RpZmllZCwgb3B0KTtcbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWUgKyBcIipcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpIHtcblxuXG4gICAgaWYgKGNvbnRyb2xsZXJBcnJheS5sZW5ndGggIT0gMCkge1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSk7XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIGNvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24oYykge1xuICAgICAgYy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG5cbiAgfVxuXG4gIHJldHVybiBHVUk7XG5cbn0pKGRhdC51dGlscy5jc3MsXG5cIjxkaXYgaWQ9XFxcImRnLXNhdmVcXFwiIGNsYXNzPVxcXCJkZyBkaWFsb2d1ZVxcXCI+XFxuXFxuICBIZXJlJ3MgdGhlIG5ldyBsb2FkIHBhcmFtZXRlciBmb3IgeW91ciA8Y29kZT5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3I6XFxuXFxuICA8dGV4dGFyZWEgaWQ9XFxcImRnLW5ldy1jb25zdHJ1Y3RvclxcXCI+PC90ZXh0YXJlYT5cXG5cXG4gIDxkaXYgaWQ9XFxcImRnLXNhdmUtbG9jYWxseVxcXCI+XFxuXFxuICAgIDxpbnB1dCBpZD1cXFwiZGctbG9jYWwtc3RvcmFnZVxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiLz4gQXV0b21hdGljYWxseSBzYXZlXFxuICAgIHZhbHVlcyB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IG9uIGV4aXQuXFxuXFxuICAgIDxkaXYgaWQ9XFxcImRnLWxvY2FsLWV4cGxhaW5cXFwiPlRoZSB2YWx1ZXMgc2F2ZWQgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiB3aWxsXFxuICAgICAgb3ZlcnJpZGUgdGhvc2UgcGFzc2VkIHRvIDxjb2RlPmRhdC5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3IuIFRoaXMgbWFrZXMgaXRcXG4gICAgICBlYXNpZXIgdG8gd29yayBpbmNyZW1lbnRhbGx5LCBidXQgPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpcyBmcmFnaWxlLFxcbiAgICAgIGFuZCB5b3VyIGZyaWVuZHMgbWF5IG5vdCBzZWUgdGhlIHNhbWUgdmFsdWVzIHlvdSBkby5cXG4gICAgICBcXG4gICAgPC9kaXY+XFxuICAgIFxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCIsXG5cIi5kZyB1bHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO3dpZHRoOjEwMCU7Y2xlYXI6Ym90aH0uZGcuYWN7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjA7ei1pbmRleDowfS5kZzpub3QoLmFjKSAubWFpbntvdmVyZmxvdzpoaWRkZW59LmRnLm1haW57LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO2JvcmRlcjowO3Bvc2l0aW9uOmFic29sdXRlO2xpbmUtaGVpZ2h0OjE5cHg7aGVpZ2h0OjIwcHg7Y3Vyc29yOnBvaW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojMDAwfS5kZy5tYWluIC5jbG9zZS1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTExfS5kZy5he2Zsb2F0OnJpZ2h0O21hcmdpbi1yaWdodDoxNXB4O292ZXJmbG93LXg6aGlkZGVufS5kZy5hLmhhcy1zYXZlIHVse21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZSB1bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3twb3NpdGlvbjpmaXhlZDt0b3A6MDt6LWluZGV4OjEwMDJ9LmRnIGxpey13ZWJraXQtdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0Oy1tb3otdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDt0cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0fS5kZyBsaTpub3QoLmZvbGRlcil7Y3Vyc29yOmF1dG87aGVpZ2h0OjI3cHg7bGluZS1oZWlnaHQ6MjdweDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowIDRweCAwIDVweH0uZGcgbGkuZm9sZGVye3BhZGRpbmc6MDtib3JkZXItbGVmdDo0cHggc29saWQgcmdiYSgwLDAsMCwwKX0uZGcgbGkudGl0bGV7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWxlZnQ6LTRweH0uZGcgLmNsb3NlZCBsaTpub3QoLnRpdGxlKSwuZGcgLmNsb3NlZCB1bCBsaSwuZGcgLmNsb3NlZCB1bCBsaSA+ICp7aGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlcjowfS5kZyAuY3J7Y2xlYXI6Ym90aDtwYWRkaW5nLWxlZnQ6M3B4O2hlaWdodDoyN3B4fS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3tmbG9hdDpsZWZ0O3dpZHRoOjYwJX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtib3JkZXI6MDttYXJnaW4tdG9wOjRweDtwYWRkaW5nOjNweDt3aWR0aDoxMDAlO2Zsb2F0OnJpZ2h0fS5kZyAuaGFzLXNsaWRlciBpbnB1dFt0eXBlPXRleHRde3dpZHRoOjMwJTttYXJnaW4tbGVmdDowfS5kZyAuc2xpZGVye2Zsb2F0OmxlZnQ7d2lkdGg6NjYlO21hcmdpbi1sZWZ0Oi01cHg7bWFyZ2luLXJpZ2h0OjA7aGVpZ2h0OjE5cHg7bWFyZ2luLXRvcDo0cHh9LmRnIC5zbGlkZXItZmd7aGVpZ2h0OjEwMCV9LmRnIC5jIGlucHV0W3R5cGU9Y2hlY2tib3hde21hcmdpbi10b3A6OXB4fS5kZyAuYyBzZWxlY3R7bWFyZ2luLXRvcDo1cHh9LmRnIC5jci5mdW5jdGlvbiwuZGcgLmNyLmZ1bmN0aW9uIC5wcm9wZXJ0eS1uYW1lLC5kZyAuY3IuZnVuY3Rpb24gKiwuZGcgLmNyLmJvb2xlYW4sLmRnIC5jci5ib29sZWFuICp7Y3Vyc29yOnBvaW50ZXJ9LmRnIC5zZWxlY3RvcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLWxlZnQ6LTlweDttYXJnaW4tdG9wOjIzcHg7ei1pbmRleDoxMH0uZGcgLmM6aG92ZXIgLnNlbGVjdG9yLC5kZyAuc2VsZWN0b3IuZHJhZ3tkaXNwbGF5OmJsb2NrfS5kZyBsaS5zYXZlLXJvd3twYWRkaW5nOjB9LmRnIGxpLnNhdmUtcm93IC5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzowcHggNnB4fS5kZy5kaWFsb2d1ZXtiYWNrZ3JvdW5kLWNvbG9yOiMyMjI7d2lkdGg6NDYwcHg7cGFkZGluZzoxNXB4O2ZvbnQtc2l6ZToxM3B4O2xpbmUtaGVpZ2h0OjE1cHh9I2RnLW5ldy1jb25zdHJ1Y3RvcntwYWRkaW5nOjEwcHg7Y29sb3I6IzIyMjtmb250LWZhbWlseTpNb25hY28sIG1vbm9zcGFjZTtmb250LXNpemU6MTBweDtib3JkZXI6MDtyZXNpemU6bm9uZTtib3gtc2hhZG93Omluc2V0IDFweCAxcHggMXB4ICM4ODg7d29yZC13cmFwOmJyZWFrLXdvcmQ7bWFyZ2luOjEycHggMDtkaXNwbGF5OmJsb2NrO3dpZHRoOjQ0MHB4O292ZXJmbG93LXk6c2Nyb2xsO2hlaWdodDoxMDBweDtwb3NpdGlvbjpyZWxhdGl2ZX0jZGctbG9jYWwtZXhwbGFpbntkaXNwbGF5Om5vbmU7Zm9udC1zaXplOjExcHg7bGluZS1oZWlnaHQ6MTdweDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7cGFkZGluZzo4cHg7bWFyZ2luLXRvcDoxMHB4fSNkZy1sb2NhbC1leHBsYWluIGNvZGV7Zm9udC1zaXplOjEwcHh9I2RhdC1ndWktc2F2ZS1sb2NhbGx5e2Rpc3BsYXk6bm9uZX0uZGd7Y29sb3I6I2VlZTtmb250OjExcHggJ0x1Y2lkYSBHcmFuZGUnLCBzYW5zLXNlcmlmO3RleHQtc2hhZG93OjAgLTFweCAwICMxMTF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjVweDtiYWNrZ3JvdW5kOiMxYTFhMWF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lcntoZWlnaHQ6MDtkaXNwbGF5Om5vbmV9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1ie2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6IzY3Njc2N30uZGcgbGk6bm90KC5mb2xkZXIpe2JhY2tncm91bmQ6IzFhMWExYTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjMmMyYzJjfS5kZyBsaS5zYXZlLXJvd3tsaW5lLWhlaWdodDoyNXB4O2JhY2tncm91bmQ6I2RhZDVjYjtib3JkZXI6MH0uZGcgbGkuc2F2ZS1yb3cgc2VsZWN0e21hcmdpbi1sZWZ0OjVweDt3aWR0aDoxMDhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbnttYXJnaW4tbGVmdDo1cHg7bWFyZ2luLXRvcDoxcHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1zaXplOjlweDtsaW5lLWhlaWdodDo3cHg7cGFkZGluZzo0cHggNHB4IDVweCA0cHg7YmFja2dyb3VuZDojYzViZGFkO2NvbG9yOiNmZmY7dGV4dC1zaGFkb3c6MCAxcHggMCAjYjBhNThmO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4ZjtjdXJzb3I6cG9pbnRlcn0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbi5nZWFyc3tiYWNrZ3JvdW5kOiNjNWJkYWQgdXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXNBQUFBTkNBWUFBQUIvOVpRN0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBUUpKUkVGVWVOcGlZS0FVL1AvL1B3R0lDL0FwQ0FCaUJTQVcrSThBQ2xBY2dLeFE0VDlob01BRVVyeHgyUVNHTjYrZWdEWCsvdldUNGU3TjgyQU1Zb1BBeC9ldndXb1lvU1liQUNYMnM3S3hDeHpjc2V6RGgzZXZGb0RFQllURUVxeWNnZ1dBekE5QXVVU1FRZ2VZUGE5ZlB2Ni9ZV20vQWN4NUlQYjd0eS9mdytRWmJsdzY3dkRzOFIwWUh5UWhnT2J4K3lBSmtCcW1HNWRQUERoMWFQT0dSL2V1Z1cwRzR2bElvVElmeUZjQStRZWtoaEhKaFBkUXhiaUFJZ3VNQlRRWnJQRDcxMDhNNnJvV1lERlFpSUFBdjZBb3cvMWJGd1hnaXMrZjJMVUF5bndvSWFOY3o4WE54M0RsN01FSlVER1FweDlndFE4WUN1ZUIrRDI2T0VDQUFRRGFkdDdlNDZENDJRQUFBQUJKUlU1RXJrSmdnZz09KSAycHggMXB4IG5vLXJlcGVhdDtoZWlnaHQ6N3B4O3dpZHRoOjhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNiYWIxOWU7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmfS5kZyBsaS5mb2xkZXJ7Ym9yZGVyLWJvdHRvbTowfS5kZyBsaS50aXRsZXtwYWRkaW5nLWxlZnQ6MTZweDtiYWNrZ3JvdW5kOiMwMDAgdXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsSStoS2dGeG9DZ0FPdz09KSA2cHggMTBweCBuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpfS5kZyAuY2xvc2VkIGxpLnRpdGxle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsR0lXcU1DYldBRUFPdz09KX0uZGcgLmNyLmJvb2xlYW57Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICM4MDY3ODd9LmRnIC5jci5mdW5jdGlvbntib3JkZXItbGVmdDozcHggc29saWQgI2U2MWQ1Zn0uZGcgLmNyLm51bWJlcntib3JkZXItbGVmdDozcHggc29saWQgIzJmYTFkNn0uZGcgLmNyLm51bWJlciBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMyZmExZDZ9LmRnIC5jci5zdHJpbmd7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMxZWQzNmZ9LmRnIC5jci5zdHJpbmcgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMWVkMzZmfS5kZyAuY3IuZnVuY3Rpb246aG92ZXIsLmRnIC5jci5ib29sZWFuOmhvdmVye2JhY2tncm91bmQ6IzExMX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtiYWNrZ3JvdW5kOiMzMDMwMzA7b3V0bGluZTpub25lfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpmb2N1c3tiYWNrZ3JvdW5kOiM0OTQ5NDk7Y29sb3I6I2ZmZn0uZGcgLmMgLnNsaWRlcntiYWNrZ3JvdW5kOiMzMDMwMzA7Y3Vyc29yOmV3LXJlc2l6ZX0uZGcgLmMgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiMyZmExZDZ9LmRnIC5jIC5zbGlkZXI6aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyAuc2xpZGVyOmhvdmVyIC5zbGlkZXItZmd7YmFja2dyb3VuZDojNDRhYmRhfVxcblwiLFxuZGF0LmNvbnRyb2xsZXJzLmZhY3RvcnkgPSAoZnVuY3Rpb24gKE9wdGlvbkNvbnRyb2xsZXIsIE51bWJlckNvbnRyb2xsZXJCb3gsIE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIFN0cmluZ0NvbnRyb2xsZXIsIEZ1bmN0aW9uQ29udHJvbGxlciwgQm9vbGVhbkNvbnRyb2xsZXIsIGNvbW1vbikge1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXG4gICAgICAgIC8vIFByb3ZpZGluZyBvcHRpb25zP1xuICAgICAgICBpZiAoY29tbW9uLmlzQXJyYXkoYXJndW1lbnRzWzJdKSB8fCBjb21tb24uaXNPYmplY3QoYXJndW1lbnRzWzJdKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvdmlkaW5nIGEgbWFwP1xuXG4gICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoaW5pdGlhbFZhbHVlKSkge1xuXG4gICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIGNvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG5cbiAgICAgICAgICAgIC8vIEhhcyBtaW4gYW5kIG1heC5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10gfSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNGdW5jdGlvbihpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0Jvb2xlYW4oaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSkoZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCxcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyLFxuZGF0LmNvbnRyb2xsZXJzLlN0cmluZ0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIHRleHQgaW5wdXQgdG8gYWx0ZXIgdGhlIHN0cmluZyBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgU3RyaW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG5cbiAgfTtcblxuICBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBTdG9wcyB0aGUgY2FyZXQgZnJvbSBtb3Zpbmcgb24gYWNjb3VudCBvZjpcbiAgICAgICAgICAvLyBrZXl1cCAtPiBzZXRWYWx1ZSAtPiB1cGRhdGVEaXNwbGF5XG4gICAgICAgICAgaWYgKCFkb20uaXNBY3RpdmUodGhpcy5fX2lucHV0KSkge1xuICAgICAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94LFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG5kYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Db2xvckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgQ29sb3IsIGludGVycHJldCwgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgIENvbG9yQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB0aGlzLl9fY29sb3IgPSBuZXcgQ29sb3IodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICB0aGlzLl9fdGVtcCA9IG5ldyBDb2xvcigwKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcblxuICAgIHRoaXMuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5jbGFzc05hbWUgPSAnc2VsZWN0b3InO1xuXG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5jbGFzc05hbWUgPSAnc2F0dXJhdGlvbi1maWVsZCc7XG5cbiAgICB0aGlzLl9fZmllbGRfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcbiAgICB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgPSAnMnB4IHNvbGlkICc7XG5cbiAgICB0aGlzLl9faHVlX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9faHVlX2tub2IuY2xhc3NOYW1lID0gJ2h1ZS1rbm9iJztcblxuICAgIHRoaXMuX19odWVfZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyA9ICcwIDFweCAxcHggJztcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykgeyAvLyBvbiBlbnRlclxuICAgICAgICBvbkJsdXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NlbGVjdG9yLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICBkb21cbiAgICAgICAgLmFkZENsYXNzKHRoaXMsICdkcmFnJylcbiAgICAgICAgLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHZhciB2YWx1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAodGhpcy5fX2NvbG9yLnYgPCAuNSA/ICcjZmZmJyA6ICcjMDAwJyksXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuNSknLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcbiAgICBcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19odWVfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMnB4JyxcbiAgICAgIGJvcmRlclJpZ2h0OiAnNHB4IHNvbGlkICNmZmYnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMHB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnM3B4JyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodmFsdWVfZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJhY2tncm91bmQ6ICdub25lJ1xuICAgIH0pO1xuICAgIFxuICAgIGxpbmVhckdyYWRpZW50KHZhbHVlX2ZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBjdXJzb3I6ICducy1yZXNpemUnXG4gICAgfSk7XG5cbiAgICBodWVHcmFkaWVudCh0aGlzLl9faHVlX2ZpZWxkKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4vLyAgICAgIHdpZHRoOiAnMTIwcHgnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbi8vICAgICAgcGFkZGluZzogJzRweCcsXG4vLyAgICAgIG1hcmdpbkJvdHRvbTogJzZweCcsXG4gICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgdGV4dFNoYWRvdzogdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgwLDAsMCwwLjcpJ1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKHRoaXMuX19maWVsZF9rbm9iLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19odWVfZmllbGQsICdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kSCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdub25lJztcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRTVik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5iaW5kU1YoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZFNWKTtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMudmFsdWUpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzLl9fY29sb3IuX19zdGF0ZSA9IGk7XG4gICAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBfdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5iaW5kSCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRIKTtcbiAgICB9XG5cbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZV9maWVsZCk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19maWVsZF9rbm9iKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9faHVlX2ZpZWxkKTtcbiAgICB0aGlzLl9faHVlX2ZpZWxkLmFwcGVuZENoaWxkKHRoaXMuX19odWVfa25vYik7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3NlbGVjdG9yKTtcblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZnVuY3Rpb24gc2V0U1YoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciB3ID0gZG9tLmdldFdpZHRoKF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgICB2YXIgbyA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICAgIHZhciBzID0gKGUuY2xpZW50WCAtIG8ubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCkgLyB3O1xuICAgICAgdmFyIHYgPSAxIC0gKGUuY2xpZW50WSAtIG8udG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIC8gdztcblxuICAgICAgaWYgKHYgPiAxKSB2ID0gMTtcbiAgICAgIGVsc2UgaWYgKHYgPCAwKSB2ID0gMDtcblxuICAgICAgaWYgKHMgPiAxKSBzID0gMTtcbiAgICAgIGVsc2UgaWYgKHMgPCAwKSBzID0gMDtcblxuICAgICAgX3RoaXMuX19jb2xvci52ID0gdjtcbiAgICAgIF90aGlzLl9fY29sb3IucyA9IHM7XG5cbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblxuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgcyA9IGRvbS5nZXRIZWlnaHQoX3RoaXMuX19odWVfZmllbGQpO1xuICAgICAgdmFyIG8gPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9faHVlX2ZpZWxkKTtcbiAgICAgIHZhciBoID0gMSAtIChlLmNsaWVudFkgLSBvLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSAvIHM7XG5cbiAgICAgIGlmIChoID4gMSkgaCA9IDE7XG4gICAgICBlbHNlIGlmIChoIDwgMCkgaCA9IDA7XG5cbiAgICAgIF90aGlzLl9fY29sb3IuaCA9IGggKiAzNjA7XG5cbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgQ29sb3JDb250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIENvbG9yQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy5nZXRWYWx1ZSgpKTtcblxuICAgICAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuXG4gICAgICAgICAgICB2YXIgbWlzbWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1pc21hdGNoIG9uIHRoZSBpbnRlcnByZXRlZCB2YWx1ZS5cblxuICAgICAgICAgICAgY29tbW9uLmVhY2goQ29sb3IuQ09NUE9ORU5UUywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIGlmICghY29tbW9uLmlzVW5kZWZpbmVkKGlbY29tcG9uZW50XSkgJiZcbiAgICAgICAgICAgICAgICAgICFjb21tb24uaXNVbmRlZmluZWQodGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkgJiZcbiAgICAgICAgICAgICAgICAgIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307IC8vIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBJZiBub3RoaW5nIGRpdmVyZ2VzLCB3ZSBrZWVwIG91ciBwcmV2aW91cyB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGZvciBzdGF0ZWZ1bG5lc3MsIG90aGVyd2lzZSB3ZSByZWNhbGN1bGF0ZSBmcmVzaFxuICAgICAgICAgICAgaWYgKG1pc21hdGNoKSB7XG4gICAgICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fdGVtcC5fX3N0YXRlLCB0aGlzLl9fY29sb3IuX19zdGF0ZSk7XG5cbiAgICAgICAgICB0aGlzLl9fdGVtcC5hID0gMTtcblxuICAgICAgICAgIHZhciBmbGlwID0gKHRoaXMuX19jb2xvci52IDwgLjUgfHwgdGhpcy5fX2NvbG9yLnMgPiAuNSkgPyAyNTUgOiAwO1xuICAgICAgICAgIHZhciBfZmxpcCA9IDI1NSAtIGZsaXA7XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAxMDAgKiAoMSAtIHRoaXMuX19jb2xvci52KSAtIDcgKyAncHgnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9fdGVtcC50b1N0cmluZygpLFxuICAgICAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKycpJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4J1xuXG4gICAgICAgICAgdGhpcy5fX3RlbXAucyA9IDE7XG4gICAgICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG5cbiAgICAgICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsnKScsXG4gICAgICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKycsLjcpJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG4gIFxuICB2YXIgdmVuZG9ycyA9IFsnLW1vei0nLCctby0nLCctd2Via2l0LScsJy1tcy0nLCcnXTtcbiAgXG4gIGZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICBjb21tb24uZWFjaCh2ZW5kb3JzLCBmdW5jdGlvbih2ZW5kb3IpIHtcbiAgICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogJyArIHZlbmRvciArICdsaW5lYXItZ3JhZGllbnQoJyt4KycsICcrYSsnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGh1ZUdyYWRpZW50KGVsZW0pIHtcbiAgICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsICNmZjAwZmYgMTclLCAjMDAwMGZmIDM0JSwgIzAwZmZmZiA1MCUsICMwMGZmMDAgNjclLCAjZmZmZjAwIDg0JSwgI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgfVxuXG5cbiAgcmV0dXJuIENvbG9yQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC5jb2xvci5Db2xvciA9IChmdW5jdGlvbiAoaW50ZXJwcmV0LCBtYXRoLCB0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyAnRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcblxuXG4gIH07XG5cbiAgQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsJ2cnLCdiJywnaCcsJ3MnLCd2JywnaGV4JywnYSddO1xuXG4gIGNvbW1vbi5leHRlbmQoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfSxcblxuICAgIHRvT3JpZ2luYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cblxuICB9KTtcblxuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuXG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICghdGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gbWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlUkdCKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcblxuICAgICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gbWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblxuICAgICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBtYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhyb3cgJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZSc7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlSFNWKGNvbG9yKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gbWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLFxuICAgICAgICB7XG4gICAgICAgICAgczogcmVzdWx0LnMsXG4gICAgICAgICAgdjogcmVzdWx0LnZcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICAgIH0gZWxzZSBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29sb3I7XG5cbn0pKGRhdC5jb2xvci5pbnRlcnByZXQsXG5kYXQuY29sb3IubWF0aCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRtcENvbXBvbmVudDtcblxuICByZXR1cm4ge1xuXG4gICAgaHN2X3RvX3JnYjogZnVuY3Rpb24oaCwgcywgdikge1xuXG4gICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuXG4gICAgICB2YXIgZiA9IGggLyA2MCAtIE1hdGguZmxvb3IoaCAvIDYwKTtcbiAgICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxLjAgLSAoZiAqIHMpKTtcbiAgICAgIHZhciB0ID0gdiAqICgxLjAgLSAoKDEuMCAtIGYpICogcykpO1xuICAgICAgdmFyIGMgPSBbXG4gICAgICAgIFt2LCB0LCBwXSxcbiAgICAgICAgW3EsIHYsIHBdLFxuICAgICAgICBbcCwgdiwgdF0sXG4gICAgICAgIFtwLCBxLCB2XSxcbiAgICAgICAgW3QsIHAsIHZdLFxuICAgICAgICBbdiwgcCwgcV1cbiAgICAgIF1baGldO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjWzBdICogMjU1LFxuICAgICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgICBiOiBjWzJdICogMjU1XG4gICAgICB9O1xuXG4gICAgfSxcblxuICAgIHJnYl90b19oc3Y6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblxuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgIGgsIHM7XG5cbiAgICAgIGlmIChtYXggIT0gMCkge1xuICAgICAgICBzID0gZGVsdGEgLyBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IE5hTixcbiAgICAgICAgICBzOiAwLFxuICAgICAgICAgIHY6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIgPT0gbWF4KSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGcgPT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICB9XG4gICAgICBoIC89IDY7XG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBoICogMzYwLFxuICAgICAgICBzOiBzLFxuICAgICAgICB2OiBtYXggLyAyNTVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJnYl90b19oZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgICAgcmV0dXJuIGhleDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50X2Zyb21faGV4OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgICByZXR1cm4gKGhleCA+PiAoY29tcG9uZW50SW5kZXggKiA4KSkgJiAweEZGO1xuICAgIH0sXG5cbiAgICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCAoaGV4ICYgfiAoMHhGRiA8PCB0bXBDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgfVxuXG59KSgpLFxuZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29sb3IuaW50ZXJwcmV0LFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogcmVxdWlyZWpzIHZlcnNpb24gb2YgUGF1bCBJcmlzaCdzIFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKi9cblxuICByZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcblxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcblxuICAgICAgfTtcbn0pKCksXG5kYXQuZG9tLkNlbnRlcmVkRGl2ID0gKGZ1bmN0aW9uIChkb20sIGNvbW1vbikge1xuXG5cbiAgdmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLCB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDAnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuXG4gICAgZG9tLm1ha2VGdWxsc2NyZWVuKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG5cblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBkb20uYmluZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLmhpZGUoKTtcbiAgICB9KTtcblxuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgXG5cblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuLy8gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICc1MiUnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG5cbiAgICB0aGlzLmxheW91dCgpO1xuXG4gICAgY29tbW9uLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICAgIH0pO1xuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuXG4gICAgfTtcblxuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4vLyAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gJzQ4JSc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmxlZnQgPSB3aW5kb3cuaW5uZXJXaWR0aC8yIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gd2luZG93LmlubmVySGVpZ2h0LzIgLSBkb20uZ2V0SGVpZ2h0KHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIGxvY2tTY3JvbGwoZSkge1xuICAgIGNvbnNvbGUubG9nKGUpO1xuICB9XG5cbiAgcmV0dXJuIENlbnRlcmVkRGl2O1xuXG59KShkYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTsiXX0=
